<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task03笔记：三栏式布局]]></title>
      <url>https://alexzhong22c.github.io/2017/04/06/ife-css-task03/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="external">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<a id="more"></a>
<h2 id="任务要求："><a class="header-anchor" href="#任务要求："></a>任务要求：</h2>
<ul>
<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>
<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。</li>
</ul>
<p>这个任务中，懒于去上网找图片素材，直接引用了别人复仇者联盟的图片素材。</p>
<h2 id="实现思路"><a class="header-anchor" href="#实现思路"></a>实现思路</h2>
<h3 id="按普通顺序编写代码"><a class="header-anchor" href="#按普通顺序编写代码"></a>按普通顺序编写代码</h3>
<p>一般来说我们<strong>按照普通顺序编写代码</strong>：此时先写子栏的代码，再写main栏的代码</p>
<p>如果想要形成三栏的布局，思路有二：</p>
<p>要么运用margin形成三栏的布局</p>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/1%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-%E7%94%A8margin%E5%88%86%E5%BC%80.html">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/1%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-%E7%94%A8margin%E5%88%86%E5%BC%80.html" target="_blank" rel="external">源码</a></p>
<p>要么用BFC形成三栏的布局</p>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/2%E4%BD%BF%E7%94%A8BFC%E6%96%B9%E6%B3%95.html">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/2%E4%BD%BF%E7%94%A8BFC%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">源码</a></p>
<h3 id="先加载main栏"><a class="header-anchor" href="#先加载main栏"></a>先加载main栏</h3>
<h4 id="原理："><a class="header-anchor" href="#原理："></a>原理：</h4>
<ul>
<li>定义main-content宽度为100%（如果在IE6里不定义100%，会有点小问题，亲们自己可以一试）</li>
<li>main 左浮动，宽度为100%</li>
<li>sub 左浮动，宽度190，左外边距为-100%（此处是关键：浮动情况下，负的外边距会导致DIV上移，而使用-100%可以确使它移动到最左侧。)</li>
<li>extra 左浮动，宽度230，左外边距为-230px（道理同上，注意的是，负的左外边距值一定要大于或等于该DIV的宽度，才能靠到上一行去）</li>
</ul>
<p>当只使用负左外边距的方法时，能够实现<strong>先加载main栏</strong>，但是main栏的内容会被挡住。</p>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/1main%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E6%8C%A1%E4%BD%8F.html">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/1main%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E6%8C%A1%E4%BD%8F.html" target="_blank" rel="external">源码</a></p>
<p>解决 main栏的内容被挡住 的思路有二：</p>
<p>1. <strong>双飞翼布局</strong></p>
<p>2.  <strong>圣杯布局</strong></p>
<p>在本专题的最后，会介绍其他的方式来实现 三栏等高的 先加载main栏的 三栏式布局。</p>
<hr>
<h4 id="双飞翼布局"><a class="header-anchor" href="#双飞翼布局"></a>双飞翼布局</h4>
<p>淘宝的双飞翼布局：在原来的基础上多套了一层div，并且增设margin。<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-1%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html">2-1淘宝双飞翼布局demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-1%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html" target="_blank" rel="external">源码</a></p>
<h5 id="好处："><a class="header-anchor" href="#好处："></a>好处：</h5>
<ul>
<li>可以实现主要的内容先加载的优化</li>
<li>兼容目前所有的主流浏览器，包括IE6在内</li>
</ul>
<h5 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h5>
<ul>
<li>位置不灵活，同时css对位置的控制很强</li>
</ul>
<h4 id="圣杯布局"><a class="header-anchor" href="#圣杯布局"></a>圣杯布局</h4>
<p>圣杯布局的特点是它使用了padding和相对定位，当然它也使用了负左外边距。<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html">2-2圣杯布局demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html" target="_blank" rel="external">源码</a></p>
<h5 id="好处：-v2"><a class="header-anchor" href="#好处：-v2"></a>好处：</h5>
<ul>
<li>可以实现主要的内容先加载的优化</li>
<li>位置比较灵活：毕竟它是用 相对定位 实现的</li>
<li>main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。</li>
<li>任何一栏都可以是最高栏，不会出问题。</li>
<li>只需要针对ie6来hack：<code>zoom:1</code> ，兼容目前所有的主流浏览器，包括IE5.5</li>
</ul>
<h5 id="缺点：-v2"><a class="header-anchor" href="#缺点：-v2"></a>缺点：</h5>
<ul>
<li>当浏览器宽度过窄时，子栏可能会消失，extra栏的内容可能会跑到主栏里面。</li>
</ul>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2-X%E8%AF%81%E6%98%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%86%85%E9%83%A8%E7%81%B5%E6%B4%BB.html">证明圣杯布局内部灵活的demo</a> – <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2-X%E8%AF%81%E6%98%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%86%85%E9%83%A8%E7%81%B5%E6%B4%BB.html" target="_blank" rel="external">证明圣杯布局内部灵活的源码</a></p>
<hr>
<h4 id="实现三栏等高的其他方法"><a class="header-anchor" href="#实现三栏等高的其他方法"></a>实现三栏等高的其他方法</h4>
<h5 id="float-box-sizing-background-clip"><a class="header-anchor" href="#float-box-sizing-background-clip"></a>float + box-sizing + background-clip</h5>
<p>.main元素的border区域为两侧定宽列的所在区域，实现伪等高效果；设置.main的padding和background-clip来实现元素间隔。两侧元素通过负margin调整到.main元素的border区域</p>
<p>缺点: 兼容性不好，用到了CSS3的属性，应该至少要ie9</p>
<h5 id="绝对定位"><a class="header-anchor" href="#绝对定位"></a>绝对定位</h5>
<p>设置子元素的top:0;bottom:0;使得所有子元素的高度都和父元素的高度相同，实现等高效果</p>
<h5 id="flex布局"><a class="header-anchor" href="#flex布局"></a>flex布局</h5>
<p>flex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果</p>
<p>缺点: 兼容性不高</p>
<hr>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/xiaohuochai/p/5459587.html" target="_blank" rel="external">三栏式布局(所谓的圣杯和双飞翼)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25070186?refer=learncoding" target="_blank" rel="external">详解 CSS 七种三栏布局技巧</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 圣杯布局 </tag>
            
            <tag> 双飞翼布局 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭合浮动和BFC和阻止上下外边距的合并]]></title>
      <url>https://alexzhong22c.github.io/2017/04/01/clearfix-n-bfc/</url>
      <content type="html"><![CDATA[<p>本文部分内容参考 <a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="external">那些年我们一起清除过的浮动</a> ，但是 一丝冰凉 的这篇文章有很多地方我都不认同，取其精华去其糟粕，所以本文并没有包含那些我所不认同的内容。</p>
<a id="more"></a>
<h2 id="区分-清除浮动-和-闭合浮动"><a class="header-anchor" href="#区分-清除浮动-和-闭合浮动"></a>区分 清除浮动 和 闭合浮动</h2>
<ul>
<li>清除浮动：清除对应的英文单词是 clear，对应CSS中的属性是 clear：left | right | both | none；</li>
<li>闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。</li>
</ul>
<p>两者的区别 <a href="http://www.iyunlu.com/demo/enclosing-float-and-clearing-float/index.html" target="_blank" rel="external">请看Demo</a></p>
<p>闭合浮动主要用来解决<strong>因为子元素浮动导致父元素高度塌陷</strong>的问题。</p>
<h2 id="闭合浮动的一些老方法："><a class="header-anchor" href="#闭合浮动的一些老方法："></a>闭合浮动的一些老方法：</h2>
<ol>
<li>在子元素们的最后追加一个<code>style=&quot;clear:both&quot;</code>的空标签，这个不好</li>
<li>在子元素们的最后追加一个br标签，使用br标签的<code>clear=&quot;all | left | right | none&quot;</code> 属性，因为一般不建议在HTML中使用br，这个也不好</li>
<li>通过<strong>设置父元素</strong>overflow值设置为hidden；在IE6中还需要触发 hasLayout ，例如 zoom：1；因为最终还是有补不了的bug被大家弃用</li>
<li>通过<strong>设置父元素</strong>overflow值设置为auto，同样也有bug</li>
<li>父元素也设置浮动，缺点是<strong>使得与父元素相邻的元素的布局会受到影响</strong>，不可能一直浮动到body，不推荐使用</li>
<li>父元素设置display:table，盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用。文章最后还会再介绍到给<strong>父元素的伪元素设置display:table</strong>。</li>
</ol>
<h3 id="7-使用：after伪元素"><a class="header-anchor" href="#7-使用：after伪元素"></a>7. 使用<code>：after</code>伪元素</h3>
<blockquote>
<p>需要注意的是 :after是伪元素，不是伪类（另外，某些CSS手册里面称之为“伪对象”，不太对）。</p>
</blockquote>
<p>由于IE6-7不支持:after，要同时使用 zoom:1触发IE6和IE7的 hasLayout。<strong>在后面的demo中会介绍到。</strong></p>
<ul>
<li>优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）</li>
<li>缺点：复用方式不当会造成代码量增加</li>
<li>建议：定义公共类，以减少CSS代码</li>
</ul>
<h3 id="不要使用方案3和4"><a class="header-anchor" href="#不要使用方案3和4"></a>不要使用方案3和4</h3>
<p>方案3、4通过overflow闭合浮动，实际上已经创建了新的 块级格式化上下文，而它们设置的对象都是父元素，这将导致其布局和相对于浮动的行为等发生一系列的变化，闭合浮动只不过是一系列变化中的一个作用而已。所以为了闭合浮动去改变全局特性，这是不明智的，带来的风险就是一系列的bug，比如firefox 早期版本产生 focus，截断绝对定位的层等等。始终要明白，如果单单只是需要闭合浮动，overflow就不要使用，而不是某些文章所说的“慎用”。</p>
<h3 id="父级div定义height的方法"><a class="header-anchor" href="#父级div定义height的方法"></a>父级div定义height的方法</h3>
<ul>
<li>父级div定义height，这样就<strong>不必闭合浮动</strong>了</li>
<li>不推荐使用，只建议高度固定的布局时使用</li>
</ul>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>通过对比，我们不难发现，其实以上列举的方法，无非有两类：</p>
<p>其一，通过在浮动元素的末尾添加一个空的元素</p>
<p>其二，通过设置父元素 overflow 或者display：table 属性来闭合浮动，原理就是BFC，下面探讨一下：</p>
<h2 id="bfc知识"><a class="header-anchor" href="#bfc知识"></a>BFC知识</h2>
<p><a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank" rel="external">Block formatting contexts </a>（块级格式化上下文），以下简称 BFC。在CSS3里面改动后称之为flow root。</p>
<h3 id="bfc的特性"><a class="header-anchor" href="#bfc的特性"></a>BFC的特性</h3>
<p>一丝冰凉 对于BFC的特征的解释非常模糊，甚至不正确。我认为她这部分内容所解释的现象只适用到IE7</p>
<p>通俗地来说就是：</p>
<ul>
<li>创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反过来外面的元素也不影响里面的元素</li>
<li>同时BFC仍然属于文档中的普通流</li>
</ul>
<h3 id="如何触发bfc"><a class="header-anchor" href="#如何触发bfc"></a>如何触发BFC</h3>
<ul>
<li>float 除了none以外的值</li>
<li>overflow 除了visible 以外的值（hidden，auto，scroll ）</li>
<li>display (table-cell，table-caption，inline-block)</li>
<li>实际上，用<code>display:table</code>来产生匿名框也可以触发BFC，见文章 <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="external">A new micro clearfix hack</a> 或见本节的备注</li>
<li>position（absolute，fixed）</li>
<li>fieldset元素</li>
</ul>
<blockquote>
<p>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。</p>
<p>fieldset 元素在www.w3.org里目前没有任何有关这个触发行为的信息，直到HTML5标准里才出现。有些浏览器bugs（Webkit，Mozilla）提到过这个触发行为，但是没有任何官方声明。实际上，即使fieldset在大多数的浏览器上都能创建新的块级格式化上下文，开发者也不应该把这当做是理所当然的。CSS 2.1没有定义哪种属性适用于表单控件，也没有定义如何使用CSS来给它们添加样式。用户代理可能会给这些属性应用CSS属性，建议开发者们把这种支持当做实验性质的，更高版本的CSS可能会进一步规范这个。</p>
</blockquote>
<p><strong>由于浏览器的差异：</strong></p>
<ul>
<li>在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动；</li>
<li>在不支持 BFC的浏览器 （IE6-7），通过触发 hasLayout 闭合浮动。IE6-7的hasLayout 可以等同于 BFC。</li>
</ul>
<h2 id="深入理解伪元素闭合浮动"><a class="header-anchor" href="#深入理解伪元素闭合浮动"></a>深入理解伪元素闭合浮动</h2>
<p>上面已经列举了7种闭合浮动的方法，通过第三节分析的原理，我们发现其实更多的：对父元素使用display：table-cell，display：inline-block等只要触发了BFC的属性值都可以闭合浮动。从各个方面比较，<strong>方案7</strong>：after伪元素闭合浮动无疑是相对比较好的解决方案了。这种思路的演进历史可以参考文章：<a href="https://css-tricks.com/snippets/css/clear-fix/" target="_blank" rel="external">https://css-tricks.com/snippets/css/clear-fix/</a></p>
<p>而最后，方案7里面有两个最优的小方案：</p>
<h3 id="最优小方案1："><a class="header-anchor" href="#最优小方案1："></a>最优小方案1：</h3>
<pre><code>.clearfix:before, .clearfix:after {
content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both; }

.clearfix { *zoom:1; }
</code></pre>
<p>1）通过 content:&quot;.&quot;生成内容作为伪元素的内容</p>
<p>2）display:block 使生成的元素以块级元素显示,占满剩余空间;</p>
<p>3）height:0 避免生成内容破坏原有布局的高度。</p>
<p>4）visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;</p>
<p>5）同时要使用 zoom:1触发IE6和IE7的 hasLayout</p>
<p><strong>通过分析发现，除了clear：both用来清除浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0的缘故。</strong></p>
<p><strong>更重要的是，我认为这个方法根本就没产生 BFC 。</strong></p>
<blockquote>
<p>另外，不建议将content设置为空字符串&quot;&quot;，在firefox 7里面会看到它会产生空隙</p>
</blockquote>
<h3 id="最优小方案2："><a class="header-anchor" href="#最优小方案2："></a>最优小方案2：</h3>
<pre><code>.clearfix:before,
.clearfix:after {
    content: &quot; &quot;; /* 1 */
    display: table; /* 2 */
}

.clearfix:after {
    clear: both;
}

.clearfix {
    *zoom: 1;
}
</code></pre>
<p>1. 使用content: &quot; &quot; 是为了避免Opera的bug，否则它会在 被清除浮动的元素的顶部和底部 产生一个看得出的空格</p>
<p>2. 这里对伪元素使用的<code>display: table;</code>会产生一个 <a href="http://www.w3.org/TR/CSS2/tables.html#anonymous-boxes" target="_blank" rel="external">anonymous boxes</a> 和一个BFC，这个BFC意味着before伪类会阻止上外边距的合并，同时after伪类会闭合浮动。</p>
<blockquote>
<p>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。</p>
</blockquote>
<p>这个小方案的好处是：不用隐藏用content属性产生的内容，并且代码量特别少。</p>
<h4 id="firefox-3-5版本的问题"><a class="header-anchor" href="#firefox-3-5版本的问题"></a>Firefox &lt; 3.5版本的问题</h4>
<p>Firefox &lt; 3.5禁止在body元素和它的第一个子元素之间插入多余的空格，所以</p>
<ul>
<li>要么对before伪类使用<code>content:&quot;.&quot;</code></li>
<li>要么额外加上<code>visibility:hidden</code>等等属性来隐藏这种情况下所插入的字符(但这也不能解释淘宝网闭合浮动的写法，因为淘宝网主要把它用在after伪类上)</li>
</ul>
<h3 id="设置before伪元素的作用："><a class="header-anchor" href="#设置before伪元素的作用："></a>设置before伪元素的作用：</h3>
<p>设定before伪元素的属性<strong>并不是用来闭合浮动的</strong>，不过它能阻止上外边距的合并，这会带来两个好处：</p>
<ul>
<li>这种清除浮动的方式所表现出来的外貌看上去和 其他的清除浮动的方式(比如overflow:hidden)的 一致。</li>
<li>和IE6/7使用zoom:1后的外貌保持一致</li>
</ul>
<p>毕竟，<strong>使用after伪元素闭合浮动</strong>的时候，下外边距的合并已经被阻止了，为了上下看上去对称，before伪元素也应该这样。</p>
<p>主要译自： <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="external">A new micro clearfix hack</a></p>
<h3 id="创新方案：零宽度空格"><a class="header-anchor" href="#创新方案：零宽度空格"></a>创新方案：零宽度空格</h3>
<p>通过查询发现Unicode字符里有一个“零宽度空格”，也就是<a href="http://www.fileformat.info/info/unicode/char/200b/index.htm" target="_blank" rel="external">U+200B </a>，这个字符本身是不可见的，所以我们完全可以省略掉 visibility:hidden了</p>
<pre><code>.clearfix:after {content:&quot;200B&quot;; display:block; height:0; clear:both; }
.clearfix { *zoom:1; }
</code></pre>
<p>在实际开发中，由于存在Unicode字符不适合内嵌CSS的GB2312编码的页面，使用前面两个小方案完全可以解决我们的需求了。</p>
<h3 id="别混淆了闭合浮动-bfc-阻止上下外边距的合并"><a class="header-anchor" href="#别混淆了闭合浮动-bfc-阻止上下外边距的合并"></a>别混淆了闭合浮动/BFC/阻止上下外边距的合并</h3>
<p>这是一个比较详细的 <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/%E9%97%AD%E5%90%88%E6%B5%AE%E5%8A%A8%E5%92%8CBFC%E5%92%8C%E9%98%BB%E6%AD%A2%E4%B8%8A%E4%B8%8B%E5%A4%96%E8%BE%B9%E8%B7%9D%E7%9A%84%E5%90%88%E5%B9%B6.html" target="_blank" rel="external">demo</a>：</p>
<p>这个demo里面加入了<strong>企图对伪元素用display:block配合content:&quot; &quot;闭合浮动</strong>这种不太恰当的方法。</p>
<p>从这个demo可以看到：</p>
<ul>
<li><strong>使用伪元素闭合浮动</strong>必然会引发的一个效果是阻止下外边距的合并</li>
<li>BFC必然会引发的一个效果是阻止上下外边距的合并</li>
<li>闭合浮动 的方式不只有 触发BFC ，触发BFC 只是其中的一种方法</li>
<li>阻止上下外边距合并的方式不只有 触发BFC，触发BFC 只是其中的一种方法</li>
<li>而那些能触发BFC的方式可以参考本文前文的说明，其中就说明了浮动会触发BFC</li>
<li>单独的display:block并不会触发BFC</li>
<li>对伪元素用display:table会触发BFC</li>
<li>不应当<strong>企图对伪元素用display:block配合content:&quot; &quot;闭合浮动</strong>，因为这种方式的清除浮动 只有在ie7以下的浏览器里才能阻止上下外边距的合并，所以使用它的话不同浏览器的样式会不统一</li>
<li>要小心地对浮动的子元素设置下外边距，因为在IE7以下浏览器里面，如果没有其他子元素撑起父元素的高度，浮动的子元素的下外边距直接被解释为0(这是为了尽量减小页面的高度)，造成样式的不统一</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 清除浮动 </tag>
            
            <tag> BFC </tag>
            
            <tag> 伪元素 </tag>
            
            <tag> 阻止上下外边距合并 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task02笔记]]></title>
      <url>https://alexzhong22c.github.io/2017/04/01/ife-css-task02/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="external">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<a id="more"></a>
<h2 id="css选择器优先级"><a class="header-anchor" href="#css选择器优先级"></a>CSS选择器优先级</h2>
<p>在文章 <a href="https://alexzhong22c.github.io/2017/03/31/css-selectors-specificity/">CSS选择器优先级</a> 中我整合了这部分笔记。</p>
<h2 id="list-style-xxx"><a class="header-anchor" href="#list-style-xxx"></a>list-style-xxx</h2>
<p>我们常用list-style，实则它是一个 简写属性。</p>
<h3 id="list-style-type"><a class="header-anchor" href="#list-style-type"></a>list-style-type</h3>
<p>而<code>list-style-type</code>在CSS2中的新特性需要至少IE8的支持，所以我们一般只使用它在CSS1中的内容。况且，很少人提及list-style在移动设备浏览器上的支持，所以不能乱用。</p>
<p>另外，任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “decimal-leading-zero”、“lower-greek”、“lower-latin”、“upper-latin”、“armenian”、“georgian” 或 “inherit”。</p>
<p>可以使用的有：</p>
<ul>
<li>none</li>
</ul>
<p>用于无序列表的：</p>
<ul>
<li>disc 实心圆</li>
<li>circle 空心圆</li>
<li>square 实心方块</li>
</ul>
<p>用于有序列表的：</p>
<ul>
<li>decimal 数字</li>
<li>lower-alpha、upper-alpha</li>
<li>lower-roman、upper-roman</li>
</ul>
<h3 id="list-style-position"><a class="header-anchor" href="#list-style-position"></a>list-style-position</h3>
<p>默认值是outside，和inside的区别，看一下 <a href="http://www.w3school.com.cn/tiy/t.asp?f=csse_list-style-position" target="_blank" rel="external">demo</a> 马上就清楚</p>
<h3 id="list-style-image"><a class="header-anchor" href="#list-style-image"></a>list-style-image</h3>
<p>使用图像来替换列表项的标记。</p>
<p>这个属性指定作为一个有序或无序列表项标志的图像。图像相对于列表项内容的放置位置通常使用 list-style-position 属性控制。</p>
<p>注释：<strong>请始终规定一个 “list-style-type” 属性以防图像不可用。</strong></p>
<pre><code>ul {
  list-style:square outside url('/i/arrow.gif');
}
</code></pre>
<h2 id="border-collapse"><a class="header-anchor" href="#border-collapse"></a>border-collapse</h2>
<p>默认值是separate，不会忽略border-spacing和empty-cells属性。</p>
<p>collapse会忽略border-spacing和empty-cells属性。</p>
<p>注释：如果没有规定 !DOCTYPE，则 border-collapse 可能产生意想不到的结果。</p>
<h2 id="text-indent"><a class="header-anchor" href="#text-indent"></a>text-indent</h2>
<p>直接参考：<a href="http://ued.ctrip.com/blog/text-indent-summing-up.html" target="_blank" rel="external">http://ued.ctrip.com/blog/text-indent-summing-up.html</a></p>
<p>其总结就是：</p>
<p>1.text-indent只用于div，p这样的元素上，像image、input、inline-block、inline元素绝对不用。</p>
<p>2.text-indent的值如果子元素也要用到父元素的值，用px单位，而绝不用em。</p>
<h2 id="禁止用户选择文字"><a class="header-anchor" href="#禁止用户选择文字"></a>禁止用户选择文字</h2>
<p>一般情况下用<code>user-select:none</code>，</p>
<p>IE6-9不支持该属性，但支持使用标签属性 <code>onselectstart=&quot;return false;&quot;</code> 来达到 <code>user-select:none</code> 的效果；Safari和Chrome也支持该标签属性；</p>
<p>直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 <code>unselectable=&quot;on&quot;</code> 来达到 <code>user-select:none</code> 的效果；unselectable 的另一个值是 off；</p>
<p>除Chrome和Safari外，在其它浏览器中，如果将文本设置为 <code>-ms-user-select:none;</code>，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 <code>-ms-user-select:none;</code> 的区域文本；</p>
<p><strong>所以，“禁止用户选择文字”一般是用来引导用户在界面的操作，而不能用来 控制用户的行为 或者 重度依赖这个trick。</strong></p>
<p>参考： <a href="http://www.css88.com/book/css/properties/user-interface/user-select.htm" target="_blank" rel="external">user-select-css88</a> 说明很完备。</p>
<pre><code class="language-html">&lt;body&gt;
前方的文字&lt;div class=&quot;test&quot; onselectstart=&quot;return false;&quot; unselectable=&quot;on&quot;&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>CSS代码：</p>
<pre><code class="language-css">.test{
  -webkit-user-select:none;
  -moz-user-select:none;
  -o-user-select:none;
  user-select:none;
  /*onselectstart和unselectable在html那里*/
}
</code></pre>
<p><strong>另外，结合JavaScript代码来实现禁止效果，效果会更好。</strong></p>
<p>例如：<a href="http://stackoverflow.com/questions/2700000/how-to-disable-text-selection-using-jquery" target="_blank" rel="external">http://stackoverflow.com/questions/2700000/how-to-disable-text-selection-using-jquery</a></p>
<h2 id="text-align"><a class="header-anchor" href="#text-align"></a>text-align</h2>
<p><a href="http://www.css88.com/book/css/properties/text/text-align.htm" target="_blank" rel="external">text-align–CSS88</a> 还介绍了单行文字怎么应用justify</p>
<h2 id="fieldset默认样式隐藏"><a class="header-anchor" href="#fieldset默认样式隐藏"></a>fieldset默认样式隐藏</h2>
<p>看到一篇文章介绍 <a href="http://canfly2010.iteye.com/blog/678584" target="_blank" rel="external">Extjs FieldSet组件</a> 的文章很有趣，这个组件的目的是将fieldset的边框去掉或者改变内边距。</p>
<p>学到的一个知识是：</p>
<blockquote>
<p>fieldset默认是带边框的，而legend默认一般显示在左上角。但在某些场合或许不愿意让fieldset和legend的默认样式或默认布局影响设计方案中的美观。</p>
<p>解决方法：在CSS中将fieldset的border设置为0，legend的display设置为none即可。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> list-style </tag>
            
            <tag> 文字 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS选择器优先级]]></title>
      <url>https://alexzhong22c.github.io/2017/03/31/css-selectors-specificity/</url>
      <content type="html"><![CDATA[<p>CSS优先级计算的快速回顾，最后附上一些应用知识的实例。</p>
<a id="more"></a>
<h2 id="计算特殊性值的情况"><a class="header-anchor" href="#计算特殊性值的情况"></a>计算特殊性值的情况</h2>
<p>选择器的特殊性值表述为4个部分，基础值用0,0,0,0表示，为了方便描述用 A,B,C,D 分别代表各位：</p>
<p>能令A增加的：行间样式</p>
<p>能令B增加的：ID选择器</p>
<p>能令C增加的：类选择器、属性选择器或伪类</p>
<p>能令D增加的：元素和伪元素</p>
<p><strong>通配选择器 *</strong> 对特殊性值没有贡献，也当做是经过加 0 计算了</p>
<hr>
<p>例如：以下规则中选择器的特殊性分别是：</p>
<pre><code>a{color: yellow;} /*特殊性值：0,0,0,1*/
div a{color: green;} /*特殊性值：0,0,0,2*/
.demo a{color: black;} /*特殊性值：0,0,1,1*/
.demo input[type=&quot;text&quot;]{color: blue;} /*特殊性值：0,0,2,1*/
.demo *[type=&quot;text&quot;]{color: grey;} /*特殊性值：0,0,2,0*/
#demo a{color: orange;} /*特殊性值：0,1,0,1*/
div#demo a{color: red;} /*特殊性值：0,1,0,2*/
</code></pre>
<p><a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="external">验证结果参考demo</a></p>
<p>常见疑问：</p>
<ul>
<li>特殊性值不会进位</li>
<li><strong>假如特殊性值相同</strong>的两条规则应用到同一个元素，只有后声明的那条规则会生效</li>
<li>由上文可得：外联样式优先级并不一定低于内联样式</li>
</ul>
<h2 id="不计算特殊性值的情况"><a class="header-anchor" href="#不计算特殊性值的情况"></a>不计算特殊性值的情况</h2>
<ul>
<li><code>!important</code>(权重) 优先于 任何需要计算的特殊性值，可以视它为1,0,0,0,0</li>
<li>通配选择器定义的规则 优先于 元素<strong>继承</strong>过来的规则</li>
</ul>
<h2 id="not伪类例外"><a class="header-anchor" href="#not伪类例外"></a><code>:not</code>伪类例外</h2>
<p><code>:not</code> 否定伪类在优先级计算中不会被看作是伪类，但是在计算选择器数量时还是会把<strong>其中的选择器</strong>当做普通选择器进行计数。</p>
<h2 id="知识应用实例"><a class="header-anchor" href="#知识应用实例"></a>知识应用实例</h2>
<h3 id="a的四种状态实例"><a class="header-anchor" href="#a的四种状态实例"></a>a的四种状态实例</h3>
<p>我们知道a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active，并且这四个伪类如果对同一个元素设置同一个属性，那它们的声明顺序还有一定要求，一般大家都遵循“爱恨原则LVHA”（LoVe HAte），为什么是这个顺序？不能是其它顺序吗？</p>
<blockquote>
<p>当鼠标滑过a链接时，满足:link和:hover两个伪类，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；同理，当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。</p>
</blockquote>
<p>因此得出LVHA这个顺序。</p>
<blockquote>
<p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</p>
</blockquote>
<p><strong>对于:hover在IE6下只有a元素支持，:active只有IE7-6不支持，:focus在IE6-7下不被支持。</strong></p>
<h3 id="继承失效实例"><a class="header-anchor" href="#继承失效实例"></a>继承失效实例</h3>
<h4 id="代码示例："><a class="header-anchor" href="#代码示例："></a>代码示例：</h4>
<pre><code class="language-html">&lt;p&gt;Hello,&lt;span&gt;CSS&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p>CSS代码：</p>
<pre><code class="language-css">* {
    color:red;
}
p {
    color:green;
}
</code></pre>
<p>结果：<code>span</code>标签内的文本颜色是红色，而不是绿色。</p>
<h4 id="解释："><a class="header-anchor" href="#解释："></a>解释：</h4>
<p>我们常用*来做CSS reset，这常见的问题是导致继承失效：</p>
<p>继承的样式根本没有任何特殊性，而使用通配选择器<code>*</code>的声明具有0, 0, 0, 0特殊性。当二者冲突时，通配选择器胜出，导致继承失效。</p>
<p>自己写 CSS 时不要滥用 <code>*</code>，reset.css 也只是设置 margin, padding, box-sizing 等少数几个属性时才使用，这几个被重置的属性都不继承。</p>
<p>另外，不要用<code>*</code>设置font-family</p>
<h2 id="进一步理解-important"><a class="header-anchor" href="#进一步理解-important"></a>进一步理解<code>!important</code></h2>
<p>使用<code>!important</code>不是一个好习惯，因为它改变了你样式表本来的级联规则，从而难以调试。</p>
<h3 id="一些不成文规则"><a class="header-anchor" href="#一些不成文规则"></a>一些不成文规则</h3>
<ul>
<li><strong>不要</strong>在全站范围的css中使用<code>!important</code>.</li>
<li><strong>只在</strong>需要覆盖全站范围的css或是外部css（例如引用的ExtJs或是YUI）的时候才在指定的页面上使用<code>!important</code>。</li>
<li><strong>不要</strong>在你的插件中使用<code>!important</code>。</li>
<li><strong>永远</strong>都要优先考虑使用样式规则的优先级来解决问题而不是<code>!important</code>。</li>
</ul>
<p><strong>取而代之，你可以:</strong></p>
<p>更好的利用CSS的级联属性</p>
<p>更多的使用适合的选择器。比如在你需要选定的对象元素前加上更多的元素，使选择的范围缩小，你的选择器就变得更有针对性，从而提高优先级。</p>
<h3 id="什么时候应该使用："><a class="header-anchor" href="#什么时候应该使用："></a>什么时候应该使用：</h3>
<p>你的网站上有一个设定了全站样式的CSS文件，同时你（或是你同事）写了一些效果<s>通常都是</s>很差的行内样式（行内样式的优先级是最高的）。</p>
<p>在这种情况下，你就可以在你全局的CSS文件中写一些<code>!important</code>的样式来覆盖掉那些直接写在元素上的行内样式。</p>
<p>活生生的例子比如：有人在jQuery插件里写了糟糕的行内样式。</p>
<hr>
<p>参考：<a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="external">css优先级计算规则–王美建</a></p>
<p>参考我在这篇文章 <a href="https://segmentfault.com/a/1190000000453851" target="_blank" rel="external">CSS优先级详解</a> 的评论</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS选择器 </tag>
            
            <tag> 优先级 </tag>
            
            <tag> 权重 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task01笔记]]></title>
      <url>https://alexzhong22c.github.io/2017/03/27/ife-css-task01/</url>
      <content type="html"><![CDATA[<p>因为大家对html代码不是很重视，所以整理了一些容易忽略的问题并且对一些知识点作了梳理。</p>
<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="external">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<a id="more"></a>
<h2 id="常见问题总结"><a class="header-anchor" href="#常见问题总结"></a>常见问题总结</h2>
<h3 id="和强调相关的元素"><a class="header-anchor" href="#和强调相关的元素"></a>和强调相关的元素</h3>
<p><code>&lt;em&gt;</code> 用于对文本内容进行强调，强调位置的不同通常会改变句子的含义。如果仅仅在语态或语气上为了突出某一个文本，那应该使用<code>&lt;i&gt;</code>。</p>
<p>但如果为了突出某一部分的重要性、严重性或紧急性，那应该使用 <code>&lt;strong&gt;</code>。根据 W3C 对 <code>&lt;b&gt;</code>元素的说明，<code>&lt;b&gt;</code>元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签。</p>
<p>相同的，在考虑使用 <code>&lt;i&gt;</code> 之前，也要想想是否用<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;dfn&gt;</code> 或 <code>&lt;mark&gt;</code> 等元素更合适。</p>
<h3 id="单标签要闭合吗"><a class="header-anchor" href="#单标签要闭合吗"></a>单标签要闭合吗</h3>
<p>一句话总结,xhtml严格要求空标签必须自闭合,html5又不要求自闭合但是兼容xhtml的自闭合写法。</p>
<h3 id="alt属性"><a class="header-anchor" href="#alt属性"></a>alt属性</h3>
<p>为了写优雅的代码：img元素记得加alt属性</p>
<h3 id="表单控件"><a class="header-anchor" href="#表单控件"></a>表单控件</h3>
<ul>
<li>name对于radio很重要；name对于checkbox很重要</li>
<li>可以为radio, checkbox添加checked属性以及为option添加selected属性让其默认选中</li>
</ul>
<h3 id="h5加id的观点"><a class="header-anchor" href="#h5加id的观点"></a>H5加id的观点</h3>
<p>虽然语义化标签好用，但是当它需要加id的时候还是加吧：id=“header”</p>
<hr>
<h3 id="form元素"><a class="header-anchor" href="#form元素"></a>form元素</h3>
<p>水电费水电费水电费水电费s</p>
<pre><code>&lt;form&gt;
  &lt;label for=&quot;GET-name&quot;&gt;Name:&lt;/label&gt;
  &lt;input id=&quot;GET-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="fieldset元素"><a class="header-anchor" href="#fieldset元素"></a>fieldset元素</h3>
<p>fieldset元素 通常用来对表单的相关元素分组</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Title&lt;/legend&gt;
    &lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio&quot;&gt; &lt;label for=&quot;radio&quot;&gt;Click me&lt;/label&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h3 id="legend元素"><a class="header-anchor" href="#legend元素"></a>legend元素</h3>
<p>HTML的<code>&lt;legend&gt;</code>元素（也称为HTML的域说明元素（or HMTL
Legend Field Element））代表一个用于表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题。</p>
<h3 id="label元素"><a class="header-anchor" href="#label元素"></a>label元素</h3>
<p>label标签，为input元素定义标注，改进了表单控件的可用性，当你点击到label标签时，会自动聚焦到对应控件上。</p>
<h4 id="使用-label-for-属性-bind-input-id"><a class="header-anchor" href="#使用-label-for-属性-bind-input-id"></a>使用 label  “for” 属性 bind input “id”</h4>
<pre><code>&lt;label for=&quot;User&quot;&gt;Click me&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;
</code></pre>
<hr>
<h3 id="和按钮相关的元素"><a class="header-anchor" href="#和按钮相关的元素"></a>和按钮相关的元素</h3>
<p>在一个页面上画一个按钮，有四种办法：</p>
<ul>
<li><code>&lt;input type=&quot;button&quot; /&gt;</code>这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><code>&lt;input type=&quot;submit&quot; /&gt;</code> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。</li>
<li><code>&lt;button&gt;</code>这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题（<a href="">葛亮</a>）。</li>
<li>其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。</li>
</ul>
<p>type=&quot;button&quot;和type=&quot;submit&quot;各写一个，绑个alert或者dom操作。可以发现：button如果没别的，就会一动不动；submit如果没别的，就会刷新页面（应该是一闪然后保持原页面）；sb绑了dom，就是js的效果一闪，然后保持原页面。可以写js事件来绑定button，js是客户端的。但submit的实质作用是提交给服务端的，不是写个js阻止就能完事。</p>
<h3 id="dl-dt-dd元素"><a class="header-anchor" href="#dl-dt-dd元素"></a>dl dt dd元素</h3>
<p>严格来说定义列表只用来<strong>标记字典或术语表</strong>这样的结构，也有一说是它也可以用来标记对话。在实践中，如果有一系列的“标题 + 详情”这样的结构，使用定义列表也勉强说得过去。但实际上是有更好的标记方式，比如 hx + div/p 本身就表达了标题与详情的对应关系；如果一定要强调这一系列数据的并列关系，可以在外围使用 ul 或 ol。</p>
<p><a href="http://know.webhek.com/html5/html-dl-dt-dd.html" target="_blank" rel="external">http://know.webhek.com/html5/html-dl-dt-dd.html</a></p>
<p><a href="http://www.cnblogs.com/duhuo/p/5656511.html" target="_blank" rel="external">http://www.cnblogs.com/duhuo/p/5656511.html</a></p>
<h2 id="content-categories内容分类"><a class="header-anchor" href="#content-categories内容分类"></a>Content categories内容分类</h2>
<p>Content categories 这个话题的主要内容都写到了我的博客里： <a href="https://alexzhong22c.github.io/2017/01/25/h5-new-ele/">内容分类–谈谈H5标签</a></p>
<p>这里拿出一些比较重要的内容来讲：</p>
<h3 id="分节内容模型"><a class="header-anchor" href="#分节内容模型"></a>分节内容模型</h3>
<p>在当前的大纲中创建一个<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="external">分节</a>，此分节将定义<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="external"><code>header</code></a>元素、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer" target="_blank" rel="external"><code>footer</code></a> 元素和标题元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories#Heading_content" target="_blank" rel="external">heading content</a>）的范围。</p>
<h4 id="article元素"><a class="header-anchor" href="#article元素"></a>article元素</h4>
<p><code>&lt;article&gt;</code>元素表示文档、页面、应用或网站中的<strong>独立结构</strong>，其意在成为<strong>可独立分配的或可复用的结构</strong>，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。</p>
<p>用时要特别注意内容的独立性：一般独立完整的内容才使用article元素，如果只是一段内容的话应该是用section元素。</p>
<blockquote>
<p>使用说明：</p>
<ul>
<li>当<code>&lt;article&gt;</code>元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的<code>&lt;article&gt;</code>元素可嵌套在代表博客文章的<code>&lt;article&gt;</code>元素中。</li>
<li><code>&lt;article&gt;</code>元素的作者信息可通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/address" target="_blank" rel="external"><code>address</code></a>元素提供，但是不适用于嵌套的<code>&lt;article&gt;</code>元素。</li>
<li><code>&lt;article&gt;</code>元素的发布日期和时间可通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/time" target="_blank" rel="external"><code>time</code></a>元素的<code>pubdate</code>属性表示。</li>
</ul>
</blockquote>
<h4 id="section元素"><a class="header-anchor" href="#section元素"></a>section元素</h4>
<ul>
<li>用于定义文章中的<strong>章节</strong>(通常应该有标题和段落内容)</li>
</ul>
<ul>
<li>用来定义文档中特定的内容区块，可视为一个区域分组元素。</li>
</ul>
<ul>
<li>用一句话来概括它的作用就是：给内容分段，给页面分区</li>
</ul>
<ul>
<li>注意它与div的区别，div强调在形式上的独立性，section强调的是内容上的独立性，注意它的语义。</li>
</ul>
<blockquote>
<p>article和section对比：</p>
<p>1. 语义不同：</p>
<ul>
<li>article元素是独立完整的内容，section元素页面内容分块</li>
</ul>
<p>2. 相同点：</p>
<p>本质上都是带有语义的div块元素</p>
<p>分别可以看做<code>&lt;div id=&quot;section&quot;&gt;</code>和<code>&lt;div id=&quot;article&quot;&gt;</code></p>
</blockquote>
<h4 id="aside元素"><a class="header-anchor" href="#aside元素"></a>aside元素</h4>
<ul>
<li>aside元素通常用来设置<strong>侧边栏</strong></li>
<li>用于定义article元素之外的内容，前提是这些内容与article元素内的内容相关。</li>
<li>同时也可嵌套在article元素内部使用，作为主要内容的<strong>附属信息</strong>。比如与内容有关的参考资料，名词解释等。</li>
</ul>
<h4 id="nav元素"><a class="header-anchor" href="#nav元素"></a>nav元素</h4>
<ul>
<li>用来定义目录、导航栏</li>
<li>并非所有的超链接都放在nav元素中，通常只把一个文档中的主导航栏放在nav中。</li>
<li>通常一个页面导航可以这样写：</li>
</ul>
<pre><code class="language-html">&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>
<p>或者：</p>
<pre><code class="language-html">&lt;div id=&quot;nav&quot;&gt;
   &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<h3 id="标题内容模型"><a class="header-anchor" href="#标题内容模型"></a>标题内容模型</h3>
<p>定义了分节的标题，而这个分节可能由一个明确的分节内容元素直接标记，也可能由标题本身隐式地定义。</p>
<p>属于此分类的元素有：h1到h6和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/hgroup" target="_blank" rel="external"><code>hground</code></a></p>
<blockquote>
<p>注意：尽管<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="external"><code>header</code></a>可能包含一些标题内容，但<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="external"><code>header</code></a>并不是标题内容本身。</p>
</blockquote>
<h3 id="表单相关内容模型"><a class="header-anchor" href="#表单相关内容模型"></a>表单相关内容模型</h3>
<p>拥有表单父节点（exposed by a <strong>form</strong> attribute）的元素。</p>
<p>一个表单父节点可以是form元素，也可以是其id在表单属性中被指定了的元素。</p>
<p><strong>thead/tobody/tfoot标签bug挺多的，暂时不要用！！</strong></p>
<p><code>caption</code>标签必须紧随 table 标签之后</p>
<h3 id="其他比较常用的元素"><a class="header-anchor" href="#其他比较常用的元素"></a>其他比较常用的元素</h3>
<h4 id="header元素"><a class="header-anchor" href="#header元素"></a>header元素</h4>
<p><code>&lt;header&gt;</code>元素表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</p>
<h4 id="footer元素"><a class="header-anchor" href="#footer元素"></a>footer元素</h4>
<p><strong>HTML <code>&lt;footer&gt;</code>元素</strong>表示最近一个<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document#Defining_Sections_in_HTML5" target="_blank" rel="external">章节内容</a>或者<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document#Sectioning_root" target="_blank" rel="external">根节点</a>（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p>
<blockquote>
<ul>
<li><code>&lt;footer&gt;</code>元素内的作者信息应包含在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/address" target="_blank" rel="external"><code>address</code></a> 元素中。</li>
<li><code>&lt;footer&gt;</code>元素不是章节内容，因此在<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="external">outline</a>中不能包含新的章节。</li>
</ul>
</blockquote>
<hr>
<h4 id="time元素"><a class="header-anchor" href="#time元素"></a>time元素</h4>
<ul>
<li>time元素代表24小时中的某个时刻或某个日期，表示时刻允许出现时差。它可以定义很多格式的日期和时间
<ul>
<li>datetime属性。代表中日期和时间之间要用“T”文字分隔，“T”表示时间，请注意倒数第二行，时间加上Z文字表示给机器编码时使用UTC标准时间，表示向机器编码另一地区时间，如果是编码本地时间，则不需要添加时差。</li>
<li>pubdate属性是个可选标签。加上它搜索引擎/浏览器就可以很方便的识别出那个日期是文章、新闻的发表日期。</li>
</ul>
</li>
</ul>
<pre><code>&lt;time datetime=&quot;2015-10-22&quot;&gt;2015年10月12日&lt;/time&gt;
&lt;time datetime=&quot;2015-10-22T20:00&quot;&gt;2015年10月12日晚上8点&lt;/time&gt;
&lt;time datetime=&quot;2015-10-22T20:00Z&quot;&gt;2015年10月12日晚上8点&lt;/time&gt;
&lt;time datetime=&quot;2015-10-22T20:00+09:00&quot;&gt;美国时间2015年10月12日8点&lt;/time&gt;
</code></pre>
<h4 id="address元素"><a class="header-anchor" href="#address元素"></a>address元素</h4>
<ul>
<li>通常用来说明作者的<strong>联系信息</strong>，例如名字、E-mail、电话、地址等。</li>
<li>address元素中的内容会以斜体显示。</li>
<li>如果单纯只有作者名的内容建议用<code>em</code></li>
</ul>
<hr>
<ul>
<li><code>一般图片有caption时才使用figure元素和figcaption元素</code></li>
<li>另外，当文档中的一些嵌入式内容，比如引用的图片，插图，表格，代码段等，可以作为独立的单元，当这部分转移到附录中或者其他页面时不会影响到主体，这样的元素都可以放在<code>&lt;figure&gt;</code>元素内，而且可以搭配其子元素<code>&lt;figcaption&gt;</code>作很好的元素说明或者备注信息</li>
</ul>
<h4 id="figure元素"><a class="header-anchor" href="#figure元素"></a>figure元素</h4>
<p>figure元素是一个媒体组合元素，也就是对其他的媒体元素进行组合，比如：图像、图标等等。</p>
<h4 id="figcaptio元素"><a class="header-anchor" href="#figcaptio元素"></a>figcaptio元素</h4>
<p>用来给figure元素定义标题。</p>
<h4 id="video元素"><a class="header-anchor" href="#video元素"></a>video元素</h4>
<ul>
<li>src属性：音频地址</li>
<li>loop属性：是否重复播放</li>
<li>autoplay属性：是否自动播放</li>
<li>controls属性：添加控制</li>
<li>poster属性：在视频加载完成前显示什么</li>
<li>当然这个元素对于个别浏览器会有些隐性的小问题</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
            <tag> HTML </tag>
            
            <tag> IFE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[eslint折腾记]]></title>
      <url>https://alexzhong22c.github.io/2017/03/11/try-eslint/</url>
      <content type="html"><![CDATA[<p>关于 eslint 这一个简单的工具的使用，本人目前仍在摸索。</p>
<a id="more"></a>
<h2 id="卸载干净"><a class="header-anchor" href="#卸载干净"></a>卸载干净</h2>
<p>在同类型的 jslint 、jshint 、eslint 当中我选择了 eslint 。</p>
<p>为了简单起见，我先从 sublime 的 eslint 插件入手。</p>
<p>一开始我想着对自己要求严格一点，那就用 airbnb 版的 eslint 插件配置吧。</p>
<p>没想到：</p>
<ul>
<li>airbnb 对ES6的使用非常深入，这使得我如果不按照ES6来写的话会遭遇大量的错误，即便把要使用ES6的配置关闭，这个代码校正也让我无法承受</li>
<li>网上不建议初学者直接上手 ES6</li>
<li>最近做一个小项目，我的前端搭档要求 JavaScript 代码要兼容比较老的一些浏览器</li>
<li>用babel 可以将ES6转成ES5，但是最后是在你的工程中配置了babel</li>
</ul>
<p>为了 airbnb 版，我安装了一堆npm插件，大概是卸载干净了。</p>
<p>最终，我只安装了<a href="https://github.com/SublimeLinter/SublimeLinter3" target="_blank" rel="external">SublimeLinter</a>和<a href="https://github.com/roadhump/SublimeLinter-eslint" target="_blank" rel="external">SublimeLinter-contrib-eslint</a> 和cssLint，xxxx。另外的这一篇 <a href="http://www.tuicool.com/articles/faANRvj" target="_blank" rel="external">《在Sublime3中使用ESLint》</a> 也值得一读。</p>
<h2 id="私人配置"><a class="header-anchor" href="#私人配置"></a>私人配置</h2>
<p>我用的是eslintrc.json文件来自定义配置，这样的一个好处是，可以通过</p>
<pre><code>&quot;extends&quot;: &quot;standard&quot;,
</code></pre>
<p>引入 standar 版的 eslint 插件配置，作为我的配置的主题。然后它就像css 一样，写在文件后方的配置可以<strong>覆盖</strong>前方的同名配置，这样就可以私人订制一些个别的修改，经过了一个晚上的奋战，下面这些就是我私人添加的配置，仅供参考：</p>
<pre><code>{
  &quot;extends&quot;: &quot;standard&quot;,					//引入大神的配置作为主体
  &quot;globals&quot;: {
    &quot;$&quot;: true,                                //zepto
    &quot;define&quot;: true,                           //requirejs
    &quot;require&quot;: true                           //requirejs
  },
  &quot;env&quot;: {
    &quot;browser&quot;: true                           //执行环境 浏览器
  },
  &quot;rules&quot;: {
    //官方文档 http://eslint.org/docs/rules/
    &quot;no-unused-vars&quot;: [1, { &quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;none&quot;, &quot;ignoreRestSiblings&quot;: true }],                 //变量定义后未使用
    &quot;quotes&quot;: [1, &quot;single&quot;, { &quot;avoidEscape&quot;: true, &quot;allowTemplateLiterals&quot;: true }],
    // &quot;no-inner-declarations&quot;: [0, &quot;both&quot;],     //不建议在{}代码块内部声明变量或函数
    &quot;no-extra-boolean-cast&quot;: 1,               //多余的感叹号转布尔型
    &quot;no-extra-semi&quot;: 1,                       //多余的分号
    &quot;no-extra-parens&quot;: 1,                     //多余的括号
    &quot;no-empty&quot;: 1,                            //空代码块
    &quot;no-use-before-define&quot;: [1, &quot;nofunc&quot;],    //使用前未定义
    &quot;complexity&quot;: [1, 10],                    //圈复杂度大于10 警告
    &quot;no-cond-assign&quot;: [2, &quot;always&quot;],          //条件语句中禁止赋值操作
    &quot;no-native-reassign&quot;: 2,                  //禁止覆盖原生对象

    //代码风格优化
        &quot;operator-linebreak&quot;: [&quot;error&quot;, &quot;before&quot;],
    &quot;no-else-return&quot;: 1,                      //在else代码块中return，else是多余的
    &quot;no-multi-spaces&quot;: 1,                     //不允许多个空格
    &quot;key-spacing&quot;: [1, {&quot;beforeColon&quot;: false, &quot;afterColon&quot;: true}],//object直接量建议写法 : 后一个空格前面不留空格
    &quot;block-scoped-var&quot;: 2,                    //变量应在外部上下文中声明，不应在{}代码块中
    &quot;consistent-return&quot;: 2,                   //函数返回值可能是不同类型

    &quot;no-loop-func&quot;: 2,                        //禁止在循环体中定义函数
    &quot;no-return-assign&quot;: [2, &quot;always&quot;],        //不允return时有赋值操作
    &quot;no-redeclare&quot;: [2, {&quot;builtinGlobals&quot;: true}],//不允许重复声明
    &quot;no-unused-expressions&quot;: [2, {&quot;allowShortCircuit&quot;: true, &quot;allowTernary&quot;: true}],//不执行的表达式
    &quot;no-useless-concat&quot;: 2,                   //无意义的string concat
    &quot;no-void&quot;: 2,                             //禁用void
    &quot;no-with&quot;: 1,                             //禁用with
    &quot;valid-jsdoc&quot;: [2, {&quot;requireParamDescription&quot;: true, &quot;requireReturnDescription&quot;: true}],//jsdoc
    &quot;no-warning-comments&quot;: [2, { &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;any other term&quot;], &quot;location&quot;: &quot;anywhere&quot; }],//标记未写注释
    &quot;curly&quot;: 1                                //if、else、while、for代码块用{}包围
  }
}
</code></pre>
<p>另外，<a href="http://blog.csdn.net/lj745280746/article/details/49658249" target="_blank" rel="external">sublime 集成 ESLint</a> 也值得一读</p>
]]></content>
      
        <categories>
            
            <category> essay </category>
            
        </categories>
        
        
        <tags>
            
            <tag> eslint </tag>
            
            <tag> 配置 </tag>
            
            <tag> 插件 </tag>
            
            <tag> essay </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IIFE回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/03/10/iife-intro/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="定义"><a class="header-anchor" href="#定义"></a>定义</h2>
<p>IIFE: 意为立即调用的函数表达式，也就是说，<strong>声明函数的同时立即调用这个函数。</strong></p>
<h3 id="对比"><a class="header-anchor" href="#对比"></a>对比</h3>
<p>如果不采用IIFE：</p>
<pre><code>function foo(){
  var a = 10;
  console.log(a);
}

foo();
</code></pre>
<p>函数声明和执行是可以分离的。</p>
<hr>
<p>如果采用IIFE：</p>
<pre><code>(function foo(){
  var a = 10;
  console.log(a);
})();
</code></pre>
<p>JS编译器不再认为这是一个函数声明，而是一个IIFE，即需要立刻执行声明的函数。</p>
<p>两者达到的目的是相同的，都是声明了一个函数foo并且随后调用函数foo。</p>
<h2 id="为什么需要iife"><a class="header-anchor" href="#为什么需要iife"></a>为什么需要IIFE</h2>
<ul>
<li>立即执行一个函数</li>
<li>需要用函数实现作用域隔离</li>
</ul>
<p>在这两种情景下，使用IIFE就比较方便。</p>
<p>如果只是为了立即执行一个函数，显然IIFE所带来的好处有限。实际上，IIFE的出现是为了弥补JS在scope方面的缺陷：JS只有全局作用域（global scope）、函数作用域（function scope），从ES6开始才有块级作用域（block scope）。对比现在流行的其他面向对象的语言可以看出，JS在访问控制这方面是多么的脆弱！那么如何实现作用域的隔离呢？在JS中，只有function，只有function，**只有function才能实现作用域隔离，**因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。</p>
<p>在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，当然声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：这通常的目的是为了隔离作用域了！<strong>既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。</strong></p>
<h2 id="iife的函数名和参数"><a class="header-anchor" href="#iife的函数名和参数"></a>IIFE的函数名和参数</h2>
<pre><code>var a = 2;
(function IIFE(global){
    var a = 3;
    console.log(a); // 3
    console.log(global.a); // 2
})(window);

console.log(a); // 2
</code></pre>
<h2 id="iife构造单例模式"><a class="header-anchor" href="#iife构造单例模式"></a>IIFE构造单例模式</h2>
<p>JS的模块就是函数，最常见的模块定义如下：</p>
<pre><code>function myModule(){
  var someThing = &quot;123&quot;;
  var otherThing = &quot;456&quot;;

  function doSomeThing(){
    console.log(someThing);
  }

  function doOtherThing(){
    console.log(otherThing);
  }

  return {
    doSomeThing:doSomeThing,
    doOtherThing:doOtherThing
  }
}

var foo = myModule();
foo.doSomeThing();
foo.doOtherThing();

var foo1 = myModule();
foo1.doSomeThing();
</code></pre>
<p>如果需要一个单例模式的模块，那么可以利用IIFE：</p>
<pre><code>var myModule = (function module(){
  var someThing = &quot;123&quot;;
  var otherThing = &quot;456&quot;;

  function doSomeThing(){
    console.log(someThing);
  }

  function doOtherThing(){
    console.log(otherThing);
  }

  return {
    doSomeThing:doSomeThing,
    doOtherThing:doOtherThing
  }
})();

myModule.doSomeThing();
myModule.doOtherThing();
</code></pre>
<p>参考：<a href="http://dz.sdut.edu.cn/blog/subaochen/2016/02/%E8%AF%B4%E4%B8%80%E8%AF%B4js%E7%9A%84iife/" target="_blank" rel="external">IIFE–subaochen</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> IIFE </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js的for循环回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/03/09/for-loop/</url>
      <content type="html"><![CDATA[<p>非常经典，还分析了老的几个浏览器：<a href="http://www.zhangxinxu.com/wordpress/2013/04/es5%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" target="_blank" rel="external">es5新增数组方法和兼容性问题</a></p>
<p>ES5 中分别有三种 for 循环：</p>
<ul>
<li>简单的for循环</li>
<li>for in</li>
<li>for each</li>
</ul>
<p>ES6 新增了for of</p>
<p>因为for循环和Array关系非常密切，所以先谈谈Array。</p>
<a id="more"></a>
<h2 id="array的本质"><a class="header-anchor" href="#array的本质"></a>Array的本质</h2>
<p>Javascript 中的 Array 并不像大部分其他语言的数组。</p>
<ul>
<li>Javascript 中的 Array 在内存上并不连续</li>
<li>Array 的索引并不是指偏移量</li>
<li>Array 的索引也不是 Number 类型，而是 String 类型的
<ul>
<li>我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0”</li>
</ul>
</li>
</ul>
<p>有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p>
<h2 id="简单-for-循环"><a class="header-anchor" href="#简单-for-循环"></a>简单 for 循环</h2>
<p>最常见的写法是：</p>
<pre><code>const arr = [1, 2, 3];
for(let i = 0;i &lt; arr.length; i++) {
  console.log(arr[i]);
}
</code></pre>
<p>当数组长度在循环过程中不会改变时，我们最好将数组长度用变量存储起来，这样会获得更好的效率：</p>
<pre><code>const arr = [1, 2, 3];
for(let i = 0,len=arr.length; i &lt; len; i++) {
  console.log(arr[i]);
}
</code></pre>
<h2 id="for-in"><a class="header-anchor" href="#for-in"></a>for in</h2>
<p>for-in 一般情况下只用于遍历稀疏数组，这样的好处大大的：</p>
<pre><code>let key;
const arr = [];
arr[0] = &quot;a&quot;;
arr[100] = &quot;b&quot;;
arr[10000] = &quot;c&quot;;
for(key in arr) {
    if(arr.hasOwnProperty(key)  &amp;&amp;    
        /^0$|^[1-9]\d*$/.test(key) &amp;&amp;    
        key &lt;= 4294967294               
        ) {
        console.log(arr[key]);
    }
}
</code></pre>
<p>for-in 只会遍历存在的实体，上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，普通 for 循环则会遍历 10001 次）。</p>
<p>为了避免重复劳动，我们可以包装一下上面的代码：</p>
<pre><code>function arrayHasOwnIndex(array, prop) {
    return array.hasOwnProperty(prop) &amp;&amp;
        /^0$|^[1-9]\d*$/.test(prop) &amp;&amp;
        prop &lt;= 4294967294; // 2^32 - 2
}
</code></pre>
<p>使用示例如下：</p>
<pre><code>for (let key in arr) {
    if (arrayHasOwnIndex(arr, key)) {
        console.log(arr[key]);
    }
}
</code></pre>
<h3 id="为什么上面代码要加那么多条件判断"><a class="header-anchor" href="#为什么上面代码要加那么多条件判断"></a>为什么上面代码要加那么多条件判断</h3>
<p>for-in 循环遍历的是对象的属性，而不是数组的索引。因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。</p>
<pre><code>const person = {
    fname: &quot;san&quot;,
    lname: &quot;zhang&quot;,
    age: 99
};
let info;
for(info in person) {
    console.log(&quot;person[&quot; + info + &quot;] = &quot; + person[info]);
}
</code></pre>
<p>结果如下：</p>
<pre><code>person[fname] = san
person[lname] = zhang
person[age] = 99
</code></pre>
<p>需要注意的是， for-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p>
<p>因为期望的是对象，所以<strong>不应该用for in来循环遍历数组</strong>：如果采用prototype扩展原生的Array，这些属性也会被for in遍历出来，这样就有可能出乎程序员的意料：</p>
<pre><code>// Somewhere deep in your JavaScript library...
Array.prototype.foo = 1;

// Now you have no idea what the below code will do.
var a = [1, 2, 3, 4, 5];
for (var x in a){
  // Now foo is a part of EVERY array and 
  // will show up here as a value of 'x'.
  console.log(x);
}

/**
 * 输出:
 * 0
 * 1
 * 2
 * 3
 * 4
 * foo
 */
</code></pre>
<h3 id="注意"><a class="header-anchor" href="#注意"></a>注意</h3>
<p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="external">for…in–MDN</a>：</p>
<blockquote>
<p><code>for...in</code> 循环以任意序迭代一个对象的属性。</p>
<p>如果一个属性在一次迭代中被修改，在稍后被访问，其在循环中的值是其在稍后时间的值。正常。</p>
<p>一个在被访问之前已经被删除的属性将不会在之后被访问。正常。</p>
<p>在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略。不正常。</p>
<p><strong>通常，在迭代过程中最好不要在对象上进行添加属性的值、修改或者删除属性的操作，除非是对当前正在被访问的属性。</strong></p>
<p>因为一个被添加的属性在迭代过程中可能会不被访问到。如果不是当前正在被访问的元素：一个修改后的属性可能会在修改前或者修改后被访问 并且 一个被删除的属性可能会在它被删除之前被访问。</p>
</blockquote>
<p>通俗来讲就是：要改的话就只能改当前循环访问到的属性，而其他<strong>没有被访问的</strong>或者<strong>还未被当前循环访问到的</strong>属性就不能改。</p>
<h3 id="for-in-性能"><a class="header-anchor" href="#for-in-性能"></a>for in 性能</h3>
<p>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：</p>
<pre><code>const obj = {
    &quot;prop1&quot;: &quot;value1&quot;,
    &quot;prop2&quot;: &quot;value2&quot;
};

const props = [&quot;prop1&quot;, &quot;prop2&quot;];
for(let i = 0; i &lt; props.length; i++) {
    console.log(obj[props[i]]);
}
</code></pre>
<p>上面代码中，将对象的属性都存入一个数组中，相对于 <code>for-in</code> 查找每一个属性，该代码只关注<strong>给定的</strong>属性，节省了循环的开销和时间。</p>
<h2 id="foreach"><a class="header-anchor" href="#foreach"></a>forEach</h2>
<p>forEach只支持IE9及以上。forEach把数组对象的引索当做是number类型。本文章的最后有它的polyfill。</p>
<p><code>forEach</code> 可以当做是<code>for(let i = 0; i &lt; len; i++)</code>的简写，但是不能完成 <code>i + n</code> 这种循环，同时也不支持 <code>continue</code>和 <code>break</code>，只能通过 <code>return</code> 来控制循环。另外，使用<code>forEach</code>的话，是不能退出循环本身的。</p>
<p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 callback 函数会被依次传入三个参数：</p>
<ul>
<li>数组当前项的值；</li>
<li>数组当前项的索引；</li>
<li>数组对象本身；</li>
</ul>
<p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</p>
<pre><code>const arr = [];
arr[0] = &quot;a&quot;;
arr[3] = &quot;b&quot;;
arr[10] = &quot;c&quot;;
arr.name = &quot;Hello world&quot;;
arr.forEach((data, index, array) =&gt; {
    console.log(data, index, array);
});
</code></pre>
<p>运行结果：</p>
<pre><code>a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
</code></pre>
<p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p>
<p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p>
<p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p>
<ul>
<li>every: 循环在第一次 return false 后返回</li>
<li>some: 循环在第一次 return true 后返回</li>
<li>filter: 返回一个新的数组，该数组内的元素满足回调函数</li>
<li>map: 将原数组中的元素处理后再返回</li>
<li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li>
</ul>
<h3 id="foreach的性能"><a class="header-anchor" href="#foreach的性能"></a>forEach的性能</h3>
<p>大家可以看 jsPerf ，在不同浏览器下测试的结果都是 forEach 的速度不如 for。如果大家把测试代码放在控制台的话，可能会得到不一样的结果，主要原因是控制台的执行环境与真实的代码执行环境有所区别。</p>
<h2 id="for-of"><a class="header-anchor" href="#for-of"></a>for of</h2>
<pre><code>const arr = ['a', 'b', 'c'];
for(let data of arr) {
    console.log(data);
}
</code></pre>
<p>运行结果是：</p>
<pre><code>a
b
c
</code></pre>
<h3 id="为什么要引进-for-of？"><a class="header-anchor" href="#为什么要引进-for-of？"></a>为什么要引进 for-of？</h3>
<p>要回答这个问题，我们先来看看ES6之前的 3 种 for 循环有什么缺陷：</p>
<ul>
<li>forEach 不能 break 和 return；</li>
<li>for-in 缺点更加明显，它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。而且，遍历数组元素的顺序可能是随机的。</li>
</ul>
<p>所以，鉴于以上种种缺陷，我们需要改进原先的 for 循环。但 ES6 不会破坏你已经写好的 JS 代码。目前，成千上万的 Web 网站依赖 for-in 循环，其中一些网站甚至将其用于数组遍历。如果想通过修正 for-in 循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在 ES6 中增加了一种新的循环语法来解决目前的问题，即 for-of 。</p>
<p>那 for-of 到底可以干什么呢？</p>
<ul>
<li>跟 forEach 相比，可以正确响应 break, continue, return。</li>
<li>for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</li>
<li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li>
<li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历。</li>
</ul>
<p>总结一下，for-of 循环有以下几个特征：</p>
<ul>
<li>这是最简洁、最直接的遍历数组元素的语法。</li>
<li>这个方法避开了 for-in 循环的所有缺陷。</li>
<li>与 forEach 不同的是，它可以正确响应 break、continue 和 return 语句。</li>
<li>其不仅可以遍历数组，还可以遍历类数组对象和其他可迭代对象。</li>
</ul>
<p>但需要注意的是，for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用</p>
<p>for-in 循环（这也是它的本职工作）。</p>
<p>最后要说的是，ES6 引进的另一个方式也能实现遍历数组的值，那就是 Iterator。上个例子：</p>
<pre><code>const arr = ['a', 'b', 'c'];
const iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
</code></pre>
<p>Iterator 要另外再介绍。</p>
<h2 id="补充foreach的polyfill"><a class="header-anchor" href="#补充foreach的polyfill"></a>补充forEach的polyfill</h2>
<pre><code>// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {
    var T, k;
    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }
    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);
    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument &quot;length&quot;.
    // 3. Let len be toUint32(lenValue).
    var len = O.length &gt;&gt;&gt; 0;
    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== &quot;function&quot;) {
      throw new TypeError(callback + ' is not a function');
    }
    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length &gt; 1) {
      T = thisArg;
    }
    // 6. Let k be 0
    k = 0;
    // 7. Repeat, while k &lt; len
    while (k &lt; len) {
      var kValue;
      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {
        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];
        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[事件进阶话题]]></title>
      <url>https://alexzhong22c.github.io/2017/03/05/js-event2/</url>
      <content type="html"><![CDATA[<p>此文内容深度其实不大，个人还需要进一步学习。</p>
<a id="more"></a>
<h2 id="常用事件和技巧"><a class="header-anchor" href="#常用事件和技巧"></a>常用事件和技巧</h2>
<p>用户的操作有很多种，所以有很多事件。为了开发方便，浏览器又提供了一些事件，所以有很多很多的事件。这里只介绍几种常用的事件和使用技巧。</p>
<h3 id="load"><a class="header-anchor" href="#load"></a>load</h3>
<p><code>load</code> 事件在资源加载完成时触发。这个资源可以是图片、CSS 文件、JS 文件、视频、document 和 window 等等。</p>
<p>比较常用的就是监听 window 的 <code>load</code> 事件，当页面内所有资源全部加载完成之后就会触发。比如用 JS 对图片以及其他资源处理，我们在 <code>load</code> 事件中触发，可以保证 JS 不会在资源未加载完成就开始处理资源导致报错。</p>
<p>同样的，也可以监听图片等其他资源加载情况。</p>
<h3 id="beforeunload"><a class="header-anchor" href="#beforeunload"></a>beforeunload</h3>
<p>当浏览者在页面上的输入框输入一些内容时，未保存、误操作关掉网页可能会导致输入信息丢失。</p>
<p>当浏览者输入信息但未保存时关掉网页，我们就可以开始监听这个事件，例如：</p>
<pre><code>window.addEventListener(&quot;beforeunload&quot;, function( event ) {
    event.returnValue = &quot;放弃当前未保存内容而关闭页面？&quot;;
});
</code></pre>
<p>这时候试图关闭网页的时候，会弹窗阻止操作，点击确认之后才会关闭。当然，如果没有必要，就不要监听，不要以为使用它可以为你留住浏览者。</p>
<h3 id="resize"><a class="header-anchor" href="#resize"></a>resize</h3>
<p>当节点尺寸发生变化时，触发这个事件。通常用在 window 上，这样可以监听浏览器窗口的变化。通常用在复杂布局和响应式上。</p>
<p>常见的视差滚动效果网站以及同类比较复杂的布局网站，往往使用 JavaScript 来计算尺寸、位置。如果用户调整浏览器大小，尺寸、位置不随着改变则会出现错位情况。在 window 上监听该事件，触发时调用计算尺寸、位置的函数，可以根据浏览器的大小来重新计算。</p>
<p>但需要注意一点，当浏览器发生任意变化都会触发 <code>resize</code> 事件，哪怕是缩小 1px 的浏览器宽度，这样调整浏览器时会触发大量的 <code>resize</code> 事件，你的回调函数就会被大量的执行，导致变卡、崩溃等。</p>
<p>你可以使用函数 throttle 或者 debounce 技巧来进行优化，throttle 方法大体思路就是在某一段时间内无论多次调用，只执行一次函数，到达时间就执行；debounce 方法大体思路就是在某一段时间内等待是否还会重复调用，如果不会再调用，就执行函数，如果还有重复调用，则不执行继续等待。关于它们更详细的信息，我后面会介绍一下发表在我的博客上，这里不再赘述。</p>
<h3 id="error"><a class="header-anchor" href="#error"></a>error</h3>
<p>当我们加载资源失败或者加载成功但是只加载一部分而无法使用时，就会触发 <code>error</code> 事件，我们可以通过监听该事件来提示一个友好的报错或者进行其他处理。比如 JS 资源加载失败，则提示尝试刷新；图片资源加载失败，在图片下面提示图片加载失败等。该事件不会冒泡。因为子节点加载失败，并不意味着父节点加载失败，所以你的处理函数必须精确绑定到目标节点。</p>
<p>需要注意的是，对于该事件，你可以使用 <code>addEventListener</code> 等进行监听，但是有时候会出现失效情况（看<a href="http://jsbin.com/esimAWA/2/quiet" target="_blank" rel="external">这个例子</a>），这是因为 <code>error</code> 事件都触发过了，你的 JS 监听处理代码还没有加载进来执行。为了避免这种情况，用内联法更好一些：</p>
<pre><code>&lt;img src=&quot;not-found.jpg&quot; onerror=&quot;doSomething&quot; /&gt;
</code></pre>
<p>如果还有其他常用事件，欢迎留言补充。</p>
<h2 id="事件回调函数的作用域问题"><a class="header-anchor" href="#事件回调函数的作用域问题"></a>事件回调函数的作用域问题</h2>
<p>与事件绑定在一起的回调函数作用域会有问题，我们来看个例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=utf-8 /&gt;
  &lt;title&gt;Events in JavaScript: Removing event listeners&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button id=&quot;element&quot;&gt;Click Me&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>JavaScript代码：</p>
<pre><code class="language-javascript">var element = document.getElementById('element');

var user = {
 firstname: 'Bob',
 greeting: function(){
   alert('My name is ' + this.firstname);
 }
};

// Attach user.greeting as a callback
element.addEventListener('click', user.greeting);
</code></pre>
<p>回调函数调用的 <code>user.greeting</code> 函数作用域应该是在 <code>user</code> 下的，本期望输出 <code>My name is Bob</code> 结果却输出了 <code>My name is undefined</code>。这是因为事件绑定函数时，该函数会以当前元素为作用域执行。为了证明这一点，我们可以为当前 <code>element</code> 添加属性：</p>
<pre><code>element.firstname = 'jiangshui';
</code></pre>
<p>再次点击，可以正确弹出 <code>My name is jiangshui</code>。那么我们来解决一下这个问题：</p>
<h3 id="使用匿名函数-办法一"><a class="header-anchor" href="#使用匿名函数-办法一"></a>使用匿名函数——办法一</h3>
<p>将JavaScript代码修改为：</p>
<pre><code>var element = document.getElementById('element');

var user = {
 firstname: 'Bob',
 greeting: function(){
   alert('My name is ' + this.firstname);
 }
};

// Call the method with the correct
// context inside an anonymouse function
element.addEventListener('click', function() {
  user.greeting();
});
</code></pre>
<p>包裹之后，虽然匿名函数的作用域被指向事件触发元素，但执行的内容就像直接调用一样，不会影响其作用域。</p>
<h3 id="使用-bind-方法"><a class="header-anchor" href="#使用-bind-方法"></a>使用 bind 方法</h3>
<p>使用匿名函数是有缺陷的，每次调用都包裹进匿名函数里面，增加了冗余代码等，此外如果想使用<code>removeEventListener</code> 解除绑定，还需要再创建一个函数引用。<code>Function</code> 类型提供了 <code>bind</code> 方法，可以为函数绑定作用域，无论函数在哪里调用，都不会改变它的作用域。通过如下语句绑定作用域：</p>
<pre><code>user.greeting = user.greeting.bind(user);
</code></pre>
<p>这样我们就可以直接使用：</p>
<pre><code>element.addEventListener('click', user.greeting);
</code></pre>
<h2 id="ie-浏览器的差异和兼容性问题"><a class="header-anchor" href="#ie-浏览器的差异和兼容性问题"></a>IE 浏览器的差异和兼容性问题</h2>
<p>IE 浏览器就是特立独行，它对于事件的操作与标准有一些差异。不过 IE 浏览器现在也开始慢慢努力改造，让浏览器变得更加标准。</p>
<h3 id="ie-下绑定事件"><a class="header-anchor" href="#ie-下绑定事件"></a>IE 下绑定事件</h3>
<p>在 IE 下面绑定一个事件监听，在 IE9- 无法使用标准的 <code>addEventListener</code> 函数，而是使用自家的 <code>attachEvent</code>，具体用法：</p>
<pre><code>element.attachEvent(&lt;event-name&gt;, &lt;callback&gt;);
</code></pre>
<p>其中 `` 参数需要注意，它需要为事件名称添加 <code>on</code> 前缀，比如有个事件叫 <code>click</code>，标准事件监听函数监听 <code>click</code>，IE 这里需要监听 <code>onclick</code>。</p>
<p>另一个，它没有第三个参数，也就是说它只支持监听在冒泡阶段触发的事件，所以为了统一，在使用标准事件监听函数的时候，第三参数传递 false。</p>
<p>当然，这个方法在 IE9 已经被抛弃，在 IE11 已经被移除了，IE 也在慢慢变好。</p>
<h3 id="ie-中-event-对象需要注意的地方"><a class="header-anchor" href="#ie-中-event-对象需要注意的地方"></a>IE 中 Event 对象需要注意的地方</h3>
<p>IE 中往回调函数中传递的事件对象与标准也有一些差异，你需要使用 <code>window.event</code> 来获取事件对象。所以你通常会写出下面代码来获取事件对象：</p>
<pre><code>event = event || window.event
</code></pre>
<p>此外还有一些事件属性有差别，比如比较常用的 <code>event.target</code> 属性，IE 中没有，而是使用 <code>event.srcElement</code> 来代替。如果你的回调函数需要处理触发事件的节点，那么需要写：</p>
<pre><code>node = event.srcElement || event.target;
</code></pre>
<p>常见的就是这点，更细节的不再多说。在概念学习中，我们没必要为不标准的东西支付学习成本；在实际应用中，类库已经帮我们封装好这些兼容性问题。可喜的是 IE 浏览器现在也开始不断向标准进步。</p>
<p>摘自：<a href="http://yujiangshui.com/javascript-event/#%E4%BA%8B%E4%BB%B6%E8%BF%9B%E9%98%B6%E8%AF%9D%E9%A2%98" target="_blank" rel="external">于江水</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 事件 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[float和绝对定位比较]]></title>
      <url>https://alexzhong22c.github.io/2017/03/04/float-n-absolute/</url>
      <content type="html"><![CDATA[<p>因为float实现的效果和绝对定位比较类似，稍后会对它们进行比较。</p>
<a id="more"></a>
<h2 id="float"><a class="header-anchor" href="#float"></a>float</h2>
<ul>
<li>在浮动一张图片或者其他元素时，是在要求浏览器把它往上方推，直到它碰到父元素的内边界。</li>
<li>浮动非图片元素时，要给它设定宽度。</li>
<li>默认情况下浮动元素的位置一般要受到父元素位置的限制，而且改变浮动元素在html文档中的次序，有可能会影响float的实现效果。</li>
</ul>
<h2 id="position"><a class="header-anchor" href="#position"></a>position</h2>
<ul>
<li>static 静态定位，每个元素都处于常规文档流中</li>
<li>relative 相对的是它原来在文档流中的位置（或者默认位置） 。
<ul>
<li>这个元素原来占据的空间没有动，其他元素也没动。</li>
<li>top right bottom left(可以给top left属性设定负值，把元素向上向左移动)</li>
</ul>
</li>
<li>absolute 绝对定位会把元素彻底从文档流中拿出来，再相对其他元素定位。</li>
<li>fixed 固定定位元素的定位上下文是视口，因此它不会随页面滚动而移动。</li>
</ul>
<h2 id="float和绝对定位比较"><a class="header-anchor" href="#float和绝对定位比较"></a>float和绝对定位比较</h2>
<p>我最常见的一个问题就是在一些布局中不知道用float好还是用绝对定位好，因为他们有一些相似的作用。</p>
<p>float 的诞生本来就是为了让文字环绕图片。</p>
<p><code>position: absolute</code>会导致元素脱离文档流，被定位的元素等于在文档中不占据任何位置，在另一个层呈现，可以设置z-index。PS的图层效果就是position: absolute。</p>
<p>float也会导致元素脱离文档流，但还在文档或容器中占据位置(不会跑到父元素的外面去)，把文档流和其它float元素向左或向右挤，并可能导致换行。图片的文字环绕布局效果就是float：</p>
<pre><code class="language-html">&lt;p&gt;
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
&lt;img src=&quot;/i/eg_cute.gif&quot; /&gt;
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
&lt;/p&gt;
</code></pre>
<p>CSS：</p>
<pre><code class="language-css">img 
{
float:right
}
</code></pre>
<h2 id="left-和-top属性"><a class="header-anchor" href="#left-和-top属性"></a>left 和 top属性</h2>
<p>float和绝对定位可以一起用在同一个元素，但是效果不好。
**left和top等属性应该用于position的定位，**但是我经常见到有些老手也会把它们用到float的元素上，这就很尴尬地滥用了，一般情况下这是因为对基础知识掌握不牢固所导致的。</p>
<h2 id="用到float的三栏布局所带来的启发"><a class="header-anchor" href="#用到float的三栏布局所带来的启发"></a>用到float的三栏布局所带来的启发</h2>
<p>需要说明的是，浮动布局依然遵循常规文档流，所以与绝对定位相比，浮动定位时HTML源文件中元素声明的位置显得格外重要。所以，在用到float实现的三栏布局中，交换左栏和右栏的声明次序会有很大影响，也有方法不用交换各栏的次序也可以实现同样的布局，但是，这就要用到一种比较晦涩的使用负边距值的方法。一般情况下，人们十有八九会选择交换源文件中左中两栏的声明次序。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> float </tag>
            
            <tag> 绝对定位 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[和margin有关的知识]]></title>
      <url>https://alexzhong22c.github.io/2017/03/04/about-margin/</url>
      <content type="html"><![CDATA[<p>总结一下和margin有关的基本知识，属于必须了解的范畴。</p>
<a id="more"></a>
<h2 id="基本知识"><a class="header-anchor" href="#基本知识"></a>基本知识</h2>
<h3 id="外边距的单位"><a class="header-anchor" href="#外边距的单位"></a>外边距的单位</h3>
<ul>
<li>为文本元素设置外边距时通常需要混合使用不同的单位</li>
<li>左右边距使用像素，使文本始终和包含元素边界保持固定间距</li>
<li>上下外边距以em为单位，让段间距随字号变化而响应增大或缩小</li>
</ul>
<h3 id="如果没有设置width属性"><a class="header-anchor" href="#如果没有设置width属性"></a>如果没有设置width属性</h3>
<ul>
<li>如果不设置块级元素的width属性，那么这个属性的默认值是auto,结果会让元素的宽度扩展到与父元素同宽。</li>
</ul>
<ul>
<li>没有宽度(没有设置width)的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边框和外边框，会导致内容宽度减少，减少量等于水平边框、内边框和外边框的和。</li>
</ul>
<h3 id="margin可以写1到4个值"><a class="header-anchor" href="#margin可以写1到4个值"></a>margin可以写1到4个值</h3>
<p>在实际应用中，个人不推荐使用三个值的margin，一是容易记错，二是不容易日后修改，一开始如果写成margin:10px 20px 30px;日后需求改动为上10px，右30px，下30px，左20px，你不得不还是得把这个margin拆开为margin:10px 30px 30px 20px;费力且不讨好，不如一开始就老老实实的写成margin:10px 20px 30px 20px;来的实在，不要为了现在节省俩个字节而让日后再次开发的成本上升。</p>
<h2 id="垂直外边距合并问题"><a class="header-anchor" href="#垂直外边距合并问题"></a>垂直外边距合并问题</h2>
<p>简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。你可以查看 <a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">W3Shool CSS外边距合并</a> 了解这个基本知识。</p>
<p>实际工作中，垂直外边距合并问题常见于<strong>第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距</strong>，而且只在标准浏览器下 (FirfFox、Chrome、Opera、Sarfi)产生问题，IE下反而表现良好。例子可以查看下面代码(IE下表现“正常”，标准浏览器下查看出现“bug”)：</p>
<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
	&lt;head&gt;
        &lt;title&gt;垂直外边距合并&lt;/title&gt;
        &lt;style&gt;
        .top{width:160px; height:50px; background:#ccf;}
        .middle{width:160px; background:#cfc;}
        .middle .firstChild{margin-top:20px;}
        &lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
        &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;middle&quot;&gt;
        &lt;div class=&quot;firstChild&quot;&gt;我其实只是想和我的父元素隔开点距离。&lt;/div&gt;
        &lt;div class=&quot;secondChild&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果按照CSS规范，IE的“良好表现”其实是一个错误的表现，因为IE的hasLayout渲染导致了这个“表现良好”的外观。而其他标准浏览器则会表现出“有问题”的外观。好了，如果你读过了上面W3Shcool的CSS外边距合并的文章后，就很容易讨论这个问题了。这个问题发生的原因是根据规范，一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>
<p>再说了白点就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己 “领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级，假传圣旨，把自己的margin当领导的margin执行。 对于垂直外边距合并的解决方案上面已经解释了，<strong>为父元素例子中的middle元素增加一个border-top或者padding-top即可解决这个问题。</strong></p>
<blockquote>
<p>一般说来这个问题解释到这里，大多数文章就不会再深入下去了，但作为一名实战开发者，最求的是知其然知其所以然，原本使用margin-top就是为了与父元素隔开距离，而按照你这么一个解法，其实是一种“修复”，为了“弥补修复”这个父子垂直外边距合并这个CSS规范“Bug”，而强制在父元素上使用border-top和padding-top，不舒服，也不容易记住，下次再发生这样的情况还是会忘记这条准则，而且在页面设计稿里如果不需要 border-top加个上边框，这么一加反而画蛇添足，为以后修改留下隐患。</p>
<p>为什么一定要用border-top,padding-top去为了这么一个所谓的标准规范而多写这么一行代码呢？答案你可以参考另外一篇文章<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="external">用Margin还是用Padding</a>里找到答案。</p>
</blockquote>
<h2 id="用margin还是用padding"><a class="header-anchor" href="#用margin还是用padding"></a>用Margin还是用Padding</h2>
<h3 id="何时应当使用margin："><a class="header-anchor" href="#何时应当使用margin："></a>何时应当使用margin：</h3>
<p>需要在border外侧添加空白时。</p>
<p>空白处不需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，需要相互抵消时。如15px + 20px的margin，将得到20px的空白。</p>
<h3 id="何时应当时用padding："><a class="header-anchor" href="#何时应当时用padding："></a>何时应当时用padding：</h3>
<p>需要在border内测添加空白时。</p>
<p>空白处需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px + 20px的padding，将得到35px的空白。</p>
<p>个人认为：margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p>
<p>这里我截取了部分另外一篇文章的内容，详细内容请见<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="external">用Margin还是用Padding</a></p>
<hr>
<h2 id="margin在块元素-内联元素中的区别"><a class="header-anchor" href="#margin在块元素-内联元素中的区别"></a>margin在块元素、内联元素中的区别</h2>
<p>HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。</p>
<p>另外有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。</p>
<p>margin在块级元素下，他的性能可以完全体现，上下左右任你设定。且记住块级元素的margin的参照基准是前一个元素即相对于自身之前的元素有margin距离。如果元素是第一个元素，则就是相对于父元素的margin距离（但第一个元素相对于父元素margin-top而父元素又没有设定 padding-top/border-top的话要需要印证上面的垂直外边距合并的知识）</p>
<p>margin也能用于内联元素，这是规范所允许的，但是margin-top和margin-bottom对内联元素（对行）的高度没有影响，并且由于边界效果(margin效果)是透明的，他也没有任何的视觉影响。</p>
<p>这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距，那么你只能使用这三个属性：line- height，fong-size，vertical-align。</p>
<blockquote>
<p>请记住，这个影响内联元素高度的是line-height而不是height，因为内联元素是一行行的，定一个height的话，那这到底是整段inline元素的高呢？还是inline元素一行的高呢？这都说不准，所以统一都给每行定一个高，只能是line-height了。</p>
</blockquote>
<p>margin-top/margin-bottom对内联元素没有多大实际效果，不过margin-left/margin-right还是能够对内联元素产生影响的。应用margin:10px 20px 30px 40px;，左边这个css如果写在inline元素上，他的效果大致是，上下无效果，左边离他相邻元素或者文本距离为40px，右边离他相邻元素或者文本距离为20px。你可以自行尝试一番。</p>
<p>最后在内联元素中还有上文我们提到的非可置换inline元素（non-replaced element），这些个元素img|input|select|textarea|button|label虽然是内联元素，但margin依旧可以影响到他的上下左右！</p>
<p>总结下来margin 属性可以应用于几乎所有的元素，除了表格显示类型（不包括 table-caption, table and inline-table）的元素，而且垂直外边距对非置换内联元素（non-replaced inline element）不起作用。</p>
<hr>
<h2 id="常见的浏览器下margin出现的bug"><a class="header-anchor" href="#常见的浏览器下margin出现的bug"></a>常见的浏览器下margin出现的bug</h2>
<p>林林总总写了那么多，最后总结一些浏览器中常见的margin Bug吧，以后遇到margin下的布局问题可以查看这里找到解决的方案，如果你还发现其他关于浏览器下margin的Bug你可以发表留言，核对采纳后我会及时添加进去，感谢你的分享：</p>
<p>IE6中双边距Bug：</p>
<p>发生场合：当给父元素内第一个浮动元素设置margin-left（元素float:left）或margin-right（元素float:right）时margin加倍。</p>
<p>解决方法：是给浮动元素加上display:inline;CSS属性；或者用padding-left代替margin-left。</p>
<p>原理分析：块级对象默认的display属性值是block，当设置了浮动的同时，还设置了它的外边距就会出现这种情况。也许你会问：“为什么之后的对象和第一个对象之间就不存在双倍边距的Bug”？因为浮动都有其相对应的对象，只有相对于其父对象的浮动对象才会出现这样的问题。第一个对象是相对父对象的，而之后对象是相对第一个对象的，所以之后对象在设置后不会出现问题。为什么display:inline可以解决这个双边距bug，首先是 inline元素或inline-block元素是不存在双边距问题的。然后，float:left等浮动属性可以让inline元素 haslayout，会让inline元素表现得跟inline-block元素的特性一样，支持高宽，垂直margin和padding等，所以div class的所有样式可以用在这个display inline的元素上。</p>
<p>IE6中浮动元素3px间隔Bug：</p>
<p>发生场合：发生在一个元素浮动，然后一个不浮动的元素自然上浮与之靠近会出现的3px的bug。</p>
<p>解决方法：右边元素也一起浮动；或者为右边元素添加IE6 Hack _margin-left:-3px;从而消除3px间距。</p>
<p>原理分析：IE6浏览器缺陷Bug。</p>
<p>IE6/7负margin隐藏Bug：</p>
<p>发生场合：当给一个有hasLayout的父元素内的非hasLayout元素设置负marin时，超出父元素部分不可见。</p>
<p>解决方法：去掉父元素的hasLayout；或者赋hasLayout给子元素,并添加position:relative;</p>
<p>原理分析：iE6/7独有的hasLayout产生问题。</p>
<p>IE6/7下ul/ol标记消失bug：</p>
<p>发生场合：当ul/ol触发了haslayout并且是在ul/ol上写margin-left，前面默认的ul/ol标记会消失。</p>
<p>解决方法：给li设置margin-left，而不是给ul/ol设置margin-left。</p>
<p>原理分析：IE6/7浏览器Bug</p>
<p>IE6/7下margin与absolute元素重叠bug：</p>
<p>发生场合：双栏自适应布局中，左侧元素absolute绝对定位，右侧的margin撑开距离定位。在IE6/7下左侧应用了absolute属性的块级元素与右边的自适应的文字内容重叠。</p>
<p>解决方法：把左侧块级元素更改为内联元素，比如把div更换为span。</p>
<p>原理分析：这是由于IE6/IE7浏览器将inline水平标签元素和block水平的标签元素没有加以区分一视同仁渲染了。属于IE6/7浏览器渲染Bug。</p>
<p>IE6/7/8下auto margin居中bug：</p>
<p>发生场合：给block元素设置margin auto无法居中</p>
<p>解决方法：出现这种bug的原因通常是没有Doctype，然后触发了ie的quirks mode，加上Doctype声明就可以了。</p>
<p>在《打败IE的葵花宝典》里给出的方法是给block元素添加一个width能够解决，但根据本人亲测，加 with此种方法是无效的，如果没有Doctype即使给元素添加width也无法让block元素居中。
原理分析：缺少Doctype声明。</p>
<p>IE8下input[button | submit] 设置margin:auto无法居中</p>
<p>发生场合：ie8下，如果给像button这样的标签（如button input[type=“button”] input[type=“submit”]）设置{ display: block; margin:0 auto; }如果不设置宽度的话无法居中。</p>
<p>解决方法：可以给为input加上宽度</p>
<p>原理分析：IE8浏览器Bug。</p>
<p>IE8百分比padding垂直margin bug：</p>
<p>发生场合：当父元素设置了百分比的padding，子元素有垂直的margin的时候，就好像父元素被设置了margin一样。</p>
<p>解决方法：给父元素加一个overflow:hidden/auto。</p>
<p>原理分析：IE8浏览器Bug</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> margin </tag>
            
            <tag> bug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp的入门和一些简单使用]]></title>
      <url>https://alexzhong22c.github.io/2017/03/02/gulp-usage/</url>
      <content type="html"><![CDATA[<p>总结gulp的入门和一些简单使用，以便于快速上手。</p>
<a id="more"></a>
<p>建议参考 <a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">gulp详细入门教程-一点</a></p>
<p>大概的过程为</p>
<ol>
<li>安装nodejs</li>
<li>安装npm</li>
<li>全局安装gulp</li>
<li>新建package.json文件</li>
<li>本地安装gulp插件</li>
<li>新建gulpfile.js文件</li>
<li>运行gulp</li>
</ol>
<h2 id="某些过程的详细介绍"><a class="header-anchor" href="#某些过程的详细介绍"></a>某些过程的详细介绍</h2>
<h3 id="全局安装gulp"><a class="header-anchor" href="#全局安装gulp"></a>全局安装gulp</h3>
<p>命令行执行<code>npm install gulp -g</code>或者<code>cnpm install gulp -g</code></p>
<p>查看是否正确安装：命令提示符执行<code>gulp -v</code>，出现版本号即为正确安装。</p>
<h3 id="应不应该共用node-modules文件夹"><a class="header-anchor" href="#应不应该共用node-modules文件夹"></a>应不应该共用node_modules文件夹</h3>
<p>共用node_modules有好处也有不便之处。npm的设计之初就不考虑共用node_modules的问题，所以如果硬要多个项目共用同一个node_modules会有许多不便之处。应该为每一个项目创建一个node_modules。</p>
<p>在提交项目的时候在.gitignore文件中设置不提交node_modules文件夹即可。</p>
<p>或者使用</p>
<pre><code>rm -rf node_modules
</code></pre>
<p>PS：不要直接删除本地插件包</p>
<p>删除node_modules文件夹再提交项目，下载项目的时候用<code>npm install</code>就能下载回来在 package.json 中记录的插件。</p>
<h3 id="安装参数-save-dev"><a class="header-anchor" href="#安装参数-save-dev"></a>安装参数–save-dev</h3>
<p>当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下<code>npm install module-name</code>），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（<code>dependencies</code>）。</p>
<p><code>-save</code>和<code>save-dev</code>可以省掉你手动修改package.json文件的步骤。
<code>spm install module-name -save</code> 自动把模块和版本号添加到dependencies部分
<code>spm install module-name -save-dve</code> 自动把模块和版本号添加到devdependencies部分</p>
<p>至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 <code>devDepandencies</code>主要是配置测试框架， 例如jshint、mocha。</p>
<blockquote>
<p>再做一个试验就懂得了区别：删除node_modules目录，然后执行 npm install --production，可以看到，npm只帮我们自动安装package.json中dependencies部分的模块；如果执行npm install ，则package.json中指定的dependencies和devDependencies都会被自动安装进来。</p>
</blockquote>
<h3 id="本地安装gulp插件"><a class="header-anchor" href="#本地安装gulp插件"></a>本地安装gulp插件</h3>
<pre><code>npm install gulp --save-dev
</code></pre>
<p>全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用</p>
<h3 id="安装组件"><a class="header-anchor" href="#安装组件"></a>安装组件</h3>
<p><a href="http://www.dbpoo.com/getting-started-with-gulp/" target="_blank" rel="external">Gulp安装及配合组件构建前端开发一体化</a></p>
<h4 id="gulp-jshint"><a class="header-anchor" href="#gulp-jshint"></a>gulp-jshint</h4>
<p><a href="https://www.npmjs.com/package/gulp-jshint" target="_blank" rel="external">gulp-jshint</a></p>
<p>如果无法在文件夹创建<code>.jshintrc</code>文件的话，就去网上别人的工程里面下载一个：<a href="https://github.com/fex-team/GMU" target="_blank" rel="external">GMU-github</a></p>
<hr>
<p>入门和进阶视频教程：</p>
<p><a href="https://ninghao.net/video/2003" target="_blank" rel="external">ninghao.net</a></p>
<p>一些比较细致介绍和问题的解决：</p>
<p><a href="http://web.jobbole.com/86025/" target="_blank" rel="external">gulp使用小结(一)</a></p>
<p>[<a href="http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/" target="_blank" rel="external">Gulp探究折腾之路(I)</a>](<a href="http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/" target="_blank" rel="external">http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/</a>)</p>
]]></content>
      
        <categories>
            
            <category> gulp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[桌面端和移动端图标的引入]]></title>
      <url>https://alexzhong22c.github.io/2017/02/27/icon-usage/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://bitsofco.de/all-about-favicons-and-touch-icons/" target="_blank" rel="external">All About Favicons-bitsofcode</a> ：</p>
</blockquote>
<p>这星期我决定找到一些合适的方式来使用网站的favicon（另外还包括移动端的touch icon）。我想总结一下我自己的观点并且通过简明的语言来表述清楚：</p>
<a id="more"></a>
<h2 id="一些基础的知识"><a class="header-anchor" href="#一些基础的知识"></a>一些基础的知识</h2>
<p>favicon 是浏览器展示web网页时用到的一种图片。最典型的就是16x16像素大小，不过现在通常需要更多更大的尺寸以供不同的用途使用：</p>
<ul>
<li>地址栏</li>
<li>链接栏</li>
<li>书签</li>
<li>标签</li>
<li>桌面图标</li>
</ul>
<p>如果没有指明favicon的位置，所有主流的浏览器（甚至包括IE5时代的浏览器）都会默认去网站根目录找一个叫&quot;favicon.ico&quot;的文件。从技术层面来讲，这意味着我们不需要用作任何声明就能在网站中使用图标。</p>
<p>然而，这种情况下图标的格式需要受到限制。另外还不支持带透明的图标，这并不是一个最优的办法。因为现在我们能使用更多格式的图标：<a href="http://caniuse.com/#feat=link-icon-png" target="_blank" rel="external">png</a>, gif, jpeg，在某些情况下还有<a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="external">svg</a> 。</p>
<h2 id="favicon声明和link标签"><a class="header-anchor" href="#favicon声明和link标签"></a>favicon声明和link标签</h2>
<p>你可以用link标签设置你喜欢的图标：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;&quot; type=&quot;&quot; sizes=&quot;&quot; href=&quot;&quot;&gt;  
</code></pre>
<h3 id="rel属性"><a class="header-anchor" href="#rel属性"></a>rel属性</h3>
<p>用于声明链接目标和html文档的关系。通常用来引入css样式表。如果是图标，比较官方的写法应该是：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;icon&quot;&gt;
</code></pre>
<p>曾经你可能见过这种写法：</p>
<pre><code class="language-JavaScript"> &lt;link rel=&quot;shortcut icon&quot;&gt;
</code></pre>
<p>这是因为某些老浏览器（IE8或者更早）需要这么写，否则浏览器会忽略这整个link标签。因此，即便<code>rel=&quot;shortcut icon&quot;</code>不在HTML5标准里面，它依然在现代浏览器中有效。然而后面我们会讲到，在实际中你可能只需要使用<code>&lt;link rel=&quot;icon&quot;&gt;</code> 这一种写法即可。</p>
<h3 id="type属性"><a class="header-anchor" href="#type属性"></a>type属性</h3>
<p>用来	指定链接目标的<a href="http://www.iana.org/assignments/media-types/media-types.xhtml#image" target="_blank" rel="external">MIME type format</a>。比如，指定一个图标文件是<code>image/x-icon</code> 类型还一个png文件 <code>image/png</code>。</p>
<p>根据W3C，指定type类型仅仅只是一个建议。但除此之外，IE9和IE10需要指定type属性。在这些版本的浏览器里面，虽然不必指定<code>rel=&quot;shortcut icon&quot;</code>，作为替代，它们需要指定媒体文件的type为 <code>image/x-icon</code> 。</p>
<p>幸运的是，IE11和其他现代浏览器不需要指定媒体文件的type。</p>
<h3 id="sizes属性"><a class="header-anchor" href="#sizes属性"></a>sizes属性</h3>
<p>用于声明特定被链接的文件的大小，不同大小用于不同用途。你能为每种用途提供各自最优的文件。这对使用png图片的情景尤为重要，因为png是不能拓展的。这是一张很好的<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="external">备忘单</a>,它会告诉你应该使用的文件的大小和用途。</p>
<h3 id="href属性"><a class="header-anchor" href="#href属性"></a>href属性</h3>
<p>不必多说，这是用来指定图标的位置和地址的。</p>
<h2 id="做个小结"><a class="header-anchor" href="#做个小结"></a>做个小结</h2>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Link “rel”/ “type”</th>
<th>Accepted Formats</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE 8 and below</td>
<td>link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 9, IE 10</td>
<td>link rel=”icon” type=”image/x-icon” or link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 11</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Chrome</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Firefox</td>
<td>link rel=”icon”</td>
<td>ico, png, gif, <a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="external">svg*</a></td>
</tr>
<tr>
<td>Safari</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Opera</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
</tbody>
</table>
<p>看上去，最好的方案应该是声明两个版本，用现代浏览器的方法引用png，IE8的方法引用ico文件。</p>
<p>然而，如果ico和png同时被引用，现代浏览器会不论标签顺序的先后，只选择ico。这意味着，如果我们要兼容老浏览器，现代浏览器可能会被提供一个错误的图片文件的格式。</p>
<h3 id="当只引入ico时"><a class="header-anchor" href="#当只引入ico时"></a>当只引入ico时</h3>
<pre><code class="language-html">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
</code></pre>
<h3 id="当需要引入ico和png"><a class="header-anchor" href="#当需要引入ico和png"></a>当需要引入ico和png</h3>
<p>最佳的方案应该是<strong>只声明引入png，让老浏览器使用默认的方式引入ico</strong>，这样最稳妥。(但实际上，把ico文件放在根目录时，某些现代浏览器可能并不会引入它)</p>
<pre><code class="language-JavaScript">&lt;!-- For IE 10 and below --&gt;  
&lt;!--  No link, just place a file called favicon.ico in the root directory --&gt;

&lt;!-- For IE 11, Chrome, Firefox, Safari, Opera --&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-16.png&quot; sizes=&quot;16x16&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-32.png&quot; sizes=&quot;32x32&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-48.png&quot; sizes=&quot;48x48&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-62.png&quot; sizes=&quot;62x62&quot; type=&quot;image/png&quot;&gt;  
</code></pre>
<h2 id="移动设备的touch-icon"><a class="header-anchor" href="#移动设备的touch-icon"></a>移动设备的touch Icon</h2>
<p>一些移动设备允许用户自定义浏览器主页书签。像原生app图标一样，在这种情景下，我们应该提供专门的图标。</p>
<p>怎么指定这个图标由浏览器/移动设备决定：</p>
<table>
<thead>
<tr>
<th>Device / Browser</th>
<th>Link “rel”</th>
<th>Sizes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apple / Safari</td>
<td>link rel=”apple-touch-icon” or link rel=”apple-touch-icon-precomposed”</td>
<td>76x76 - iPad 2 and iPad mini ;120x120 - iPhone 4s, 5, 6 ;152x152 - iPad (retina) ;180x180 - iPhone 6 Plus</td>
</tr>
<tr>
<td>Apple / Opera Coast</td>
<td>link rel=”icon” (<a href="https://dev.opera.com/articles/opera-coast/" target="_blank" rel="external">Will also accept Safari and Windows formats</a>)</td>
<td>228x228</td>
</tr>
<tr>
<td>Android / Chrome</td>
<td>link rel=”icon” (<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="external">Will, for a limited time, also accept Safari format</a>)</td>
<td>192x192</td>
</tr>
</tbody>
</table>
<p>对于Windows，这些图标应该用meta标签指定。</p>
<p>For Windows 8 / IE 10 -</p>
<pre><code class="language-html">&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;pinned-tile.png&quot;&gt;  
&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#009900&quot;&gt;  
</code></pre>
<p>For Windows 8.1 / IE 11 -</p>
<pre><code class="language-html">&lt;!-- In &lt;head&gt; --&gt;  
&lt;meta name=&quot;msapplication-config&quot; content=&quot;ieconfig.xml&quot; /&gt;

&lt;!--  In ieconfig.xml --&gt;  
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;browserconfig&gt;  
  &lt;msapplication&gt;
    &lt;tile&gt;
      &lt;square70x70logo src=&quot;images/smalltile.png&quot;/&gt;
      &lt;square150x150logo src=&quot;images/mediumtile.png&quot;/&gt;
      &lt;wide310x150logo src=&quot;images/widetile.png&quot;/&gt;
      &lt;square310x310logo src=&quot;images/largetile.png&quot;/&gt;
      &lt;TileColor&gt;#009900&lt;/TileColor&gt;
    &lt;/tile&gt;
  &lt;/msapplication&gt;
&lt;/browserconfig&gt;  
</code></pre>
<p>就是这样，用到 favicon的地方还挺多的。如果是一个很基础的网站，我可能只会使用ico图标	。期待 SVG favicon 时代的到来。</p>
<p>另可参考：<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="external">https://github.com/audreyr/favicon-cheat-sheet</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图标 </tag>
            
            <tag> meta标签 </tag>
            
            <tag> link标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发事件入门概述]]></title>
      <url>https://alexzhong22c.github.io/2017/02/25/webapp-events-intro/</url>
      <content type="html"><![CDATA[<p>本文修改自<a href="http://www.infoq.com/cn/articles/touch-pointer-event" target="_blank" rel="external">PPK的《移动Web手册》</a></p>
<a id="more"></a>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<p>触摸事件为苹果发明，它将触摸和鼠标两种行为区分开，而微软的指针事件则将它们合并，此标准更具前瞻性，现已被W3C采纳为正式标准。</p>
<p>早在2007年，苹果公司就发布了第一款真正支持触摸屏的浏览器。这款浏览器会监控用户的触摸操作，并派发相应的事件。</p>
<p>除了指针事件的发明者微软外，其他多数浏览器厂商复制谷歌或Mozilla的实现。这两套事件是本章讨论的主题。</p>
<p>乍一看，在指针事件上，IE又是那么“与众不同”，但事实并不如你所想。</p>
<p>微软在这方面提出了一个有趣的哲学观点，我们将在后面详细讨论。在撰写本书时，谷歌和Mozilla正在考虑着手实现指针事件。W3C也正在从触摸事件过渡到指针事件。</p>
<p>在大多数方面，触摸事件和指针事件是普通的JavaScript事件。当触摸动作发生时，触摸事件和指针事件被触发。你可以为它们指定事件处理函数，它们的事件对象也提供了有用的触摸相关的信息。触控事件和传统的鼠标、键盘事件之间有一些技术上的差异。 此外，出于兼容性的考虑，触屏设备必须触发鼠标事件，因为很多网站仍然依赖于它们。但是，在没有鼠标的设备上触发鼠标事件会发生什么事情呢？本章专门讨论这些问题。</p>
<p>本章的其余部分在本质上更具有哲学性。随着iPhone的推出，苹果引入了一种新的交互模式：触摸。 现在，触摸、传统鼠标、键盘三种交互模式并存。Web开发人员需要确保网站适应这三种交互模式。乍一看，触摸事件和鼠标事件差不多。那它们之间有什么区别呢？我们真的需要为触摸交互模式再设计一套事件吗？</p>
<h2 id="触摸事件"><a class="header-anchor" href="#触摸事件"></a>触摸事件</h2>
<ol>
<li>touchstart，在用户的手指触摸屏幕的瞬间触发。</li>
<li>touchmove，在用户移动手指的过程中连续触发。</li>
<li>touchend，用户的手指离开屏幕的瞬间触发。</li>
<li>touchcancel ，（不太被使用），其含义取决于浏览器。后面将会讨论。</li>
</ol>
<p>pointerdown、pointermove和pointerup事件在同一时刻触发</p>
<p>这些事件得到了大多数触屏浏览器的支持，但IE浏览器是一个例外。还有一些很古老的和不完善的浏览器也不支持，比如塞班Anna的默认浏览器。代理浏览器也不支持，因为这些事件不适用于代理浏览模式。其中的原因我们将会在“浏览器”一章讨论。</p>
<h3 id="touchcancel"><a class="header-anchor" href="#touchcancel"></a>touchcancel</h3>
<p>不同浏览器对<code>touchcancel</code>的实现有所不同。</p>
<p>幸运的是，我还没有发现必须使用touchcancel的情景。貌似其他脚本和库也几乎没有使用
touchcancel。有些代码为了安全起见，把它等同于touchend。综上所述，本章将忽略touchcancel事件。如果在某些情况下浏览器
没有触发touchend事件，导致一些奇怪的问题，你可以将touchend的处理函数绑定到touchcancel上。</p>
<h2 id="指针事件"><a class="header-anchor" href="#指针事件"></a>指针事件</h2>
<p><strong>指针事件合并了触摸和鼠标操作，它的必要性在于有一些超极本、平板电脑（Surface系列）同时支持触摸和鼠标操作，并且需要在两者间进行无缝的切换。</strong></p>
<ul>
<li>pointerdown</li>
<li>pointermove</li>
<li>pointerup</li>
<li>pointerover</li>
<li>pointerout</li>
</ul>
<h2 id="键盘事件"><a class="header-anchor" href="#键盘事件"></a>键盘事件</h2>
<p>因为容易理解，不解释。</p>
<h2 id="其他事件"><a class="header-anchor" href="#其他事件"></a>// 其他事件</h2>
<h3 id="触摸：touchenter和touchleave"><a class="header-anchor" href="#触摸：touchenter和touchleave"></a>触摸：touchenter和touchleave</h3>
<p>触摸事件规范中曾经包含<code>touchenter</code>和<code>touchleave</code>事件，这两个事件在用户手指移入
或移出某个元素时触发。但是这两个事件从来没有被实现。微软有这两个事件的替代事件，但是只有IE浏览器支持。某些情况下可以知道用户手指滑入、滑出某个
元素是非常有用的，所以我希望这两个事件可以重返规范。现在暂时不应该用它们。</p>
<h3 id="缩放事件-不在规范"><a class="header-anchor" href="#缩放事件-不在规范"></a>缩放事件(不在规范)</h3>
<p>能响应用户缩放还是很有用的：比如你可以在用户缩放后改变界面，或者只是收集缩放数据以得知页面字号是不是过小。但既然不在规范内，就不应该使用。</p>
<h3 id="手势事件："><a class="header-anchor" href="#手势事件："></a>手势事件：</h3>
<p>两个或多个触摸事件同时发生。放大放小图片时等等场景会用到。仅Safari和IE支持，不建议使用。</p>
<p>手势事件存在两个问题：一来，其他浏览器不支持。二来，它们根本没什么用处。理论上，通过这套事件检
测用户的手势听起来很不错，但实际上，你需要分析触摸坐标、移动速度甚至加速度才能搞清楚用户真正的意图。所以我们不需要手势事件，因为普通的触摸事件已
经提供了同样的信息。所以本章不再讨论手势事件。</p>
<h2 id="实例"><a class="header-anchor" href="#实例"></a>实例</h2>
<p>通过实例对比触摸、指针事件与鼠标键盘事件。</p>
<ul>
<li>下拉菜单。对于用mouseover的下拉菜单，触摸事件几乎不可用。</li>
<li>拖拽。触摸和鼠标差不多，键盘难操作。</li>
<li>滚动层。鼠标难操作。</li>
</ul>
<h3 id="下拉菜单"><a class="header-anchor" href="#下拉菜单"></a>下拉菜单</h3>
<p>跨设备环境的最好解决方案是使用点击事件。点击展开菜单，而不是鼠标悬停时展开。点击另一菜单项则会收起当前菜单。我们在本章后面会看到，点击事件很安全。并且基于点击的下拉菜单可以适用于鼠标和触摸交互。</p>
<p>尽管如此，移动浏览器仍然需要与现实抗争：网上仍然有成千上万基于鼠标悬停的下拉菜单。幸运的是，下拉菜单是一个特殊的用例。苹果公司在设计触摸事件的时候已经考虑到了并且其他浏览器照搬了他们的实现。这点我们在本章后面会遇到。</p>
<p>与下拉菜单完全不同的一个实例是拖动和拖放。用户在鼠标按下时选中一个元素，然后移动，最后松开鼠标将元素放在某个地方。最后脚本会计算放置点是否有效并根据计算结果做出处理。</p>
<h3 id="拖放"><a class="header-anchor" href="#拖放"></a>拖放</h3>
<p>将这个实现移植到基于触摸的交互非常简单：将mousedown替换为touchstart，mousemove替换为touchmove，mouseup替换为touchend就可以了。唯一的问题是如何确定事件的坐标。后面我们会讲到。</p>
<p>这里的问题是键盘的可访问性。如何让用户通过键盘移动可拖动元素？你可以将一个区域的元素设置成可以 通过键盘聚焦，一旦某个元素得到焦点，就开始监听方向键。这在技术上并不困难，但是用户体验很差。这个问题基本上无法解决：拖放操作本身就是为鼠标和触摸 交互设计的，无法在键盘上得到好的体验。</p>
<h3 id="滚动层"><a class="header-anchor" href="#滚动层"></a>滚动层</h3>
<p>在2011年时，我需要一个可以在所有	设备上工作的水平滚动元素。那时候设备还没有原生支持，仍需要脚本，所以我写过一个。现在设备已经原生支持，那段脚本不再需要了。这点我们在CSS章节已经看到。不过这段脚本仍然是一个很有用的实例，所以我们假设仍然需要那段脚本。</p>
<p><img src="http://olqa2s510.bkt.clouddn.com/roll-layer.png" alt="img"></p>
<p>写这段脚本不是什么难事：在ontouchstart事件中计算滚动元素的当前位置，并初始化其他事 件处理函数；在ontouchmove事件中将元素移动相应像素的距离；在ontouchend中，运行一个函数来计算合理的减速，一旦被移动的元素停止 移动，这个函数结束。很简单吧，我花了大概两个小时。</p>
<p>非触摸设备怎么办呢？为了让滚动层可以工作，我需要将触摸交互翻译成鼠标、键盘交互。键盘很简单，只需监听keydown事件，当用户按下左/右键时滚动元素。这点可能不是那么容易发现，但是现在这个脚本算是正式支持键盘操作了。</p>
<p>鼠标设备怎么办？从技术上来讲，增加对mousedown、mousemove和mouseup事件的处理并不难，但是交互非常奇怪：用户必须一直按下鼠标按键才能滚动元素。这种交互和拖放一样，但是对于滚动层来说并不是那么直观。</p>
<p>我可以用老式的滚动条箭头：当鼠标移动到箭头上时脚本开始工作。但是视觉上看，增加箭头有些零乱。除此之外，当用户触摸或者使用键盘时还得隐藏箭头。我没有找到一种安全正确的方法（我们在后面会再次遇到这个问题），最终我并没有支持鼠标交互。</p>
<h2 id="事件和交互模式"><a class="header-anchor" href="#事件和交互模式"></a>事件和交互模式</h2>
<ul>
<li>鼠标事件。1996年Netscape引入</li>
<li>键盘事件。后来引入。</li>
<li>触摸交互。2007年左右开始出现。</li>
</ul>
<p>Web开发者必须确保他们的网站可以在三种交互模式下正常工作。做到这点有时候很简单，有时候却很困难，不过都是必要的。不仅是为你现在的网站增加这些支持，你应该开始思考为UI元素增加对各种操作模式的支持。</p>
<p>在未来，我们可能会有更多的交互模式，比如Xbox
Kinect，它将身体动作转换成屏幕动作。这样你可以用你的手来控制屏幕上的指针。从技术角度来讲，控制指针意味着将使用鼠标事件，但是从用户的角度看这是一种新的操作模式。毕竟感觉上完全不同。</p>
<p>汽车、冰箱、可穿戴以及新兴的设备都可能为用户和Web开发人员带来新的交互模式，比如doorclose（关门）事件。</p>
<p>思考交互模式和JavaScript事件带来三个问题：</p>
<ol>
<li>是不是每个交互模式都需要自己的事件？</li>
<li>已有的交互模式的事件在新设备上不再有意义时，是否需要继续支持？</li>
<li>如何判断设备支持哪种交互模式或用户正在使用哪种模式？</li>
</ol>
<p>目前来看，前两个问题的答案是肯定的，第三个问题的答案比较复杂。但是，在将来，第一个问题的答案可能是否定的。再看看Kinect的例子：我们是发明全新的硬件事件，还是使用指针和鼠标事件呢？从技术上来讲，无论用户怎么移动，指针还是指针。</p>
<h3 id="等价事件"><a class="header-anchor" href="#等价事件"></a>等价事件</h3>
<p>目前每种交互模式都有自己的一套事件，但这并不意味着它们是完全无关且不同的。事实上，某些事件是等价的。下面的表格给出了这方面的情况。</p>
<p><img src="http://olqa2s510.bkt.clouddn.com/compare-3-events1.png" alt="img"></p>
<p>很显然，触摸动作序列：touchstart-touchmove-touchend和鼠标序 列：mousedown-mousemove-mouseup以及键盘序列：keydown-keypress-keyup很相似，这并不是巧合，因为这 三种交互模式都可以描述为start-move-stop。（所以我们不需要完全不同的事件，对不对？）</p>
<p>但是，有时候两个操作模式很像，但第三个却不。比如在下拉菜单的例子里，鼠标和键盘很像，而触摸不同。在拖放实例中，鼠标和触摸几乎一致，但键盘非常不同。在滚动层的例子里，这三种操作模式完全不同。（所以我们还是需要不同的事件，对吧？）</p>
<p>最后是mouseover和mouseout的问题。focus和blur是它们的键盘模式的等价事件，但是触摸模式没有这样的等价事件。就像我们在“CSS”一章看到的，在触摸屏设备中不存在“悬停”。</p>
<h3 id="触摸事件的不同之处"><a class="header-anchor" href="#触摸事件的不同之处"></a>触摸事件的不同之处</h3>
<p>可以看出，等价事件确实存在，这取决于上下文。但是触摸、按键和鼠标事件并不完全相同。显然，由于键盘是这三种交互模式中最与众不同的，所以Web开发人员倾向于将注意力集中在鼠标与触摸上。让我们先来讨论这二者的差异吧。</p>
<p>当鼠标指针移入某个元素，或者用户按下某个鼠标按键时，系统可以立即判断出应该触发哪个事件。而对于 触摸操作来说就不同了，**触摸操作可以引出不同的动作：在你的手指触碰屏幕的瞬间，系统还无法判断出你的意图。**你只是想轻触（Tap）某个元素？还是想滚动 某个可滚动元素？亦或是想缩放？还是想双触（Double-Tap）？浏览器必须等待一定时间间隔才能做出判断。这个时间间隔并不是非常短，而是一个可察 觉的间隔。这点在后面还会讲到。</p>
<p>**多个触摸动作可以同时发生。**这一点对鼠标动作来说是不可能的：一台计算机只能有一个鼠标（指针）。通 常来说，多点触摸不会带来麻烦：大多数网站只支持单点触摸。单点触摸很容易用鼠标来模拟。即便是网页中有两个滑动条，它们之间也不会互相干扰。因为就算用 户同时滑动它们，你也可以认为它们之间是相互独立的。二者都可以很好地通过触摸和鼠标进行操作。</p>
<p>当网站允许并需要多点触摸时，情况就不同了。如果脚本将同时发生的多点触摸翻译成手势、旋转或者缩放动作，鼠标就无法模拟了。多点触摸带来的问题需要具体问题具体分析。但是你必须意识到这一点。</p>
<p>鼠标指针总是指着某一个像素，而手指触摸会覆盖很多像素点。通常，系统会从这些像素点计算出一个中心点作为触摸事件的坐标。并且在touchstart和touchend之间给手指移动留有余地。但是后面会讲到有些浏览器并没有这么做。</p>
<p>**触摸事件是不连续的，而鼠标事件是连续的。**当你将鼠标指针从元素A移动到元素B时，鼠标指针会不可避 免地掠过AB之间的元素。鼠标移动是连续的还意味着你可以通过脚本进行监控。触摸操作就不同了，你可以放开元素A，抬起手直接去碰元素B。这正是我们在下 拉菜单实例里试图支持触摸事件时遇到的问题。下拉菜单设计之初就需要连续的事件，因为它是为鼠标环境而设计的。</p>
<p>**触摸事件比鼠标事件携带了更多的信息。**比如，触摸屏可以探测到用户手指的温度，触摸区域的半径，触摸的压力值。现在虽然没有给出这些数据，不过将来很有可能给出。因为在IE的指针事件中，已经预留了一些对应的属性。</p>
<p>不管怎样，鼠标和触摸虽然相似但又不完全相同。</p>
<h3 id="指针事件-v2"><a class="header-anchor" href="#指针事件-v2"></a>指针事件</h3>
<blockquote>
<p>事实上因为兼容性问题，**直到现在指针事件仍是不可用的，**最好还是用苹果的触摸事件。</p>
</blockquote>
<p>我们发现，通常情况下鼠标事件和触摸事件非常相似，但是二者还是有一些本质区别的。有了这个认识，我们就可以更好地理解微软的指针事件，以及为什么会提出指针事件。</p>
<p>微软认为没有必要分出鼠标、触摸两种事件。不管是鼠标指针、手指（触摸）还是触控笔（也叫定位笔），统称为指针，只要通过这些指针改变了些什么，就触发指针事件。所以，下面是微软版本的等价事件：</p>
<p><img src="http://olqa2s510.bkt.clouddn.com/compare-3-events2.png" alt="img"></p>
<p>现在我们有了两种事件分类方式：鼠标、触摸分离的苹果版本；鼠标、触摸整合的微软版本。到目前为止， 只有IE支持微软的版本。其他浏览器都支持苹果版本。又如我们在前面看到的，Mozilla和Google正在考虑实现指针事件 （PointerEvent）。所以未来情况可能还会发生变化。</p>
<p>Google 之所以对指针事件感兴趣，是因为它的Chromebook Pixel笔记本和微软的Surface平板电脑一样，都有触摸屏和带触摸板的键盘。二者都支持鼠标和触摸操作。如果这两种事件能统一成一种，网站对它们的支持就会变得简单很多。</p>
<p>微软的Surface是一个触屏平板电脑，你还可以外接一个带触摸板的键盘。在访问网站时你可以在鼠标和触摸之间切换。这种情况需要通过指针事件来处理。</p>
<p>我个人认为微软的方案是个好主意。随着时间的推移，越来越多的设备会同时支持鼠标和触摸操作。所以指 针事件是超前意识。同时指针事件可以方便地扩展以支持其他操作，而不局限于触控笔，还包括Wacom绘图板之类的设备。在将来，可以方便地囊括体感电视遥 控器、Kinect动作。这两种操作都可以操控指针、激活元素，比如激活链接。（不过，关冰箱门事件不在这个范围内。）所以，指针事件比相互分离的鼠标和 触摸事件有更好的前景。</p>
<p>我们来试试在刚才上面三个实例中实现指针事件。</p>
<ol>
<li>拖放操作完美匹配：无论用户是用鼠标还是触摸，亦或是触控笔选中了一个元素，拖动它然后放下它。指针事件都可以在不增加代码的情况下支持Kinect、电视遥控和其他类似指针的操作。</li>
<li>滚动层可以在指针事件下正常工作。在触摸交互模式下，滚动层完美工作。当使用触控笔时，用户在滚动层按下、滚动，最后释放。这个操作也讲得 通。鼠标操作和触控笔相似，但是按下笔选取滚动层这个操作有些奇怪。这也是为什么我觉得对滚动层的操作很难移植到鼠标操作。不过，无论我们使用分离的鼠 标、触摸事件还是使用指针事件，这个问题仍然存在。所以指针事件不会带来额外的问题。</li>
<li>下拉菜单是三个实例中最复杂的一个。pointerover和pointerout看似恰是为下拉菜单设计的。但是仔细一看，完全不是。<strong>下拉菜单无法很好地在触摸交互下工作，就算换成指针事件也一样。最好的处理方法还是用点击（click）事件。</strong></li>
</ol>
<p>上面的实例说明，当某种交互不是专门针对某个操作模式设计的时候，指针事件就能很好地工作。在后面我 们会讨论，如果你愿意，你还是可以<strong>通过指针事件对象的pointerType属性来判断是鼠标还是触摸操作。</strong>（指针事件的初衷是统一鼠标、触摸事件，显然 这个属性与初衷相悖，不过这也是实践所需。）</p>
<h3 id="mouseover和-pointerover"><a class="header-anchor" href="#mouseover和-pointerover"></a>mouseover和 pointerover</h3>
<p>pointerover融合了mouseover事件和我们虚构的“touchover”事件：在鼠 标指针或用户手指滑入某个元素时触发。pointerout则是在用户手指或鼠标指针离开某个元素时触发。这就是我们在CSS章节讨论的:hover问 题，只不过是在JavaScript上下文中。</p>
<p>我们再一次遇到了连续事件和非连续事件的本质区别。当使用鼠标从A移动到B时，用户必须经过A、B之 间的元素，别无选择。但是触摸操作就可以先触摸A，再直接触摸B，中间不会碰到其他任何元素。除非是在拖放元素，手指不能离开屏幕。此时 pointerover就很有用了：可以在pointerover时判断当前滑入的对象是不是一个合法的放置区域。</p>
<p>除了这种情景，pointerover与mouseover还是有本质区别的。尤其是在鼠标移入某个 区域后显示额外信息这类精细的操作中，鼠标移入（mouseover）根本无法正常工作。因为此时用户的触摸操作不太可能从某个地方移入期望的区域。更可 能的情况是，用户直接触摸相应的元素，而没有任何移入（pointerover）操作。当然，额外的信息也就无法展现出来了。</p>
<p>解决办法是，只处理mouseover和mouseout事件。因为这两个事件在触摸操作时都会被触发。仅在触摸点移入和移出时不会触发，这一点我们在后面会详细解释。虽然有了这个解决方案，但是由于悬停操作在触摸环境下实在是太另类了，所以这个方案并不完美。</p>
<h3 id="输入模式的渐进增强"><a class="header-anchor" href="#输入模式的渐进增强"></a>输入模式的渐进增强</h3>
<p>渐进增强就像响应式设计教导我们的，要支持各种屏幕尺寸的设备，我们必须想办法来支持多种输入模式（这里的输入模式指鼠标、触摸、键盘等输入模式）。我们暂且称之为输入模式的渐进增强。不过“输入模式的渐进增强”的概念并没有“响应式设计”那么一目了然。</p>
<p>“响应式设计”的基本思想是以同一个设计适应多种屏幕尺寸。而“输入模式的渐进增强”在很多情况下需要我们为不同输入模式分别编写不同的脚本。比如前面讲到的滚动层实例就需要我们为鼠标、键盘和触摸写三个不同的脚本。</p>
<p>除此之外，在用户与网站交互的过程中，屏幕尺寸通常是不会改变的。而输入模式却可以频繁改变。以微软的Surface平板为例：在浏览同一页面时，用户可以在鼠标和触摸操作之间随意切换。而你的脚本必须支持这种复杂的操作。</p>
<p>通常情况下，相比智能手机来说，这种支持对平板电脑来说更重要。因为手机上的输入模式相对少一些。尽管如此，也不要一厢情愿地假设在浏览页面时用户只使用一种输入模式。虽然这种假设可以让Web开发者的工作变得轻松一些，但是并不能改变这骨感的现实。</p>
<p>我们可以从响应式设计中借鉴一些思想应用到“输入模式的渐进增强”中。在“响应式设计”中有一个好的 思想：**从限制最多的情况着手，<strong>比如最小的屏幕。类似的，D-pad可以算是最局限的输入模式了。它由四个方向键和一个OK键组成。好消息是，D-pad的 按键完全和普通键盘兼容：触发相同的事件、使用相同的键码。所以我们不需要区分D-pad和普通键盘。坏消息是，尽管如此，它们还是很有局限性。更坏的消息是，在这方面我也没有什么指导意见可以分享。因为“输入模式的渐进增强”这个概念太新了，以至于我们</strong>还没有找到普适的应对策略。**而且连一些可以帮助大家 的好点子都很少。你可以把这视为一个问题，也可以视为一个挑战。谁知道呢，没准你就是那个教会这个世界如何实现“输入模式的渐进增强”的人。</p>
<h3 id="判断当前的交互模式"><a class="header-anchor" href="#判断当前的交互模式"></a>判断当前的交互模式</h3>
<p>“输入模式的渐进增强”可能需要你去检测用户的当前交互模式。尽管很困难，但这在技术上可以实现。然而，我们真正的问题是，它究竟能提供哪些有用的信息呢？</p>
<p>让我们再次以微软Surface的用户为例。你可以检测到用户正在使用鼠标。但这是否意味着他们将在 整个会话中一直使用鼠标呢?不尽其然。事实上，他们很有可能、或者至少是偶尔地会使用键盘或是触摸屏，又或者干脆把键盘和鼠标触控板折叠起来，只使用触摸 屏。假如发生了以上任一情况，那么你的互动模式检测的价值何在呢？</p>
<p>你唯一可以确定的合理判断是，当用户以某种模式开始某个动作时，他们不会在中途切换模式。因此，如果 你检测到用户正移动鼠标进行拖放，那么他们不太可能在拖曳过程中切换到触摸操作。但是，一旦拖放完成，用户就可能选择切换到触摸、或继续使用鼠标、亦或使 用键盘，来进行下一步操作。</p>
<p>**你必须确保所有交互在任何交互模式下均可实现，**这一点至关重要。鼠标、触摸甚至键盘都应该可以执行拖放操作。一旦做到了这一点，那么用户正在使用何种交	互模式都将无关紧要。</p>
<p>让我们假设，你有很好的理由去寻找当前的交互模式。也许你想收集一些数据来研究用户的模式使用偏好。那么我们来看一下几种可能性。</p>
<ul>
<li>指针事件最简单明了：它具备pointerType属性，其值可以是mouse、touch或pen。找到当前值即可知道用户的操作。另一 个简单的情况：当有任何按键事件触发时，用户一定会使用键盘。但这与未来的交互无关——用户仍然可能随时转换到键盘或是触摸。但无论如何，这还是提供了一 些有用的信息。</li>
<li>与之类似的，当一个触摸事件触发时，你可以肯定你的用户在当下一定正在使用触摸交互模式。同理，这并不影响未来的交互，但至少提供了一些信息。</li>
<li>对于鼠标事件要格外小心：当用户触摸屏幕时，鼠标事件也会触发，因此检测交互模式并不适用于鼠标事件。检测鼠标使用的方法就是排除其他交互模式。如果用户没有使用触摸或键盘，那么他有可能正在使用鼠标。</li>
</ul>
<p>目前有很多方法可以检测到一个触摸交互模式是否可用。其中有一种由Modernizr普及，但可惜并不十分可靠的方法是：</p>
<pre><code class="language-javascript">var hasTouch = !!('ontouchstart' in window);
</code></pre>
<p>“如果window对象有ontouchstart属性，说明浏览器支持触摸事件，我们就可以放心地 使用。”这可能正是你所想的。前半句的结论是“虽然正确”，但是，支持触摸事件的浏览器并不一定运行在具有触摸屏的设备上。比如，黑莓6的浏览器支持触摸 事件，但它却运行在一个非触摸设备上。老版本的Chrome浏览器也有类似的问题。并且，依赖ontouchstart的方法让IE变得无能为力。</p>
<p>唯一安全的检测浏览器支持触摸事件、运行在触摸设备上并且用户正在使用触摸交互的方法就是看是否确实有触摸或指针事件被触发。</p>
<pre><code class="language-javascript">    var hasTouch = false;
    document.ontouchstart = function () { 
        hasTouch = true;
    }
    document.onpointerdown = function (e) { 
        if (e.pointerType === 'touch') {
            hasTouch = true;
        }
    }
</code></pre>
<p><strong>最好的办法是依次检测各种交互模式：首先从指针事件开始。pointerType属性可以提供有用的信息。然后检测触摸事件。后面我们会看到触摸操作还会触发鼠标事件，所以只有当触摸事件没有触发时，才考虑鼠标事件。最后轮到键盘。</strong></p>
<pre><code class="language-javascript">    var interactionMode;
    document.onpointerdown = function (e) { 
        interactionMode = e.pointerType;
    }
    document.ontouchstart = function () {
        if (!interactionMode) {
            interactionMode = 'touch';
        }
    }
    document.onmousedown = function () {
        if (!interactionMode) {
            interactionMode = 'mouse';
        }
    }
    document.onkeydown = function () { 
        if (!interactionMode) {
            interactionMode = 'keyboard';
        }
    }
</code></pre>
<p>登录界面或类似的地方是运行上面代码的理想场景。在这个场景中，用户必须与网站交互。当用户登录时， 用类似上面的代码检测用户正在使用哪种交互方式。要注意，这也只能说明用户在登录时使用的交互模式，并不是整个交互过程都会使用这个模式。虽然信息有限， 但这段代码还是有一定预测功能的。</p>
<p>尽管上面的方法无法预测用户接下来会使用哪种交互模式，但是目前最好的处理不同交互模式的方法还是<strong>为鼠标、键盘和触摸编写不同的代码。</strong></p>
<h2 id="补充"><a class="header-anchor" href="#补充"></a>补充</h2>
<h3 id="触摸事件的级联"><a class="header-anchor" href="#触摸事件的级联"></a>触摸事件的级联</h3>
<p>移动浏览器同时支持触摸事件和鼠标事件，会导致一个触摸动作触发多个事件。</p>
<ul>
<li>触摸（Tap）：touchstart/pointerdown、touchend/pointerup、mouseover、mousemove、mousedown、mouseup、click、:hover样式（需要注意的是为了兼容mouseover，抬起手指并不会触发mouseout，再次触摸才会）</li>
<li>滑动（Swipe）：touchstart、touchmove、touchend、scroll</li>
<li>缩放（Pinch）：touchstart、touchmove、touchend、scroll，可能还有resize</li>
<li>双触（double-tap）：touchstart、两次touchend、scroll，可能还有resize</li>
<li>按住（touchhold）：touchstart、touchend，有些浏览器还有contextmenu</li>
</ul>
<h3 id="剖析click"><a class="header-anchor" href="#剖析click"></a>剖析click</h3>
<p>300毫秒问题，无解。（Chrome支持但苹果不可能支持）</p>
]]></content>
      
        <categories>
            
            <category> WebApp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> essay </tag>
            
            <tag> 触摸事件 </tag>
            
            <tag> 指针事件 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发入门概述]]></title>
      <url>https://alexzhong22c.github.io/2017/02/24/webapp-intro/</url>
      <content type="html"><![CDATA[<p><strong>PPK的《移动Web手册》</strong> 是对移动Web现状（2014年夏）的一个系统检阅，市场上有不少公司将赌注放在HTML5上，因此对于HTML5在移动Web上的应用多有炒作，但实际上如何呢？看完本书能让你有个清醒的认识。</p>
<p>移动浏览器虽然大都实现了桌面浏览器的功能，但实际上移动设备上的情况更加复杂，而且由于Android系统的碎片化直接导致浏览器的碎片化，它们对于一些和桌面不同情况的处理，以及一些最新特性的支持都是不尽相同的。</p>
<p><strong>所以HTML5在移动Web上的兼容性目前是很差的，</strong> 还有像触摸事件向指针事件标准化的过渡，估计最少需要5-10年才能达到一个比较理想的状态。</p>
<a id="more"></a>
<h2 id="浏览器相关"><a class="header-anchor" href="#浏览器相关"></a>浏览器相关</h2>
<h3 id="浏览器的类型"><a class="header-anchor" href="#浏览器的类型"></a>浏览器的类型</h3>
<ul>
<li>内置浏览器</li>
<li>可下载浏览器</li>
<li>代理浏览器</li>
<li>webview</li>
</ul>
<p>大多数内置浏览器都被紧密集成到底层的操作系统中，也就是说，无法单独升级浏览器。因此，为了得到新的Safary版本，你必须升级IOS。内置浏览器都有不同的内核比如：安卓是webkit、winphone是ie、ios是safari，大致上就是这样。</p>
<p>可下载浏览器，顾名思义用户可下载安装的浏览器，见的多的就是firefox、chrome了、360等。</p>
<p>代理浏览器是指服务端进行对页面的渲染，再把结果发送给客户端进行显示，比较少见。代理浏览器与完备浏览器（full browser）相对，代表为opera mini、UC mini。</p>
<p>WebView是留给原生应用的一个操作系统浏览接口。苹果不允许在IOS设备上安装其他渲染引擎。（其他平台是可以的）因此，其他浏览器要想在IOS上安装就必须用苹果的WebView。IOS上的Chrome就是这样的，同样的还有Opera Coast。大体上，WebView是独立的程序，用了内置浏览器很多底层的组件（比如渲染引擎），但是在其他方面可能会有所不同。<strong>如果希望你的页面能在WebView里跑起来的话，你最好在WebView上测试一下。</strong></p>
<p>补充：</p>
<blockquote>
<p>代理浏览器的原理：当用户请求页面，它不会发送一个普通HTTP请求而是通过加密链接发送特殊请求到一个特殊的代理服务器。代理服务器来抓取用户希望访问的内容，渲染页面，然后压缩渲染的页面成为某种图片，类似于PDF，然后代理服务器将这个文件发到客户端。</p>
<ul>
<li>好处：给用户节省流量。</li>
<li>弊端：页面内的javascript不能正常工作。</li>
</ul>
<p>随着现在wifi的普及等原因，代理浏览器用得很少。</p>
</blockquote>
<hr>
<h3 id="手机上的webkit"><a class="header-anchor" href="#手机上的webkit"></a>手机上的WebKit</h3>
<p>先列出不使用WebKit的浏览器：</p>
<blockquote>
<p>1. IE Mobile(即将替换为edge)，使用Trident
2. Opera Mini使用Presto，但是最终会换成Blink
3. Chrome浏览器用Blink
4. Firefox Mobile和Firefox OS使用Gecko
5. UC Mini、Nokia Xpress还有Jolla的Sailfish OS上的内置浏览器也用的是Gecko</p>
</blockquote>
<p>任何没在上面提到的浏览器都用WebKit。乍一看，这么多浏览器都用WebKit的事实对于Web开发者似乎是一个强大的支持，不幸的是，一个浏览器用Webkit并不意味着它跟其他任何基于Webkit的浏览器一样。实际上，**它们有很大的不同，依赖于操作系统、键盘、鼠标还有触屏交互。平台所有者必须提供所有这些功能。**手机上的Webkit名存实亡。</p>
<p>很多浏览器用着差不多一样的渲染引擎但是在细节上却大不相同。你最好在所有不同的基于WebKit的浏览器上测试你的网站。</p>
<hr>
<h3 id="测试android浏览器"><a class="header-anchor" href="#测试android浏览器"></a>测试Android浏览器</h3>
<p>对于Android设备的浏览器，有三个必须测试的浏览器：</p>
<blockquote>
<p>1. 安卓WebKit4，富含不同的设备和不同版本的安卓系统。一个专门的设备实验室需要大概6到8个这样的来自不同厂商的设备。一个小型实验室必须拥有2到3个：三星、HTC和一个其他厂商的设备
2. Google Chrome。如果你的设备上没有，下载一个。
3. 三星Chrome（三星字Galaxy S4发布以来，三星开始使用他自己开发的基于Chromium的一款浏览器作为内置浏览器，因此出现三星Chrome）。你讲需要购买一个2013年获以后发布的三星高端手机——类似Galaxy S4或更新的设备</p>
</blockquote>
<h2 id="视口相关"><a class="header-anchor" href="#视口相关"></a>视口相关</h2>
<h3 id="css像素和设备像素"><a class="header-anchor" href="#css像素和设备像素"></a>css像素和设备像素</h3>
<p>设备像素：设备屏幕的物理像素。</p>
<p>CSS像素：为Web开发者创造的，在CSS和JS中使用的一个抽象层。CSS像素和设备像素的比例取决于屏幕是否高DPI和用户缩放的比例。</p>
<blockquote>
<p>css像素是专门为我们Web开发者创造的一个抽象层。当在使用css和javascript的时候，你并不在意一个css像素跨越了多少个设备像素。你开心地将这个依赖于屏幕特性和用户缩放程度的复杂计算交给了浏览器。</p>
<p>用户放大得越大，一个css像素覆盖的设备像素越多。</p>
</blockquote>
<hr>
<h3 id="布局视口"><a class="header-anchor" href="#布局视口"></a>布局视口</h3>
<p>CSS布局会根据它来计算，并被它约束。在手机上，为了容纳为桌面浏览器设计的网站，**默认的布局视口宽度远大于屏幕的宽度。**为了让用户看到网站全貌，它会缩小网站。</p>
<pre><code class="language-html">&lt;!-- width属性设置布局视口的宽度为特定的值 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
</code></pre>
<p>但在另一篇文章里面，并不推荐设置width属性。</p>
<h3 id="视觉视口"><a class="header-anchor" href="#视觉视口"></a>视觉视口</h3>
<p>它是用户正在看到的网站的区域。这个视口与设备屏幕一样宽。</p>
<p>用户可以缩放来操作视觉视口，同时不会影响布局视口，布局视口仍保持在原来的宽度。视觉视口与设备屏幕一样宽，并且它的CSS像素的数量会随着用户缩放而改变。</p>
<h3 id="理想视口"><a class="header-anchor" href="#理想视口"></a>理想视口</h3>
<p>对于特定设备上的特定浏览器的布局视口的一个理想尺寸，在这个尺寸下，用户刚进入页面时不再需要缩放，拥有最理想的浏览和阅读的宽度。</p>
<hr>
<h3 id="缩放"><a class="header-anchor" href="#缩放"></a>缩放</h3>
<p>桌面浏览器的缩放仅改变内容尺寸，不改变布局视口；移动端缩放则整体改变。</p>
<p><strong>不要禁止缩放！</strong> 禁止缩放是邪恶的，并且浏览器可以关闭禁止缩放功能。</p>
<p>禁止缩放的代码为：</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
</code></pre>
<h3 id="分辨率"><a class="header-anchor" href="#分辨率"></a>分辨率</h3>
<p>物理分辨率：设备每英寸内点数（DPI）</p>
<p>设备像素比：设备像素个数和理想视口的比（DPR）</p>
<p>dppx和dpi：每一个像素的点数。JS中的<code>window.devicePixelRatio</code>和媒体查询的<code>device-pixel-ratio</code>的单位。IE不支持，因此要使用dpi单位：</p>
<pre><code class="language-javascript">if(window.devicePixelRatio) {
    // DPR大于等于2时执行
}

@media all and((-webkit-min-device-pixel-ratio:2), (min-resolution:192dpi)) {
    // DPR大于等于2时生效
}
</code></pre>
<p>1dppx = 96dpi：一英寸对应CSS中96个像素。</p>
<h3 id="meta视口标签："><a class="header-anchor" href="#meta视口标签："></a>meta视口标签：</h3>
<p>meta视口标签存在的主要目的是让布局视口的尺寸和理想视口的尺寸匹配。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot;&gt;
</code></pre>
<p>其中可用的name为：</p>
<ul>
<li>width：device-width适用于大多数情况。</li>
<li>initial-scale：一般设为1，为了兼容应同时设置width=device-width。</li>
<li>minimum-scale</li>
<li>maximum-scale</li>
<li>user-scalable</li>
</ul>
<h3 id="媒体查询"><a class="header-anchor" href="#媒体查询"></a>媒体查询</h3>
<p>媒体类型：目前只有print被正确实现。一般使用all。</p>
<blockquote>
<p>Web开发者希望区分能力弱和能力强的浏览器，而弱浏览器为了避免探测开始伪装自己。</p>
<p>过去的浏览器最多可处理WAP和HTML的子集XHTML-MP，它们大都遵循标准并实现handheld，Web开发者为这些类型提供简单的样式。而新的现代移动浏览器出现后，它们支持全部样式、JS，因此宁愿不实现handheld而获得和桌面浏览器一样的待遇。</p>
</blockquote>
<h3 id="javascript"><a class="header-anchor" href="#javascript"></a>JavaScript</h3>
<p>媒体查询与JavaScript属性相对应。</p>
<ul>
<li>物理屏幕分辨率：screen.width/height（有兼容问题不建议使用）</li>
<li>布局视口：document.documentElement.clientWidth</li>
<li>视觉视口：window.innerWidth</li>
<li>理想视口：screen.width/height（有兼容问题不建议使用）</li>
<li>设备像素比：window.devicePixelRatio</li>
<li>屏幕方向：window.orientation</li>
</ul>
<p><code>document.documentElement.clientWidth/Height</code>返回的是布局视口的尺寸，被普遍支持。</p>
<p><code>window.innerWidth/Height</code>返回视觉视口的尺寸。接近被普遍支持。</p>
<p><code>screen.width/height</code>返回理想视口的尺寸。有很严重的浏览器兼容性问题，	不建议使用。</p>
<h2 id="css相关"><a class="header-anchor" href="#css相关"></a>CSS相关</h2>
<p>移动浏览器与桌面浏览器对CSS支持的差异：</p>
<ul>
<li>桌面用例在移动端不存在。如hover。</li>
<li>视口不统一。如单位vw和vh。</li>
<li>对独立可滚动层的需求在移动设备上更难实现。如background-attachment。</li>
<li>硬件限制。在老设备上transition和animation可能无法使用。</li>
</ul>
<p>以下属性都<strong>不建议</strong>在移动Web上使用:</p>
<h3 id="position-fixed"><a class="header-anchor" href="#position-fixed"></a>position:fixed</h3>
<p>此属性标准没有支持缩放。</p>
<h3 id="overflow-auto"><a class="header-anchor" href="#overflow-auto"></a>overflow:auto</h3>
<p>多个可滚动层体验不好，并且移动上默认不显示滚动条会漏掉内容。</p>
<p><code>-webkit-overflow-scrolling:auto</code>：平滑滚动。</p>
<h3 id="background-attachment"><a class="header-anchor" href="#background-attachment"></a>background-attachment</h3>
<p>三个可选值scroll、fixed、local。会创建过多的可滚动层，影响性能。</p>
<h3 id="尺寸单位vw和vh"><a class="header-anchor" href="#尺寸单位vw和vh"></a>尺寸单位vw和vh</h3>
<p>非常冷门的单位，本来也没什么人用，这里就不多说了。</p>
<h3 id="active和-hover"><a class="header-anchor" href="#active和-hover"></a>:active和:hover</h3>
<p><code>:hover</code>在桌面浏览器用的过多，因此移动设备必须支持，但实际上在用户触摸元素时触发，引起事件级联。</p>
<p><code>:active</code>相对支持的不好，可以和<code>:focus</code>同时使用，后者支持的较好。</p>
<h3 id="transition和animation"><a class="header-anchor" href="#transition和animation"></a>transition和animation</h3>
<p>实际上浏览器支持的很好，但这两个属性会用到GPU，而移动设备GPU很糟糕，至少是早期的很糟糕。</p>
<h3 id="css过度和动画"><a class="header-anchor" href="#css过度和动画"></a>css过度和动画</h3>
<p>只要你使用了过度和动画，就在你能找到的最老、最差的设备上进行测试。它们的问题不在浏览器，而在<strong>设备</strong>，浏览器对两者的支持都很好。但是为了达到非常平滑的效果，浏览器必须借助设备GPU的计算能力。在高端智能手机上不成问题，但对于早期和廉价的手机来说，它们可能根本没有响应的硬件和系统API。这就导致最终的动画效果很生硬。</p>
<h2 id="触摸和指针事件"><a class="header-anchor" href="#触摸和指针事件"></a>触摸和指针事件</h2>
<p>触摸事件为苹果发明，它将触摸和鼠标两种行为区分开，而微软的指针事件则将它们合并，此标准更具前瞻性，现已被W3C采纳为正式标准。</p>
<p>内容详见另一篇文章：</p>
<h2 id="克服过时的惯性思维"><a class="header-anchor" href="#克服过时的惯性思维"></a>克服过时的惯性思维</h2>
<ul>
<li>浏览器探测。事实上无论是浏览器探测还是特性探测在移动浏览器上都可能表现不佳。</li>
</ul>
<blockquote>
<p>浏览器只会返回它支持某项特性，但不会告诉你支持程度有多差。</p>
</blockquote>
<ul>
<li>Javascript脚本库。**在编写小功能时不要依赖脚本库而是应该用原生JS实现。 **</li>
</ul>
<h2 id="移动web的未来"><a class="header-anchor" href="#移动web的未来"></a>移动Web的未来</h2>
<h3 id="html5-vs-原生应用"><a class="header-anchor" href="#html5-vs-原生应用"></a>HTML5 vs 原生应用</h3>
<blockquote>
<p>全面追赶原生应用并不是Web技术的关键所在。我感觉我们应该聚焦在Web擅长的方面，并将它们做得更好。或者找出我们能够做好的方面，将它们做得超越原生应用。</p>
</blockquote>
<h3 id="模拟原生应用"><a class="header-anchor" href="#模拟原生应用"></a>模拟原生应用</h3>
<ul>
<li>网络连通性和AppCache。离线存储对移动Web应用非常有意义，但是AppCache简直是个垃圾。新的Service Worker试图取代它。</li>
<li>安装到主屏幕。被支持的并不好。</li>
<li>设备API。第一支持不完善，标准总是落后于现实；第二有安全问题，需要授权，而像安卓的用户授权是行不通的。</li>
</ul>
<blockquote>
<p>当你安装一个安卓应用时，系统会让你授权该应用可以具备哪些权限。这个设计的失败不仅在于我们需要更精细的权限控制，而且还在于它出现的时机不对：当用户安装某个应用时，用户只想尽快的用上它，他们会同意任何事情。</p>
</blockquote>
<h3 id="模拟web"><a class="header-anchor" href="#模拟web"></a>模拟Web</h3>
<p>Applink，直达应用的深层页面。（注：Android M和iOS 9都有类似的更新支持这项特性）</p>
<h3 id="分享应用"><a class="header-anchor" href="#分享应用"></a>分享应用</h3>
<p>PPK的脑洞：Web应用由于其良好的兼容性，应该让它可以通过蓝牙、NFC等在不同设备之间共享。</p>
]]></content>
      
        <categories>
            
            <category> WebApp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
            <tag> essay </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yelee主题改bug总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/22/my-hexo-theme/</url>
      <content type="html"><![CDATA[<p>从找一个喜欢的hexo主题到修改好bug发布到博客上面，整个过程花了我不少时间，下面是对这个改bug过程中发现的小问题做的总结。</p>
<p>此文无图。</p>
<a id="more"></a>
<p>一开始我是在知乎上面找好看的主题，找了很长一段时间才找到一个我比较喜欢的主题，并且挑选了一个已经被大神们优化得不错的主题来借鉴借鉴。</p>
<p>我的hexo主题其实就是直接Fork了<a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="external">ngudream</a>的主题，只不过该大神日常比较忙碌，我自己琢磨了一下代码，把一些报错的小bug给修复了，暂时还没有为这个主题添加什么特殊的功能。（原因是这个主题在各位大神的努力下，功能已经非常齐全炫酷了。）</p>
<p>直接参考ngudream的这篇文章就可以了，在此在此表示一万个感谢：</p>
<p><a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="external">http://ngudream.com/2017/01/24/n-hexo-blog/</a></p>
<p>在这个过程中我发现了一些小问题：</p>
<h2 id="左右搜索栏"><a class="header-anchor" href="#左右搜索栏"></a>左右搜索栏</h2>
<p>一定要先根据这个来安装插件：</p>
<p><a href="http://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="external">Yilia主题添加本地站内搜索-高明飞</a></p>
<h3 id="找不到content-json"><a class="header-anchor" href="#找不到content-json"></a>找不到content.json</h3>
<ul>
<li>这是因为左下角搜索栏找不到content.json</li>
</ul>
<ul>
<li>将<code>yelee\source</code>文件夹下的search文件夹剪切到 根目录的source文件夹里面</li>
<li>生成一次页面</li>
<li>再把刚刚的search文件夹剪切回<code>yelee\source</code>文件夹下即可</li>
</ul>
<h3 id="cb-search-json-404-not-found"><a class="header-anchor" href="#cb-search-json-404-not-found"></a>cb-search.json 404 (Not Found)</h3>
<ul>
<li>是因为没有安装右下角搜索栏插件</li>
</ul>
<ul>
<li>如果安装插件之后语法报错，就把别人项目的文件代码复制过来就行了，省得去检查语法</li>
</ul>
<h3 id="百度分享因为混合内容报错"><a class="header-anchor" href="#百度分享因为混合内容报错"></a>百度分享因为混合内容报错</h3>
<p>如果因为混合内容报错（即https网站引用了http的资源），你可以将百度分享的地址改为：<code>https://github.com/hrwhisper/baiduShare</code>；本来我想把static文件夹放在外面一点的，但是有bug，我现在只是做到不报错而已，具体的百度分享内容都没弄</p>
<h3 id="百度站长要重新配置"><a class="header-anchor" href="#百度站长要重新配置"></a>百度站长要重新配置</h3>
<ul>
<li>查阅相关资料，依照资料放baidu_verify_QshFoK3ZRz.html在yelee的source文件夹下通过站长验证，放googleeff62ed1566e185e.html也是同理。</li>
</ul>
<p>百度sitemap要另外安装：</p>
<pre><code>npm install hexo-generator-baidu-sitemap --save 
</code></pre>
<ul>
<li>如果想要给谷歌提交网站，只需要在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Search Console</a>验证网站，并提交站点地图就可以了。谷歌真的好简单啊！谷歌的<code>sitemap.xml</code>不需要写到配置文件中，自动生效。
<ul>
<li>有个问题是，Github禁止百度爬虫，所以提交的sitemap迟早会显示失败，成功几率非常小</li>
</ul>
</li>
</ul>
<h2 id="温馨提示"><a class="header-anchor" href="#温馨提示"></a>温馨提示</h2>
<ul>
<li>多说也是会因为混合内容而报错，但是我只能改良，不能彻底解决这个问题
<ul>
<li>将多说的<code>embed.js</code>本地化，	将这个文件的地址改动到<code>duoshuo.ejs</code>和<code>click2show.ejs</code>和layout的<code>after-footer.ejs</code>文件里面，但是依然报错</li>
<li>见到http就给它加s</li>
</ul>
</li>
<li>在Markdown文章头部的标注信息的冒号后面要加一个空格，这是语法要求</li>
</ul>
<ul>
<li>在hexo s调试下，百度站长push报错属于正常现象</li>
<li>在hexo s调试下，文章导航的特效会失灵，属于正常现象</li>
</ul>
<ul>
<li>发现大神每篇文章文件的名字都是英文，Markdown里面的标题才是中英随意的，不然isPost()函数会出错
<ul>
<li>用cmd创文件名的时候英文全小写，空格用-表示，为了风格统一</li>
</ul>
</li>
<li>插件这种东西最好不要复制，所以<strong>在重新搭建博客的时候</strong>我没有直接复制node_modules文件夹，这也容易令人忽略了大神自己在这个文件夹下改良的index.js和search.ejs文件</li>
</ul>
<h2 id="请不要fork我的主题"><a class="header-anchor" href="#请不要fork我的主题"></a>请不要Fork我的主题</h2>
<p>去Fork大神ngudream的主题就可以了，因为我的个人改动比较私人化，所以Fork之后别人可能会看不懂。另外我的主题作了几个不好的改动：</p>
<ul>
<li>为了避免报错，一开始我把一些if语句的判断条件直接改为false，原本它们的判断条件是xxx.on的</li>
</ul>
<ul>
<li>还有一个feed属性没研究，应该是订阅博客的功能，好像也被我粗暴地关了</li>
<li>报错<code>Cannot GET /plugins/css/special.css</code>，我直接把“字往下掉”动画关掉</li>
<li>然后就是折腾在显示主页时标签栏出现的undefined，一开始我不知道那个把三项文字的标签转为二项的js文件，所以一直研究ejs代码都没弄好。后来我直接给主页加一个英文名字blog就算了。总算不出现undefined</li>
<li>乱关乱开了一下博文最下方的分享栏，不知道会不会出问题，这个模块应该是百度分享</li>
<li>点击微信之后，那个左右滑动的栏目我暂时改不了代码，本来我想去掉qq的，但是只好把qq的二维码弄上
<ul>
<li>还有就是去掉qq之后，点击微信，上面那个圆形地方就没有图案显示</li>
</ul>
</li>
<li>发现search-result-list模块的文字被顶到后面
<ul>
<li>把.col-3的CSS的marginbottom改为4px就行了</li>
</ul>
</li>
</ul>
<h3 id="我没有完善的内容"><a class="header-anchor" href="#我没有完善的内容"></a>我没有完善的内容</h3>
<ul>
<li>代码压缩没搞</li>
<li>公益404没搞</li>
<li>右下角搜索栏搞了，但是利用的不是打分排名</li>
<li>谷歌分析到现在也不会，所以先不用，应该和百度站长是差不多的，没心思搞</li>
<li>好像就只有360浏览器看不到emoji表情，所以即便安装了插件，文章尽量不要用emoji</li>
</ul>
<h2 id="整个过程的心得"><a class="header-anchor" href="#整个过程的心得"></a>整个过程的心得</h2>
<ul>
<li>在这过程中学会了用HTML-beautify来美化sublime中的html代码排版</li>
<li>对ejs的代码写法有所了解</li>
<li>明白了代码中的partial是干嘛的：复用模板</li>
<li>第一次发现一些私人的代码改动都是写在<code>after-footer.ejs</code>里面</li>
<li>发现dos的报错信息还是有点用的</li>
<li>令我困惑的是填yml文件中的url项，后来发现用来填绑定的域名，域名要自己出钱买</li>
<li>一开始遇到<code>Cannot read property 'on' of undefined</code>不会调，后来发现是yml文件填得不好，可能是不符合语法，导致错误。再比如yml文件中代码没有在适当的地方空空格。</li>
<li>如果在网上打开js文件发现中文变乱码，在谷歌浏览器打开查看就可以了，这是最不消耗脑力的办法</li>
</ul>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> yelee </tag>
            
            <tag> theme </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建hexo博客个人总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/22/my-hexo-blog/</url>
      <content type="html"><![CDATA[<p>因为大神们在这个方面的文献已经很多了，所以我觉得我没有必要再写一个教程了。关于教程，可以推荐<a href="http://blog.csdn.net/itjia_0203/article/details/52504837" target="_blank" rel="external">sylujia的hexo搭建教程</a>来看看，写得很详细而且思路也很好，但是我记得这个教程有一两点步骤不太妥当，如果完全按照教程来搞会报错，但如果自身有一点基本知识的话，这点问题真的算不上是问题。</p>
<a id="more"></a>
<p>我是按照<a href="http://blog.csdn.net/itjia_0203/article/details/52504837" target="_blank" rel="external">sylujia的hexo搭建教程</a>来搭建的，发现这个教程有几个不周全的地方。</p>
<h2 id="这个教程的不周全之处"><a class="header-anchor" href="#这个教程的不周全之处"></a>这个教程的不周全之处</h2>
<h3 id="不周之处一"><a class="header-anchor" href="#不周之处一"></a>不周之处一</h3>
<p>没有直接介绍如何在github仓库创建hexo分支，这个部分可以参考这段代码：</p>
<pre><code>1.  在github上创建仓库，仓库名为your-user-name.github.io
2.  本地创建两个分支：master 与 hexo：
先让gitbash去到your-user-name.github.io文件夹，再输入以下命令
    touch README.md
    git init
    git add README.md
    git commit -m &quot;first commit&quot;
    git remote add origin https://github.com/your-user-name/your-user-name.github.io.git
    git push -u origin master

    在本地新建一个分支： 
        git branch hexo
    切换到你的新分支: 
        git checkout hexo
    将新分支发布在github上： 
        git push origin hexo
    至此分支创建完毕
3.  在github网站上的仓库设置hexo为默认分支
</code></pre>
<p>对于这段代码的解释可以参考原文<a href="http://www.cnblogs.com/ld1024/p/5913169.html" target="_blank" rel="external">冷星1024的hexo搭建教程</a> 。这一步应该在git与github建立联系之后，在安装hexo之前完成。</p>
<h3 id="不周之处二"><a class="header-anchor" href="#不周之处二"></a>不周之处二</h3>
<p>看到这一步：</p>
<p>在项目文件夹下执行以下命令：</p>
<pre><code>$ git init #初始化为一个git目录
$ git remote add origin git@github.com:sylujia/sylujia.github.io.git #使用你自己的地址关联
$ git pull #pull一下你的远端库
</code></pre>
<p>执行之后命令行的位置应该是<strong>不在</strong>hexo分支下的，如果按照教程继续执行<code>$ git checkout hexo</code>应该会面临失败，而用<code>git clean -d -fx &quot;&quot;</code>来解决问题会删掉本地的文件这也是万万不可的。</p>
<p>比较合适的一个做法应该是改进它的下一步为：</p>
<pre><code>$ git add . #添加所有文件到暂存区
$ git commit -m &quot;提交信息&quot;     #提交到本地仓库
$ git push -f origin hexo  #把本地库强制push到远端库的hexo分支
</code></pre>
<p>接着往下做就行了，一直到教程的<strong>优化与部署</strong>环节。不建议小白看<strong>优化与部署</strong>及之后的内容，只不过是把之前的内容重新过一遍而已，最后那段内容甚至可能涉及抄袭，有点敷衍，不看就行了。</p>
<h2 id="原始文件和部署文件分离"><a class="header-anchor" href="#原始文件和部署文件分离"></a>原始文件和部署文件分离</h2>
<p>选用这个教程的好处就是为了在搭建之后能很方便地备份和还原博客。其原理就是将原始文件和部署文件分离上传到仓库。这是这个教程没有明确说明的一个点。</p>
<p>在搭建好hexo博客之后，应该要按照以下过程管理博客：</p>
<h3 id="日常修改"><a class="header-anchor" href="#日常修改"></a>日常修改</h3>
<p>在本地对博客进行修改(添加新博文、修改样式等等)后，</p>
<p>1. 先执行hexo clean(这是为了减少上传的原始文件的大小，也可以忽略这步，那么速度也会快一点点)</p>
<p>2.依次执行</p>
<pre><code>git add .
git commit -m &quot;...&quot;
git push origin hexo
</code></pre>
<p>指令将改动 推送到github(此时当前分支应为hexo)</p>
<p>3. 执行<code>hexo g -d</code>发布网站到master分支上。</p>
<h3 id="如果本地资料丢失-之前所做的备份就能实现还原"><a class="header-anchor" href="#如果本地资料丢失-之前所做的备份就能实现还原"></a>如果本地资料丢失，之前所做的备份就能实现还原</h3>
<p>重装电脑或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<pre><code>使用
git clone git@github.com:sylujia/sylujia.github.io.git
拷贝仓库（默认分支为hexo）
在本地新拷贝的sylujia.github.io文件夹下通过Git bash依次执行下列指令：
npm install hexo、npm install、npm install hexo-deployer-git
（注意：不需要hexo init这条指令）
</code></pre>
<h2 id="理解过程和解决bug可能会用到的知识点"><a class="header-anchor" href="#理解过程和解决bug可能会用到的知识点"></a>理解过程和解决bug可能会用到的知识点</h2>
<h3 id="git与github区别"><a class="header-anchor" href="#git与github区别"></a>Git与GitHub区别</h3>
<p>理解Git与GitHub是两个不同的概念，这有利于理解搭建hexo博客的过程，万一报错了自己也能解决。</p>
<p>git是一个<a href="http://lib.csdn.net/base/git" target="_blank" rel="external">版本控制</a>的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。自行进一步理解git能够对搭建hexo博客的过程有理性的认识。</p>
<p>关于git的一些基本操作的含义可以看这里：<a href="http://blog.csdn.net/mchdba/article/details/12083965?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">个人常用命令add,commit以及push-黄杉</a></p>
<h3 id="gitignore文件"><a class="header-anchor" href="#gitignore文件"></a>.gitignore文件</h3>
<p>.gitignore顾名思义就是告诉git需要忽略的文件，这是一个很重要并且很实用的文件。</p>
<p>一般我们写完代码后会执行编译、调试等操作，这期间会产生很多中间文件和可执行文件，这些都不是代码文件，是不需要git来管理的。</p>
<p>我们在git status的时候会看到很多这样的文件，如果用git add -A来添加的话会把他们都加进去，而手动一个个添加的话也太麻烦了。</p>
<p>这时我们就需要.gitignore了。</p>
<h3 id="强制push"><a class="header-anchor" href="#强制push"></a>强制push</h3>
<p>如果<code>git push origin master</code>不行的话，是因为<strong>检测到远程的仓库和你本地仓库里面的文件各不相同</strong>所以不允许commit。</p>
<p>这时候你可以选择使用<code>git push -f origin master</code>强制地push，硬将你的内容推到github仓库上。</p>
<h3 id="遇到不能切换分支问题"><a class="header-anchor" href="#遇到不能切换分支问题"></a>遇到不能切换分支问题</h3>
<p>在本地切换分支的命令是<code>git checkout hexo</code></p>
<p>如果报错说不能换分支，</p>
<p>使用<code>git clean -d -fx &quot;&quot;</code>把以前的git记录清除掉就行了，</p>
<p>但是这也会删掉本地的文件，不要乱用。</p>
<h2 id="hexo搭建过程咨询服务"><a class="header-anchor" href="#hexo搭建过程咨询服务"></a>hexo搭建过程咨询服务</h2>
<p>以上文章内容已经提供了充足的资源来供一个小白自学如何搭建并且有能力自助解决搭建过程中出现的问题。但是我相信如果不亲自折腾一下hexo的话，是不会了解到其中的一些基本的原理，是不可能理解上述内容的，所以搭建过程是相当困难的。</p>
<p>如果按照一个比较完整的教程，<strong>10小时</strong>学会搭建一个hexo博客不是难事。</p>
<p>但是如果不懂得任何原理，按照教程来搭建，万一遇到报错或者问题会消耗大量的时间，我就是一个例子，经历了搭建好了一个hexo博客–换主题–修改主题的一些bug–重新搭建一个结构良好的hexo博客，我花了将近<strong>两个星期</strong>的时间。</p>
<p>在这两个星期的时间里面，因为遇到了一些有问题的教程，本来想请教大神，但总遭到大神们以忙为理由委婉拒绝，我只好花了大量时间来试错和研究和理解整个流程和原理。</p>
<p>可见，<strong>选对教程</strong>、<strong>理解原理</strong>能大大减少自我摸索过程中的痛苦。</p>
<p>一次偶然的机会，我收取了一个网友50元，在他整个搭建过程中向他提供问题咨询，包学包会。结果发现他在整个过程中能免除很多痛苦，而且节省了他大量的时间。两个星期的问题能够在三四天时间内轻松解决，其实这50元还真的挺值。</p>
<p>后来我陆续接了几单咨询来做，通过这个互利的过程，我对咨询和解决方案行业的态度发生的巨大的改观。我个人也欢迎联系付费咨询的合作！</p>
<h2 id="本文补充"><a class="header-anchor" href="#本文补充"></a>本文补充</h2>
<p>之前讲到的几个博文链接地址我都已经放上了，另外还有一篇原创的不错的文章，地址挂了，我把全文截图放在这里，可以右键另存为来看：</p>
<p><img src="http://olqa2s510.bkt.clouddn.com/CrazyMilk-%20blog.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 心得 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ToDo小应用完工总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/17/todo-app/</url>
      <content type="html"><![CDATA[<p>完成了百度IFE2015的 <a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003" target="_blank" rel="external">task3</a> ，实现了一个 ToDo 的单页应用，功能颇为强大。</p>
<p>使用 localStorage 存储数据，JSON 模拟数据表，实现了分类和待办状态的改变，具有良好的交互体验。</p>
<p>repository地址：<a href="https://github.com/AlexZhong22c/ToDoApp-IFE2015" target="_blank" rel="external">https://github.com/AlexZhong22c/ToDoApp-IFE2015</a></p>
<p>在线预览地址：<a href="https://alexzhong22c.github.io/ToDoApp-IFE2015/">https://alexzhong22c.github.io/ToDoApp-IFE2015/</a></p>
<a id="more"></a>
<h2 id="知识收获"><a class="header-anchor" href="#知识收获"></a>知识收获</h2>
<h3 id="自适应高度布局"><a class="header-anchor" href="#自适应高度布局"></a>自适应高度布局</h3>
<p>分为上中下三栏，中间的一栏自适应浏览器高度。这是参考了横向的三栏布局来写的。</p>
<ul>
<li>中间一栏要在外面包一层div，如果外面本来就有一层div这种布局就非常合适。上栏和下栏用绝对定位即可。</li>
<li>外面的这层div使用大面积的padding</li>
</ul>
<h3 id="在javascript-中创建html元素-用createelement-还是innerhtml好一点？"><a class="header-anchor" href="#在javascript-中创建html元素-用createelement-还是innerhtml好一点？"></a>在JavaScript 中创建HTML元素，用createElement()还是innerHTML好一点？</h3>
<ul>
<li>最叼的好像是 使用<a href="https://github.com/xwcoder/template" target="_blank" rel="external">模板技术</a>，其实我的静态博客用的就是这种。</li>
<li>在用js代码的循环创建元素的时候就顺便一个个绑定好事件这是一种比较简单的思路，这样就不用给每个元素增加id或者class了。这时候用createElement来创建元素就比较方便绑定事件，而如果用innerHTML来创建元素的话肯定不能在形成元素的循环里面给元素绑定事件了，这样太硬编码了。</li>
</ul>
<blockquote>
<p>《高性能JavaScript》：</p>
<ul>
<li>如果在对性能有苛刻要求更新一大段的HTML，innerHTML在大多数浏览器中执行更快。在旧版本浏览器中innerHTML方法更快，在基于Webkit内核却相反。</li>
<li>对于大多数日常操作而言，差异不大，根据代码可读性、可维护性、团队习惯、代码风格来决定采用哪种方法。</li>
<li>某答主说：**他一般大段就使用innerHTML了，而用dom创建单个元素或少量元素。 **</li>
<li>或者DOM结构嵌套的级数比较多的就用innerHTML</li>
<li>如果要使用createElement()，强烈推荐一下createDocumentFragment()
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="external">documentFragment</a> 被所有主流浏览器支持，甚至是IE 6。所以，没有理由不用。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="html属性用双引号-使用小写英文"><a class="header-anchor" href="#html属性用双引号-使用小写英文"></a>html属性用双引号、使用小写英文</h3>
<ul>
<li><strong>HTML4标准里没有单引号的对应实体，</strong> 所以单引号里写单引号很麻烦。后来XML规范才加入了’ 并由XHTML 1.0引入HTML。不过考虑到兼容性，前端几乎从来不写。
<ul>
<li>刚才在单引号里面写单引号只能用实体不能用反斜杠转移字符，根据HTML标准，反斜杠是不行的。</li>
</ul>
</li>
<li><strong>而JS中字符串用单引号，其实可能是HTML属性用双引号的结果。</strong></li>
<li>另外，一般大家惯用的做法是 HTML 用双引号，JS 用单引号的原因是，这样在 JS 中拼 HTML 片段不用转义：
<ul>
<li><code>elem.innerHTML = '&lt;div class=&quot;post&quot;&gt;&lt;/div&gt;';</code></li>
<li>当然你要反过来也可以，但不是主流做法。</li>
</ul>
</li>
<li>HTML属性不仅仅只有URL，另外引号出现在URL也是合法的。</li>
<li>根据W3Cschool的说法，<strong>要求属性和属性值使用小写，属性值应该始终被包括在引号内。</strong>
<ul>
<li>用innerHTML来创建taskid=1和cateid=0这种属性好像没有用啊，因为浏览器自动解析成：taskid=&quot;1&quot;和cateid=“0”</li>
</ul>
</li>
</ul>
<h3 id="ul里面能放除了li的其他标签吗？"><a class="header-anchor" href="#ul里面能放除了li的其他标签吗？"></a>ul里面能放除了li的其他标签吗？</h3>
<p>不能，<code>&lt;ul&gt;</code>里面只能放<code>&lt;li&gt;</code>。但是<code>&lt;li&gt;</code>里面可以放<code>&lt;hx&gt;</code>,<code>&lt;p&gt;</code>等标签。</p>
<p>ul里面放其他标签，不光不符合语义，在IE7- 里面也会有问题：</p>
<p>如果<code>&lt;other&gt;</code>标签前面有<code>&lt;li&gt;</code>标签，浏览器会认为<code>&lt;other&gt;</code>为<code>&lt;li&gt;</code>的子节点。</p>
<h3 id="box-shadow"><a class="header-anchor" href="#box-shadow"></a>box-shadow</h3>
<p>是CSS3里面的属性。只要shadow不占太多px的地方，用一下还是非常好的</p>
<h3 id="jquery"><a class="header-anchor" href="#jquery"></a>JQuery</h3>
<ul>
<li>JQuery的<code>not()</code>方法非常好用，<code>each()</code>也非常好</li>
</ul>
<ul>
<li>在绑定事件 函数中的 JQuery选择器 在函数触发后才会去选择对象</li>
<li>像这个App中分类列表的单击交互，如果想要只有被单击选择的HTML元素有 高亮，那么在绑定单击事件来响应单击选择的时候，记得先清除所有同类HTML元素的 高亮</li>
</ul>
<h4 id="jquery中-this-和-this-有区别："><a class="header-anchor" href="#jquery中-this-和-this-有区别："></a>JQuery中 this 和 $(“this”)有区别：</h4>
<p><a href="http://www.jb51.net/article/57376.htm" target="_blank" rel="external">JQuery中 this 和 $(“this”)有区别</a></p>
<p>如果你要使用html元素本身的属性或方法就需要使用this,如果你要使用jQuery包装后的方法或属性就要$(this),一般则有如下的关系.</p>
<pre><code>$(this)[0] == this;
</code></pre>
<p>上文的代码是要使用this的地方是要调用表单form的有reset方法,而这一方法jQuery没有包装支持,所以才有this.reset(),也可以使用$(this)[0].reset();</p>
<hr>
<p>关于什么时候使用二者?可以看如下例子:</p>
<pre><code>$('a').click(function(){
        this.innerHTML==$(this).html()=='jQuery';//三者是一样的.
        this.getAttribute('href')==this.href==$(this).attr('href')//三者是一样的;
        this.getAttribute('target')==this.target==$(this).attr('target')//三者是一样的;
        this.getAttribute('data-id')==$(this).attr('data-id')//二者是一样的;
    });
</code></pre>
<h3 id="caller的经典用法"><a class="header-anchor" href="#caller的经典用法"></a>caller的经典用法</h3>
<p>注：<strong>该特性是非标准的，请尽量不要在生产环境中使用它！</strong></p>
<p><img src="http://olqa2s510.bkt.clouddn.com/caller%E7%9A%84%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95.png" alt=""></p>
<h2 id="匠心勿失"><a class="header-anchor" href="#匠心勿失"></a>匠心勿失</h2>
<h3 id="html-css"><a class="header-anchor" href="#html-css"></a>HTML+CSS</h3>
<ul>
<li><a href="http://blog.bingo929.com/CSS-coding-semantic-naming.html" target="_blank" rel="external">CSS命名惯例语义化</a></li>
<li>把需要的li全都设成了<code>cursor:pointer</code></li>
<li>虽然DOM结构是由js代码渲染的，在HTML留下一些<strong>template</strong>方便参考和编写代码</li>
<li>将颜色抽象成单独的class，方便更换颜色：</li>
</ul>
<pre><code>.white-bg {background: #FFFFCC;}
.black-bg {background: #3F3A39;}
.green-bg {background: #CFE8CC;}
.blue-bg {background: #5D6684;}
.grey-bg {background: #E9E9E9;}
.lt-blue-bg {background: #DADADA;}
</code></pre>
<p>我认为，只有占<strong>大块区域</strong>的元素才用色彩的class来设置<strong>背景颜色</strong>。因为如果要上色的元素很多的话，或者元素会短时间内存在再消失的话，一个一个加class就很麻烦。</p>
<h3 id="javascript"><a class="header-anchor" href="#javascript"></a>JavaScript</h3>
<ul>
<li>优化了 JavaScript 函数的命名，使得风格统一，语义明确。
<ul>
<li>这个App里面，用来控制视图层的函数最好用refresh来命名，用update命名的函数用于更新数据库的信息</li>
</ul>
</li>
</ul>
<ul>
<li>一般留下数组index为0的位置来存放一些默认的数组元素。比如存储“分类”的数组就将“默认分类”设为是它的0号元素。</li>
<li>深刻感受到使用主键等等概念管理数据库的简便</li>
<li>如果是 JavaScript 对象字面量，键值对的 键 最好不要用&quot;“包着，转成JSON的时候 键 会自动被”&quot;包上</li>
<li><strong>util.js</strong>是基于前面的小任务写的，它的功能很薄弱。例如<code>$(#modal-foot button)</code>返回来的只是一个元素对象，不合理，所以为了省事我直接用JQuery库就好了。</li>
</ul>
<h3 id="改进代码"><a class="header-anchor" href="#改进代码"></a>改进代码</h3>
<pre><code>function queryCateById(id) {
    var allCates = queryAllCates();
    var result = null;
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            result = allCates[i];
            break;
        }
    }
    return result;
}
</code></pre>
<p>简化为：</p>
<pre><code>function queryCateById(id) {
    var allCates = queryAllCates();
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            return allCates[i];
        }
    }
}
</code></pre>
<h3 id="容易犯的错误"><a class="header-anchor" href="#容易犯的错误"></a>容易犯的错误</h3>
<ul>
<li>JQuery中使用id选择器返回的也是<strong>元素数组</strong>。</li>
</ul>
<pre><code>console.log($(&quot;#modal-foot&quot;))// 元素数组
console.log($(&quot;#modal-foot&quot;)[0])// 这才是想要的元素
</code></pre>
<ul>
<li>HTML会自动忽略空格，要空格请用<code>&amp;nbsp;</code></li>
</ul>
<hr>
<p>在JQuery中，$(selector)[0]中的[0]会将JQuery对象转化为JavaScript对象。所以onclick有两种写法：</p>
<pre><code>$(&quot;#modal-foot button.cancel&quot;)[0].onclick = function() {
	// ```
}; 
///////分割线
$(&quot;#modal-foot button.cancel&quot;).click(function() {
	$(&quot;.cover&quot;).hide();
}); 
// $(selector).click(function() {});
</code></pre>
<p>另外还有一个例子可以看一下：</p>
<pre><code>$(&quot;.cover&quot;).show();
$(&quot;.cover&quot;).css(&quot;display&quot;,&quot;block&quot;);
$(&quot;.cover&quot;)[0].style.display = &quot;block&quot;;
</code></pre>
<h3 id="优化命名"><a class="header-anchor" href="#优化命名"></a>优化命名</h3>
<p><strong>函数名</strong>中包含&quot;all&quot;还是挺有用的，但是<strong>函数中的变量名</strong>包含&quot;all&quot;就没什么作用，如果是数组用&quot;arr&quot;命名就可以了。</p>
<p>比如：</p>
<pre><code>// 函数名中包含all，比较容易与其他类似的函数区分
function queryAllCates() {
    return JSON.parse(localStorage.cate);
}
</code></pre>
<p>再比如：</p>
<pre><code>function queryCateById(id) {
    var allCates = JSON.parse(localStorage.cate);
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            return allCates[i];
        }
    }
}
// 函数内变量名带all好像也没什么用。allCates还不如直接叫cates或者叫catesArr
</code></pre>
<p>但是：</p>
<p>如果用addNewTask作为函数名，肯定不够用addTask作为函数名好。</p>
<h2 id="发现bug-找时间再fix"><a class="header-anchor" href="#发现bug-找时间再fix"></a>发现bug，找时间再fix</h2>
<p>有一个bug就是修改task内容的时候，仍能按下其他任务</p>
]]></content>
      
        <categories>
            
            <category> 项目总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> App </tag>
            
            <tag> caller </tag>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[相等操作符回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/02/11/equality-operators/</url>
      <content type="html"><![CDATA[<p>最早的ECMAscript中的相等和不相等操作符会在执行比较之前，先将对象转换成相似的类型(即，强制转型)。</p>
<p>后来有人对这种转换的合理性提出质疑。</p>
<p>最后，ECMAcript的解决方案是提供两组操作符：</p>
<ul>
<li>相等和不相等——先转换再比较</li>
<li>全等和不全等——仅比较而不转换</li>
</ul>
<a id="more"></a>
<h2 id="相等-和不相等"><a class="header-anchor" href="#相等-和不相等"></a>相等(==)和不相等(!=)</h2>
<p>&quot;==“和”!=“是互补对立的：如果两个操作数用”==“比较时返回 true，则这两个操作数用”!=“比较时就会返回 false ; 另外，用”==“返回 false 时，用”!=&quot;则返回true，这点很容易理解。</p>
<p>这两个操作符都会强制转型，<strong>在比较相等性之前</strong>会作以下工作：</p>
<ul>
<li>布尔值转换为数值，详见后面的补充。</li>
<li>字符串和数值比较时，将字符串转换成数值</li>
<li>对象和<strong>不是对象的操作数</strong>比较时，调用对象的<code>valueOf()</code>方法，用得到的基本类型值按照前面的规则进行比较。</li>
</ul>
<p>==和!=<strong>在进行比较之时</strong>遵循以下规则：</p>
<ul>
<li>null 和 undefined 是相等的。null == undefined
<ul>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
</ul>
</li>
<li>NaN和任何操作数不等，NaN 不等于NaN。
<ul>
<li>如果有一个操作数是 NaN，则&quot;==“返回 false ，而”!=&quot;返回 true 。</li>
<li>重要提示：即便两个操作数都是NaN，&quot;==&quot;也返回false，因为按照规则，NaN 不等于NaN。</li>
</ul>
</li>
<li>如果两个操作数都是对象，则比较它们是不是指向同一个对象。</li>
</ul>
<p>补充：</p>
<p>1. 相等运算符隐藏的强制转型，会带来一些违反直觉的结果：</p>
<pre><code> '' == 0            // true
' \t\r\n ' == 0     // true

false == 'false'    // false，这个超坑爹
false == '0'        // true
</code></pre>
<p>2.</p>
<pre><code>true == 1 返回true
false == 0 返回true
true == 2 返回true
</code></pre>
<p>还有另外一个概念叫<strong>Boolean 表达式</strong>，容易和以上概念混淆。在需要用到 Boolean 表达式的情景(比如if等语句中的条件判断)，非 Boolean 表达式也可以被转换为 Boolean 值，但是要遵循下列规则：</p>
<ul>
<li>所有的对象都被当作 true。</li>
<li>当且仅当字符串为空时，该字符串被当作 false。</li>
<li><strong>null</strong> 和 <strong>undefined</strong> 被当作 false。</li>
<li>当且仅当数字为零时，该数字被当作 false。</li>
</ul>
<h2 id="全等-和不全等"><a class="header-anchor" href="#全等-和不全等"></a>全等(===)和不全等(!==)</h2>
<p>和**相等(==)和不相等(!=)**类似，只不过在比较之前没有强制转型的过程，两个操作数直接比较。</p>
<h2 id="尽量使用全等和不全等"><a class="header-anchor" href="#尽量使用全等和不全等"></a>尽量使用全等和不全等</h2>
<p>举个简单的例子，团队协作中你肯定需要读别人的代码。而当你看到“==”时，要判断清楚作者的代码意图是确实需要转型，还是无所谓要不要转型只是随手写了，还是不应该转型但是写错了……所花费的脑力和时间比明确的“===”（加上可能需要的明确转型）要多得多。要记得团队中的每个人（包括原作者自己）都需要付出这理解和维护成本。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作符回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/02/11/js-operators/</url>
      <content type="html"><![CDATA[<p>ECMAScript 操作符的与众不同之处在于，它们能适用于很多种基本数据类型的值，例如字符串、数字值、布尔值、甚至对象。</p>
<p>不过，在应用于对象时，响应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p>
<a id="more"></a>
<h2 id="一元操作符"><a class="header-anchor" href="#一元操作符"></a>一元操作符</h2>
<p>自增和自减直接借鉴了C语言</p>
<p>自增、自减、加、减这些一元操作符可以用于转换数据类型。</p>
<h2 id="位操作符"><a class="header-anchor" href="#位操作符"></a>位操作符</h2>
<p>这是借鉴了一些底层的语言，在特殊情况下才会用到，一般情况下已经很少用了</p>
<h2 id="布尔操作符"><a class="header-anchor" href="#布尔操作符"></a>布尔操作符</h2>
<h3 id="逻辑非"><a class="header-anchor" href="#逻辑非"></a>逻辑非</h3>
<p>返回的是布尔值</p>
<h3 id="逻辑与和逻辑或"><a class="header-anchor" href="#逻辑与和逻辑或"></a>逻辑与和逻辑或</h3>
<p>如果操作数不只有布尔值：</p>
<h4 id="none"><a class="header-anchor" href="#none"></a>&amp;&amp;</h4>
<p>如果第一个操作数是 Boolean 类型，而且值为 false ，那么直接返回 false。
如果第一个操作数是 Boolean 类型，而且值为 true，另外一个操作数是 object 类型，那么将返回这个对象。
如果两个操作数都是 object 类型，那么，返回第二个对象。
如果任何一个操作数是 null，那么，返回 null。
如果任何一个操作数是 NaN，那么返回 NaN。
如果任何一个操作数是 undefinded，那么返回 undefined。</p>
<h4 id="none-v2"><a class="header-anchor" href="#none-v2"></a>||</h4>
<p>如果第一个操作数是 boolean 类型，而且值为 true， 那么，直接返回 true。
如果第一个操作数是 Boolean 类型，而且值为 false ，第二个操作数为 object，那么返回 object 对象。
如果两个操作数都是 object 类型，那么返回第一个对象。
如果两个操作数都是 null，那么，返回 null。
如果两个操作数都是 NaN，那么返回 NaN。
如果两个操作数都是 undefined，那么，返回 undefined。</p>
<h4 id="不用搞得这么复杂-推荐大家看这部分的说明"><a class="header-anchor" href="#不用搞得这么复杂-推荐大家看这部分的说明"></a>不用搞得这么复杂 推荐大家看这部分的说明</h4>
<p>a &amp;&amp; b : 将a, b转换为Boolean类型, 再执行逻辑与, true返回b, false返回a
a || b : 将a, b转换为Boolean类型, 再执行逻辑或, true返回a, false返回b
转换规则:
对象为true
非零数字为true
非空字符串为true
其他为false</p>
<hr>
<p>我们可以利用 逻辑或 这一行为来避免为变量赋值 null 或 undefined 值：</p>
<pre><code>var myObject = preferredObject || backupObject;
</code></pre>
<p>变量 preferredObject 的值优先赋给 myObject ，变量 backupObject 的值作为后备。</p>
<h2 id="乘性操作符"><a class="header-anchor" href="#乘性操作符"></a>乘性操作符</h2>
<p>Infinity 和 -Infinity 表示无穷大和负无穷大</p>
<h3 id="乘法"><a class="header-anchor" href="#乘法"></a>乘法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity * 0 ==&gt; NaN</li>
</ul>
<h3 id="除法"><a class="header-anchor" href="#除法"></a>除法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity / Infinity ==&gt; NaN</li>
<li>0 / 0 ==&gt; NaN</li>
</ul>
<h3 id="求模"><a class="header-anchor" href="#求模"></a>求模</h3>
<p>a % b：</p>
<p>如果a有限大，而b无限大，结果为a</p>
<p>如果a为0， 结果为0</p>
<p>其他特殊情况一般为NaN</p>
<h2 id="加性操作符"><a class="header-anchor" href="#加性操作符"></a>加性操作符</h2>
<h3 id="加法"><a class="header-anchor" href="#加法"></a>加法</h3>
<ul>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后拼接字符串
<ul>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的toString() 方法</li>
<li>对于undefined 和 null ，调用String()函数取得字符串&quot;undefined&quot;和&quot;null&quot;</li>
</ul>
</li>
</ul>
<h3 id="减法"><a class="header-anchor" href="#减法"></a>减法</h3>
<p>略</p>
<h2 id="关系操作符"><a class="header-anchor" href="#关系操作符"></a>关系操作符</h2>
<ul>
<li>如果两个操作符都是字符串，则比较两个字符串对应的字符编码值
<ul>
<li>大写字母的字符编码 全部小于 小写字母的字符编码</li>
</ul>
</li>
</ul>
<h2 id="相等操作符"><a class="header-anchor" href="#相等操作符"></a>相等操作符</h2>
<p>见另外一篇文章 <a href="https://alexzhong22c.github.io/2017/02/11/equality-operators/">相等操作符</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js事件绑定基础回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/01/29/js-event/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="绑定事件监听"><a class="header-anchor" href="#绑定事件监听"></a>绑定事件监听</h2>
<p>在 JavaScript 中，有三种常用的绑定事件的方法：</p>
<ol>
<li>HTML 内联属性（避免使用）</li>
<li>DOM 属性绑定</li>
<li>使用事件监听函数</li>
</ol>
<h3 id="html-内联属性-避免使用"><a class="header-anchor" href="#html-内联属性-避免使用"></a>HTML 内联属性（避免使用）</h3>
<pre><code>&lt;button onclick=&quot;alert('你点击了这个按钮');&quot;&gt;点击这个按钮&lt;/button&gt;
</code></pre>
<p>使用这种方法，JavaScript 代码与 HTML 代码耦合在了一起，不便于维护和开发。所以除非在必须使用的情况（例如统计链接点击数据）下，尽量避免使用这种方法。</p>
<h3 id="在javascript代码中绑定"><a class="header-anchor" href="#在javascript代码中绑定"></a>在JavaScript代码中绑定</h3>
<pre><code>element.onclick = function(event){
    alert('你点击了这个按钮');
};

</code></pre>
<p>缺陷是：因为直接赋值给对应属性，如果你在后面代码中再次为 <code>element</code> 绑定一个回调函数，会覆盖掉之前回调函数的内容。</p>
<p>虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。</p>
<h3 id="绑定事件监听函数"><a class="header-anchor" href="#绑定事件监听函数"></a>绑定事件监听函数</h3>
<pre><code>var btn = document.getElementsByTagName('button');
btn[0].addEventListener('click', function() {
    alert('你点击了这个按钮');
}, false);

</code></pre>
<p>最后一个参数表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。</p>
<p>但一般使用时我们往往传递 false，这是因为 IE 浏览器不支持在捕获阶段监听事件，毕竟 IE 浏览器的份额是不可忽略的。</p>
<h2 id="移除事件监听"><a class="header-anchor" href="#移除事件监听"></a>移除事件监听</h2>
<p>需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如：</p>
<pre><code>var fun = function() {
    // function logic
};

element.addEventListener('click', fun, false);
element.removeEventListener('click', fun, false);

</code></pre>
<h2 id="事件触发过程"><a class="header-anchor" href="#事件触发过程"></a>事件触发过程</h2>
<ol>
<li>
<p>捕获阶段（Capture Phase）</p>
</li>
<li>
<p>目标阶段（Target Phase）</p>
</li>
<li>
<p>冒泡阶段（Bubbling Phase）</p>
</li>
</ol>
<h2 id="使用事件代理-event-delegate-提升性能"><a class="header-anchor" href="#使用事件代理-event-delegate-提升性能"></a>使用事件代理（Event Delegate）提升性能</h2>
<p>使用事件代理主要有两个优势：</p>
<ol>
<li>减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。</li>
<li>动态变化的 DOM 结构，仍然可以监听。以前，当一个 DOM 动态创建之后，不会带有任何事件监听，除非你重新执行事件监听函数；而使用事件监听无须担忧这个问题。</li>
</ol>
<p>如果使用原生的方式实现事件代理，需要注意过滤非目标节点，可以通过 id、class 或者 tagname 等等，例如：</p>
<pre><code>element.addEventListener('click', function(event) {
    // 判断是否是 a 节点
    if ( event.target.tagName == 'A' ) {
        // a 的一些交互操作
    }
}, false);
</code></pre>
<h2 id="停止事件冒泡-stoppropagation"><a class="header-anchor" href="#停止事件冒泡-stoppropagation"></a>停止事件冒泡（stopPropagation）</h2>
<pre><code>element.addEventListener('click', function(event) {
    event.stopPropagation();
}, false);

</code></pre>
<h2 id="事件的-event-对象"><a class="header-anchor" href="#事件的-event-对象"></a>事件的 Event 对象</h2>
<p>事件对象包括很多有用的信息，比如事件触发时，鼠标在屏幕上的坐标、被触发的 DOM 详细信息、以及上图最下面继承过来的停止冒泡方法（stopPropagation）。下面介绍一下比较常用的几个属性和方法：</p>
<h3 id="type-string"><a class="header-anchor" href="#type-string"></a><code>type</code>(string)</h3>
<p>事件的名称，比如 “click”。</p>
<h3 id="target-node"><a class="header-anchor" href="#target-node"></a><code>target</code>(node)</h3>
<p>事件要触发的目标节点。</p>
<h3 id="bubbles-boolean"><a class="header-anchor" href="#bubbles-boolean"></a><code>bubbles</code> (boolean)</h3>
<p>表明该事件是否是在冒泡阶段触发的。</p>
<h3 id="preventdefault-function"><a class="header-anchor" href="#preventdefault-function"></a><code>preventDefault</code> (function)</h3>
<p>这个方法可以禁止一切默认的行为，例如点击 <code>a</code> 标签时，会打开一个新页面，如果为 <code>a</code> 标签监听事件 <code>click</code> 同时调用该方法，则不会打开新页面。</p>
<h3 id="stoppropagation-function"><a class="header-anchor" href="#stoppropagation-function"></a><code>stopPropagation</code> (function)</h3>
<p>停止冒泡，上面有提到，不再赘述。</p>
<h3 id="stopimmediatepropagation-function"><a class="header-anchor" href="#stopimmediatepropagation-function"></a><code>stopImmediatePropagation</code> (function)</h3>
<p>与 <code>stopPropagation</code> 类似，就是阻止触发其他监听函数。但是与 <code>stopPropagation</code> 不同的是，它更加 “强力”，阻止除了目标之外的事件触发，甚至阻止针对同一个目标节点的相同事件。</p>
<h2 id="jquery-中的事件"><a class="header-anchor" href="#jquery-中的事件"></a>jQuery 中的事件</h2>
<p>如果你在写文章或者 Demo，为了简单，你当然可以用上面的事件监听函数，以及那些事件对象提供的方法等。*<em>但在实际中，有一些方法和属性是有兼容性问题的，所以我们会使用 jQuery 来消除兼容性问题。 *</em></p>
<h3 id="绑定事件和事件代理"><a class="header-anchor" href="#绑定事件和事件代理"></a>绑定事件和事件代理</h3>
<pre><code>$( &quot;#dataTable tbody tr&quot; ).on( &quot;click&quot;, function() {
  console.log( $( this ).text() );
});

</code></pre>
<h3 id="处理过兼容性的事件对象-event-object"><a class="header-anchor" href="#处理过兼容性的事件对象-event-object"></a>处理过兼容性的事件对象（Event Object）</h3>
<p>事件对象有些方法等也有兼容性差异，jQuery 将其封装处理，并提供跟标准一直的命名。</p>
<p>如果你想在 jQuery 事件回调函数中访问原来的事件对象，需要使用 <code>event.originalEvent</code>，它指向原生的事件对象。</p>
<h3 id="触发事件-trigger-方法"><a class="header-anchor" href="#触发事件-trigger-方法"></a>触发事件 <code>trigger</code> 方法</h3>
<p>点击某个绑定了 <code>click</code> 事件的节点，自然会触发该节点的 <code>click</code> 事件，从而执行对应回调函数。</p>
<p><code>trigger</code> 方法可以模拟触发事件，我们单击另一个节点 elementB，可以使用：</p>
<pre><code>$(elementB).on('click', function(){
    $(elementA).trigger( &quot;click&quot; );
});

</code></pre>
<p>来触发 elementA 节点的单击监听回调函数。详情请看文档 <a href="http://api.jquery.com/trigger/" target="_blank" rel="external">.trigger()</a>。</p>
<h2 id="原生js事件绑定兼容"><a class="header-anchor" href="#原生js事件绑定兼容"></a>原生js事件绑定兼容</h2>
<p>Dean Edward 所写的 addEvent() 函数：</p>
<pre><code>function addEvent(element, type, handler) {
    if (!handler.$$guid) handler.$$guid = addEvent.guid++;
    if (!element.events) element.events = {};
        var handlers = element.events[type];
    if (!handlers) {
        handlers = element.events[type] = {};
        if (element[&quot;on&quot; + type]) {
            handlers[0] = element[&quot;on&quot; + type];
        }
    }
    handlers[handler.$$guid] = handler;
    element[&quot;on&quot; + type] = handleEvent;
}

addEvent.guid = 1;
    
function removeEvent(element, type, handler) {
    if (element.events &amp;&amp; element.events[type]) {
        delete element.events[type][handler.$$guid];
    }
}
function handleEvent(event) {
    var returnValue = true;
    event = event || fixEvent(window.event);
    var handlers = this.events[event.type];
    for (var i in handlers) {
        this.$$handleEvent = handlers[i];
        if (this.$$handleEvent(event) === false) {
            returnValue = false;
        }
    }
    return returnValue;
};
    
function fixEvent(event) {
    event.preventDefault = fixEvent.preventDefault;
    event.stopPropagation = fixEvent.stopPropagation;
    return event;
};
fixEvent.preventDefault = function() {
    this.returnValue = false;
};
fixEvent.stopPropagation = function() {
    this.cancelBubble = true;
};
</code></pre>
<p>eslint版：</p>
<pre><code>function addEvent (element, type, handler) {
  if (!handler.$$guid) handler.$$guid = addEvent.guid++
  if (!element.events) element.events = {}
  let handlers = element.events[type]
  if (!handlers) {
    handlers = element.events[type] = {}
    if (element['on' + type]) {
      handlers[0] = element['on' + type]
    }
  }
  handlers[handler.$$guid] = handler
  element['on' + type] = handleEvent
}
addEvent.guid = 1

function removeEvent (element, type, handler) {
  if (element.events &amp;&amp; element.events[type]) {
    delete element.events[type][handler.$$guid]
  }
}

function handleEvent (event) {
  var returnValue = true
  event = event || fixEvent(window.event)
  var handlers = this.events[event.type]
  for (var i in handlers) {
    this.$$handleEvent = handlers[i]
    if (this.$$handleEvent(event) === false) {
      returnValue = false
    }
  }
  return returnValue
}

function fixEvent (event) {
  event.preventDefault = fixEvent.preventDefault
  event.stopPropagation = fixEvent.stopPropagation
  return event
}
fixEvent.preventDefault = function () {
  this.returnValue = false
}
fixEvent.stopPropagation = function () {
  this.cancelBubble = true
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 事件 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[font-face--CSS3]]></title>
      <url>https://alexzhong22c.github.io/2017/01/25/font-face/</url>
      <content type="html"><![CDATA[<p><code>@font-face</code>是一个css命令，用来导入服务器端字体，将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。因此本地浏览器浏览网页时，不需要设置字体，就可以自动看到@font-face设置的任何字体。</p>
<p>如果你看到一些英文网站或blog看到一些很漂亮的自定义Web字体，比如说首页的Logo，Tags以及页面中的手写英文体，这些都是**@font-face**实现的。</p>
<a id="more"></a>
<h2 id="font-face在css中使用"><a class="header-anchor" href="#font-face在css中使用"></a>@font-face在css中使用</h2>
<pre><code>@font-face {
　　font-family: &lt;YourWebFontName&gt;;
　　src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;
　　[font-weight: &lt;weight&gt;];
　　[font-style: &lt;style&gt;];
}
</code></pre>
<p>取值说明：</p>
<ol>
<li>YourWebFontName:你自定义的字体名称，最好是使用你下载的默认字体名（下载回来的叫什么字体，这里就填什么字体名），他将被引用到你的Web元素中的font-family。如“font-family:“YourWebFontName”;”</li>
<li>source:此值指的是自定义的字体的存放路径，可以是相对路径也可以是绝路径；</li>
<li>format：此值指的是自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</li>
<li>weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</li>
</ol>
<h2 id="兼容浏览器"><a class="header-anchor" href="#兼容浏览器"></a>兼容浏览器</h2>
<p>说到浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，这样大家有必要了解一下，各种版本的浏览器支持什么样的字体：</p>
<blockquote>
<p><strong>一、TureTpe(.ttf)格式：</strong></p>
<p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p>
<p><strong>二、OpenType(.otf)格式：</strong></p>
<p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，所以也提供了更多的功能,支持这种字体的浏览器有【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】；</p>
<p><strong>三、Web Open Font Format(.woff)格式：</strong></p>
<p><strong>.woff字体是Web字体中最佳格式</strong>，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p>
<p><strong>四、Embedded Open Type(.eot)格式：</strong></p>
<p>.eot字体是<strong>IE专用字体</strong>，可以从TrueType创建此格式字体,支持这种字体的浏览器有【IE4+】；</p>
<p><strong>五、SVG(.svg)格式：</strong></p>
<p>.svg字体是基于SVG字体渲染的一种格式,支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p>
</blockquote>
<p><strong>这就意味着在@font-face中我们至少需要.woff,.eot两种格式字体</strong>，<strong>甚至还需要.svg等字体达到更多种浏览版本的支持。</strong></p>
<hr>
<p>为了使@font-face达到更多的浏览器支持，<a href="http://paulirish.com/" target="_blank" rel="external">Paul Irish</a>写了一个独特的@font-face语法叫<a href="http://paulirish.com/2009/bulletproof-font-face-implementation-syntax/" target="_blank" rel="external">Bulletproof @font-face</a>:</p>
<pre><code>  @font-face {
	font-family: 'YourWebFontName';
	src: url('YourWebFontName.eot?#iefix') format('eot');/*IE*/
	src:url('YourWebFontName.woff') format('woff'), url('YourWebFontName.ttf') format('truetype');/*non-IE*/
   }
</code></pre>
<p>但为了让各多的浏览器支持，你也可以写成：</p>
<pre><code>  @font-face {
	font-family: 'YourWebFontName';
	src: url('YourWebFontName.eot'); /* IE9 Compat Modes */
	src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
             url('YourWebFontName.woff') format('woff'), /* Modern Browsers */
             url('YourWebFontName.ttf')  format('truetype'), /* Safari, Android, iOS */
             url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */
   }
</code></pre>
<p>直接改改<code>YourWebFontName</code>就行了。</p>
<p>然后就在CSS 里面引用给对应的元素：</p>
<pre><code>p {
	font-family: 'YourWebFontName'
}
</code></pre>
<hr>
<h2 id="获取特殊字体"><a class="header-anchor" href="#获取特殊字体"></a>获取特殊字体</h2>
<p>我平时都是到Google Web Fonts和Dafont.com寻找自己需要的字体，当然网上也还有别的下载字体的地方,如：<a href="http://webfonts.fonts.com/" target="_blank" rel="external">Webfonts</a>,<a href="http://typekit.com/" target="_blank" rel="external">Typekit</a>,<a href="http://kernest.com/" target="_blank" rel="external">Kernest</a>,<a href="http://www.google.com/webfonts" target="_blank" rel="external">Google Web Fonts</a>,<a href="http://kernest.com/licenses" target="_blank" rel="external">Kernest</a>,<a href="http://www.dafont.com/" target="_blank" rel="external">Dafont</a>,<a href="http://nicewebtype.com/fonts/" target="_blank" rel="external">Niec Web Type</a>,不然你点<a href="http://www.google.com/search?q=webfonts" target="_blank" rel="external">这里</a>将有更多的免费字体。前面几个链接是帮助你获取一些优美的怪异的特殊字体!</p>
<h3 id="获取-font-face所需字体格式："><a class="header-anchor" href="#获取-font-face所需字体格式："></a>获取@font-face所需字体格式：</h3>
<p>特殊字体已经在你的电脑中了，现在我们需要想办法获得@font-face所需的.eot,.woff,.ttf,.svg字体格式。要获取这些字体格式，我们同样是需要第三方工具或者软件来实现，下面我给大家推荐一款我常用的一个工具<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="external">fontsquirrel</a>, 链接：<a href="http://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="external">http://www.fontsquirrel.com/tools/webfont-generator</a></p>
<p>使用这个在线字体格式生成工具，我们只需要上传我们下载回来的一种字体格式，就能生成其它的.eot,.woff,.ttf,.svg字体格式，很方便地说！这款工具的具体使用方法，可参考原文：</p>
<p><a href="http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2084875.html" target="_blank" rel="external">http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2084875.html</a> ，本文也是转载该站 的内容 ，在此表示 感谢 ！</p>
<p>或者这个在线字体格式转换地址：<a href="https://cloudconvert.com/" target="_blank" rel="external">https://cloudconvert.com/</a> 也是可以的，有其它比较实用方便的网址，欢迎留言提供，方便大家。</p>
<hr>
<p>推荐给body写：</p>
<pre><code>font-family: -apple-system-font,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Open Sans&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;WenQuanYi Micro Hei&quot;,sans-serif;
</code></pre>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> font-face </tag>
            
            <tag> 字体 </tag>
            
            <tag> 特殊 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内容分类--谈谈H5标签]]></title>
      <url>https://alexzhong22c.github.io/2017/01/25/h5-new-ele/</url>
      <content type="html"><![CDATA[<p>对内容作了调整，方便自己理解，详情请参考MDN：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories</a></p>
<p>每一个HTML元素都必须遵循定义了它可以包含哪一类内容的规则。</p>
<p>以下是三种类型的内容分类：</p>
<a id="more"></a>
<ul>
<li>主内容类，描述了很多元素共享的内容规范；</li>
<li>表单相关的内容类，描述了表单相关元素共有的内容规范；</li>
<li>特殊内容类，描述了仅仅在某些特殊元素上才需要遵守的内容规范，通常这些元素都有特殊的上下文关系。</li>
</ul>
<p><img src="http://olqa2s510.bkt.clouddn.com/Content_categories_venn.png" alt="Content_categories_venn"></p>
<h2 id="元数据内容模型"><a class="header-anchor" href="#元数据内容模型"></a>元数据内容模型</h2>
<p>此类元素 修改文档其余部分的陈述或者行为，建立与其他文档的链接，或者传达其他外带信息。</p>
<p>属于这一类的元素有：link 、meta、noscript、script、style、title等等</p>
<h2 id="分节内容模型"><a class="header-anchor" href="#分节内容模型"></a>分节内容模型</h2>
<p>在当前的大纲中创建一个<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="external">分节</a>，此分节将定义<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="external"><code>header</code></a>元素、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer" target="_blank" rel="external"><code>footer</code></a> 元素和标题元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories#Heading_content" target="_blank" rel="external">heading content</a>）的范围。</p>
<h3 id="article元素"><a class="header-anchor" href="#article元素"></a>article元素</h3>
<p><code>&lt;article&gt;</code>元素表示文档、页面、应用或网站中的<strong>独立结构</strong>，其意在成为<strong>可独立分配的或可复用的结构</strong>，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。</p>
<p>用时要特别注意内容的独立性：一般独立完整的内容才使用article元素，如果只是一段内容的话应该是用section元素。</p>
<blockquote>
<p>使用说明：</p>
<ul>
<li>当<code>&lt;article&gt;</code>元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的<code>&lt;article&gt;</code>元素可嵌套在代表博客文章的<code>&lt;article&gt;</code>元素中。</li>
<li><code>&lt;article&gt;</code>元素的作者信息可通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/address" target="_blank" rel="external">``</a>元素提供，但是不适用于嵌套的<code>&lt;article&gt;</code>元素。</li>
<li><code>&lt;article&gt;</code>元素的发布日期和时间可通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/time" target="_blank" rel="external">``</a>元素的<code>pubdate</code>属性表示。</li>
</ul>
</blockquote>
<h3 id="section元素"><a class="header-anchor" href="#section元素"></a>section元素</h3>
<ul>
<li>用于定义文章中的章节(通常应该有标题和段落内容)</li>
</ul>
<ul>
<li>用来定义文档中特定的内容区块，可视为一个区域分组元素。</li>
</ul>
<ul>
<li>用一句话来概括它的作用就是：给内容分段，给页面分区</li>
</ul>
<ul>
<li>注意它与div的区别，div强调在形式上的独立性，section强调的是内容上的独立性，注意它的语义。</li>
</ul>
<blockquote>
<p>article和section对比：</p>
<p>1. 语义不同：</p>
<ul>
<li>article元素是独立完整的内容，section元素页面内容分块</li>
</ul>
<p>2. 相同点：</p>
<p>本质上都是带有语义的div块元素</p>
<p>分别可以看做<code>&lt;div id=&quot;section&quot;&gt;</code>和<code>&lt;div id=&quot;article&quot;&gt;</code></p>
</blockquote>
<h3 id="aside元素"><a class="header-anchor" href="#aside元素"></a>aside元素</h3>
<ul>
<li>aside元素通常用来设置侧边栏</li>
<li>用于定义article元素之外的内容，前提是这些内容与article元素内的内容相关。</li>
<li>同时也可嵌套在article元素内部使用，作为主要内容的附属信息。比如与内容有关的参考资料，名词解释等。</li>
</ul>
<h3 id="nav元素"><a class="header-anchor" href="#nav元素"></a>nav元素</h3>
<ul>
<li>用来定义目录、导航栏</li>
<li>并非所有的超链接都放在nav元素中，通常只把一个文档中的主导航栏放在nav中。</li>
</ul>
<h2 id="标题内容模型"><a class="header-anchor" href="#标题内容模型"></a>标题内容模型</h2>
<p>定义了分节的标题，而这个分节可能由一个明确的分节内容元素直接标记，也可能由标题本身隐式地定义。</p>
<p>属于此分类的元素有：h1到h6和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/hgroup" target="_blank" rel="external"><code>hground</code></a></p>
<blockquote>
<p>注意：尽管<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="external"><code>header</code></a>可能包含一些标题内容，但<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="external"><code>header</code></a>并不是标题内容本身。</p>
</blockquote>
<h2 id="表单相关内容模型"><a class="header-anchor" href="#表单相关内容模型"></a>表单相关内容模型</h2>
<p>拥有表单父节点（exposed by a <strong>form</strong> attribute）的元素。</p>
<p>一个表单父节点可以是form元素，也可以是其id在表单属性中被指定了的元素。</p>
<h2 id="其他比较常用的元素"><a class="header-anchor" href="#其他比较常用的元素"></a>其他比较常用的元素</h2>
<h3 id="header元素"><a class="header-anchor" href="#header元素"></a>header元素</h3>
<p><code>&lt;header&gt;</code>元素表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</p>
<h3 id="footer元素"><a class="header-anchor" href="#footer元素"></a>footer元素</h3>
<p><strong>HTML <code>&lt;footer&gt;</code>元素</strong>表示最近一个<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document#Defining_Sections_in_HTML5" target="_blank" rel="external">章节内容</a>或者<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document#Sectioning_root" target="_blank" rel="external">根节点</a>（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p>
<blockquote>
<ul>
<li><code>&lt;footer&gt;</code>元素内的作者信息应包含在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/address" target="_blank" rel="external">``</a> 元素中。</li>
<li><code>&lt;footer&gt;</code>元素不是章节内容，因此在<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="external">outline</a>中不能包含新的章节。</li>
</ul>
</blockquote>
<hr>
<h3 id="time元素"><a class="header-anchor" href="#time元素"></a>time元素</h3>
<ul>
<li>time元素代表24小时中的某个时刻或某个日期，表示时刻允许出现时差。它可以定义很多格式的日期和时间
<ul>
<li>datetime属性。代表中日期和时间之间要用“T”文字分隔，“T”表示时间，请注意倒数第二行，时间加上Z文字表示给机器编码时使用UTC标准时间，表示向机器编码另一地区时间，如果是编码本地时间，则不需要添加时差。</li>
<li>pubdate属性是个可选标签。加上它搜索引擎/浏览器就可以很方便的识别出那个日期是文章、新闻的发表日期。</li>
</ul>
</li>
</ul>
<pre><code>&lt;time datetime=&quot;2015-10-22&quot;&gt;2015年10月12日&lt;/time&gt;
&lt;time datetime=&quot;2015-10-22T20:00&quot;&gt;2015年10月12日晚上8点&lt;/time&gt;
&lt;time datetime=&quot;2015-10-22T20:00Z&quot;&gt;2015年10月12日晚上8点&lt;/time&gt;
&lt;time datetime=&quot;2015-10-22T20:00+09:00&quot;&gt;美国时间2015年10月12日8点&lt;/time&gt;
</code></pre>
<h3 id="address元素"><a class="header-anchor" href="#address元素"></a>address元素</h3>
<p>HTML的<code>&lt;address&gt;</code>元素可以让作者为它最近的<code>&lt;article&gt;</code>或者<code>&lt;body&gt;</code>祖先元素提供联系信息。在后一种情况下，它应用于整个文档。</p>
<ul>
<li>通常用来说明作者的联系信息，例如名字、E-mail、电话、地址等。</li>
<li>address元素中的内容会以斜体显示。</li>
<li>通常，<code>&lt;address&gt;</code>元素可以放在当前section的<code>&lt;footer&gt;</code>元素中，如果存在的话。</li>
<li>浏览器兼容很好，尽量使用</li>
</ul>
<hr>
<h3 id="form元素"><a class="header-anchor" href="#form元素"></a>form元素</h3>
<p>水电费水电费水电费水电费s</p>
<pre><code>&lt;form&gt;
  &lt;label for=&quot;GET-name&quot;&gt;Name:&lt;/label&gt;
  &lt;input id=&quot;GET-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="fieldset元素"><a class="header-anchor" href="#fieldset元素"></a>fieldset元素</h3>
<p>fieldset元素 通常用来对表单的相关元素分组</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Title&lt;/legend&gt;
    &lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio&quot;&gt; &lt;label for=&quot;radio&quot;&gt;Click me&lt;/label&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h3 id="legend元素"><a class="header-anchor" href="#legend元素"></a>legend元素</h3>
<p>HTML的<code>&lt;legend&gt;</code>元素（也称为HTML的域说明元素（or HMTL
Legend Field Element））代表一个用于表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题。</p>
<h3 id="label属性"><a class="header-anchor" href="#label属性"></a>label属性</h3>
<p>HTML<code>&lt;label&gt;</code>元素表示用户界面中项目的标题。</p>
<h4 id="使用-label-for-属性-bind-input-id"><a class="header-anchor" href="#使用-label-for-属性-bind-input-id"></a>使用 label  “for” 属性 bind input “id”</h4>
<pre><code>&lt;label for=&quot;User&quot;&gt;Click me&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;
</code></pre>
<hr>
<h3 id="figure元素"><a class="header-anchor" href="#figure元素"></a>figure元素</h3>
<p>figure元素是一个媒体组合元素，也就是对其他的媒体元素进行组合，比如：图像、图标等等。</p>
<h3 id="figcaptio元素"><a class="header-anchor" href="#figcaptio元素"></a>figcaptio元素</h3>
<p>用来给figure元素定义标题。</p>
<h3 id="video元素"><a class="header-anchor" href="#video元素"></a>video元素</h3>
<ul>
<li>src属性：音频地址</li>
<li>loop属性：是否重复播放</li>
<li>autoplay属性：是否自动播放</li>
<li>controls属性：添加控制</li>
<li>poster属性：在视频加载完成前显示什么</li>
<li>当然这个元素对于个别浏览器会有些隐性的小问题</li>
</ul>
<h2 id="另外附上提高html代码性能的几点建议："><a class="header-anchor" href="#另外附上提高html代码性能的几点建议："></a>另外附上提高HTML代码性能的几点建议：</h2>
<h3 id="语义化标记"><a class="header-anchor" href="#语义化标记"></a>语义化标记</h3>
<p>语义指意义相关的事物，HTML 可从页面内容中看出语义：元素和属性的命名一定程度上表达了内容的角色和功能。HTML5 引入了新的语义元素，如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>及<code>&lt;nav&gt;</code>。</p>
<p>选择合适的元素来编写代码可保证代码的易读性：</p>
<ul>
<li>使用<code>&lt;h1&gt;</code>(<code>&lt;h2&gt;</code>,<code>&lt;h3&gt;</code>…)表示标题，<code>&lt;ul&gt;</code>或<code>&lt;ol&gt;</code>实现列表</li>
<li>注意使用<code>&lt;article&gt;</code>标签之前应添加<code>&lt;h1&gt;</code>标签；</li>
<li>选择合适的HTML5语义元素如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>,<code>&lt;nav&gt;</code>,<code>&lt;aside&gt;</code>;</li>
<li>使用<code>&lt;p&gt;</code>描述Body 文本，HTML5 语义元素可以形成内容，反之不成立。</li>
<li>使用<code>&lt;label&gt;</code>元素，输入类型，占位符及其他属性来强制验证。</li>
<li>将文本和元素混合，并作为另一元素的子元素，会导致布局错误</li>
<li>img元素记得加alt属性</li>
</ul>
<h4 id="i-b-em-strong元素"><a class="header-anchor" href="#i-b-em-strong元素"></a>i/b/em/strong元素</h4>
<p><code>&lt;em&gt;</code> 用于对文本内容进行强调，强调位置的不同通常会改变句子的含义。如果仅仅在语态或语气上为了突出某一个文本，那应该使用<code>&lt;i&gt;</code>。</p>
<p>但如果为了突出某一部分的重要性、严重性或紧急性，那应该使用 <code>&lt;strong&gt;</code>。根据 W3C 对 <code>&lt;b&gt;</code>元素的说明，<code>&lt;b&gt;</code>元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签。</p>
<p>相同的，在考虑使用 <code>&lt;i&gt;</code> 之前，也要想想是否用<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;dfn&gt;</code> 或 <code>&lt;mark&gt;</code> 等元素更合适。</p>
<h3 id="布局"><a class="header-anchor" href="#布局"></a>布局</h3>
<p>要提高HTML代码的性能，要遵循HTML 代码以实现功能和为目标，而不是样式。</p>
<ul>
<li>使用<code>&lt;p&gt;</code>元素修饰文本，而不是布局；默认<code>&lt;p&gt;</code>是自动提供边缘，而且其他样式也是浏览器默认提供的。</li>
<li>避免使用<code>&lt;br&gt;</code>分行，可以使用block元素或CSS显示属性来代替。</li>
<li>避免使用<code>&lt;hr&gt;</code>来添加水平线，可使用CSS的border-bottom 来代替。</li>
<li>不到关键时刻不要使用div标签。</li>
<li>尽量少用Tables来布局。</li>
<li>可以多使用Flex Box</li>
<li>使用CSS 来调整边距等。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js函数基础回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/01/13/js-function/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="创建函数对象的三种方法"><a class="header-anchor" href="#创建函数对象的三种方法"></a>创建函数对象的三种方法</h2>
<h3 id="函数声明"><a class="header-anchor" href="#函数声明"></a>函数声明</h3>
<p>就是对函数进行普通的声明</p>
<pre><code>function add(a, b) {
    return a + b;
}
</code></pre>
<h3 id="函数表达式"><a class="header-anchor" href="#函数表达式"></a>函数表达式</h3>
<ul>
<li>将函数赋值给变量</li>
</ul>
<pre><code>// function variable
var add = function(a, b) {
    // body...
};
</code></pre>
<ul>
<li>立即执行函数，把匿名函数用括号括起来，再直接调用。</li>
</ul>
<pre><code>// IEF(Immediately Executed Function)
(function() {
    // body...
})();
</code></pre>
<ul>
<li>函数对象作为返回值</li>
</ul>
<pre><code>return function() {
    // body...
};
</code></pre>
<ul>
<li>命名式函数表达式</li>
</ul>
<pre><code>//NFE(Named Function Expression)
var add = function foo(a, b) {
    // body...
};
</code></pre>
<p>这里大家肯定会好奇，这个函数怎么调用？到底用哪个名字呢？</p>
<p>做一个测试：</p>
<pre><code>var func = function nfe() {};
console.log(func === nfe);
// 在 IE6~8，得到 false
// 在 IE9+ 及现代浏览器中 Uncaught ReferenceError: nfe is not defined
</code></pre>
<p>那么命名函数表达式有什么使用场景呢？</p>
<ul>
<li>一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。</li>
<li>或者在递归时，使用名字调用自己。</li>
</ul>
<p>但是这两种用法都不常见。</p>
<h3 id="function-构造器"><a class="header-anchor" href="#function-构造器"></a>Function 构造器</h3>
<p>除了函数声明、函数表达式。还有一种创建函数对象的方式，是使用函数构造器。</p>
<pre><code>var func = new Function('a','b','console.log(a+b);');
func(1,2);//3

var func2 = Function('a','b','console.log(a+b);');
func2(1,2);//3
</code></pre>
<p>Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。</p>
<p>还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。</p>
<h3 id="三种方法的对比"><a class="header-anchor" href="#三种方法的对比"></a>// 三种方法的对比:</h3>
<p><img src="http://olqa2s510.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt=""></p>
<h2 id="变量-函数的声明前置"><a class="header-anchor" href="#变量-函数的声明前置"></a>变量 &amp; 函数的声明前置</h2>
<p>举两个例子</p>
<p>例1，函数声明：</p>
<pre><code>var num = add(1,2);
console.log(num);

function add(a, b) {
    return a + b;
}
</code></pre>
<p>例2，函数表达式：</p>
<pre><code>var num = add(1, 2);
console.log(num);

var add = function(a, b) {
    return a + b;
};
</code></pre>
<p>例1中得到的结果是 3，而例2中是 <code>Uncaught TypeError: add is not a function</code>。</p>
<p>因为函数和变量在声明的时候，会被前置到当前作用域的顶端。例1将函数声明<code>function add(a, b)</code>前置到作用域前端，例2将声明<code>var add</code>前置到其作用域的前端了，并没有赋值。<strong>赋值的过程是在函数执行到响应位置的时候才进行的。</strong></p>
<h2 id="调用方式"><a class="header-anchor" href="#调用方式"></a>调用方式</h2>
<ul>
<li>直接调用</li>
</ul>
<pre><code>foo();
</code></pre>
<ul>
<li>对象方法</li>
</ul>
<pre><code>o.method();
</code></pre>
<ul>
<li>构造器</li>
</ul>
<pre><code>new Foo();
</code></pre>
<ul>
<li>call/apply/bind</li>
</ul>
<pre><code>func.call(o);
</code></pre>
<h2 id="函数属性"><a class="header-anchor" href="#函数属性"></a>函数属性</h2>
<h3 id="arguments属性"><a class="header-anchor" href="#arguments属性"></a>arguments属性</h3>
<p>函数的arguments属性使函数可以处理可变数量的参数。 <strong>arguments</strong> 对象的 <strong>length</strong> 属性包含了传递给函数的参数数目。 <strong>arguments</strong> 对象中包含的各个参数的访问方式与数组元素的访问方式相同。</p>
<pre><code>function ArgTest(arg1, arg2){
   var s = &quot;&quot;;
   s += &quot;The individual arguments are: &quot;
   for (n = 0; n &lt; arguments.length; n++){
      s += ArgTest.arguments[n];
      s += &quot; &quot;;
   }
   return(s);
}
console.log(ArgTest(1, 2, &quot;hello&quot;));
// Output: The individual arguments are: 1 2 hello
</code></pre>
<h3 id="caller属性"><a class="header-anchor" href="#caller属性"></a>caller属性</h3>
<blockquote>
<p>functionName.caller</p>
</blockquote>
<p><em>functionName</em> 对象是任何正在执行的函数的名称。</p>
<p><strong>caller</strong> 属性只有当函数正在执行时才被定义。  如果函数是从 JavaScript 程序的顶层调用的，则 <strong>caller</strong> 包含 <strong>null</strong>。</p>
<p>如果在字符串上下文中使用 <strong>caller</strong> 属性，则其结果和 <em>functionName</em>.<strong>toString</strong> 相同，也就是说，将显示函数的反编译文本。</p>
<p>下面的示例阐释了 <strong>caller</strong> 属性的用法：</p>
<pre><code>function CallLevel(){
   if (CallLevel.caller == null)
      return(&quot;CallLevel was called from the top level.&quot;);
   else
      return(&quot;CallLevel was called by another function.&quot;);
}

console.log(CallLevel());
// Output: CallLevel was called from the top level.
</code></pre>
<h3 id="apply属性-方法"><a class="header-anchor" href="#apply属性-方法"></a>apply属性(方法)</h3>
<blockquote>
<p>调用函数，并用指定对象替换函数的 <strong>this</strong> 值，同时用指定数组替换函数的参数。</p>
<p>apply([thisObj[,argArray]])</p>
<p><code>thisObj</code>：可选。要用作 this 对象的对象。即调用这个函数的对象。</p>
<p><code>argArray</code>：可选。要传递到函数的一组参数。</p>
</blockquote>
<h3 id="call属性-方法"><a class="header-anchor" href="#call属性-方法"></a>call属性(方法)</h3>
<p>apply 后面的参数为数组，而call 为扁平化传参</p>
<pre><code>function foo(x, y) {
    console.log(x, y, this);
}

foo.call(100, 1, 2); //1 2 Number {[[PrimitiveValue]]: 100}
foo.apply(true, [3, 4]); //3 4 Boolean {[[PrimitiveValue]]: true}
foo.apply(null); //undefined undefined Window
foo.apply(undefined); //undefined undefined Window
</code></pre>
<p>传入 null/undefined 时，实际为 Window 对象
在严格模式下：上述代码最后两行分别输出 null, undefined</p>
<h3 id="bind属性-方法"><a class="header-anchor" href="#bind属性-方法"></a>bind属性(方法)</h3>
<ol>
<li>下面的代码演示如何使用 <strong>bind</strong> 方法。</li>
</ol>
<pre><code>// Define the original function.
var checkNumericRange = function (value) {
    if (typeof value !== 'number')
        return false;
    else
        return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;
}

// The range object will become the this value in the callback function.
var range = { minimum: 10, maximum: 20 };

// Bind the checkNumericRange function.
var boundCheckNumericRange = checkNumericRange.bind(range);

// Use the new function to check whether 12 is in the numeric range.
var result = boundCheckNumericRange (12);
document.write(result);
console.log(result);	// true
</code></pre>
<ol>
<li>在下面的示例中，thisArg 对象与包含原始方法的对象不同。</li>
</ol>
<pre><code>// Create an object that contains the original function.
// Offer the range: [50,100]
var originalObject = {
    minimum: 50,
    maximum: 100,
    checkNumericRange: function (value) {
        if (typeof value !== 'number')
            return false;
        else
            return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;
    }
}

// Check whether 10 is in the numeric range.
var result = originalObject.checkNumericRange(10);
console.log(result + &quot; &quot;);
// Output: false

// The range object supplies the range for the bound function.
// Offer the range: [10,20]
var range = { minimum: 10, maximum: 20 };

// Create a new version of the checkNumericRange function that uses range.
var boundObjectWithRange = originalObject.checkNumericRange.bind(range);

// Check whether 10 is in the numeric range.
var result = boundObjectWithRange(10);
console.log(result);
// Output: true
</code></pre>
<p>显然后者更加灵活一点。</p>
<p>再来一个例子：</p>
<pre><code>this.x = 9;
var module = {
    x: 81,
    getX: function() {
        return console.log(this.x);
    }
};

module.getX(); //81
// 函数的调用者为module，函数的this指向module


var getX = module.getX;
getX(); //9
// var getX = module.getX; 将这个方法赋值给一个全局变量，这时 this 指向了 window
// 函数的调用者为window，函数的this指向window

var boundGetX = getX.bind(module);
boundGetX(); //81
// 应用bind,函数的调用者为window，函数的this指向module
</code></pre>
<p>一般情况下，谁调用函数，函数的this就指向谁。</p>
<p><code>bind</code> 主要用于改变函数中的 <code>this</code></p>
<ul>
<li><code>module.getX();</code>直接通过对象调用自己的方法，结果是 81</li>
<li><code>var getX = module.getX;</code> 将这个方法赋值给一个全局变量，这时 this 指向了 window，所以结果为 9</li>
<li><code>var boundGetX = getX.bind(module);</code> 使用 bind 绑定了自己的对象，这样 this 仍然指向 module 对象，所以结果为 81</li>
</ul>
<ol>
<li>以下代码演示如何使用 <em>arg1[,arg2[,argN]]]</em> 参数。绑定函数将 <strong>bind</strong> 方法中指定的参数用作第一个参数和第二个参数。在调用绑定函数时指定的任何参数将用作第三个、第四个参数（依此类推）。</li>
</ol>
<pre><code>// Define the original function with four parameters.
var displayArgs = function (val1, val2, val3, val4) {
    console.log(val1 + &quot; &quot; + val2 + &quot; &quot; + val3 + &quot; &quot; + val4);
}

var emptyObject = {};

// Create a new function that uses the 12 and &quot;a&quot; parameters
// as the first and second parameters.
var displayArgs2 = displayArgs.bind(emptyObject, 12, &quot;a&quot;);

// Call the new function. The &quot;b&quot; and &quot;c&quot; parameters are used
// as the third and fourth parameters.
displayArgs2(&quot;b&quot;, &quot;c&quot;);
// Output: 12 a b c 
</code></pre>
<h4 id="bind-与-currying"><a class="header-anchor" href="#bind-与-currying"></a>bind 与 currying</h4>
<p>bind 可以使函数柯里化，那么什么是柯里化？</p>
<blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回 <strong>接受</strong>余下的参数且<strong>返回</strong>结果的新函数 的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>
</blockquote>
<pre><code>function add(a, b, c) {
    return a + b + c;
}

var func = add.bind(undefined, 100);
func(1, 2); //103

var func2 = func.bind(undefined, 200);
func2(10); //310
</code></pre>
<p>add 函数拥有 3 个参数。我们想先传入一个参数，再去传其他参数。</p>
<p><code>var func = add.bind(undefined, 100);</code>add 函数对象调用 bind 方法，由于不需要将 this 指向原来的 add 函数对象，所以第一个参数写为 undefined 或 null。第二个参数 100 传给了 add 函数中的形参 a，并赋值给一个新的函数对象 func。</p>
<p>这时，<code>func(1, 2)</code> 即相当于传入后两个参数，所以结果为 103。</p>
<p>同理，基于 func 可以创造一个函数 func2。它只用传最后一个参数。</p>
<h4 id="bind-与-new"><a class="header-anchor" href="#bind-与-new"></a>bind 与 new</h4>
<pre><code>function foo() {
    this.b = 100;
    return this.a;
}

console.log(foo()); //undefined

var func = foo.bind({
    a: 1
});

console.log(func()); //1
console.log(new func()); //foo {b: 100}
</code></pre>
<p>对于使用了 <code>new func()</code> 这种方式创建对象，其返回值<code>应为一个对象。</code></p>
<p>而原函数 foo 的返回值不是对象，所以会直接忽视这个 return 方法。而是变为 <code>return this;</code>。并且 this 会被初始化为一个空对象，这个空对象的原型指向 foo.prototype。所以后面的 bind 是不起作用的。</p>
<p>这里面这个 this 对象包含一个属性 <code>b = 100</code>。所以返回的是对象 <code>{b: 100}</code>。</p>
<p>mdn有提到，bind不要和构造函数一起用，各浏览器可能结果不一样。mdn建议不要这样用。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 函数属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[let和const回顾]]></title>
      <url>https://alexzhong22c.github.io/2016/11/09/let-n-const/</url>
      <content type="html"><![CDATA[<p>简单来说是： let是修复了var的作用域的一些bug，变的更加好用。let是更好的var。var的作用于是函数作用于，而let是块级别（大括号括起来的内容）
const声明的变量只可以在声明时赋值，它被设计的本意就是不可随意修改，这是最大的特点。</p>
<a id="more"></a>
<h2 id="let"><a class="header-anchor" href="#let"></a>let</h2>
<p><code>let</code>与<code>var</code>一样，也可以用来声明变量，但它有着更好的作用域规则。</p>
<p><code>let</code>与<code>var</code>还是有不同之处的，所以如果你只是在代码中将<code>var</code>全局搜索替换为<code>let</code>，一些依赖<code>var</code>声明的独特特性（可能你不是故意这样写）的代码可能无法正常运行。但对于绝大多数代码来说，在ES6的新代码模式下，你应该停止使用<code>var</code>声明变量，能使用<code>let</code>就用吧！</p>
<p>这一规则可以帮助你捕捉bug，除了<code>NaN</code>错误以外，每一个异常都会在当前行抛出。</p>
<ul>
<li><strong>let声明的变量拥有块级作用域。</strong> 也就是说用<code>let</code>声明的变量的作用域只是外层块，而不是整个外层函数。</li>
<li><strong>let声明的全局变量不是全局对象的属性。</strong> 这就意味着，你不可 以通过<code>window.变量名</code>的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。</li>
<li><strong>形如for (let x…)的循环在每次迭代时都为x创建新的绑定。</strong></li>
</ul>
<p>可以看一个<strong>循环内变量过度共享</strong>的例子：</p>
<pre><code>var messages = [&quot;喵！&quot;, &quot;我是一只会说话的猫！&quot;, &quot;回调（callback）非常有趣!&quot;];
for (var i = 0; i &lt; messages.length; i++) {
	setTimeout(function () {
		cat.say(messages[i]);
	}, i * 1500);
}
</code></pre>
<p>这只会说话的猫并没有按照预期连说三条消息，它说了三次“undefined”。</p>
<p>事实上，这个问题的答案是，循环本身及三次timeout回调均共享唯一的变量<em>i</em>。当循环结束执行时，<em>i</em>的值为3（因为<code>messages.length</code>的值为3），此时回调尚未被触发。</p>
<p>所以当第一个timeout执行时，调用<code>cat.say(messages[i])</code>，此时i的值为3，所以猫咪最终打印出来的是<code>messages[3]</code>的值亦即<code>undefined</code>。</p>
<p>如果一个<code>for (let...)</code>循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。</p>
<p>所以在会说话的猫示例中，也可以通过将<code>var</code>替换为<code>let</code>修复bug。</p>
<p>这种情况适用于现有的三种循环方式：<code>for-of</code>、<code>for-in</code>、以及传统的用分号分隔的类C循环。</p>
<ul>
<li><strong>let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误</strong> 。举个例子：</li>
</ul>
<pre><code>  function update() {
  	console.log(&quot;当前时间:&quot;, t);  // 引用错误（ReferenceError）
  	...
  	let t = readTachymeter();
  }
</code></pre>
<p>不可访问的这段时间变量一直处于作用域中，但是尚未装载，它们位于<em>临时死区（Temporal Dead Zone，简称TDZ</em>）中。我一直想用科幻小说来类比这个脑洞大开的行话，但是还没想好怎么搞。</p>
<p>（脆弱的性能细节：在大多数情况下，查看代码就可以区分声明是否已经执行，所以事实上，JavaScript引擎不需要在每次代码运行时都额外执行 一次变量可访问检查来确保变量已经被初始化。然而在闭包内部有时不是透明的，这时JavaScript引擎将会做一个运行时检查，也就意味着<code>let</code>相对<code>var</code>而言比较慢。）</p>
<p>（脆弱的平行宇宙作用域细节：在一些编程语言中，一个变量的作用域始于声明之处，而非前后覆盖整个封闭代码块。标准委员会曾考虑过将这种作用域准则赋予<code>let</code>关键词，但是一旦使用这种准则，原本提前使用变量的语句会导致引用错误（ReferenceError），现在该语句不位于<code>let t</code>的声明作用域中，根本不会引用此处的变量<code>t</code>，而是引用外层作用域的相应变量。但是这个方法无法与闭包和函数提升很好得结合，所以该提案最终被否决了。）</p>
<ul>
<li><strong>用let重定义变量会抛出一个语法错误（SyntaxError）。</strong></li>
</ul>
<p>这一条规则也可以帮助你检测琐碎的小问题。诚然，这亦是<code>var</code>与<code>let</code>的不同之处，当你全局搜索<code>var</code>替换为<code>let</code>时也会导致<code>let</code>重定义语法错误，因为这一规则对全局<code>let</code>变量也有效。</p>
<p>如果你的多个脚本中都声明了相同的全局变量，你最好继续用<code>var</code>声明这些变量。如果你换用了<code>let</code>，后加载的脚本都会执行失败并抛出错误。</p>
<p>或者你可以考虑使用ES6内建的模块机制，后面的文章中会详细讲解。</p>
<p>（脆弱的语法细节：<code>let</code>是一个严格模式下的保留词。在非严格模式下，出于向后兼容的目的，你仍可以用<code>let</code>命名来声明变量、函数和参数，虽然你不会犯傻，但是你确实可以编写<code>var let = 'q';</code>这样的代码！不过<code>let let;</code>无论如何都是非法的。）</p>
<p>在那些不同之外，<code>let</code>和<code>var</code>几乎很相似了。举个例子，它们都支持使用逗号分隔声明多重变量，它们也都支持<a href="http://www.infoq.com/cn/articles/es6-in-depth-destructuring" target="_blank" rel="external">解构</a>特性。</p>
<p>注意，<code>class</code>类声明的行为与<code>var</code>不同而与<code>let</code>一致。如果你加载一段包含同名类的脚本，后定义的类会抛出重定义错误。</p>
<h2 id="const"><a class="header-anchor" href="#const"></a>const</h2>
<p>是的，还有一个新的关键词！</p>
<p>ES6引入的第三个声明类关键词与<code>let</code>类似：<code>const</code>。</p>
<p><code>const</code>声明的变量与<code>let</code>声明的变量类似，它们的不同之处在于，<code>const</code>声明的变量只可以在声明时赋值，不可随意修改，否则会导致<code>SyntaxError</code>（语法错误）。</p>
<pre><code>const MAX_CAT_SIZE_KG = 3000; // 正确

MAX_CAT_SIZE_KG = 5000; // 语法错误（SyntaxError）
MAX_CAT_SIZE_KG++; // 虽然换了一种方式，但仍然会导致语法错误
</code></pre>
<p>当然，规范设计的足够明智，用<code>const</code>声明变量后必须要赋值，否则也抛出语法错误。</p>
<pre><code>const theFairest;  // 依然是语法错误，你这个倒霉蛋
</code></pre>
<h2 id="现在可以使用let和const了么？"><a class="header-anchor" href="#现在可以使用let和const了么？"></a>现在可以使用let和const了么？</h2>
<p>是的。如果要在web上使用<code>let</code>和<code>const</code>特性，你需要使用一个诸如<a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>、<a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a>或<a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>的ES6转译器。（Babel和Traceur暂不支持临时死区特性。）</p>
<p>io.js支持<code>let</code>和<code>const</code>，但是只在严格模式下编码可以使用。Node.js同样支持，但是需要启用<code>--harmony</code>选项</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
