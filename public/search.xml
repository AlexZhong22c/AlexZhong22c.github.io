<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>https://alexzhong22c.github.io/2017/03/11/try-eslint/</url>
      <content type="html"><![CDATA[<p>title: eslint折腾记
date: 2017-03-11 21:50:31
categories: [essay]
tags: [eslint, ]</p>
<p>关于 eslint 这一个简单的工具的使用，本人目前仍在摸索。</p>
<a id="more"></a>
<h2 id="卸载干净"><a class="header-anchor" href="#卸载干净"></a>卸载干净</h2>
<p>在同类型的 jslint 、jshint 、eslint 当中我选择了 eslint 。</p>
<p>为了简单起见，我先从 sublime 的 eslint 插件入手。</p>
<p>一开始我想着对自己要求严格一点，那就用 airbnb 版的 eslint 插件配置吧。</p>
<p>没想到：</p>
<ul>
<li>airbnb 对ES6的使用非常深入，这使得我如果不按照ES6来写的话会遭遇大量的错误，即便把要使用ES6的配置关闭，这个代码校正也让我无法承受</li>
<li>网上不建议初学者直接上手 ES6</li>
<li>最近做一个小项目，我的前端搭档要求 JavaScript 代码要兼容比较老的一些浏览器</li>
<li>用babel 可以将ES6转成ES5，但是最后是在你的工程中配置了babel</li>
</ul>
<p>为了 airbnb 版，我安装了一堆npm插件，大概是卸载干净了。</p>
<p>最终，我只安装了<a href="https://github.com/SublimeLinter/SublimeLinter3" target="_blank" rel="external">SublimeLinter</a>和<a href="https://github.com/roadhump/SublimeLinter-eslint" target="_blank" rel="external">SublimeLinter-contrib-eslint</a> 和cssLint，xxxx。另外的这一篇 <a href="http://www.tuicool.com/articles/faANRvj" target="_blank" rel="external">《在Sublime3中使用ESLint》</a> 也值得一读。</p>
<h2 id="私人配置"><a class="header-anchor" href="#私人配置"></a>私人配置</h2>
<p>我用的是eslintrc.json文件来自定义配置，这样的一个好处是，可以通过</p>
<pre><code>&quot;extends&quot;: &quot;standard&quot;,
</code></pre>
<p>引入 standar 版的 eslint 插件配置，作为我的配置的主题。然后它就像css 一样，写在文件后方的配置可以<strong>覆盖</strong>前方的同名配置，这样就可以私人订制一些个别的修改，经过了一个晚上的奋战，下面这些就是我私人添加的配置，仅供参考：</p>
<pre><code>{
  &quot;extends&quot;: &quot;standard&quot;,					//引入大神的配置作为主体
  &quot;globals&quot;: {
    &quot;$&quot;: true,                                //zepto
    &quot;define&quot;: true,                           //requirejs
    &quot;require&quot;: true                           //requirejs
  },
  &quot;env&quot;: {
    &quot;browser&quot;: true                           //执行环境 浏览器
  },
  &quot;rules&quot;: {
    //官方文档 http://eslint.org/docs/rules/
    &quot;no-unused-vars&quot;: [1, { &quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;none&quot;, &quot;ignoreRestSiblings&quot;: true }],                 //变量定义后未使用
    &quot;quotes&quot;: [1, &quot;single&quot;, { &quot;avoidEscape&quot;: true, &quot;allowTemplateLiterals&quot;: true }],
    // &quot;no-inner-declarations&quot;: [0, &quot;both&quot;],     //不建议在{}代码块内部声明变量或函数
    &quot;no-extra-boolean-cast&quot;: 1,               //多余的感叹号转布尔型
    &quot;no-extra-semi&quot;: 1,                       //多余的分号
    &quot;no-extra-parens&quot;: 1,                     //多余的括号
    &quot;no-empty&quot;: 1,                            //空代码块
    &quot;no-use-before-define&quot;: [1, &quot;nofunc&quot;],    //使用前未定义
    &quot;complexity&quot;: [1, 10],                    //圈复杂度大于10 警告
    &quot;no-cond-assign&quot;: [2, &quot;always&quot;],          //条件语句中禁止赋值操作
    &quot;no-native-reassign&quot;: 2,                  //禁止覆盖原生对象

    //代码风格优化
        &quot;operator-linebreak&quot;: [&quot;error&quot;, &quot;before&quot;],
    &quot;no-else-return&quot;: 1,                      //在else代码块中return，else是多余的
    &quot;no-multi-spaces&quot;: 1,                     //不允许多个空格
    &quot;key-spacing&quot;: [1, {&quot;beforeColon&quot;: false, &quot;afterColon&quot;: true}],//object直接量建议写法 : 后一个空格前面不留空格
    &quot;block-scoped-var&quot;: 2,                    //变量应在外部上下文中声明，不应在{}代码块中
    &quot;consistent-return&quot;: 2,                   //函数返回值可能是不同类型

    &quot;no-loop-func&quot;: 2,                        //禁止在循环体中定义函数
    &quot;no-return-assign&quot;: [2, &quot;always&quot;],        //不允return时有赋值操作
    &quot;no-redeclare&quot;: [2, {&quot;builtinGlobals&quot;: true}],//不允许重复声明
    &quot;no-unused-expressions&quot;: [2, {&quot;allowShortCircuit&quot;: true, &quot;allowTernary&quot;: true}],//不执行的表达式
    &quot;no-useless-concat&quot;: 2,                   //无意义的string concat
    &quot;no-void&quot;: 2,                             //禁用void
    &quot;no-with&quot;: 1,                             //禁用with
    &quot;valid-jsdoc&quot;: [2, {&quot;requireParamDescription&quot;: true, &quot;requireReturnDescription&quot;: true}],//jsdoc
    &quot;no-warning-comments&quot;: [2, { &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;any other term&quot;], &quot;location&quot;: &quot;anywhere&quot; }],//标记未写注释
    &quot;curly&quot;: 1                                //if、else、while、for代码块用{}包围
  }
}
</code></pre>
<h2 id="none"><a class="header-anchor" href="#none"></a></h2>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[事件进阶话题]]></title>
      <url>https://alexzhong22c.github.io/2017/03/05/js-event2/</url>
      <content type="html"><![CDATA[<p>此文内容深度其实不大，个人还需要进一步学习。</p>
<a id="more"></a>
<h2 id="常用事件和技巧"><a class="header-anchor" href="#常用事件和技巧"></a>常用事件和技巧</h2>
<p>用户的操作有很多种，所以有很多事件。为了开发方便，浏览器又提供了一些事件，所以有很多很多的事件。这里只介绍几种常用的事件和使用技巧。</p>
<h4 id="load"><a class="header-anchor" href="#load"></a><code>load</code></h4>
<p><code>load</code> 事件在资源加载完成时触发。这个资源可以是图片、CSS 文件、JS 文件、视频、document 和 window 等等。</p>
<p>比较常用的就是监听 window 的 <code>load</code> 事件，当页面内所有资源全部加载完成之后就会触发。比如用 JS 对图片以及其他资源处理，我们在 <code>load</code> 事件中触发，可以保证 JS 不会在资源未加载完成就开始处理资源导致报错。</p>
<p>同样的，也可以监听图片等其他资源加载情况。</p>
<h4 id="beforeunload"><a class="header-anchor" href="#beforeunload"></a><code>beforeunload</code></h4>
<p>当浏览者在页面上的输入框输入一些内容时，未保存、误操作关掉网页可能会导致输入信息丢失。</p>
<p>当浏览者输入信息但未保存时关掉网页，我们就可以开始监听这个事件，例如：</p>
<pre><code>window.addEventListener(&quot;beforeunload&quot;, function( event ) {
    event.returnValue = &quot;放弃当前未保存内容而关闭页面？&quot;;
});
</code></pre>
<p>这时候试图关闭网页的时候，会弹窗阻止操作，点击确认之后才会关闭。当然，如果没有必要，就不要监听，不要以为使用它可以为你留住浏览者。</p>
<h4 id="resize"><a class="header-anchor" href="#resize"></a><code>resize</code></h4>
<p>当节点尺寸发生变化时，触发这个事件。通常用在 window 上，这样可以监听浏览器窗口的变化。通常用在复杂布局和响应式上。</p>
<p>常见的视差滚动效果网站以及同类比较复杂的布局网站，往往使用 JavaScript 来计算尺寸、位置。如果用户调整浏览器大小，尺寸、位置不随着改变则会出现错位情况。在 window 上监听该事件，触发时调用计算尺寸、位置的函数，可以根据浏览器的大小来重新计算。</p>
<p>但需要注意一点，当浏览器发生任意变化都会触发 <code>resize</code> 事件，哪怕是缩小 1px 的浏览器宽度，这样调整浏览器时会触发大量的 <code>resize</code> 事件，你的回调函数就会被大量的执行，导致变卡、崩溃等。</p>
<p>你可以使用函数 throttle 或者 debounce 技巧来进行优化，throttle 方法大体思路就是在某一段时间内无论多次调用，只执行一次函数，到达时间就执行；debounce 方法大体思路就是在某一段时间内等待是否还会重复调用，如果不会再调用，就执行函数，如果还有重复调用，则不执行继续等待。关于它们更详细的信息，我后面会介绍一下发表在我的博客上，这里不再赘述。</p>
<h4 id="error"><a class="header-anchor" href="#error"></a><code>error</code></h4>
<p>当我们加载资源失败或者加载成功但是只加载一部分而无法使用时，就会触发 <code>error</code> 事件，我们可以通过监听该事件来提示一个友好的报错或者进行其他处理。比如 JS 资源加载失败，则提示尝试刷新；图片资源加载失败，在图片下面提示图片加载失败等。该事件不会冒泡。因为子节点加载失败，并不意味着父节点加载失败，所以你的处理函数必须精确绑定到目标节点。</p>
<p>需要注意的是，对于该事件，你可以使用 <code>addEventListener</code> 等进行监听，但是有时候会出现失效情况（看<a href="http://jsbin.com/esimAWA/2/quiet" target="_blank" rel="external">这个例子</a>），这是因为 <code>error</code> 事件都触发过了，你的 JS 监听处理代码还没有加载进来执行。为了避免这种情况，用内联法更好一些：</p>
<pre><code>&lt;img src=&quot;not-found.jpg&quot; onerror=&quot;doSomething&quot; /&gt;
</code></pre>
<p>如果还有其他常用事件，欢迎留言补充。</p>
<h2 id="事件回调函数的作用域问题"><a class="header-anchor" href="#事件回调函数的作用域问题"></a>事件回调函数的作用域问题</h2>
<p>与事件绑定在一起的回调函数作用域会有问题，我们来看个例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=utf-8 /&gt;
  &lt;title&gt;Events in JavaScript: Removing event listeners&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button id=&quot;element&quot;&gt;Click Me&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>JavaScript代码：</p>
<pre><code class="language-javascript">var element = document.getElementById('element');

var user = {
 firstname: 'Bob',
 greeting: function(){
   alert('My name is ' + this.firstname);
 }
};

// Attach user.greeting as a callback
element.addEventListener('click', user.greeting);
</code></pre>
<p>回调函数调用的 <code>user.greeting</code> 函数作用域应该是在 <code>user</code> 下的，本期望输出 <code>My name is Bob</code> 结果却输出了 <code>My name is undefined</code>。这是因为事件绑定函数时，该函数会以当前元素为作用域执行。为了证明这一点，我们可以为当前 <code>element</code> 添加属性：</p>
<pre><code>element.firstname = 'jiangshui';
</code></pre>
<p>再次点击，可以正确弹出 <code>My name is jiangshui</code>。那么我们来解决一下这个问题：</p>
<h3 id="使用匿名函数-办法一"><a class="header-anchor" href="#使用匿名函数-办法一"></a>使用匿名函数——办法一</h3>
<p>将JavaScript代码修改为：</p>
<pre><code>var element = document.getElementById('element');

var user = {
 firstname: 'Bob',
 greeting: function(){
   alert('My name is ' + this.firstname);
 }
};

// Call the method with the correct
// context inside an anonymouse function
element.addEventListener('click', function() {
  user.greeting();
});
</code></pre>
<p>包裹之后，虽然匿名函数的作用域被指向事件触发元素，但执行的内容就像直接调用一样，不会影响其作用域。</p>
<h3 id="使用-bind-方法"><a class="header-anchor" href="#使用-bind-方法"></a>使用 bind 方法</h3>
<p>使用匿名函数是有缺陷的，每次调用都包裹进匿名函数里面，增加了冗余代码等，此外如果想使用<code>removeEventListener</code> 解除绑定，还需要再创建一个函数引用。<code>Function</code> 类型提供了 <code>bind</code> 方法，可以为函数绑定作用域，无论函数在哪里调用，都不会改变它的作用域。通过如下语句绑定作用域：</p>
<pre><code>user.greeting = user.greeting.bind(user);
</code></pre>
<p>这样我们就可以直接使用：</p>
<pre><code>element.addEventListener('click', user.greeting);
</code></pre>
<h2 id="ie-浏览器的差异和兼容性问题"><a class="header-anchor" href="#ie-浏览器的差异和兼容性问题"></a>IE 浏览器的差异和兼容性问题</h2>
<p>IE 浏览器就是特立独行，它对于事件的操作与标准有一些差异。不过 IE 浏览器现在也开始慢慢努力改造，让浏览器变得更加标准。</p>
<h3 id="ie-下绑定事件"><a class="header-anchor" href="#ie-下绑定事件"></a>IE 下绑定事件</h3>
<p>在 IE 下面绑定一个事件监听，在 IE9- 无法使用标准的 <code>addEventListener</code> 函数，而是使用自家的 <code>attachEvent</code>，具体用法：</p>
<pre><code>element.attachEvent(&lt;event-name&gt;, &lt;callback&gt;);
</code></pre>
<p>其中 `` 参数需要注意，它需要为事件名称添加 <code>on</code> 前缀，比如有个事件叫 <code>click</code>，标准事件监听函数监听 <code>click</code>，IE 这里需要监听 <code>onclick</code>。</p>
<p>另一个，它没有第三个参数，也就是说它只支持监听在冒泡阶段触发的事件，所以为了统一，在使用标准事件监听函数的时候，第三参数传递 false。</p>
<p>当然，这个方法在 IE9 已经被抛弃，在 IE11 已经被移除了，IE 也在慢慢变好。</p>
<h3 id="ie-中-event-对象需要注意的地方"><a class="header-anchor" href="#ie-中-event-对象需要注意的地方"></a>IE 中 Event 对象需要注意的地方</h3>
<p>IE 中往回调函数中传递的事件对象与标准也有一些差异，你需要使用 <code>window.event</code> 来获取事件对象。所以你通常会写出下面代码来获取事件对象：</p>
<pre><code>event = event || window.event
</code></pre>
<p>此外还有一些事件属性有差别，比如比较常用的 <code>event.target</code> 属性，IE 中没有，而是使用 <code>event.srcElement</code> 来代替。如果你的回调函数需要处理触发事件的节点，那么需要写：</p>
<pre><code>node = event.srcElement || event.target;
</code></pre>
<p>常见的就是这点，更细节的不再多说。在概念学习中，我们没必要为不标准的东西支付学习成本；在实际应用中，类库已经帮我们封装好这些兼容性问题。可喜的是 IE 浏览器现在也开始不断向标准进步。</p>
<p>摘自：<a href="http://yujiangshui.com/javascript-event/#%E4%BA%8B%E4%BB%B6%E8%BF%9B%E9%98%B6%E8%AF%9D%E9%A2%98" target="_blank" rel="external">于江水</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 事件 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[float和绝对定位比较]]></title>
      <url>https://alexzhong22c.github.io/2017/03/04/float-n-absolute/</url>
      <content type="html"><![CDATA[<p>因为float实现的效果和绝对定位比较类似，稍后会对它们进行比较。</p>
<a id="more"></a>
<h2 id="float"><a class="header-anchor" href="#float"></a>float</h2>
<ul>
<li>在浮动一张图片或者其他元素时，是在要求浏览器把它往上方推，直到它碰到父元素的内边界。</li>
<li>浮动非图片元素时，要给它设定宽度。</li>
<li>默认情况下浮动元素的位置一般要受到父元素位置的限制，而且改变浮动元素在html文档中的次序，有可能会影响float的实现效果。</li>
</ul>
<h2 id="position"><a class="header-anchor" href="#position"></a>position</h2>
<ul>
<li>static 静态定位，每个元素都处于常规文档流中</li>
<li>relative 相对的是它原来在文档流中的位置（或者默认位置） 。
<ul>
<li>这个元素原来占据的空间没有动，其他元素也没动。</li>
<li>top right bottom left(可以给top left属性设定负值，把元素向上向左移动)</li>
</ul>
</li>
<li>absolute 绝对定位会把元素彻底从文档流中拿出来，再相对其他元素定位。</li>
<li>fixed 固定定位元素的定位上下文是视口，因此它不会随页面滚动而移动。</li>
</ul>
<h2 id="float和绝对定位比较"><a class="header-anchor" href="#float和绝对定位比较"></a>float和绝对定位比较</h2>
<p>我最常见的一个问题就是在一些布局中不知道用float好还是用绝对定位好，因为他们有一些相似的作用。</p>
<p>float 的诞生本来就是为了让文字环绕图片。</p>
<p><code>position: absolute</code>会导致元素脱离文档流，被定位的元素等于在文档中不占据任何位置，在另一个层呈现，可以设置z-index。PS的图层效果就是position: absolute。</p>
<p>float也会导致元素脱离文档流，但还在文档或容器中占据位置(不会跑到父元素的外面去)，把文档流和其它float元素向左或向右挤，并可能导致换行。图片的文字环绕布局效果就是float：</p>
<pre><code class="language-html">&lt;p&gt;
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
&lt;img src=&quot;/i/eg_cute.gif&quot; /&gt;
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
&lt;/p&gt;
</code></pre>
<p>CSS：</p>
<pre><code class="language-css">img 
{
float:right
}
</code></pre>
<h2 id="left-和-top属性"><a class="header-anchor" href="#left-和-top属性"></a>left 和 top属性</h2>
<p>float和绝对定位可以一起用在同一个元素，但是效果不好。
**left和top等属性应该用于position的定位，**但是我经常见到有些老手也会把它们用到float的元素上，这就很尴尬地滥用了，一般情况下这是因为对基础知识掌握不牢固所导致的。</p>
<h2 id="用到float的三栏布局所带来的启发"><a class="header-anchor" href="#用到float的三栏布局所带来的启发"></a>用到float的三栏布局所带来的启发</h2>
<p>需要说明的是，浮动布局依然遵循常规文档流，所以与绝对定位相比，浮动定位时HTML源文件中元素声明的位置显得格外重要。所以，在用到float实现的三栏布局中，交换左栏和右栏的声明次序会有很大影响，也有方法不用交换各栏的次序也可以实现同样的布局，但是，这就要用到一种比较晦涩的使用负边距值的方法。一般情况下，人们十有八九会选择交换源文件中左中两栏的声明次序。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> float </tag>
            
            <tag> 绝对定位 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[和margin有关的知识]]></title>
      <url>https://alexzhong22c.github.io/2017/03/04/about-margin/</url>
      <content type="html"><![CDATA[<p>总结一下和margin有关的基本知识，属于必须了解的范畴。</p>
<a id="more"></a>
<h2 id="基本知识"><a class="header-anchor" href="#基本知识"></a>基本知识</h2>
<h3 id="外边距的单位"><a class="header-anchor" href="#外边距的单位"></a>外边距的单位</h3>
<ul>
<li>为文本元素设置外边距时通常需要混合使用不同的单位</li>
<li>左右边距使用像素，使文本始终和包含元素边界保持固定间距</li>
<li>上下外边距以em为单位，让段间距随字号变化而响应增大或缩小</li>
</ul>
<h3 id="如果没有设置width属性"><a class="header-anchor" href="#如果没有设置width属性"></a>如果没有设置width属性</h3>
<ul>
<li>如果不设置块级元素的width属性，那么这个属性的默认值是auto,结果会让元素的宽度扩展到与父元素同宽。</li>
</ul>
<ul>
<li>没有宽度(没有设置width)的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边框和外边框，会导致内容宽度减少，减少量等于水平边框、内边框和外边框的和。</li>
</ul>
<h3 id="margin可以写1到4个值"><a class="header-anchor" href="#margin可以写1到4个值"></a>margin可以写1到4个值</h3>
<p>在实际应用中，个人不推荐使用三个值的margin，一是容易记错，二是不容易日后修改，一开始如果写成margin:10px 20px 30px;日后需求改动为上10px，右30px，下30px，左20px，你不得不还是得把这个margin拆开为margin:10px 30px 30px 20px;费力且不讨好，不如一开始就老老实实的写成margin:10px 20px 30px 20px;来的实在，不要为了现在节省俩个字节而让日后再次开发的成本上升。</p>
<h2 id="垂直外边距合并问题"><a class="header-anchor" href="#垂直外边距合并问题"></a>垂直外边距合并问题</h2>
<p>简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。你可以查看W3Shool CSS外边距合并了解这个基本知识。</p>
<p>实际工作中，垂直外边距合并问题常见于<strong>第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距</strong>，而且只在标准浏览器下 (FirfFox、Chrome、Opera、Sarfi)产生问题，IE下反而表现良好。例子可以查看下面代码(IE下表现“正常”，标准浏览器下查看出现“bug”)：</p>
<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
	&lt;head&gt;
        &lt;title&gt;垂直外边距合并&lt;/title&gt;
        &lt;style&gt;
        .top{width:160px; height:50px; background:#ccf;}
        .middle{width:160px; background:#cfc;}
        .middle .firstChild{margin-top:20px;}
        &lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
        &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;middle&quot;&gt;
        &lt;div class=&quot;firstChild&quot;&gt;我其实只是想和我的父元素隔开点距离。&lt;/div&gt;
        &lt;div class=&quot;secondChild&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果按照CSS规范，IE的“良好表现”其实是一个错误的表现，因为IE的hasLayout渲染导致了这个“表现良好”的外观。而其他标准浏览器则会表现出“有问题”的外观。好了，如果你读过了上面W3Shcool的CSS外边距合并的文章后，就很容易讨论这个问题了。这个问题发生的原因是根据规范，一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>
<p>再说了白点就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己 “领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级，假传圣旨，把自己的margin当领导的margin执行。 对于垂直外边距合并的解决方案上面已经解释了，<strong>为父元素例子中的middle元素增加一个border-top或者padding-top即可解决这个问题。</strong></p>
<blockquote>
<p>一般说来这个问题解释到这里，大多数文章就不会再深入下去了，但作为一名实战开发者，最求的是知其然知其所以然，原本使用margin-top就是为了与父元素隔开距离，而按照你这么一个解法，其实是一种“修复”，为了“弥补修复”这个父子垂直外边距合并这个CSS规范“Bug”，而强制在父元素上使用border-top和padding-top，不舒服，也不容易记住，下次再发生这样的情况还是会忘记这条准则，而且在页面设计稿里如果不需要 border-top加个上边框，这么一加反而画蛇添足，为以后修改留下隐患。</p>
<p>为什么一定要用border-top,padding-top去为了这么一个所谓的标准规范而多写这么一行代码呢？答案你可以参考另外一篇文章<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="external">用Margin还是用Padding</a>里找到答案。</p>
</blockquote>
<h2 id="用margin还是用padding"><a class="header-anchor" href="#用margin还是用padding"></a>用Margin还是用Padding</h2>
<h3 id="何时应当使用margin："><a class="header-anchor" href="#何时应当使用margin："></a>何时应当使用margin：</h3>
<p>需要在border外侧添加空白时。</p>
<p>空白处不需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，需要相互抵消时。如15px + 20px的margin，将得到20px的空白。</p>
<h3 id="何时应当时用padding："><a class="header-anchor" href="#何时应当时用padding："></a>何时应当时用padding：</h3>
<p>需要在border内测添加空白时。</p>
<p>空白处需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px + 20px的padding，将得到35px的空白。</p>
<p>个人认为：margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p>
<p>这里我截取了部分另外一篇文章的内容，详细内容请见<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="external">用Margin还是用Padding</a></p>
<hr>
<h2 id="margin在块元素-内联元素中的区别"><a class="header-anchor" href="#margin在块元素-内联元素中的区别"></a>margin在块元素、内联元素中的区别</h2>
<p>HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。</p>
<p>另外有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。</p>
<p>margin在块级元素下，他的性能可以完全体现，上下左右任你设定。且记住块级元素的margin的参照基准是前一个元素即相对于自身之前的元素有margin距离。如果元素是第一个元素，则就是相对于父元素的margin距离（但第一个元素相对于父元素margin-top而父元素又没有设定 padding-top/border-top的话要需要印证上面的垂直外边距合并的知识）</p>
<p>margin也能用于内联元素，这是规范所允许的，但是margin-top和margin-bottom对内联元素（对行）的高度没有影响，并且由于边界效果(margin效果)是透明的，他也没有任何的视觉影响。</p>
<p>这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距，那么你只能使用这三个属性：line- height，fong-size，vertical-align。</p>
<blockquote>
<p>请记住，这个影响内联元素高度的是line-height而不是height，因为内联元素是一行行的，定一个height的话，那这到底是整段inline元素的高呢？还是inline元素一行的高呢？这都说不准，所以统一都给每行定一个高，只能是line-height了。</p>
</blockquote>
<p>margin-top/margin-bottom对内联元素没有多大实际效果，不过margin-left/margin-right还是能够对内联元素产生影响的。应用margin:10px 20px 30px 40px;，左边这个css如果写在inline元素上，他的效果大致是，上下无效果，左边离他相邻元素或者文本距离为40px，右边离他相邻元素或者文本距离为20px。你可以自行尝试一番。</p>
<p>最后在内联元素中还有上文我们提到的非可置换inline元素（non-replaced element），这些个元素img|input|select|textarea|button|label虽然是内联元素，但margin依旧可以影响到他的上下左右！</p>
<p>总结下来margin 属性可以应用于几乎所有的元素，除了表格显示类型（不包括 table-caption, table and inline-table）的元素，而且垂直外边距对非置换内联元素（non-replaced inline element）不起作用。</p>
<hr>
<h2 id="常见的浏览器下margin出现的bug"><a class="header-anchor" href="#常见的浏览器下margin出现的bug"></a>常见的浏览器下margin出现的bug</h2>
<p>林林总总写了那么多，最后总结一些浏览器中常见的margin Bug吧，以后遇到margin下的布局问题可以查看这里找到解决的方案，如果你还发现其他关于浏览器下margin的Bug你可以发表留言，核对采纳后我会及时添加进去，感谢你的分享：</p>
<p>IE6中双边距Bug：</p>
<p>发生场合：当给父元素内第一个浮动元素设置margin-left（元素float:left）或margin-right（元素float:right）时margin加倍。</p>
<p>解决方法：是给浮动元素加上display:inline;CSS属性；或者用padding-left代替margin-left。</p>
<p>原理分析：块级对象默认的display属性值是block，当设置了浮动的同时，还设置了它的外边距就会出现这种情况。也许你会问：“为什么之后的对象和第一个对象之间就不存在双倍边距的Bug”？因为浮动都有其相对应的对象，只有相对于其父对象的浮动对象才会出现这样的问题。第一个对象是相对父对象的，而之后对象是相对第一个对象的，所以之后对象在设置后不会出现问题。为什么display:inline可以解决这个双边距bug，首先是 inline元素或inline-block元素是不存在双边距问题的。然后，float:left等浮动属性可以让inline元素 haslayout，会让inline元素表现得跟inline-block元素的特性一样，支持高宽，垂直margin和padding等，所以div class的所有样式可以用在这个display inline的元素上。</p>
<p>IE6中浮动元素3px间隔Bug：</p>
<p>发生场合：发生在一个元素浮动，然后一个不浮动的元素自然上浮与之靠近会出现的3px的bug。</p>
<p>解决方法：右边元素也一起浮动；或者为右边元素添加IE6 Hack _margin-left:-3px;从而消除3px间距。</p>
<p>原理分析：IE6浏览器缺陷Bug。</p>
<p>IE6/7负margin隐藏Bug：</p>
<p>发生场合：当给一个有hasLayout的父元素内的非hasLayout元素设置负marin时，超出父元素部分不可见。</p>
<p>解决方法：去掉父元素的hasLayout；或者赋hasLayout给子元素,并添加position:relative;</p>
<p>原理分析：iE6/7独有的hasLayout产生问题。</p>
<p>IE6/7下ul/ol标记消失bug：</p>
<p>发生场合：当ul/ol触发了haslayout并且是在ul/ol上写margin-left，前面默认的ul/ol标记会消失。</p>
<p>解决方法：给li设置margin-left，而不是给ul/ol设置margin-left。</p>
<p>原理分析：IE6/7浏览器Bug</p>
<p>IE6/7下margin与absolute元素重叠bug：</p>
<p>发生场合：双栏自适应布局中，左侧元素absolute绝对定位，右侧的margin撑开距离定位。在IE6/7下左侧应用了absolute属性的块级元素与右边的自适应的文字内容重叠。</p>
<p>解决方法：把左侧块级元素更改为内联元素，比如把div更换为span。</p>
<p>原理分析：这是由于IE6/IE7浏览器将inline水平标签元素和block水平的标签元素没有加以区分一视同仁渲染了。属于IE6/7浏览器渲染Bug。</p>
<p>IE6/7/8下auto margin居中bug：</p>
<p>发生场合：给block元素设置margin auto无法居中</p>
<p>解决方法：出现这种bug的原因通常是没有Doctype，然后触发了ie的quirks mode，加上Doctype声明就可以了。</p>
<p>在《打败IE的葵花宝典》里给出的方法是给block元素添加一个width能够解决，但根据本人亲测，加 with此种方法是无效的，如果没有Doctype即使给元素添加width也无法让block元素居中。
原理分析：缺少Doctype声明。</p>
<p>IE8下input[button | submit] 设置margin:auto无法居中</p>
<p>发生场合：ie8下，如果给像button这样的标签（如button input[type=“button”] input[type=“submit”]）设置{ display: block; margin:0 auto; }如果不设置宽度的话无法居中。</p>
<p>解决方法：可以给为input加上宽度</p>
<p>原理分析：IE8浏览器Bug。</p>
<p>IE8百分比padding垂直margin bug：</p>
<p>发生场合：当父元素设置了百分比的padding，子元素有垂直的margin的时候，就好像父元素被设置了margin一样。</p>
<p>解决方法：给父元素加一个overflow:hidden/auto。</p>
<p>原理分析：IE8浏览器Bug</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> margin </tag>
            
            <tag> bug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp的入门和一些简单使用]]></title>
      <url>https://alexzhong22c.github.io/2017/03/02/gulp-usage/</url>
      <content type="html"><![CDATA[<p>总结gulp的入门和一些简单使用，以便于快速上手。</p>
<a id="more"></a>
<p>建议参考 <a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">gulp详细入门教程-一点</a></p>
<p>大概的过程为</p>
<ol>
<li>安装nodejs</li>
<li>安装npm</li>
<li>全局安装gulp</li>
<li>新建package.json文件</li>
<li>本地安装gulp插件</li>
<li>新建gulpfile.js文件</li>
<li>运行gulp</li>
</ol>
<h2 id="某些过程的详细介绍"><a class="header-anchor" href="#某些过程的详细介绍"></a>某些过程的详细介绍</h2>
<h3 id="全局安装gulp"><a class="header-anchor" href="#全局安装gulp"></a>全局安装gulp</h3>
<p>命令行执行<code>npm install gulp -g</code>或者<code>cnpm install gulp -g</code></p>
<p>查看是否正确安装：命令提示符执行<code>gulp -v</code>，出现版本号即为正确安装。</p>
<h3 id="应不应该共用node-modules文件夹"><a class="header-anchor" href="#应不应该共用node-modules文件夹"></a>应不应该共用node_modules文件夹</h3>
<p>共用node_modules有好处也有不便之处。npm的设计之初就不考虑共用node_modules的问题，所以如果硬要多个项目共用同一个node_modules会有许多不便之处。应该为每一个项目创建一个node_modules。</p>
<p>在提交项目的时候在.gitignore文件中设置不提交node_modules文件夹即可。</p>
<p>或者使用</p>
<pre><code>rm -rf node_modules
</code></pre>
<p>PS：不要直接删除本地插件包</p>
<p>删除node_modules文件夹再提交项目，下载项目的时候用<code>npm install</code>就能下载回来在 package.json 中记录的插件。</p>
<h3 id="安装参数-save-dev"><a class="header-anchor" href="#安装参数-save-dev"></a>安装参数–save-dev</h3>
<p>当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下<code>npm install module-name</code>），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（<code>dependencies</code>）。</p>
<p><code>-save</code>和<code>save-dev</code>可以省掉你手动修改package.json文件的步骤。
<code>spm install module-name -save</code> 自动把模块和版本号添加到dependencies部分
<code>spm install module-name -save-dve</code> 自动把模块和版本号添加到devdependencies部分</p>
<p>至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 <code>devDepandencies</code>主要是配置测试框架， 例如jshint、mocha。</p>
<blockquote>
<p>再做一个试验就懂得了区别：删除node_modules目录，然后执行 npm install --production，可以看到，npm只帮我们自动安装package.json中dependencies部分的模块；如果执行npm install ，则package.json中指定的dependencies和devDependencies都会被自动安装进来。</p>
</blockquote>
<h3 id="本地安装gulp插件"><a class="header-anchor" href="#本地安装gulp插件"></a>本地安装gulp插件</h3>
<pre><code>npm install gulp --save-dev
</code></pre>
<p>全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用</p>
<h3 id="安装组件"><a class="header-anchor" href="#安装组件"></a>安装组件</h3>
<p><a href="http://www.dbpoo.com/getting-started-with-gulp/" target="_blank" rel="external">Gulp安装及配合组件构建前端开发一体化</a></p>
<h4 id="gulp-jshint"><a class="header-anchor" href="#gulp-jshint"></a>gulp-jshint</h4>
<p><a href="https://www.npmjs.com/package/gulp-jshint" target="_blank" rel="external">gulp-jshint</a></p>
<p>如果无法在文件夹创建<code>.jshintrc</code>文件的话，就去网上别人的工程里面下载一个：<a href="https://github.com/fex-team/GMU" target="_blank" rel="external">GMU-github</a></p>
<hr>
<p>入门和进阶视频教程：</p>
<p><a href="https://ninghao.net/video/2003" target="_blank" rel="external">ninghao.net</a></p>
<p>一些比较细致介绍和问题的解决：</p>
<p><a href="http://web.jobbole.com/86025/" target="_blank" rel="external">gulp使用小结(一)</a></p>
<p>[<a href="http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/" target="_blank" rel="external">Gulp探究折腾之路(I)</a>](<a href="http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/" target="_blank" rel="external">http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/</a>)</p>
]]></content>
      
        <categories>
            
            <category> gulp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[桌面端和移动端图标的引入]]></title>
      <url>https://alexzhong22c.github.io/2017/02/27/icon-usage/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://bitsofco.de/all-about-favicons-and-touch-icons/" target="_blank" rel="external">All About Favicons-bitsofcode</a> ：</p>
</blockquote>
<p>这星期我决定找到一些合适的方式来使用网站的favicon（另外还包括移动端的touch icon）。我想总结一下我自己的观点并且通过简明的语言来表述清楚：</p>
<a id="more"></a>
<h2 id="一些基础的知识"><a class="header-anchor" href="#一些基础的知识"></a>一些基础的知识</h2>
<p>favicon 是浏览器展示web网页时用到的一种图片。最典型的就是16x16像素大小，不过现在通常需要更多更大的尺寸以供不同的用途使用：</p>
<ul>
<li>地址栏</li>
<li>链接栏</li>
<li>书签</li>
<li>标签</li>
<li>桌面图标</li>
</ul>
<p>如果没有指明favicon的位置，所有主流的浏览器（甚至包括IE5时代的浏览器）都会默认去网站根目录找一个叫&quot;favicon.ico&quot;的文件。从技术层面来讲，这意味着我们不需要用作任何声明就能在网站中使用图标。</p>
<p>然而，这种情况下图标的格式需要受到限制。另外还不支持带透明的图标，这并不是一个最优的办法。因为现在我们能使用更多格式的图标：<a href="http://caniuse.com/#feat=link-icon-png" target="_blank" rel="external">png</a>, gif, jpeg，在某些情况下还有<a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="external">svg</a> 。</p>
<h2 id="favicon声明和link标签"><a class="header-anchor" href="#favicon声明和link标签"></a>favicon声明和link标签</h2>
<p>你可以用link标签设置你喜欢的图标：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;&quot; type=&quot;&quot; sizes=&quot;&quot; href=&quot;&quot;&gt;  
</code></pre>
<h3 id="rel属性"><a class="header-anchor" href="#rel属性"></a>rel属性</h3>
<p>用于声明链接目标和html文档的关系。通常用来引入css样式表。如果是图标，比较官方的写法应该是：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;icon&quot;&gt;
</code></pre>
<p>曾经你可能见过这种写法：</p>
<pre><code class="language-JavaScript"> &lt;link rel=&quot;shortcut icon&quot;&gt;
</code></pre>
<p>这是因为某些老浏览器（IE8或者更早）需要这么写，否则浏览器会忽略这整个link标签。因此，即便<code>rel=&quot;shortcut icon&quot;</code>不在HTML5标准里面，它依然在现代浏览器中有效。然而后面我们会讲到，在实际中你可能只需要使用<code>&lt;link rel=&quot;icon&quot;&gt;</code> 这一种写法即可。</p>
<h3 id="type属性"><a class="header-anchor" href="#type属性"></a>type属性</h3>
<p>用来	指定链接目标的<a href="http://www.iana.org/assignments/media-types/media-types.xhtml#image" target="_blank" rel="external">MIME type format</a>。比如，指定一个图标文件是<code>image/x-icon</code> 类型还一个png文件 <code>image/png</code>。</p>
<p>根据W3C，指定type类型仅仅只是一个建议。但除此之外，IE9和IE10需要指定type属性。在这些版本的浏览器里面，虽然不必指定<code>rel=&quot;shortcut icon&quot;</code>，作为替代，它们需要指定媒体文件的type为 <code>image/x-icon</code> 。</p>
<p>幸运的是，IE11和其他现代浏览器不需要指定媒体文件的type。</p>
<h3 id="sizes属性"><a class="header-anchor" href="#sizes属性"></a>sizes属性</h3>
<p>用于声明特定被链接的文件的大小，不同大小用于不同用途。你能为每种用途提供各自最优的文件。这对使用png图片的情景尤为重要，因为png是不能拓展的。这是一张很好的<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="external">备忘单</a>,它会告诉你应该使用的文件的大小和用途。</p>
<h3 id="href属性"><a class="header-anchor" href="#href属性"></a>href属性</h3>
<p>不必多说，这是用来指定图标的位置和地址的。</p>
<h2 id="做个小结"><a class="header-anchor" href="#做个小结"></a>做个小结</h2>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Link “rel”/ “type”</th>
<th>Accepted Formats</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE 8 and below</td>
<td>link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 9, IE 10</td>
<td>link rel=”icon” type=”image/x-icon” or link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 11</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Chrome</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Firefox</td>
<td>link rel=”icon”</td>
<td>ico, png, gif, <a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="external">svg*</a></td>
</tr>
<tr>
<td>Safari</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Opera</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
</tbody>
</table>
<p>看上去，最好的方案应该是声明两个版本，用现代浏览器的方法引用png，IE8的方法引用ico文件。</p>
<p>然而，如果ico和png同时被引用，现代浏览器会不论标签顺序的先后，只选择ico。这意味着，如果我们要兼容老浏览器，现代浏览器可能会被提供一个错误的图片文件的格式。</p>
<h3 id="当只引入ico时"><a class="header-anchor" href="#当只引入ico时"></a>当只引入ico时</h3>
<pre><code class="language-html">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
</code></pre>
<h3 id="当需要引入ico和png"><a class="header-anchor" href="#当需要引入ico和png"></a>当需要引入ico和png</h3>
<p>最佳的方案应该是<strong>只声明引入png，让老浏览器使用默认的方式引入ico</strong>，这样最稳妥。(但实际上，把ico文件放在根目录时，某些现代浏览器可能并不会引入它)</p>
<pre><code class="language-JavaScript">&lt;!-- For IE 10 and below --&gt;  
&lt;!--  No link, just place a file called favicon.ico in the root directory --&gt;

&lt;!-- For IE 11, Chrome, Firefox, Safari, Opera --&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-16.png&quot; sizes=&quot;16x16&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-32.png&quot; sizes=&quot;32x32&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-48.png&quot; sizes=&quot;48x48&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-62.png&quot; sizes=&quot;62x62&quot; type=&quot;image/png&quot;&gt;  
</code></pre>
<h2 id="移动设备的touch-icon"><a class="header-anchor" href="#移动设备的touch-icon"></a>移动设备的touch Icon</h2>
<p>一些移动设备允许用户自定义浏览器主页书签。像原生app图标一样，在这种情景下，我们应该提供专门的图标。</p>
<p>怎么指定这个图标由浏览器/移动设备决定：</p>
<table>
<thead>
<tr>
<th>Device / Browser</th>
<th>Link “rel”</th>
<th>Sizes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apple / Safari</td>
<td>link rel=”apple-touch-icon” or link rel=”apple-touch-icon-precomposed”</td>
<td>76x76 - iPad 2 and iPad mini ;120x120 - iPhone 4s, 5, 6 ;152x152 - iPad (retina) ;180x180 - iPhone 6 Plus</td>
</tr>
<tr>
<td>Apple / Opera Coast</td>
<td>link rel=”icon” (<a href="https://dev.opera.com/articles/opera-coast/" target="_blank" rel="external">Will also accept Safari and Windows formats</a>)</td>
<td>228x228</td>
</tr>
<tr>
<td>Android / Chrome</td>
<td>link rel=”icon” (<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="external">Will, for a limited time, also accept Safari format</a>)</td>
<td>192x192</td>
</tr>
</tbody>
</table>
<p>对于Windows，这些图标应该用meta标签指定。</p>
<p>For Windows 8 / IE 10 -</p>
<pre><code class="language-html">&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;pinned-tile.png&quot;&gt;  
&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#009900&quot;&gt;  
</code></pre>
<p>For Windows 8.1 / IE 11 -</p>
<pre><code class="language-html">&lt;!-- In &lt;head&gt; --&gt;  
&lt;meta name=&quot;msapplication-config&quot; content=&quot;ieconfig.xml&quot; /&gt;

&lt;!--  In ieconfig.xml --&gt;  
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;browserconfig&gt;  
  &lt;msapplication&gt;
    &lt;tile&gt;
      &lt;square70x70logo src=&quot;images/smalltile.png&quot;/&gt;
      &lt;square150x150logo src=&quot;images/mediumtile.png&quot;/&gt;
      &lt;wide310x150logo src=&quot;images/widetile.png&quot;/&gt;
      &lt;square310x310logo src=&quot;images/largetile.png&quot;/&gt;
      &lt;TileColor&gt;#009900&lt;/TileColor&gt;
    &lt;/tile&gt;
  &lt;/msapplication&gt;
&lt;/browserconfig&gt;  
</code></pre>
<p>就是这样，用到 favicon的地方还挺多的。如果是一个很基础的网站，我可能只会使用ico图标	。期待 SVG favicon 时代的到来。</p>
<p>另可参考：<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="external">https://github.com/audreyr/favicon-cheat-sheet</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图标 </tag>
            
            <tag> meta标签 </tag>
            
            <tag> link标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yelee主题改bug总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/22/my-hexo-theme/</url>
      <content type="html"><![CDATA[<p>从找一个喜欢的hexo主题到修改好bug发布到博客上面，整个过程花了我不少时间，下面是对这个改bug过程中发现的小问题做的总结。</p>
<p>此文无图。</p>
<a id="more"></a>
<p>一开始我是在知乎上面找好看的主题，找了很长一段时间才找到一个我比较喜欢的主题，并且挑选了一个已经被大神们优化得不错的主题来借鉴借鉴。</p>
<p>我的hexo主题其实就是直接Fork了<a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="external">ngudream</a>的主题，只不过该大神日常比较忙碌，我自己琢磨了一下代码，把一些报错的小bug给修复了，暂时还没有为这个主题添加什么特殊的功能。（原因是这个主题在各位大神的努力下，功能已经非常齐全炫酷了。）</p>
<p>直接参考ngudream的这篇文章就可以了，在此在此表示一万个感谢：</p>
<p><a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="external">http://ngudream.com/2017/01/24/n-hexo-blog/</a></p>
<p>在这个过程中我发现了一些小问题：</p>
<h2 id="左右搜索栏"><a class="header-anchor" href="#左右搜索栏"></a>左右搜索栏</h2>
<p>一定要先根据这个来安装插件：</p>
<p><a href="http://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="external">Yilia主题添加本地站内搜索-高明飞</a></p>
<h3 id="找不到content-json"><a class="header-anchor" href="#找不到content-json"></a>找不到content.json</h3>
<ul>
<li>这是因为左下角搜索栏找不到content.json</li>
</ul>
<ul>
<li>将<code>yelee\source</code>文件夹下的search文件夹剪切到 根目录的source文件夹里面</li>
<li>生成一次页面</li>
<li>再把刚刚的search文件夹剪切回<code>yelee\source</code>文件夹下即可</li>
</ul>
<h3 id="cb-search-json-404-not-found"><a class="header-anchor" href="#cb-search-json-404-not-found"></a>cb-search.json 404 (Not Found)</h3>
<ul>
<li>是因为没有安装右下角搜索栏插件</li>
</ul>
<ul>
<li>如果安装插件之后语法报错，就把别人项目的文件代码复制过来就行了，省得去检查语法</li>
</ul>
<h3 id="百度分享因为混合内容报错"><a class="header-anchor" href="#百度分享因为混合内容报错"></a>百度分享因为混合内容报错</h3>
<p>如果因为混合内容报错（即https网站引用了http的资源），你可以将百度分享的地址改为：<code>https://github.com/hrwhisper/baiduShare</code>；本来我想把static文件夹放在外面一点的，但是有bug，我现在只是做到不报错而已，具体的百度分享内容都没弄</p>
<h3 id="百度站长要重新配置"><a class="header-anchor" href="#百度站长要重新配置"></a>百度站长要重新配置</h3>
<ul>
<li>查阅相关资料，依照资料放baidu_verify_QshFoK3ZRz.html在yelee的source文件夹下通过站长验证，放googleeff62ed1566e185e.html也是同理。</li>
</ul>
<p>百度sitemap要另外安装：</p>
<pre><code>npm install hexo-generator-baidu-sitemap --save 
</code></pre>
<ul>
<li>如果想要给谷歌提交网站，只需要在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Search Console</a>验证网站，并提交站点地图就可以了。谷歌真的好简单啊！谷歌的<code>sitemap.xml</code>不需要写到配置文件中，自动生效。
<ul>
<li>有个问题是，Github禁止百度爬虫，所以提交的sitemap迟早会显示失败，成功几率非常小</li>
</ul>
</li>
</ul>
<h2 id="温馨提示"><a class="header-anchor" href="#温馨提示"></a>温馨提示</h2>
<ul>
<li>多说也是会因为混合内容而报错，但是我只能改良，不能彻底解决这个问题
<ul>
<li>将多说的<code>embed.js</code>本地化，	将这个文件的地址改动到<code>duoshuo.ejs</code>和<code>click2show.ejs</code>和layout的<code>after-footer.ejs</code>文件里面，但是依然报错</li>
<li>见到http就给它加s</li>
</ul>
</li>
<li>在Markdown文章头部的标注信息的冒号后面要加一个空格，这是语法要求</li>
</ul>
<ul>
<li>在hexo s调试下，百度站长push报错属于正常现象</li>
<li>在hexo s调试下，文章导航的特效会失灵，属于正常现象</li>
</ul>
<ul>
<li>发现大神每篇文章文件的名字都是英文，Markdown里面的标题才是中英随意的，不然isPost()函数会出错
<ul>
<li>用cmd创文件名的时候英文全小写，空格用-表示，为了风格统一</li>
</ul>
</li>
<li>插件这种东西最好不要复制，所以<strong>在重新搭建博客的时候</strong>我没有直接复制node_modules文件夹，这也容易令人忽略了大神自己在这个文件夹下改良的index.js和search.ejs文件</li>
</ul>
<h2 id="请不要fork我的主题"><a class="header-anchor" href="#请不要fork我的主题"></a>请不要Fork我的主题</h2>
<p>去Fork大神ngudream的主题就可以了，因为我的个人改动比较私人化，所以Fork之后别人可能会看不懂。另外我的主题作了几个不好的改动：</p>
<ul>
<li>为了避免报错，一开始我把一些if语句的判断条件直接改为false，原本它们的判断条件是xxx.on的</li>
</ul>
<ul>
<li>还有一个feed属性没研究，应该是订阅博客的功能，好像也被我粗暴地关了</li>
<li>报错<code>Cannot GET /plugins/css/special.css</code>，我直接把“字往下掉”动画关掉</li>
<li>然后就是折腾在显示主页时标签栏出现的undefined，一开始我不知道那个把三项文字的标签转为二项的js文件，所以一直研究ejs代码都没弄好。后来我直接给主页加一个英文名字blog就算了。总算不出现undefined</li>
<li>乱关乱开了一下博文最下方的分享栏，不知道会不会出问题，这个模块应该是百度分享</li>
<li>点击微信之后，那个左右滑动的栏目我暂时改不了代码，本来我想去掉qq的，但是只好把qq的二维码弄上
<ul>
<li>还有就是去掉qq之后，点击微信，上面那个圆形地方就没有图案显示</li>
</ul>
</li>
<li>发现search-result-list模块的文字被顶到后面
<ul>
<li>把.col-3的CSS的marginbottom改为4px就行了</li>
</ul>
</li>
</ul>
<h3 id="我没有完善的内容"><a class="header-anchor" href="#我没有完善的内容"></a>我没有完善的内容</h3>
<ul>
<li>代码压缩没搞</li>
<li>公益404没搞</li>
<li>右下角搜索栏搞了，但是利用的不是打分排名</li>
<li>谷歌分析到现在也不会，所以先不用，应该和百度站长是差不多的，没心思搞</li>
<li>好像就只有360浏览器看不到emoji表情，所以即便安装了插件，文章尽量不要用emoji</li>
</ul>
<h2 id="整个过程的心得"><a class="header-anchor" href="#整个过程的心得"></a>整个过程的心得</h2>
<ul>
<li>在这过程中学会了用HTML-beautify来美化sublime中的html代码排版</li>
<li>对ejs的代码写法有所了解</li>
<li>明白了代码中的partial是干嘛的：复用模板</li>
<li>第一次发现一些私人的代码改动都是写在<code>after-footer.ejs</code>里面</li>
<li>发现dos的报错信息还是有点用的</li>
<li>令我困惑的是填yml文件中的url项，后来发现用来填绑定的域名，域名要自己出钱买</li>
<li>一开始遇到<code>Cannot read property 'on' of undefined</code>不会调，后来发现是yml文件填得不好，可能是不符合语法，导致错误。再比如yml文件中代码没有在适当的地方空空格。</li>
<li>如果在网上打开js文件发现中文变乱码，在谷歌浏览器打开查看就可以了，这是最不消耗脑力的办法</li>
</ul>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> yelee </tag>
            
            <tag> theme </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建hexo博客个人总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/22/my-hexo-blog/</url>
      <content type="html"><![CDATA[<p>因为大神们在这个方面的文献已经很多了，所以我觉得我没有必要再写一个教程了。关于教程，可以推荐<a href="http://blog.csdn.net/itjia_0203/article/details/52504837" target="_blank" rel="external">sylujia的hexo搭建教程</a>来看看，写得很详细而且思路也很好，但是我记得这个教程有一两点步骤不太妥当，如果完全按照教程来搞会报错，但如果自身有一点基本知识的话，这点问题真的算不上是问题。</p>
<a id="more"></a>
<p>我是按照<a href="http://blog.csdn.net/itjia_0203/article/details/52504837" target="_blank" rel="external">sylujia的hexo搭建教程</a>来搭建的，发现这个教程有几个不周全的地方。</p>
<h2 id="这个教程的不周全之处"><a class="header-anchor" href="#这个教程的不周全之处"></a>这个教程的不周全之处</h2>
<h3 id="不周之处一"><a class="header-anchor" href="#不周之处一"></a>不周之处一</h3>
<p>没有直接介绍如何在github仓库创建hexo分支，这个部分可以参考这段代码：</p>
<pre><code>1.  在github上创建仓库，仓库名为your-user-name.github.io
2.  本地创建两个分支：master 与 hexo：
先让gitbash去到your-user-name.github.io文件夹，再输入以下命令
    touch README.md
    git init
    git add README.md
    git commit -m &quot;first commit&quot;
    git remote add origin https://github.com/your-user-name/your-user-name.github.io.git
    git push -u origin master

    在本地新建一个分支： 
        git branch hexo
    切换到你的新分支: 
        git checkout hexo
    将新分支发布在github上： 
        git push origin hexo
    至此分支创建完毕
3.  在github网站上的仓库设置hexo为默认分支
</code></pre>
<p>对于这段代码的解释可以参考原文<a href="http://www.cnblogs.com/ld1024/p/5913169.html" target="_blank" rel="external">冷星1024的hexo搭建教程</a> 。这一步应该在git与github建立联系之后，在安装hexo之前完成。</p>
<h3 id="不周之处二"><a class="header-anchor" href="#不周之处二"></a>不周之处二</h3>
<p>看到这一步：</p>
<p>在项目文件夹下执行以下命令：</p>
<pre><code>$ git init #初始化为一个git目录
$ git remote add origin git@github.com:sylujia/sylujia.github.io.git #使用你自己的地址关联
$ git pull #pull一下你的远端库
</code></pre>
<p>执行之后命令行的位置应该是<strong>不在</strong>hexo分支下的，如果按照教程继续执行<code>$ git checkout hexo</code>应该会面临失败，而用<code>git clean -d -fx &quot;&quot;</code>来解决问题会删掉本地的文件这也是万万不可的。</p>
<p>比较合适的一个做法应该是改进它的下一步为：</p>
<pre><code>$ git add . #添加所有文件到暂存区
$ git commit -m &quot;提交信息&quot;     #提交到本地仓库
$ git push -f origin hexo  #把本地库强制push到远端库的hexo分支
</code></pre>
<p>接着往下做就行了，一直到教程的<strong>优化与部署</strong>环节。不建议小白看<strong>优化与部署</strong>及之后的内容，只不过是把之前的内容重新过一遍而已，最后那段内容甚至可能涉及抄袭，有点敷衍，不看就行了。</p>
<h2 id="原始文件和部署文件分离"><a class="header-anchor" href="#原始文件和部署文件分离"></a>原始文件和部署文件分离</h2>
<p>选用这个教程的好处就是为了在搭建之后能很方便地备份和还原博客。其原理就是将原始文件和部署文件分离上传到仓库。这是这个教程没有明确说明的一个点。</p>
<p>在搭建好hexo博客之后，应该要按照以下过程管理博客：</p>
<h3 id="日常修改"><a class="header-anchor" href="#日常修改"></a>日常修改</h3>
<p>在本地对博客进行修改(添加新博文、修改样式等等)后，</p>
<p>1. 先执行hexo clean(这是为了减少上传的原始文件的大小，也可以忽略这步，那么速度也会快一点点)</p>
<p>2.依次执行</p>
<pre><code>git add .
git commit -m &quot;...&quot;
git push origin hexo
</code></pre>
<p>指令将改动 推送到github(此时当前分支应为hexo)</p>
<p>3. 执行<code>hexo g -d</code>发布网站到master分支上。</p>
<h3 id="如果本地资料丢失-之前所做的备份就能实现还原"><a class="header-anchor" href="#如果本地资料丢失-之前所做的备份就能实现还原"></a>如果本地资料丢失，之前所做的备份就能实现还原</h3>
<p>重装电脑或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<pre><code>使用
git clone git@github.com:sylujia/sylujia.github.io.git
拷贝仓库（默认分支为hexo）
在本地新拷贝的sylujia.github.io文件夹下通过Git bash依次执行下列指令：
npm install hexo、npm install、npm install hexo-deployer-git
（注意：不需要hexo init这条指令）
</code></pre>
<h2 id="理解过程和解决bug可能会用到的知识点"><a class="header-anchor" href="#理解过程和解决bug可能会用到的知识点"></a>理解过程和解决bug可能会用到的知识点</h2>
<h3 id="git与github区别"><a class="header-anchor" href="#git与github区别"></a>Git与GitHub区别</h3>
<p>理解Git与GitHub是两个不同的概念，这有利于理解搭建hexo博客的过程，万一报错了自己也能解决。</p>
<p>git是一个<a href="http://lib.csdn.net/base/git" target="_blank" rel="external">版本控制</a>的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。自行进一步理解git能够对搭建hexo博客的过程有理性的认识。</p>
<p>关于git的一些基本操作的含义可以看这里：<a href="http://blog.csdn.net/mchdba/article/details/12083965?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">个人常用命令add,commit以及push-黄杉</a></p>
<h3 id="gitignore文件"><a class="header-anchor" href="#gitignore文件"></a>.gitignore文件</h3>
<p>.gitignore顾名思义就是告诉git需要忽略的文件，这是一个很重要并且很实用的文件。</p>
<p>一般我们写完代码后会执行编译、调试等操作，这期间会产生很多中间文件和可执行文件，这些都不是代码文件，是不需要git来管理的。</p>
<p>我们在git status的时候会看到很多这样的文件，如果用git add -A来添加的话会把他们都加进去，而手动一个个添加的话也太麻烦了。</p>
<p>这时我们就需要.gitignore了。</p>
<h3 id="强制push"><a class="header-anchor" href="#强制push"></a>强制push</h3>
<p>如果<code>git push origin master</code>不行的话，是因为<strong>检测到远程的仓库和你本地仓库里面的文件各不相同</strong>所以不允许commit。</p>
<p>这时候你可以选择使用<code>git push -f origin master</code>强制地push，硬将你的内容推到github仓库上。</p>
<h3 id="遇到不能切换分支问题"><a class="header-anchor" href="#遇到不能切换分支问题"></a>遇到不能切换分支问题</h3>
<p>在本地切换分支的命令是<code>git checkout hexo</code></p>
<p>如果报错说不能换分支，</p>
<p>使用<code>git clean -d -fx &quot;&quot;</code>把以前的git记录清除掉就行了，</p>
<p>但是这也会删掉本地的文件，不要乱用。</p>
<h2 id="hexo搭建过程咨询服务"><a class="header-anchor" href="#hexo搭建过程咨询服务"></a>hexo搭建过程咨询服务</h2>
<p>以上文章内容已经提供了充足的资源来供一个小白自学如何搭建并且有能力自助解决搭建过程中出现的问题。但是我相信如果不亲自折腾一下hexo的话，是不会了解到其中的一些基本的原理，是不可能理解上述内容的，所以搭建过程是相当困难的。</p>
<p>如果按照一个比较完整的教程，<strong>10小时</strong>学会搭建一个hexo博客不是难事。</p>
<p>但是如果不懂得任何原理，按照教程来搭建，万一遇到报错或者问题会消耗大量的时间，我就是一个例子，经历了搭建好了一个hexo博客–换主题–修改主题的一些bug–重新搭建一个结构良好的hexo博客，我花了将近<strong>两个星期</strong>的时间。</p>
<p>在这两个星期的时间里面，因为遇到了一些有问题的教程，本来想请教大神，但总遭到大神们以忙为理由委婉拒绝，我只好花了大量时间来试错和研究和理解整个流程和原理。</p>
<p>可见，<strong>选对教程</strong>、<strong>理解原理</strong>能大大减少自我摸索过程中的痛苦。</p>
<p>一次偶然的机会，我收取了一个网友50元，在他整个搭建过程中向他提供问题咨询，包学包会。结果发现他在整个过程中能免除很多痛苦，而且节省了他大量的时间。两个星期的问题能够在三四天时间内轻松解决，其实这50元还真的挺值。</p>
<p>后来我陆续接了几单咨询来做，通过这个互利的过程，我对咨询和解决方案行业的态度发生的巨大的改观。我个人也欢迎联系付费咨询的合作！</p>
<h2 id="本文补充"><a class="header-anchor" href="#本文补充"></a>本文补充</h2>
<p>之前讲到的几个博文链接地址我都已经放上了，另外还有一篇原创的不错的文章，地址挂了，我把全文截图放在这里，可以右键另存为来看：</p>
<p><img src="http://olqa2s510.bkt.clouddn.com/CrazyMilk-%20blog.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 心得 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[相等操作符回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/02/11/equality-operators/</url>
      <content type="html"><![CDATA[<p>最早的ECMAscript中的相等和不相等操作符会在执行比较之前，先将对象转换成相似的类型(即，强制转型)。</p>
<p>后来有人对这种转换的合理性提出质疑。</p>
<p>最后，ECMAcript的解决方案是提供两组操作符：</p>
<ul>
<li>相等和不相等——先转换再比较</li>
<li>全等和不全等——仅比较而不转换</li>
</ul>
<a id="more"></a>
<h2 id="相等-和不相等"><a class="header-anchor" href="#相等-和不相等"></a>相等(==)和不相等(!=)</h2>
<p>&quot;==“和”!=“是互补对立的：如果两个操作数用”==“比较时返回 true，则这两个操作数用”!=“比较时就会返回 false ; 另外，用”==“返回 false 时，用”!=&quot;则返回true，这点很容易理解。</p>
<p>这两个操作符都会强制转型，<strong>在比较相等性之前</strong>会作以下工作：</p>
<ul>
<li>布尔值转换为数值，详见后面的补充。</li>
<li>字符串和数值比较时，将字符串转换成数值</li>
<li>对象和<strong>不是对象的操作数</strong>比较时，调用对象的<code>valueOf()</code>方法，用得到的基本类型值按照前面的规则进行比较。</li>
</ul>
<p>==和!=<strong>在进行比较之时</strong>遵循以下规则：</p>
<ul>
<li>null 和 undefined 是相等的。null == undefined
<ul>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
</ul>
</li>
<li>NaN和任何操作数不等，NaN 不等于NaN。
<ul>
<li>如果有一个操作数是 NaN，则&quot;==“返回 false ，而”!=&quot;返回 true 。</li>
<li>重要提示：即便两个操作数都是NaN，&quot;==&quot;也返回false，因为按照规则，NaN 不等于NaN。</li>
</ul>
</li>
<li>如果两个操作数都是对象，则比较它们是不是指向同一个对象。</li>
</ul>
<p>补充：</p>
<p>1. 相等运算符隐藏的强制转型，会带来一些违反直觉的结果：</p>
<pre><code> '' == 0            // true
' \t\r\n ' == 0     // true

false == 'false'    // false，这个超坑爹
false == '0'        // true
</code></pre>
<p>2.</p>
<pre><code>true == 1 返回true
false == 0 返回true
true == 2 返回true
</code></pre>
<p>还有另外一个概念叫<strong>Boolean 表达式</strong>，容易和以上概念混淆。在需要用到 Boolean 表达式的情景(比如if等语句中的条件判断)，非 Boolean 表达式也可以被转换为 Boolean 值，但是要遵循下列规则：</p>
<ul>
<li>所有的对象都被当作 true。</li>
<li>当且仅当字符串为空时，该字符串被当作 false。</li>
<li><strong>null</strong> 和 <strong>undefined</strong> 被当作 false。</li>
<li>当且仅当数字为零时，该数字被当作 false。</li>
</ul>
<h2 id="全等-和不全等"><a class="header-anchor" href="#全等-和不全等"></a>全等(===)和不全等(!==)</h2>
<p>和**相等(==)和不相等(!=)**类似，只不过在比较之前没有强制转型的过程，两个操作数直接比较。</p>
<h2 id="尽量使用全等和不全等"><a class="header-anchor" href="#尽量使用全等和不全等"></a>尽量使用全等和不全等</h2>
<p>举个简单的例子，团队协作中你肯定需要读别人的代码。而当你看到“==”时，要判断清楚作者的代码意图是确实需要转型，还是无所谓要不要转型只是随手写了，还是不应该转型但是写错了……所花费的脑力和时间比明确的“===”（加上可能需要的明确转型）要多得多。要记得团队中的每个人（包括原作者自己）都需要付出这理解和维护成本。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作符回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/02/11/js-operators/</url>
      <content type="html"><![CDATA[<p>ECMAScript 操作符的与众不同之处在于，它们能适用于很多种基本数据类型的值，例如字符串、数字值、布尔值、甚至对象。</p>
<p>不过，在应用于对象时，响应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p>
<a id="more"></a>
<h2 id="一元操作符"><a class="header-anchor" href="#一元操作符"></a>一元操作符</h2>
<p>自增和自减直接借鉴了C语言</p>
<p>自增、自减、加、减这些一元操作符可以用于转换数据类型。</p>
<h2 id="位操作符"><a class="header-anchor" href="#位操作符"></a>位操作符</h2>
<p>这是借鉴了一些底层的语言，在特殊情况下才会用到，一般情况下已经很少用了</p>
<h2 id="布尔操作符"><a class="header-anchor" href="#布尔操作符"></a>布尔操作符</h2>
<h3 id="逻辑非"><a class="header-anchor" href="#逻辑非"></a>逻辑非</h3>
<p>返回的是布尔值</p>
<h3 id="逻辑与和逻辑或"><a class="header-anchor" href="#逻辑与和逻辑或"></a>逻辑与和逻辑或</h3>
<p>如果操作数不只有布尔值：</p>
<h4 id="none"><a class="header-anchor" href="#none"></a>&amp;&amp;</h4>
<p>如果第一个操作数是 Boolean 类型，而且值为 false ，那么直接返回 false。
如果第一个操作数是 Boolean 类型，而且值为 true，另外一个操作数是 object 类型，那么将返回这个对象。
如果两个操作数都是 object 类型，那么，返回第二个对象。
如果任何一个操作数是 null，那么，返回 null。
如果任何一个操作数是 NaN，那么返回 NaN。
如果任何一个操作数是 undefinded，那么返回 undefined。</p>
<h4 id="none-v2"><a class="header-anchor" href="#none-v2"></a>||</h4>
<p>如果第一个操作数是 boolean 类型，而且值为 true， 那么，直接返回 true。
如果第一个操作数是 Boolean 类型，而且值为 false ，第二个操作数为 object，那么返回 object 对象。
如果两个操作数都是 object 类型，那么返回第一个对象。
如果两个操作数都是 null，那么，返回 null。
如果两个操作数都是 NaN，那么返回 NaN。
如果两个操作数都是 undefined，那么，返回 undefined。</p>
<h4 id="不用搞得这么复杂-推荐大家看这部分的说明"><a class="header-anchor" href="#不用搞得这么复杂-推荐大家看这部分的说明"></a>不用搞得这么复杂 推荐大家看这部分的说明</h4>
<p>a &amp;&amp; b : 将a, b转换为Boolean类型, 再执行逻辑与, true返回b, false返回a
a || b : 将a, b转换为Boolean类型, 再执行逻辑或, true返回a, false返回b
转换规则:
对象为true
非零数字为true
非空字符串为true
其他为false</p>
<hr>
<p>我们可以利用 逻辑或 这一行为来避免为变量赋值 null 或 undefined 值：</p>
<pre><code>var myObject = preferredObject || backupObject;
</code></pre>
<p>变量 preferredObject 的值优先赋给 myObject ，变量 backupObject 的值作为后备。</p>
<h2 id="乘性操作符"><a class="header-anchor" href="#乘性操作符"></a>乘性操作符</h2>
<p>Infinity 和 -Infinity 表示无穷大和负无穷大</p>
<h3 id="乘法"><a class="header-anchor" href="#乘法"></a>乘法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity * 0 ==&gt; NaN</li>
</ul>
<h3 id="除法"><a class="header-anchor" href="#除法"></a>除法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity / Infinity ==&gt; NaN</li>
<li>0 / 0 ==&gt; NaN</li>
</ul>
<h3 id="求模"><a class="header-anchor" href="#求模"></a>求模</h3>
<p>a % b：</p>
<p>如果a有限大，而b无限大，结果为a</p>
<p>如果a为0， 结果为0</p>
<p>其他特殊情况一般为NaN</p>
<h2 id="加性操作符"><a class="header-anchor" href="#加性操作符"></a>加性操作符</h2>
<h3 id="加法"><a class="header-anchor" href="#加法"></a>加法</h3>
<ul>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后拼接字符串
<ul>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的toString() 方法</li>
<li>对于undefined 和 null ，调用String()函数取得字符串&quot;undefined&quot;和&quot;null&quot;</li>
</ul>
</li>
</ul>
<h3 id="减法"><a class="header-anchor" href="#减法"></a>减法</h3>
<p>略</p>
<h2 id="关系操作符"><a class="header-anchor" href="#关系操作符"></a>关系操作符</h2>
<ul>
<li>如果两个操作符都是字符串，则比较两个字符串对应的字符编码值
<ul>
<li>大写字母的字符编码 全部小于 小写字母的字符编码</li>
</ul>
</li>
</ul>
<h2 id="相等操作符"><a class="header-anchor" href="#相等操作符"></a>相等操作符</h2>
<p>见另外一篇文章 <a href="https://alexzhong22c.github.io/2017/02/11/equality-operators/">相等操作符</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js事件绑定基础回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/01/29/js-event/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="绑定事件监听"><a class="header-anchor" href="#绑定事件监听"></a>绑定事件监听</h2>
<p>在 JavaScript 中，有三种常用的绑定事件的方法：</p>
<ol>
<li>HTML 内联属性（避免使用）</li>
<li>DOM 属性绑定</li>
<li>使用事件监听函数</li>
</ol>
<h3 id="html-内联属性-避免使用"><a class="header-anchor" href="#html-内联属性-避免使用"></a>HTML 内联属性（避免使用）</h3>
<pre><code>&lt;button onclick=&quot;alert('你点击了这个按钮');&quot;&gt;点击这个按钮&lt;/button&gt;
</code></pre>
<p>使用这种方法，JavaScript 代码与 HTML 代码耦合在了一起，不便于维护和开发。所以除非在必须使用的情况（例如统计链接点击数据）下，尽量避免使用这种方法。</p>
<h3 id="在javascript代码中绑定"><a class="header-anchor" href="#在javascript代码中绑定"></a>在JavaScript代码中绑定</h3>
<pre><code>element.onclick = function(event){
    alert('你点击了这个按钮');
};

</code></pre>
<p>缺陷是：因为直接赋值给对应属性，如果你在后面代码中再次为 <code>element</code> 绑定一个回调函数，会覆盖掉之前回调函数的内容。</p>
<p>虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。</p>
<h3 id="绑定事件监听函数"><a class="header-anchor" href="#绑定事件监听函数"></a>绑定事件监听函数</h3>
<pre><code>var btn = document.getElementsByTagName('button');
btn[0].addEventListener('click', function() {
    alert('你点击了这个按钮');
}, false);

</code></pre>
<p>最后一个参数表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。</p>
<p>但一般使用时我们往往传递 false，这是因为 IE 浏览器不支持在捕获阶段监听事件，毕竟 IE 浏览器的份额是不可忽略的。</p>
<h2 id="移除事件监听"><a class="header-anchor" href="#移除事件监听"></a>移除事件监听</h2>
<p>需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如：</p>
<pre><code>var fun = function() {
    // function logic
};

element.addEventListener('click', fun, false);
element.removeEventListener('click', fun, false);

</code></pre>
<h2 id="事件触发过程"><a class="header-anchor" href="#事件触发过程"></a>事件触发过程</h2>
<ol>
<li>
<p>捕获阶段（Capture Phase）</p>
</li>
<li>
<p>目标阶段（Target Phase）</p>
</li>
<li>
<p>冒泡阶段（Bubbling Phase）</p>
</li>
</ol>
<h2 id="使用事件代理-event-delegate-提升性能"><a class="header-anchor" href="#使用事件代理-event-delegate-提升性能"></a>使用事件代理（Event Delegate）提升性能</h2>
<p>使用事件代理主要有两个优势：</p>
<ol>
<li>减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。</li>
<li>动态变化的 DOM 结构，仍然可以监听。以前，当一个 DOM 动态创建之后，不会带有任何事件监听，除非你重新执行事件监听函数；而使用事件监听无须担忧这个问题。</li>
</ol>
<p>如果使用原生的方式实现事件代理，需要注意过滤非目标节点，可以通过 id、class 或者 tagname 等等，例如：</p>
<pre><code>element.addEventListener('click', function(event) {
    // 判断是否是 a 节点
    if ( event.target.tagName == 'A' ) {
        // a 的一些交互操作
    }
}, false);
</code></pre>
<h2 id="停止事件冒泡-stoppropagation"><a class="header-anchor" href="#停止事件冒泡-stoppropagation"></a>停止事件冒泡（stopPropagation）</h2>
<pre><code>element.addEventListener('click', function(event) {
    event.stopPropagation();
}, false);

</code></pre>
<h2 id="事件的-event-对象"><a class="header-anchor" href="#事件的-event-对象"></a>事件的 Event 对象</h2>
<p>事件对象包括很多有用的信息，比如事件触发时，鼠标在屏幕上的坐标、被触发的 DOM 详细信息、以及上图最下面继承过来的停止冒泡方法（stopPropagation）。下面介绍一下比较常用的几个属性和方法：</p>
<h3 id="type-string"><a class="header-anchor" href="#type-string"></a><code>type</code>(string)</h3>
<p>事件的名称，比如 “click”。</p>
<h3 id="target-node"><a class="header-anchor" href="#target-node"></a><code>target</code>(node)</h3>
<p>事件要触发的目标节点。</p>
<h3 id="bubbles-boolean"><a class="header-anchor" href="#bubbles-boolean"></a><code>bubbles</code> (boolean)</h3>
<p>表明该事件是否是在冒泡阶段触发的。</p>
<h3 id="preventdefault-function"><a class="header-anchor" href="#preventdefault-function"></a><code>preventDefault</code> (function)</h3>
<p>这个方法可以禁止一切默认的行为，例如点击 <code>a</code> 标签时，会打开一个新页面，如果为 <code>a</code> 标签监听事件 <code>click</code> 同时调用该方法，则不会打开新页面。</p>
<h3 id="stoppropagation-function"><a class="header-anchor" href="#stoppropagation-function"></a><code>stopPropagation</code> (function)</h3>
<p>停止冒泡，上面有提到，不再赘述。</p>
<h3 id="stopimmediatepropagation-function"><a class="header-anchor" href="#stopimmediatepropagation-function"></a><code>stopImmediatePropagation</code> (function)</h3>
<p>与 <code>stopPropagation</code> 类似，就是阻止触发其他监听函数。但是与 <code>stopPropagation</code> 不同的是，它更加 “强力”，阻止除了目标之外的事件触发，甚至阻止针对同一个目标节点的相同事件。</p>
<h2 id="jquery-中的事件"><a class="header-anchor" href="#jquery-中的事件"></a>jQuery 中的事件</h2>
<p>如果你在写文章或者 Demo，为了简单，你当然可以用上面的事件监听函数，以及那些事件对象提供的方法等。*<em>但在实际中，有一些方法和属性是有兼容性问题的，所以我们会使用 jQuery 来消除兼容性问题。 *</em></p>
<h3 id="绑定事件和事件代理"><a class="header-anchor" href="#绑定事件和事件代理"></a>绑定事件和事件代理</h3>
<pre><code>$( &quot;#dataTable tbody tr&quot; ).on( &quot;click&quot;, function() {
  console.log( $( this ).text() );
});

</code></pre>
<h3 id="处理过兼容性的事件对象-event-object"><a class="header-anchor" href="#处理过兼容性的事件对象-event-object"></a>处理过兼容性的事件对象（Event Object）</h3>
<p>事件对象有些方法等也有兼容性差异，jQuery 将其封装处理，并提供跟标准一直的命名。</p>
<p>如果你想在 jQuery 事件回调函数中访问原来的事件对象，需要使用 <code>event.originalEvent</code>，它指向原生的事件对象。</p>
<h3 id="触发事件-trigger-方法"><a class="header-anchor" href="#触发事件-trigger-方法"></a>触发事件 <code>trigger</code> 方法</h3>
<p>点击某个绑定了 <code>click</code> 事件的节点，自然会触发该节点的 <code>click</code> 事件，从而执行对应回调函数。</p>
<p><code>trigger</code> 方法可以模拟触发事件，我们单击另一个节点 elementB，可以使用：</p>
<pre><code>$(elementB).on('click', function(){
    $(elementA).trigger( &quot;click&quot; );
});

</code></pre>
<p>来触发 elementA 节点的单击监听回调函数。详情请看文档 <a href="http://api.jquery.com/trigger/" target="_blank" rel="external">.trigger()</a>。</p>
<h2 id="原生js事件绑定兼容"><a class="header-anchor" href="#原生js事件绑定兼容"></a>原生js事件绑定兼容</h2>
<p>Dean Edward 所写的 addEvent() 函数：</p>
<pre><code>function addEvent(element, type, handler) {
    if (!handler.$$guid) handler.$$guid = addEvent.guid++;
    if (!element.events) element.events = {};
        var handlers = element.events[type];
    if (!handlers) {
        handlers = element.events[type] = {};
        if (element[&quot;on&quot; + type]) {
            handlers[0] = element[&quot;on&quot; + type];
        }
    }
    handlers[handler.$$guid] = handler;
    element[&quot;on&quot; + type] = handleEvent;
}

addEvent.guid = 1;
    
function removeEvent(element, type, handler) {
    if (element.events &amp;&amp; element.events[type]) {
        delete element.events[type][handler.$$guid];
    }
}
function handleEvent(event) {
    var returnValue = true;
    event = event || fixEvent(window.event);
    var handlers = this.events[event.type];
    for (var i in handlers) {
        this.$$handleEvent = handlers[i];
        if (this.$$handleEvent(event) === false) {
            returnValue = false;
        }
    }
    return returnValue;
};
    
function fixEvent(event) {
    event.preventDefault = fixEvent.preventDefault;
    event.stopPropagation = fixEvent.stopPropagation;
    return event;
};
fixEvent.preventDefault = function() {
    this.returnValue = false;
};
fixEvent.stopPropagation = function() {
    this.cancelBubble = true;
};
</code></pre>
<p>eslint版：</p>
<pre><code>function addEvent (element, type, handler) {
  if (!handler.$$guid) handler.$$guid = addEvent.guid++
  if (!element.events) element.events = {}
  let handlers = element.events[type]
  if (!handlers) {
    handlers = element.events[type] = {}
    if (element['on' + type]) {
      handlers[0] = element['on' + type]
    }
  }
  handlers[handler.$$guid] = handler
  element['on' + type] = handleEvent
}
addEvent.guid = 1

function removeEvent (element, type, handler) {
  if (element.events &amp;&amp; element.events[type]) {
    delete element.events[type][handler.$$guid]
  }
}

function handleEvent (event) {
  var returnValue = true
  event = event || fixEvent(window.event)
  var handlers = this.events[event.type]
  for (var i in handlers) {
    this.$$handleEvent = handlers[i]
    if (this.$$handleEvent(event) === false) {
      returnValue = false
    }
  }
  return returnValue
}

function fixEvent (event) {
  event.preventDefault = fixEvent.preventDefault
  event.stopPropagation = fixEvent.stopPropagation
  return event
}
fixEvent.preventDefault = function () {
  this.returnValue = false
}
fixEvent.stopPropagation = function () {
  this.cancelBubble = true
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 事件 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[let和const回顾]]></title>
      <url>https://alexzhong22c.github.io/2016/11/09/let-n-const/</url>
      <content type="html"><![CDATA[<p>简单来说是： let是修复了var的作用域的一些bug，变的更加好用。let是更好的var。var的作用于是函数作用于，而let是块级别（大括号括起来的内容）
const声明的变量只可以在声明时赋值，它被设计的本意就是不可随意修改，这是最大的特点。</p>
<a id="more"></a>
<h2 id="let"><a class="header-anchor" href="#let"></a>let</h2>
<p><code>let</code>与<code>var</code>一样，也可以用来声明变量，但它有着更好的作用域规则。</p>
<p><code>let</code>与<code>var</code>还是有不同之处的，所以如果你只是在代码中将<code>var</code>全局搜索替换为<code>let</code>，一些依赖<code>var</code>声明的独特特性（可能你不是故意这样写）的代码可能无法正常运行。但对于绝大多数代码来说，在ES6的新代码模式下，你应该停止使用<code>var</code>声明变量，能使用<code>let</code>就用吧！</p>
<p>这一规则可以帮助你捕捉bug，除了<code>NaN</code>错误以外，每一个异常都会在当前行抛出。</p>
<ul>
<li>**let声明的变量拥有块级作用域。**也就是说用<code>let</code>声明的变量的作用域只是外层块，而不是整个外层函数。</li>
<li>**let声明的全局变量不是全局对象的属性。**这就意味着，你不可 以通过<code>window.变量名</code>的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。</li>
<li><strong>形如for (let x…)的循环在每次迭代时都为x创建新的绑定。</strong></li>
</ul>
<p>可以看一个<strong>循环内变量过度共享</strong>的例子：</p>
<pre><code>var messages = [&quot;喵！&quot;, &quot;我是一只会说话的猫！&quot;, &quot;回调（callback）非常有趣!&quot;];
for (var i = 0; i &lt; messages.length; i++) {
	setTimeout(function () {
		cat.say(messages[i]);
	}, i * 1500);
}
</code></pre>
<p>这只会说话的猫并没有按照预期连说三条消息，它说了三次“undefined”。</p>
<p>事实上，这个问题的答案是，循环本身及三次timeout回调均共享唯一的变量<em>i</em>。当循环结束执行时，<em>i</em>的值为3（因为<code>messages.length</code>的值为3），此时回调尚未被触发。</p>
<p>所以当第一个timeout执行时，调用<code>cat.say(messages[i])</code>，此时i的值为3，所以猫咪最终打印出来的是<code>messages[3]</code>的值亦即<code>undefined</code>。</p>
<p>如果一个<code>for (let...)</code>循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。</p>
<p>所以在会说话的猫示例中，也可以通过将<code>var</code>替换为<code>let</code>修复bug。</p>
<p>这种情况适用于现有的三种循环方式：<code>for-of</code>、<code>for-in</code>、以及传统的用分号分隔的类C循环。</p>
<ul>
<li>
<p>**let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误。**举个例子：</p>
<pre><code>function update() {
	console.log(&quot;当前时间:&quot;, t);  // 引用错误（ReferenceError）
	...
	let t = readTachymeter();
}
</code></pre>
<p>不可访问的这段时间变量一直处于作用域中，但是尚未装载，它们位于<em>临时死区（Temporal Dead Zone，简称TDZ</em>）中。我一直想用科幻小说来类比这个脑洞大开的行话，但是还没想好怎么搞。</p>
<p>（脆弱的性能细节：在大多数情况下，查看代码就可以区分声明是否已经执行，所以事实上，JavaScript引擎不需要在每次代码运行时都额外执行 一次变量可访问检查来确保变量已经被初始化。然而在闭包内部有时不是透明的，这时JavaScript引擎将会做一个运行时检查，也就意味着<code>let</code>相对<code>var</code>而言比较慢。）</p>
<p>（脆弱的平行宇宙作用域细节：在一些编程语言中，一个变量的作用域始于声明之处，而非前后覆盖整个封闭代码块。标准委员会曾考虑过将这种作用域准则赋予<code>let</code>关键词，但是一旦使用这种准则，原本提前使用变量的语句会导致引用错误（ReferenceError），现在该语句不位于<code>let t</code>的声明作用域中，根本不会引用此处的变量<code>t</code>，而是引用外层作用域的相应变量。但是这个方法无法与闭包和函数提升很好得结合，所以该提案最终被否决了。）</p>
</li>
<li>
<p><strong>用let重定义变量会抛出一个语法错误（SyntaxError）。</strong></p>
<p>这一条规则也可以帮助你检测琐碎的小问题。诚然，这亦是<code>var</code>与<code>let</code>的不同之处，当你全局搜索<code>var</code>替换为<code>let</code>时也会导致<code>let</code>重定义语法错误，因为这一规则对全局<code>let</code>变量也有效。</p>
<p>如果你的多个脚本中都声明了相同的全局变量，你最好继续用<code>var</code>声明这些变量。如果你换用了<code>let</code>，后加载的脚本都会执行失败并抛出错误。</p>
<p>或者你可以考虑使用ES6内建的模块机制，后面的文章中会详细讲解。</p>
<p>（脆弱的语法细节：<code>let</code>是一个严格模式下的保留词。在非严格模式下，出于向后兼容的目的，你仍可以用<code>let</code>命名来声明变量、函数和参数，虽然你不会犯傻，但是你确实可以编写<code>var let = 'q';</code>这样的代码！不过<code>let let;</code>无论如何都是非法的。）</p>
</li>
</ul>
<p>在那些不同之外，<code>let</code>和<code>var</code>几乎很相似了。举个例子，它们都支持使用逗号分隔声明多重变量，它们也都支持<a href="http://www.infoq.com/cn/articles/es6-in-depth-destructuring" target="_blank" rel="external">解构</a>特性。</p>
<p>注意，<code>class</code>类声明的行为与<code>var</code>不同而与<code>let</code>一致。如果你加载一段包含同名类的脚本，后定义的类会抛出重定义错误。</p>
<h2 id="const"><a class="header-anchor" href="#const"></a>const</h2>
<p>是的，还有一个新的关键词！</p>
<p>ES6引入的第三个声明类关键词与<code>let</code>类似：<code>const</code>。</p>
<p><code>const</code>声明的变量与<code>let</code>声明的变量类似，它们的不同之处在于，<code>const</code>声明的变量只可以在声明时赋值，不可随意修改，否则会导致<code>SyntaxError</code>（语法错误）。</p>
<pre><code>const MAX_CAT_SIZE_KG = 3000; // 正确

MAX_CAT_SIZE_KG = 5000; // 语法错误（SyntaxError）
MAX_CAT_SIZE_KG++; // 虽然换了一种方式，但仍然会导致语法错误
</code></pre>
<p>当然，规范设计的足够明智，用<code>const</code>声明变量后必须要赋值，否则也抛出语法错误。</p>
<pre><code>const theFairest;  // 依然是语法错误，你这个倒霉蛋
</code></pre>
<h2 id="现在可以使用let和const了么？"><a class="header-anchor" href="#现在可以使用let和const了么？"></a>现在可以使用let和const了么？</h2>
<p>是的。如果要在web上使用<code>let</code>和<code>const</code>特性，你需要使用一个诸如<a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>、<a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a>或<a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>的ES6转译器。（Babel和Traceur暂不支持临时死区特性。）</p>
<p>io.js支持<code>let</code>和<code>const</code>，但是只在严格模式下编码可以使用。Node.js同样支持，但是需要启用<code>--harmony</code>选项</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
