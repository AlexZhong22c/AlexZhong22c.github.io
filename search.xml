<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[后管常见的树形组件的vue实现]]></title>
      <url>https://blog.az22c.top/2022/05/22/admin-tree-widget/</url>
      <content type="html"><![CDATA[<p>本文主要展示一下4种树形组件基于 Vue2 和 Ant Design Vue 1.x 的一般的“实现效果”，和分析它们大致的“实现思路、经验”。【后文有图示】</p>
<a id="more"></a>
<h2 id="前言-须知"><a class="header-anchor" href="#前言-须知"></a>前言——须知</h2>
<p>在后台管理系统页面中，各类树形组件不可或缺，并且实现起来相对复杂。本文主要介绍其中<strong>几种最常见的</strong> ：</p>
<ul>
<li>树形图 多选选择框</li>
<li>树形图 单选选择框</li>
<li>查询展示功能 懒加载树形表格</li>
<li>自定义 树形表格</li>
<li>(目录即本文页面左侧显示的目录导航)</li>
</ul>
<p>本文主要展示一下它们树形组件基于 Vue 和 Ant Design Vue 的一般的“实现效果”，和分析它们大致的“实现思路、经验”。<strong>（也可以只看“实现效果”部分）</strong></p>
<hr>
<ul>
<li>根据个人经验，对于用于 选择/查询 的树形组件，若要确定他们的实现方案(或实现思路)，一般要考虑以下几个方面的功能点：
<ul>
<li>是否需要懒加载</li>
<li>查询功能</li>
<li>勾选回显：(带勾选框的，在初始化时或者查询条件下，可能需要回显勾选上“已选择”的)</li>
<li>所有节点的“展开”控制</li>
<li>(如果是支持“多选”，还要考虑以下这些方面：)</li>
<li>勾选联动</li>
<li>“全选”功能</li>
</ul>
</li>
</ul>
<p><strong>对于各种“树”组件，都可以从以上几个方面入手考虑如何实现。</strong> 当这些功能需要叠加到同一个组件来实现的时候，组件复杂程度开始显著上升。</p>
<h2 id="树形图-多选选择框"><a class="header-anchor" href="#树形图-多选选择框"></a>树形图 多选选择框</h2>
<p>通常，“选择 业务系统 / 部门 这些类型的数据”的业务逻辑，可以用这种组件来实现。</p>
<p>这些类型的业务数据，如果一次性加载，可能总共有接近 1000 个节点，个人尝试过把这个量的数据直接放到 Ant Design Vue 的 a-select-tree 等组件里面，结果在首次弹出显示这样实现的组件和数据时太卡了；点击选择某个数据项的时候也会卡。官方又不予以优化。</p>
<p><strong>小结，针对上述卡顿问题，可以自己二次开发封装实现组件来取而代之，并且实现了“懒加载”来优化。</strong></p>
<p>其实还是用的 Ant Design Vue 的组件，只不过是基于它们做上层二次开发(并且自定义接管了部分Ant Design Vue组件的逻辑处理)。</p>
<p><img src="https://cloud.az22c.top/multi-select-tree-outer-22090901.png-az22cgithub" alt="multi-select-tree-outer-22090901"></p>
<p>( 图1 ↑ )(图示只是仿造模拟图)</p>
<p><img src="https://cloud.az22c.top/multi-select-tree-itself-22090501.png-az22cgithub" alt="multi-select-tree-itself-22090501"></p>
<p>( 图2 ↑ )(图示只是仿造模拟图)</p>
<h3 id="树形图-多选选择框-效果："><a class="header-anchor" href="#树形图-多选选择框-效果："></a>“树形图 多选选择框”效果：</h3>
<ol>
<li>作为表单项显示“已选择的”业务系统或部门之类的。如图1</li>
<li>点击该表单项则弹出对话框。对话框带查询框查询功能，可多选。如图2</li>
<li>去除“已勾选项”弄得方便一点：可在对话框的上部区域操作。这样用户就不需要往下展开多层来找到目标节点</li>
</ol>
<p>而下面这个效果要实现起来挺麻烦的：（查询状态判断、查询逻辑、展开逻辑、懒加载逻辑）</p>
<ul>
<li>当用户操作触发查询时，找到与查询匹配的节点，展开其所有祖先节点。（其他的节点暂时收起不展开，待用户逐个触发展开并懒加载。）
<ul>
<li>另一种状态场景也要实现：非查询状态下，所有节点收起并且也是懒加载子节点。以获得比较流畅的性能和效果</li>
</ul>
</li>
</ul>
<h3 id="树形图-多选选择框-实现思路-经验："><a class="header-anchor" href="#树形图-多选选择框-实现思路-经验："></a>“树形图 多选选择框”实现思路、经验：</h3>
<p><strong>在本文开头，已经给出比较全面的“常见功能点总结”。而到了实现具体某个组件，往往是基于“全面考虑”开始做“减法”：</strong></p>
<p>【1】从以下几个角度考虑，节省实现很多不必要的功能实现和工作，以免工期拉得很长：</p>
<ul>
<li><strong>“已选择项”和“将选择项”的显示做分离：</strong> 令回显“已选择项”的复现逻辑没那么复杂了
<ul>
<li>(适用的情况是：需要回显的“已选择项”通常不多、选择某一节点时不需要带上选择它的那些祖先节点)</li>
<li>效果是：“已选择项”只是做了简化处理，显示在对话框上方即可</li>
<li>这样就不用为树形图，自行计算初始化组件时“勾选回显”的“已选择项”</li>
</ul>
</li>
<li>不必在树形图中实现“全选所有节点”的功能————因为在懒加载的场景下勾选“全选”有挺大的操作歧义</li>
</ul>
<blockquote>
<p>植入一条广告：一种比较全面地实现各个功能点的树形组件，见“隔壁文章” <a href="/2022/05/22/admin-custom-tree-table/">一种常见的多层级树形表格组件</a></p>
</blockquote>
<p>【2】而因为是懒加载场景，树形图计算“勾选联动”之类的，无法交给第三方组件 a-tree 组件那边计算，需要自行实现。</p>
<h2 id="树形图-单选选择框"><a class="header-anchor" href="#树形图-单选选择框"></a>树形图 单选选择框</h2>
<p>通常，“选择 业务系统 / 部门 / 菜单资源 / 组织 这些类型的数据”的业务逻辑，可以用这种组件来实现。</p>
<p>与上述“树形图 多选选择框”相同，该组件加载对应的业务数据同样可能有接近 1000 个节点，有些甚至总量能去到大几千。</p>
<p>所以同样地， <strong>“节点多导致卡顿，用懒加载解决”</strong> ，也是基于 Ant Design Vue 的组件，二次开发以实现。</p>
<p><img src="https://cloud.az22c.top/single-select-tree-22090502.png-az22cgithub" alt="single-select-tree-22090502"></p>
<p>( 图3 ↑ )(图示只是仿造模拟了表面的样式：点击弹出该浮窗)</p>
<h3 id="树形图-单选选择框-效果："><a class="header-anchor" href="#树形图-单选选择框-效果："></a>“树形图 单选选择框”效果：</h3>
<p>说到这个组件要实现哪些功能：(可以说是上述“树形图 多选选择框”组件的功能子集)</p>
<ol>
<li>作为表单项显示“已选择的”业务系统或部门之类的。如图3</li>
<li>点击该表单项则弹出浮窗。浮窗带查询框查询功能。如图3</li>
</ol>
<p>而下面这个效果要实现起来挺麻烦的：（查询状态判断、查询逻辑、展开逻辑、懒加载逻辑）</p>
<ul>
<li>当用户操作触发查询时，找到与查询匹配的节点，展开其所有祖先节点。（其他的节点暂时收起不展开，待用户逐个触发展开并懒加载。）
<ul>
<li>另一种状态场景也要实现：非查询状态下，所有节点收起并且也是懒加载子节点。以获得比较流畅的性能和效果</li>
</ul>
</li>
</ul>
<blockquote>
<p>“单选选择框 树形图”因为不需要实现“多选”的功能，所以在实现层面是相对比较简单的。</p>
</blockquote>
<h2 id="查询展示功能-懒加载树形表格"><a class="header-anchor" href="#查询展示功能-懒加载树形表格"></a>查询展示功能 懒加载树形表格</h2>
<p>通常在后台管理系统，查询展示的数据列表，要么就是“分页表格”的形式，要么就是本节所讲的这种“树形表格”的形式。</p>
<p>通常， 菜单资源 / 业务系统 / 部门 等等 很多种类型的数据的查询展示，只要是需要树状的，都可以用这种组件来实现：(如下面的 图4) (基于 Ant Design Vue 实现的组件)</p>
<p><img src="https://cloud.az22c.top/lazy-tree-table-22090501.png-az22cgithub" alt="lazy-tree-table-22090501"></p>
<p>( 图4 ↑ )(图片源自网络，仅用作外观说明：树形表格)</p>
<ul>
<li>基本上都会优化为“懒加载”的形式：
<ul>
<li>如果不是短周期的工程项目，那么数据量已经足够多了。</li>
<li>要么分页，要么懒加载。通常二选其一。</li>
</ul>
</li>
</ul>
<h3 id="查询-树形表格-权衡实现-多选"><a class="header-anchor" href="#查询-树形表格-权衡实现-多选"></a>“查询……树形表格”权衡实现“多选”</h3>
<ul>
<li>假设在此基础上，还想要为表格实现“多选”功能，因为要兼顾其他交互的效果，开发成本一下子就上升了，建议预留更多的时间。
<ul>
<li>实际情况是，在上面几种类型的业务数据当中，按实际情况只有个别的才需要做“多选”的功能</li>
<li>相比于去实现“多选”，通常针对单个项的操作已经够用了。因为基本上每一个表格都会标配提供针对单个数据项的操作</li>
</ul>
</li>
</ul>
<h3 id="查询-树形表格-替换为组合式样式"><a class="header-anchor" href="#查询-树形表格-替换为组合式样式"></a>“查询……树形表格”替换为组合式样式</h3>
<p>另一种替代实现方式：拆分为组合式样式</p>
<p>如果表格要显示的数据的字段数量(也就是表格列数)不是很多的情况下，建议改造成这种：</p>
<ul>
<li>将控制“查询树”的功能抽取出来作为一个模块，放到页面左边的区域(这个树其实也是可以做懒加载优化的)</li>
<li>结果就是一个“单选树形图+显示所选节点的子级列表”的组合，一左一右：(如下面的 图5)</li>
</ul>
<p><img src="https://cloud.az22c.top/lazy-tree-table-2-col-22090801.png-az22cgithub" alt="lazy-tree-table-2-col-22090801"></p>
<p>( 图5 ↑ )(图片源自网络，样式拼凑而成，仅用作外观说明)</p>
<ul>
<li>“组合式”的缺点就是，需要占用更多的页面横向空间，所以表格列数如果多，就很难用
<ul>
<li>针对这点可以优化，在合适的时机收起左树的占用空间转赠给右边表格区域</li>
</ul>
</li>
<li>“组合式”优点就是，因为把树形的逻辑解耦了出去，所以当表格想要实现更多更复杂功能时的负担减轻了
<ul>
<li>比如对比原来的“树形表格”，若需兼顾实现表格的“多选”功能，将少出现很多bug。</li>
<li>比如对比原来的“树形表格”，若需兼顾实现表格的“分页”功能，将少出现很多bug。</li>
</ul>
</li>
</ul>
<h2 id="自定义-树形表格"><a class="header-anchor" href="#自定义-树形表格"></a>自定义 树形表格</h2>
<p>这种其实是向后台系统提交一组树状的数据。所以交互通常是“填写内容”或者“通过选择来录入内容”，然后把数据提交的。</p>
<p>特点：</p>
<ul>
<li>通常由于树数据的每一级数据类型不一样：下一级使用表格第二列、第三列来展示
<ul>
<li>(不同于 Ant Design Vue 的 a-table 内置提供的树形表格的“下一级数据显示为后续的表格行”)</li>
</ul>
</li>
</ul>
<p><img src="https://cloud.az22c.top/custom-tree-table-22090902.png-az22cgithub" alt="custom-tree-table-22090902"></p>
<p>( 图6 ↑ )(图片源自网络，样式拼凑而成，仅用作外观说明)</p>
<ul>
<li>实现方式并不唯一：
<ul>
<li>可以直接利用 Ant Design Vue 的 a-table 合并单元格来实现表示父子级从属关系</li>
<li>可以自己使用html拼接成这种表格，再优化样式
<ul>
<li>(自己使用html拼接实现的话，页面里面这些部件基本无法实现自动对齐，通常需要固定表格的某些列宽和行高)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常见实现场景：嵌套对话框内"><a class="header-anchor" href="#常见实现场景：嵌套对话框内"></a>常见实现场景：嵌套对话框内</h3>
<details>
<summary>这种“所提交的树形数据是表单数据的一部分的”对话框，对于它的可复用性不要抱有太高的期望。</summary>
<p>“嵌套”往往是“树形图”的宿命。用于填写数据的树形组件可能也是一样的。因为它树形表格本身占据表单的空间就比较大，所以优先考虑将它设计为首屏收起来的，以“嵌套对话框内”的形式呈现。</p>
</details>
<ul>
<li>到这里做一个假设，假设这个对话框的数据，按要求要改造为一组表单数据的一部分。
<ul>
<li>通常就是嵌套对话框的场景了。外层增设一个能填写的表单对话框</li>
<li><strong>此时在多数情况下，这个内层对话框组件的可复用性基本上变为零了。</strong>
<ul>
<li>(最大程度上只能做到复用这个组件内的某些模块，而不是复用这个对话框组件本身)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cloud.az22c.top/custom-tree-table-outter-22090801.png-az22cgithub" alt="custom-tree-table-outter-22090801"></p>
<p>( 图7 ↑ )(图片源自网络，样式拼凑而成，仅用作外观说明)</p>
<p>如图7，树形表格位于内层对话框。而外层对话框是一个数据表单，需要带上内层对话框(如刚才图6)里面的树形表格的数据一起提交。</p>
<h4 id="这种嵌套对话框需求的隐藏要求："><a class="header-anchor" href="#这种嵌套对话框需求的隐藏要求："></a>这种嵌套对话框需求的隐藏要求：</h4>
<p>这种嵌套对话框需求的隐藏要求：</p>
<ul>
<li>对于这种场景，内层对话框上的表单的数据，包括树形表格的<strong>数据最好是从上层对话框流入内层对话框组件</strong>。
<ul>
<li>因为，操作的用户有可能在这个内层对话框修改完数据之后，在这个内层对话框中点击“取消”。当用户再次打开内层对话框，内层对话框所要复现的数据，应当是需要照旧从上层对话框读取并且做格式化调整后传入内层的。</li>
</ul>
</li>
<li>即便不打开内层对话框，外层对话框也能直接带着内层对话框中的树形数据 <strong>走校验+格式化</strong> 然后提交。
<ul>
<li>此时又存在着要求：外层对话框的校验规则和校验提示和内层对话框中的须看起来一致</li>
<li>内外两层对话框的两组相似的 校验、校验提示和格式化逻辑，不能全都归属于内层对话框组件内</li>
</ul>
</li>
</ul>
<h4 id="这种嵌套对话框可复用性：-0"><a class="header-anchor" href="#这种嵌套对话框可复用性：-0"></a>这种嵌套对话框可复用性： ≈ 0</h4>
<ul>
<li>在实际业务场景中，由于外层对话框可能各不相同
<ul>
<li>比如，外层对话框的数据格式主要由后端传过来的数据决定，需要优先考虑后端想要的格式，所以外接的外层对话框的数据格式和字段可能各不相同。</li>
</ul>
</li>
<li>又因为上面可以看到对话框之间内外关联太过紧密、是需要保持较多的一致性的</li>
<li>间接导致了： <strong>应对搭配各种不同的外层对话框，内层对话框组件的可复用性约等于零</strong></li>
</ul>
<p>还要兼顾原本繁琐的数据流和数据格式的处理，在嵌套对话框的场景下，变得更麻烦(在此略过没有细述)，进一步打击了对话框组件的可复用性。</p>
<p>遇到这种情况，多申请一点工期慢慢做就可以了。</p>
]]></content>
      
        <categories>
            
            <category> 项目总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> 树形 </tag>
            
            <tag> 复选框 </tag>
            
            <tag> shu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一种常见的多层级树形表格组件]]></title>
      <url>https://blog.az22c.top/2022/05/22/admin-custom-tree-table/</url>
      <content type="html"><![CDATA[<p>一种基于 Vue 和 Ant Design Vue / Element-ui 实现的，树形表格组件。这一种组件用于选择多层级树状数据中的多个节点。同时在各行各业后管需求中比较普遍常见。【后文有图示】</p>
<a id="more"></a>
<p>对于许多实际业务，因为往往比普通树形图组件稍微多了一套要实现的数据关系，所以单纯调用 Ant Design Vue 等等实现不了，只能二次开发实现。</p>
<p>本文将给出对于这一种组件，普遍通用的<strong>实现效果和大概的实现思路、经验</strong>。</p>
<p>本文前面 2 个章节是介绍“实现效果”的；之后都是讲“实现的思路、经验”的。<strong>如果读者并不需要做同样的需求，看前面 2 个章节即可。</strong></p>
<p>（本文尝试做一个“普遍通用”的总结，所以后文并不包含任何具体的实现代码。）</p>
<ul>
<li>本文的章节目录：  (目录即本文页面左侧显示的目录导航)
<ul>
<li><a href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">主要特点</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">实现要求</a></li>
<li>-----------内容分割线-----------</li>
<li><a href="#%E6%8F%90%E5%8F%96%E5%87%BA%E4%BB%A5%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E7%9A%84%E9%9A%BE%E7%82%B9">提取出以上实现方案的难点</a></li>
<li><a href="#%E9%99%8D%E4%BD%8E%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">降低实现复杂度的解决办法</a></li>
<li><a href="#%E5%AE%8F%E8%A7%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">宏观的实现思路</a></li>
</ul>
</li>
</ul>
<h2 id="主要特点"><a class="header-anchor" href="#主要特点"></a>主要特点</h2>
<ul>
<li>首先观察到它最主要的特点是：<strong>第二列的数据，也是分别从属于某个第一列数据的“子级”。</strong> 如图所示
<ul>
<li>即，是树形表格。第一列数据之间存在多层树形父子级关系。</li>
<li>同时，第二列的数据，也是分别从属于某个第一列数据的“子级”。</li>
</ul>
</li>
</ul>
<p>二次开发：上述的<code>主要特点</code>就意味着这个组件不能直接使用“第三方组件库自带的复选框显示逻辑”来实现。同时，交互逻辑都是需要自己二次开发编写的。</p>
<p>(另外，作为一种以“选择节点”作为功能的组件，这个组件需要把“已选择项”、“未选择项”、“将要选择项”，3者的信息同时表示出来。)</p>
<p>(图示只是仿造模拟图)
<img src="https://cloud.az22c.top/custom-tree-table-mix-22091001.png-az22cgithub" alt="custom-tree-table-mix-22091001"></p>
<h2 id="实现要求"><a class="header-anchor" href="#实现要求"></a>实现要求</h2>
<p>我们再进一步，<strong>看看在一般的产品层面，对这一种组件还有什么实现的要求：</strong></p>
<p>根据个人经验，在更广括看到同类事物层面，即规划“各种的树形组件”的实现方案，一般要考虑以下几个方面的功能点，基本上是“通用的”：</p>
<ul>
<li>一般而言，“通用的”的实现要求，有：
<ul>
<li>是否需要懒加载</li>
<li>查询功能</li>
<li>勾选回显：(带勾选框的，在初始化时或者查询条件下，可能需要回显勾选上“已选择”的)</li>
<li>所有节点的“展开”控制</li>
<li>(如果是支持“多选”，还要考虑以下这些方面：)</li>
<li>勾选联动</li>
<li>“全选”功能</li>
</ul>
</li>
</ul>
<hr>
<p>以上“通用的”要考虑的实现功能点，具体到这一种组件上，<strong>具体表现为：</strong></p>
<ol>
<li>初始化组件时，对于先前已选择项，<strong>回显</strong>它们的勾选状态</li>
<li>初始化组件 或 没有查询条件时，<strong>根据 已选择项 ，统计展开它们的祖先节点。</strong> 这样是为了方便系统使用者查看</li>
<li>(初始化组件时，解析后端传来的数据回显，兼容“反映孤立节点”：若某子孙节点是选择状态，同时某一个祖先节点未被选择时，让该祖先节点显示为“半选”状态)</li>
<li>当某子孙节点被选择时，<strong>联动</strong> 让祖先节点被勾选。
<ol>
<li>(比如示例图中的“用户修改”节点被选择时，需要联动让“部门用户管理test”和“用户管理test”被勾选上)</li>
</ol>
</li>
<li>查询筛选：查询框输入了内容，按查询条件查询时，<strong>展示查询筛选后的树和节点。</strong></li>
<li>（还要兼顾实现树形图的常规联动交互：勾选某一节点时，联动其所有子孙节点勾选上）</li>
<li>（常规“全选”功能需求：表格最顶部有个全选框，点击全选，更新所有节点状态为被选中）</li>
</ol>
<p>(<code>综上所述</code>，除了“懒加载”效果，其他效果都在这一种组件中实现了。)</p>
<p>当这些功能需要叠加到同一个组件来实现的时候，组件复杂程度开始显著上升。</p>
<p>只是使用了 Ant Design Vue 的 a-table 的基础样式、节点展开控制样式（Element-ui同理，不涉及代码时都一样的）。而其他都是如上所说自行计算、控制，即所谓的“二次开发”的部分。</p>
<h2 id="内容分割线"><a class="header-anchor" href="#内容分割线"></a>-----------内容分割线-----------</h2>
<blockquote>
<p>至此，这一种组件的“实现效果”介绍完毕。之后都是讲“实现的思路、经验”的。如果读者并不需要做同样的需求，后面的内容基本上可以不看。</p>
</blockquote>
<h2 id="提取出以上实现方案的难点"><a class="header-anchor" href="#提取出以上实现方案的难点"></a>提取出以上实现方案的难点</h2>
<p>【1】梳理如何兼顾父子节点间联动：</p>
<ul>
<li>(警惕组件库给出的不适宜方案：Ant Design Vue给出的a-tree-table等常规的联动方案：“子节点被选择的，其祖先节点可以不被选择”——是在这里不适用的)</li>
<li>如果试过就会知道，这种联动方案是和我们想要实现的效果相互冲突的，无论如何调整提交数据都是存在bug的</li>
<li>“父被勾选”能联动“子被勾选”，“子被勾选”也能联动“父被勾选”</li>
<li>通常需要再补一条“使用规则说明”，如上方的用户提示所示：“若某节点被勾选，则自动勾选其所有直系祖先节点”</li>
</ul>
<p>【2】考虑要不要做懒加载子节点：</p>
<ul>
<li>如果已经实现懒加载，联动关系很难做兼容处理。</li>
<li>通常，在专供大量数据使用的另一版“特供版”中，也没有实现懒加载。
<ul>
<li>解释“特供版”：面对大量数据的需求，往往为了性能流畅需要对“便利性”做一些牺牲：“特供版”组件通常就是在初始化时只展开第一层的节点，以此牺牲换取更高的性能效果。
<ul>
<li>也就是通过拷贝组件代码，削减成为另外单独一份组件代码来实现“特供版”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="降低实现复杂度的解决办法"><a class="header-anchor" href="#降低实现复杂度的解决办法"></a>降低实现复杂度的解决办法</h2>
<ul>
<li>维护都是“用于呈现于视图的”母子树：查询筛选数据的时候，整树切换数据来显示
<ul>
<li>对比别的方案：试想，假设查询树形表格前后，都是双向绑定同一树形数据。每次切换显示一次，需要计算并且更新的数据状态是很多的。
<ul>
<li>其中首先要做一次对比算法</li>
<li>对比完之后，根据全树差异，实施数据的变更：还要做一个“变更算法”。</li>
<li>可见，这个比常规的对比算法还要复杂很多层次。</li>
</ul>
</li>
<li>“母子树”具体操作：
<ul>
<li>任何对树的变更，都是从母树单向同步到子树</li>
<li>没有查询条件的时候：在视图上，显示母树，隐藏子树</li>
<li>有查询条件的时候：从母树同步数据给子树或者计算子树；在视图上，隐藏母树，显示子树</li>
</ul>
</li>
</ul>
</li>
<li>在数据中设定一个虚拟的根节点，其id为0
<ul>
<li>在计算和判断树状数据的时候，有非常大的辅助作用</li>
</ul>
</li>
<li>缓存由树状数据转化而来的一维数据，作为副本
<ul>
<li>（最好在任意一处代码都能获取到这些数据）</li>
<li>数据副本多了也会带来副作用，增加了要考虑的问题：要不要更新这个数据，什么时候更新这个数据等等</li>
</ul>
</li>
<li>任1个节点的parentId和childrenIds，最好都在“此某1个节点”用字段记录下来</li>
</ul>
<h2 id="宏观的实现思路"><a class="header-anchor" href="#宏观的实现思路"></a>宏观的实现思路</h2>
<ul>
<li>还是要传给 Ant Design Vue 的 a-table 的部分模块：（Element-ui同理）
<ul>
<li>表示整体结构的数据：树状数据，树中每个节点包括视图的所有状态相关的字段</li>
<li>展开收起树形中的节点的交互还是交给 a-table 来处理和维护：a-table 组件接收的 expandedRowKeys 字段</li>
</ul>
</li>
<li>需要自己实现和从 a-table 接管的部分模块：（即“二次开发”）
<ul>
<li>编写 slot 取缔 a-table 的所有视图上的复选框的状态显示和事件处理</li>
<li>自行维护并计算一份“全树中的目前被勾选的节点的id集合”，也就是代表所有复选框的状态
<ul>
<li>这个集合需要一直保持更新：事件触发计算，然后更新到“树状数据”每个节点的对应字段，以引发视图更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>综上2点</code>：只是使用了 a-table 的基础样式、节点展开控制样式。其他都是自行计算、控制，即所谓的“二次开发”的部分。</p>
<ul>
<li>其中比较困难的点有： （单个组件代码规模越大，越难进行抉择）
<ul>
<li>状态更新的事务安排：确定要做什么，确定涉及到的树节点，确定要做的顺序</li>
<li>折返成本大：这个组件集成了很多的功能要求。如果一开始没有梳理清楚，切换方案折返重做的成本很大</li>
<li>需要花费大量开发自测的时间检查实现的完整程度</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 项目总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> 树形 </tag>
            
            <tag> 复选框 </tag>
            
            <tag> shu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【9】收获总结]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-summary/</url>
      <content type="html"><![CDATA[<p>Vue2源码系列终于要完结了。最后总结一下阅读过程中的一些收获，主要分为4个方面：</p>
<p>“架构设计方面”、“目录和模块设计”、“编程具体模块的实现”、“怎么看源码”</p>
<a id="more"></a>
<h2 id="架构设计方面"><a class="header-anchor" href="#架构设计方面"></a>架构设计方面</h2>
<h3 id="目录和模块设计"><a class="header-anchor" href="#目录和模块设计"></a>目录和模块设计</h3>
<p>浏览器端的 Vue.js 和服务端的 Vue.js 所共享的模块抽象成一个单独的目录。这大概就是“动静分离”吧，本文后面还有讲到。</p>
<ul>
<li>路径别名：这里找了一个文件专门来放置全局的路径别名。一般都是和<code>path.resolve</code>模块结合使用。</li>
<li>core模块+分层结构：其实vue就是在core模块完成了初始化，然后导出到不同的模块进行一层一层对vue的修饰和包装。这种项目结构看源码会浪费很多时间抓不到重点。所以大致列举一下在不同的文件增加了什么属性就行了。
<ul>
<li>一般只看index的文件就可以了，其他的无非是该层内的修饰和资源配置。</li>
</ul>
</li>
</ul>
<h2 id="编程具体模块的实现"><a class="header-anchor" href="#编程具体模块的实现"></a>编程具体模块的实现</h2>
<blockquote>
<p>src/core/instance/index.js</p>
</blockquote>
<p><strong>【1】构造函数为什么不直接用class：</strong></p>
<p>在这里，我们终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 <code>new Vue</code> 去实例化它。</p>
<p>有些同学看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 <code>xxxMixin</code> 的函数调用，并把 <code>Vue</code> 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法（这里具体的细节会在之后的文章介绍，这里不展开），Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。<strong>这样是容易把代码拆分到不同的文件中。</strong></p>
<p>一方面需要拓展原型上的方法，另一方面，后面利用<code>initGlobalAPI</code>来拓展这个函数的静态属性或者静态方法。</p>
<p><strong>【2】清晰的初始化大函数划分</strong>：</p>
<p>在initMixin里面，我们能看到这种清晰的结构：</p>
<pre><code class="language-js">initLifecycle(vm);
initEvents(vm);
initRender(vm);
callHook(vm, 'beforeCreate');
initInjections(vm); // resolve injections before data/props
initState(vm);
initProvide(vm); // resolve provide after data/props
callHook(vm, 'created');
</code></pre>
<p>实际上还是需要这些大函数相互之间没有数据上的关联或者耦合，否则这个逻辑很难debug。</p>
<p><strong>【3】JSON化</strong></p>
<pre><code class="language-js">// scripts/config.js
const builds = {
  // ...一个大JSON
}
function genConfig() {}
const getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)
</code></pre>
<p>为什么有这样的设计呢？就是一开始先定义好了<code>builds</code>的格式就是JSON的，其他的代码围绕它做配置。</p>
<p>这里<code>genConfig</code>其实就是把<code>builds</code>处理成Rollup能接受的JSON参数的格式。</p>
<p><strong>【4】装饰者模式</strong></p>
<pre><code class="language-js">const mount = Vue.prototype.$mount // 暂存keeper，来自src/platforms/web/runtime/index.js
Vue.prototype.$mount = function () {
  // 各种判断
  return mount.call(this, el, hydrating)
}
</code></pre>
<p><strong>【5】函数参数的重载：</strong></p>
<pre><code class="language-js">function createElement (context, tag, data, children, normalizationType) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
</code></pre>
<p>这里参数根据data的情况，把所有“对参数位的捕获”往后挪。</p>
<p><strong>【6】一个简单好用的once函数</strong></p>
<pre><code class="language-JavaScript">// Ensure a function is called only once.
export function once (fn: Function): Function {
  let called = false
  return function () {
    if (!called) {
      called = true
      fn.apply(this, arguments)
    }
  }
}
</code></pre>
<p><strong>【7】createPatchFunction 的柯里化实现“动静分离” #一些启发</strong> 从我的文章摘抄过来</p>
<p>我们可以思考一下为何 Vue 源码绕了这么一大圈，把相关代码分散到各个目录：</p>
<p>前面也介绍过，<code>patch</code> 是平台相关的，在 Web 和 Weex 环境，它们把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。**因此每个平台都有各自的 <code>nodeOps</code> 和 <code>modules</code>，**它们的代码需要托管在 <code>src/platforms</code> 这个大目录下。</p>
<p>而不同平台的 <code>patch</code> 的主要逻辑部分是相同的，所以这部分公共的部分托管在 <code>core</code> 这个大目录下。</p>
<p>综上所述：<strong>差异化部分</strong>只需要通过参数来区别，这里利用闭包实现函数柯里化，通过 <code>createPatchFunction</code> 把差异化参数提前传入固化。好处是：</p>
<p>1先在外部<strong>判断</strong>需要什么类型的patch，然后选择把一些依赖通过参数传递进去。而不是在patch函数内部实现一大堆<strong>判断逻辑</strong></p>
<p>2不用每次调用 <code>patch</code> 的时候都传入 <code>nodeOps</code> 和 <code>modules</code>。</p>
<h2 id="怎么看源码"><a class="header-anchor" href="#怎么看源码"></a>怎么看源码</h2>
<blockquote>
<p>找到学习路线，别人已经分好的模块。还有别人先探知过程中会执行那些函数，都是脏活累活。</p>
</blockquote>
<p>vue npm包dist几个没有压缩的文件还有src文件，可能是为了方便调试的，这几个文件内容差别不大。</p>
<p>npm包怎么被一个项目所引用，知识要具备。然后打一个debugger，断点会有调用栈call stack信息的，点击是能够翻阅怎么调用进来的。</p>
<p>区分阶段：比如搜到 <code>createCompiler</code>，然后打断点打印 <code>code.render</code>，这是表示解析ast之后的字符串。ast生成过程可以先不管细节。src/instance/render-helpers/index.js可以看到压缩前后的函数名对应关系。</p>
<h4 id="看辅助函数-而且该辅助函数if-else逻辑比较多-的技巧"><a class="header-anchor" href="#看辅助函数-而且该辅助函数if-else逻辑比较多-的技巧"></a>看辅助函数(而且该辅助函数if else逻辑比较多)的技巧</h4>
<p>翻开test目录，看该辅助还是的“单元测试”</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【8-6】指令]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-66-directive/</url>
      <content type="html"><![CDATA[<p>“指令”这部分源码，也容易看得晕头转向，这部分代码贯穿了整个核心流程，是没有独立出来的。而常见的指令v-bind、v-on、v-model、v-if v-show等等都是通过这套机制来实现的。</p>
<p>这篇文章干货不多，主要是再对前面已经讲过原理的各种指令的实现有一个宏观的认识。</p>
<a id="more"></a>
<h2 id="updatedirectives的核心是-update函数-知道标题该结论就行了"><a class="header-anchor" href="#updatedirectives的核心是-update函数-知道标题该结论就行了"></a>updateDirectives的核心是<code>_update</code>函数 #知道标题该结论就行了</h2>
<p>Vue.directive  ==&gt;   Vue.options.directives</p>
<p>在 patch 过程中，会调用 createElm ==&gt; invokeCreateHooks 在调用cbs.create的时候，调用预设的updateDirectives</p>
<p>在 updateDirectives 方法中，如果虚拟DOM的 data.directives 属性存在，会调用内部方法 _update 。该方法比较很重要，自定义指令提供的钩子都在该函数中进行处理，下面分步详细解读该函数。</p>
<p><strong>指令的这几个生命周期钩子，调用时机全都在这个<code>_update</code>函数中。</strong> 生命周期就不多说，官方文档已经描述了其实现效果，照着实现就行了。</p>
<ul>
<li><code>v-bind 普通属性 + class + style</code> #都是老老实实增删改 #由钩子函数带动</li>
<li>v-on： 之前关于事件系统的文章已经有说明了</li>
<li>v-model：也很简单，能扣的细节，已经在之前的文章中讲过了</li>
<li>v-if v-show：如下</li>
</ul>
<h2 id="v-if-v-show"><a class="header-anchor" href="#v-if-v-show"></a>v-if v-show</h2>
<blockquote>
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；v-show 就简单得多：不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
</blockquote>
<ul>
<li>带有 v-if 指令的模板会编译成根据数据源真假值来调用具体辅助方法的渲染函数，v-if 会根据数据源真假值来决定<strong>是否渲染该节点</strong>。</li>
<li>v-show 指令根据表达式之真假值，切换元素的 display CSS 属性。当条件变化时该指令触发过渡效果。
<ul>
<li>在调用处理指令的钩子函数 updateDirectives 时，v-show 指令有所不同，<strong>相当于 v-show 内部实现了自定义指令的 bind、update、unbind 三个阶段的钩子函数。</strong></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【8-5】keep-alive]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-65-keep-alive/</url>
      <content type="html"><![CDATA[<p>keep-alive是vue的内置组件，如果是用户想要自己实现一个类似keep-alive的组件是不可能的，因为需要vue的主干逻辑配合该组件的实现。</p>
<p>keep-alive的作用是缓存的是子组件的vnode，而其本身的render返回的也是vnode。</p>
<p>keep-alive的原理依赖slot的机制。</p>
<a id="more"></a>
<ul>
<li>keep-alive表现出来的特点：
<ul>
<li><strong>它的作用就是缓存vnode！！！！！！！！！！！！！！！！！</strong></li>
<li><strong>只处理第一个子节点</strong>
<ul>
<li><code>&lt;keep-alive&gt;</code> 是用在其一个直属的子组件“被切换”的情形。</li>
</ul>
</li>
<li>易知其原理有一部分是基于slot等的原理</li>
<li>( 是抽象组件 )</li>
<li>api
<ul>
<li><code>this.cache</code> 和 <code>this.keys</code>：去缓存已经创建过的 <code>vnode</code></li>
<li>props
<ul>
<li>include 和 exclude</li>
<li>还定义了 max，它表示缓存的大小。因为我们是缓存的 vnode 对象，它也会持有 DOM，当我们缓存很多的时候，会比较占用内存，所以该配置允许我们指定缓存大小。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从用法可以看出，其原理无非就是对vnode数组的一些处理。这就不需要死记硬背其工作流程了。</p>
<p>【1】实际上，考虑了 MVVM“重新渲染”的过程中，需要重新执行keep-alive的逻辑。所以keep-alive有必要实现render函数，已实现更加复杂的函数逻辑。</p>
<ul>
<li><code>&lt;keep-alive&gt;</code> 作为组件配置options直接实现了 <code>render</code> 函数
<ul>
<li>而不是我们常规的template模板描述视图的方式</li>
<li>执行 <code>&lt;keep-alive&gt;</code> 组件渲染的时候，就会执行到这个 <code>render</code> 函数。</li>
</ul>
</li>
</ul>
<p>【2】另外一个特点就是依赖slot等等的机制来获取：这里面首次渲染和缓存渲染的逻辑是不一样的：</p>
<h3 id="slot的首次渲染"><a class="header-anchor" href="#slot的首次渲染"></a>slot的首次渲染</h3>
<p>对我们的例子，初始化渲染 <code>A</code> 组件以及第一次点击 <code>switch</code> 渲染 <code>B</code> 组件，都是首次渲染。</p>
<p>除了在 <code>&lt;keep-alive&gt;</code> 中建立缓存，和普通组件渲染没什么区别。</p>
<h3 id="slot的缓存渲染"><a class="header-anchor" href="#slot的缓存渲染"></a>slot的缓存渲染</h3>
<p>当我们从 <code>B</code> 组件再次点击 <code>switch</code> 切换到 <code>A</code> 组件，就会命中缓存渲染：</p>
<ul>
<li>(keep-alive这个组件作为父组件)patch 走 patchVnode
<ul>
<li><code>prepatch</code> 的钩子函数核心是 updateChildComponent
<ul>
<li>需要对自己的 <code>children</code>，也就是这些 <code>slots</code> 做重新解析，
<ul>
<li>并触发 <code>&lt;keep-alive&gt;</code> 组件实例 <code>$forceUpdate</code> 逻辑，也就是重新执行 <code>&lt;keep-alive&gt;</code> 的 <code>render</code> 方法</li>
<li>这个时候如果它包裹的第一个组件 <code>vnode</code> 命中缓存，则直接返回缓存中的 <code>vnode.componentInstance</code></li>
<li>( 在我们的例子中就是缓存的 <code>A</code> 组件 )</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>接着又会执行 <code>patch</code> 过程，再次执行到 <code>createComponent</code> 方法
<ul>
<li>（这个时候 <code>isReactivated</code> 为 true，并且在执行 <code>init</code> 钩子函数的时候不会再执行组件的 <code>mount</code> 过程了。这也就是被 <code>&lt;keep-alive&gt;</code> 包裹的组件在有缓存的时候就不会在执行组件的 <code>created</code>、<code>mounted</code> 等钩子函数的原因了）</li>
<li>在 <code>isReactivated</code> 为 true 的情况下会执行 <code>reactivateComponent</code> 方法
<ul>
<li>最后通过执行 <code>insert(parentElm, vnode.elm, refElm)</code> 就把缓存的 DOM 对象直接插入到目标元素中，完成渲染。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a class="header-anchor" href="#生命周期"></a>生命周期</h2>
<p>上面过程大概解释了keep-alive运作过程中哪些生命周期钩子是否触发：</p>
<p>在 <code>patch</code> 过程中对于已缓存的组件不会执行 <code>mounted</code>，所以不会有一般的组件的生命周期函数但是又提供了 <code>activated</code> 和 <code>deactivated</code> 钩子函数。</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【8-4】slot和slotScope]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-64-slot/</url>
      <content type="html"><![CDATA[<p>对于同一个组件实例，其 vnode 其实包括其“占位符节点”和“真实节点”，它们是父子节点关系。基于这点知识，再去理解slot等机制并不难。</p>
<p>然后再解释了一下为什么slot和slotScope之流为什么不是响应式的。已经再介绍一下vue3正式登场的v-slot。</p>
<a id="more"></a>
<h2 id="slot的原理-这是2-6之前-之后又略微调整了"><a class="header-anchor" href="#slot的原理-这是2-6之前-之后又略微调整了"></a>slot的原理 #这是2.6之前(之后又略微调整了)</h2>
<p><strong>总结：slot插槽(即传给子组件的props.children)的vnode的生成，已在父组件创建和渲染阶段完成。</strong></p>
<p>可以打印中间过程的代码生成结果，来 <strong>验证</strong> 这个看法：</p>
<p>父组件及其slot代码示例：<code>/* 父组件略 */&lt;h1 slot=&quot;header&quot;&gt;anything&lt;/h1&gt;/* 父组件略 */</code></p>
<pre><code class="language-JavaScript">// 父组件，经编译阶段最终生成的代码：
// _s可不管 _v：createTextVNode
// with(this) { return
_c('div', [_c('app-layout', [_c('h1', {
  attrs: {
    &quot;slot&quot;: &quot;header&quot;
  },
  slot: &quot;header&quot;
}, [_v(_s(title))]), _c('p', [_v(_s(msg))]), _c('p', {
  attrs: {
    &quot;slot&quot;: &quot;footer&quot;
  },
  slot: &quot;footer&quot;
}, [_v(_s(desc))])])], 1)
</code></pre>
<p>子组件代码示例：<code>&lt;slot name=&quot;header&quot;&gt;默认内容&lt;/slot&gt;</code></p>
<pre><code class="language-JavaScript">// 子组件，经编译阶段最终生成的代码：
// 【重要】 _t是renderSlot
// with(this) { return
_c('div', {
  staticClass: &quot;container&quot;
}, [ _c('header', [_t(&quot;header&quot;)], 2),
    _c('main', [_t(&quot;default&quot;, [_v(&quot;默认内容&quot;)])], 2),
    _c('footer', [_t(&quot;footer&quot;)], 2)])
</code></pre>
<h2 id="slotscope的原理-这是2-6之前-之后又略微调整了"><a class="header-anchor" href="#slotscope的原理-这是2-6之前-之后又略微调整了"></a>slotScope的原理 #这是2.6之前(之后又略微调整了)</h2>
<p><strong>总结：把 scopeSlot插槽 作为一个函数保留下来。scopeSlot插槽(即传给子组件占位符的props.children)的vnode的生成，要延迟到子组件的创建阶段</strong></p>
<p>也是打印中间过程生成代码：</p>
<p>父组件：</p>
<pre><code class="language-JavaScript">// with(this) { return
_c('div',
  [_c('child', {
    scopedSlots: _u([{
      key: &quot;default&quot;,
      fn: function(props) {
        return [
          _c('p', [_v(&quot;Hello from parent&quot;)]),
          _c('p', [_v(_s(props.text + props.msg))])
        ]}}])})],1)
</code></pre>
<p>子组件，例如：<code>&lt;slot name=&quot;header&quot; text=&quot;hello&quot; :msg=&quot;msg&quot;&gt;默认内容&lt;/slot&gt;</code></p>
<pre><code class="language-JavaScript">// 【重要】 _t是renderSlot。
// 这里代码简单了很多：
_c('div',
    {staticClass:&quot;child&quot;},
    [_t(&quot;default&quot;,null,
      {text:&quot;Hello &quot;,msg:msg}
    )],
</code></pre>
<h2 id="插槽的数据更新-v2-6之前-：-通常在响应式系统-组件更新-的流程中-非响应式"><a class="header-anchor" href="#插槽的数据更新-v2-6之前-：-通常在响应式系统-组件更新-的流程中-非响应式"></a>插槽的数据更新(v2.6之前)： 通常在响应式系统“组件更新”的流程中 #非响应式</h2>
<blockquote>
<p>vm.$slots：请注意插槽<strong>不是</strong>响应性的。</p>
</blockquote>
<p>首先，先前依靠的是父组件渲染watcher的依赖收集和派发更新。</p>
<p>比如对于slot场景下的父组件：</p>
<ul>
<li>所依赖的data发生变化</li>
<li>(渲染watcher的)派发更新,也就是调用 updateComponent 回调函数</li>
<li><code>__patch__</code>在浏览器环境中就是patch。这里因为是“新旧节点是相似节点”，判断走的是patchVnode</li>
<li>patchVnode
<ul>
<li>i.prePatch ==&gt; updateChildComponent  更新子组件，也<strong>就是更新一下子组件占位符vnode所传入的slot部分</strong>，然后经判断触发子组件forceUpdate！！！也就是调用子组件“渲染watcher.update()”。且更新的子组件的vm.$slots</li>
<li>(后面逻辑已不相关)</li>
</ul>
</li>
</ul>
<p>原理：</p>
<pre><code class="language-JavaScript">// updateChildComponent 中的代码：
  // Any static slot children from the parent may have changed during parent's update. Dynamic scoped slots may also have changed.
  //  In such cases, a forced update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    // renderChildren指的就是 子组件的slot
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );
</code></pre>
<p>我们知道，一般来说都是子组件(即渲染vnode)的vnode先生成好了。但，在这些情况，无论slot(以已有slot vnode的形式)或者是scopeSlot(以函数的形式)，若有更新则会产生flag，在占位符节点的updateChildren阶段(通过计算needsForceUpdate)发现了flag，就会执行<code>vm.$forceUpdate</code>(更新的子组件的vnode)。</p>
<blockquote>
<p>官网：vm.$forceUpdate() ：迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
</blockquote>
<h6 id="slot和其他响应式更新子组件的方式对比-所以为什么说插槽不是响应式"><a class="header-anchor" href="#slot和其他响应式更新子组件的方式对比-所以为什么说插槽不是响应式"></a>slot和其他响应式更新子组件的方式对比 #所以为什么说插槽不是响应式</h6>
<blockquote>
<p>首先一个背景是，react是自顶向下的进行递归更新的，而vue是组件的局部订阅，也就是一般来说，vue父组件渲染watcher相关的更新不会触发子组件的更新。</p>
</blockquote>
<p>而props是响应式的，也就是子组件可以订阅了props的更新。slot这里明显和props的这种方式不一样。</p>
<h2 id="响应式外-特殊情况的处理：也是手动-vm-forceupdate"><a class="header-anchor" href="#响应式外-特殊情况的处理：也是手动-vm-forceupdate"></a>(响应式外)特殊情况的处理：也是手动 vm.$forceUpdate</h2>
<p>比如这个slot用v-if控制，这样针对子渲染watcher的响应式就不管用了。这个时候，子组件patch阶段updateChildComponent会判定<code>hasDynamicScopedSlot</code>为true，去执行vm.$forceUpdate()。</p>
<h2 id="v-slot-v2-6之后"><a class="header-anchor" href="#v-slot-v2-6之后"></a>v-slot v2.6之后</h2>
<p>在编译阶段的变化：调整语法做了点优化，加上语法糖用起来会比较爽一点。</p>
<p>在运行时阶段的变化： <strong>重要</strong></p>
<ul>
<li><code>slot</code> 和 <code>slot-scope</code> 在组件内部被统一整合成了 <code>函数</code></li>
<li><strong>他们的渲染作用域都是 <code>子组件</code>  (forceUpdate将要作用于的组件实例更加准确)</strong></li>
<li>并且都能通过 <code>this.$scopedSlots</code>去访问</li>
</ul>
<h3 id="数据更新时-v-slot的逻辑：-forceupdate将要作用于的组件实例更加准确"><a class="header-anchor" href="#数据更新时-v-slot的逻辑：-forceupdate将要作用于的组件实例更加准确"></a>数据更新时，v-slot的逻辑： forceUpdate将要作用于的组件实例更加准确</h3>
<p>子组件数据更新的情况，没啥好说的。</p>
<ul>
<li>父组件数据更新的情况：
<ul>
<li>因为之前首次构建的时候，执行 <code>_t</code>即<code>renderSlot</code> 函数时，全局的组件渲染上下文是 <code>子组件</code>，那么依赖收集自然也就是收集到 <code>子组件</code>的依赖了。所以在 <code>msgInParent</code> 更新后，其实是直接去触发子组件的重新渲染的</li>
<li>对比 2.5 的版本，这是一个优化：缩短了响应式的逻辑链条。</li>
</ul>
</li>
</ul>
<h2 id="总结v-slot的特点"><a class="header-anchor" href="#总结v-slot的特点"></a>总结v-slot的特点</h2>
<ul>
<li>记一下插槽名也是可以动态的 这个事实</li>
<li>解构插槽 Prop
<ul>
<li>作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【8-2】v-model]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-62-v-model/</url>
      <content type="html"><![CDATA[<p>v-model相关的源码，其实极其复杂。这里主要用文本来概括流程，并且挖掘一些特别的点。</p>
<p>可以划分为“v-model 在控件的实现”和“v-model 在自定义组件的实现”两部分。</p>
<a id="more"></a>
<h2 id="双向绑定：还是要依赖-数据劫持-来实现"><a class="header-anchor" href="#双向绑定：还是要依赖-数据劫持-来实现"></a>双向绑定：还是要依赖 数据劫持 来实现</h2>
<p><strong>原理：</strong> 拦截监听数据变化，更新到input控件上 + 监听input控件的键入事件，同步到数据上。</p>
<ul>
<li><a href="https://www.zhihu.com/question/271270489" target="_blank" rel="noopener">现代前端框架(例如Vue)为什么选择『数据劫持』实现数据双向绑定?</a> <strong>【这个问题不懂也没关系】</strong>
<ul>
<li><strong>能实现双向绑定的方式有很多，</strong>
<ul>
<li>比如ng就是脏值检测，</li>
<li>而vue还是数据劫持。</li>
<li>KnockoutJS基于<strong>观察者模式</strong>，</li>
<li>Ember基于<strong>数据模型</strong>。</li>
<li><a href="https://www.zhihu.com/question/44724640" target="_blank" rel="noopener">详细代码见知乎 《如何监测js中变量的变化/如何实现MVVM库的数据绑定》  可不看</a></li>
<li><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631801840069098" alt="寻找蓝海96总结的能实现双向绑定的方法 --脑图 必看"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="先来总结一下v-model的特点"><a class="header-anchor" href="#先来总结一下v-model的特点"></a>先来总结一下v-model的特点</h2>
<blockquote>
<p>在 Vue3之后，v-model这个模块的语法更加灵活而且便捷，基本上只是增加了上层封装而已。</p>
</blockquote>
<ul>
<li>v-model的本质就是语法糖，但是运行时也做了一些微小的优化</li>
<li>v-model即可以支持原生表单元素，也可以支持自定义组件。</li>
<li>对于自定义组件的v-model，我们是可以配置子组件接收的 <code>prop</code> 名称，以及派发的事件名称。</li>
</ul>
<h2 id="v-model-在控件的实现"><a class="header-anchor" href="#v-model-在控件的实现"></a>v-model 在控件的实现</h2>
<p>这个流程其实就是很复杂的数据存取。总之，解析语法糖，转译之后的效果：</p>
<pre><code class="language-JavaScript">&lt;input
  v-bind:value=&quot;message&quot;
  v-on:input=&quot;message=$event.target.value&quot;&gt;
</code></pre>
<p>这个转译代码的流程，有时候会添加<code>composing</code>相关的代码到结果中：</p>
<h6 id="v-model还是和单纯-value-input-有区别-比如中文打字到一半还没按空格-v-model不会获取到-而后者会做-预输入延迟更新-即延迟触发input"><a class="header-anchor" href="#v-model还是和单纯-value-input-有区别-比如中文打字到一半还没按空格-v-model不会获取到-而后者会做-预输入延迟更新-即延迟触发input"></a>v-model还是和单纯“value + @input”有区别，比如中文打字到一半还没按空格，v-model不会获取到，而后者会做“预输入延迟更新”，即延迟触发input</h6>
<p>总结：onCompositionStart + onCompositionEnd + 自定义e.target.composing来控制是否手动触发input事件</p>
<ul>
<li>【-----------中文打字到一半还没按空格--------------------】
<ul>
<li>onCompositionStart触发，令e.target.composing = true</li>
<li>【正常打入中文】</li>
<li>onCompositionEnd触发，发现true才往下走，先重置掉e.target.composing，然后手动触发一个假input事件并dispatchEvent(e)</li>
<li>若没有“因为e.target.composing的flag而return终止”，然后引发 message = $event.target.value</li>
<li><strong>【官网】</strong> 对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 <code>input</code> 事件。</li>
</ul>
</li>
</ul>
<h2 id="v-model-在自定义组件的实现"><a class="header-anchor" href="#v-model-在自定义组件的实现"></a>v-model 在自定义组件的实现</h2>
<p>又是一些无趣的逻辑处理。在这里就不贴流程了。v-model 在自定义组件的特点是“所在的子组件还能指定哪个属性和哪个事件”：</p>
<pre><code class="language-JavaScript">{
  model: {
    prop: 'msg',
    event: 'change'
  }
}
</code></pre>
<p>无非就是执行到 transformmodel的时候：     (也就是在 createComponent的时候)</p>
<pre><code class="language-JavaScript">function transformModel (options, data) {
  var prop = (options.model &amp;&amp; options.model.prop) || 'value';
  var event = (options.model &amp;&amp; options.model.event) || 'input'
  // ......
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【8-1】event]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-61-event/</url>
      <content type="html"><![CDATA[<p>event即事件系统，这部分源码让人看得头皮发麻。但是理解之后发现这部分的逻辑是很重要的，在这里试着用几句话概括流程。</p>
<p>事件系统分为“DOM 事件”和“自定义事件”，分别为两套处理流程，先有个大概的印象即可。</p>
<a id="more"></a>
<p>首先会有编译的过程，按照惯例其源码就略过了。</p>
<pre><code class="language-js">// 父组件生成的 `data` 串为：
{
  on: {&quot;select&quot;: selectHandler}, // 针对组件的自定义事件
  nativeOn: {&quot;click&quot;: function($event) { // 原生事件
      $event.preventDefault();
      return clickHandler($event)
    }
  }
}
// 子组件生成的 `data` 串为：
{
  on: {&quot;click&quot;: function($event) { // 因为渲染节点根节点是原生dom，所以这个也是原生事件
      clickHandler($event)
    }
  }
}
</code></pre>
<p>所谓父组件，其实就是“占位符节点”。而子组件，就是该组件<code>.vue</code>文件中所声明的组件。</p>
<h2 id="dom-事件"><a class="header-anchor" href="#dom-事件"></a>DOM 事件</h2>
<p>**DOM 事件(也就是相对而言的原生事件绑定)：在 patch过程中的创建阶段和更新阶段执行 updateDOMListeners 注册 DOM 事件。**代码例子如：</p>
<ul>
<li>'&lt;child @select=“selectHandler” @click.native.prevent=“clickHandler”&gt;`</li>
<li><code>&lt;button @click=&quot;clickHandler($event)&quot;&gt;' + 'click me' + '&lt;/button&gt;</code>  in child component</li>
</ul>
<p><strong>无论是对于占位符节点和 渲染节点，它们其实事件都是绑定到同一个真实的dom上。因为渲染节点的逻辑先执行，所以它的会先绑定。</strong> 在例子中也就是<code>&lt;button&gt;</code>的<code>@click</code> + <code>&lt;child&gt;</code>的<code>@click.native</code></p>
<p>这个机制的代码流程的处理真的太恶心了，就不贴出来了。大概用文字总结一下，在debug的时候大概知道是属于哪里的问题。</p>
<ul>
<li><strong>在 patch过程中的创建阶段和更新阶段执行 updateDOMListeners 注册 DOM 事件。</strong>
<ul>
<li>遍历 <code>on</code> 去添加事件监听，遍历 <code>oldOn</code> 去移除事件监听</li>
<li>event = normalizeEvent(name)：根据我们的的事件名的一些特殊标识（之前在 <code>addHandler</code> 的时候添加上的）区分出这个事件是否有 <code>once</code>、<code>capture</code>、<code>passive</code> 等修饰符。</li>
<li>按照计算结果更新所绑定的回调。这里vue有一个巧妙的机制，能够减小绑定机制的性能消耗，并且防止内存溢出。</li>
</ul>
</li>
</ul>
<h3 id="vue优化js-dom事件绑定的机制"><a class="header-anchor" href="#vue优化js-dom事件绑定的机制"></a>vue优化js DOM事件绑定的机制</h3>
<ul>
<li><strong>事件回调在第一次只添加一次，之后仅仅去修改它的回调函数的引用指向。其实就是invoke函数创建好了，知道它每次用到invoke.fns，如果更新则更新invoke.fns就好了</strong>
<ul>
<li>【对于第一次执行】执行 <code>cur = on[name] = createFnInvoker(cur)</code> 方法去创建一个回调函数，然后在执行 <code>add(event.name, cur, event.once, event.capture, event.passive, event.params)</code> 完成一次事件绑定</li>
<li>createFnInvoker：返回一个函数，它持有一个fns属性，并且它本身的逻辑就是遍历执行这些函数</li>
<li>【对于第一次之后执行】：只需要更改 <code>old.fns = cur</code> 把之前绑定的 <code>involer.fns</code>  赋值为这一回新的回调函数即可，并且 通过 <code>on[name] = old</code> 保留引用关系</li>
<li>根据相关预设移除事件回调：<code>updateListeners</code> 函数的最后遍历 <code>oldOn</code> 拿到事件名称，判断如果满足 <code>isUndef(on[name])</code>，则执行 <code>remove(event.name, oldOn[name], event.capture)</code> <strong>去移除旧vnode相关的事件回调。</strong></li>
<li>(createFnInvoker源码那里有clone一下invoker.fns的，因为invoker.fns它们不是马上执行，后面还会篡改invoker.fns属性再用于设置回调函数，所以先转移到另外一个变量来持有)</li>
</ul>
</li>
</ul>
<p>源码就不贴了，这段逻辑可以简化为示例代码：</p>
<pre><code class="language-JavaScript">  // on: {'click': invoker持有fns, 'mouseover': invoker持有fns }
  for (name in on) {
    if ('初始化组件的事件') {
    cur = on[name] = /* 新创建的invoke并持有fns。 createFnInvoker 在这里执行 */
      domAddEventListener(event.name, cur, event.capture, event.passive, event.params); // [name]作为绑定到dom上的事件回调，是会调用到 它上面的fns的。
    } else if (cur !== old) { // else if 更新组件的事件
      old.fns = cur;
      on[name] = old; // 不重新addEventListener到DOM上，通过这2行更新fns来更新要执行的回调
    }
  }
</code></pre>
<h3 id="withmacrotask技法"><a class="header-anchor" href="#withmacrotask技法"></a>withMacroTask技法</h3>
<p>这个技法其实在vue源码中出现了多次。类似的还有withCommit之类的，都是高阶函数。</p>
<p>既然是事件回调的处理，肯定有封装对原生api的调用。<code>add</code> 和 <code>remove</code> 的逻辑很简单，就是实际上调用原生 <code>addEventListener</code> 和 <code>removeEventListener</code>，并根据参数传递一些配置，注意这里的 <code>hanlder</code> 会用 <code>withMacroTask(hanlder)</code> 包裹一下，它的定义在 <code>src/core/util/next-tick.js</code> 中：</p>
<pre><code class="language-js">export function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true // 这个变量在对应nextTick相关的闭包里面
    const res = fn.apply(null, arguments)
    useMacroTask = false
    return res
  })
}
</code></pre>
<p>实际上就是强制：如果在 DOM 事件的回调函数执行期间如果修改了数据，那么这些数据更改<strong>推入的队列</strong>会被当做 <code>macroTask</code> 在 <code>nextTick</code> 后执行。</p>
<p>注意原生dom事件本来就是属于宏任务。</p>
<h2 id="自定义事件"><a class="header-anchor" href="#自定义事件"></a>自定义事件</h2>
<p>“DOM 事件” vs “自定义事件”。一开就明白了对立的关系。</p>
<p>自定义事件的具体工作流程好像没挖出什么东西，所以就不贴流程逻辑了。</p>
<pre><code class="language-js">function add (event, fn, once) {
  if (once) {
    target.$once(event, fn) // 即Vue.prototype.$once
  } else {
    target.$on(event, fn) // 即Vue.prototype.$on
  }
}

function remove (event, fn) {
  target.$off(event, fn) // 即Vue.prototype.$off
}
</code></pre>
<blockquote>
<p>到了vue3，vue的事件中心这部分代码被从vue核心模块中抽出。</p>
</blockquote>
<p><strong>自定义事件实际上是利用 Vue 定义的事件中心</strong>，简单分析一下它的实现： Vue.prototype.$on/$once/$off/$emit</p>
<p>熟悉发布订阅设计模式的朋友，看函数签名，大概就知道其内部是怎么实现的了。对于一个<code>vm</code>，用<code>vm._events</code>存储即可。</p>
<ul>
<li>举一反三：<strong>父子组件 emit on通信的原理：本质还是利用了事件中心发布订阅</strong> 例子说明
<ul>
<li><code>vm.$emit</code> 是给当前的 <code>vm</code> 上派发的实例
<ul>
<li>之所以我们常用它做父子组件通讯，是因为它的回调函数的定义是在父组件中</li>
<li>对于我们这个例子而言，当子组件的 <code>button</code> 被点击了，它通过 <code>this.$emit('select')</code> 派发事件，</li>
</ul>
</li>
<li>那么子组件的实例就监听到了这个 <code>select</code> 事件，并执行它的回调函数——定义在父组件中的 <code>selectHandler</code> 方法，这样就相当于完成了一次父子组件的通讯。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<ul>
<li>Vue 支持 2 种事件类型，原生 DOM 事件和自定义事件，它们主要的区别<strong>在于添加和删除事件的方式不一样</strong></li>
<li><strong>自定义事件的派发是往当前组件实例上派发，但是可以利用在父组件环境定义回调函数来实现父子组件的通讯。</strong></li>
<li>另外要注意一点，只有组件节点才可以添加自定义事件，并且添加原生 DOM 事件需要使用 <code>native</code> 修饰符；而普通元素使用 <code>.native</code> 修饰符是没有作用的，也只能添加原生 DOM 事件。</li>
<li>跟 react 事件系统还是有挺多不一样的地方，比如 react会有事件池的概念，回收利用event对象。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【7】数据劫持使用Proxy的优势]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-5-proxy/</url>
      <content type="html"><![CDATA[<p>Proxy，与其说是代理，还不如说代理是基于<strong>拦截</strong>的，<strong>在功能定位上，和defineProperty是不一样的</strong>。只是恰好Proxy覆盖了defineProperty的getter和setter两个api。</p>
<a id="more"></a>
<h3 id="导论-要看看"><a class="header-anchor" href="#导论-要看看"></a>导论 #要看看</h3>
<blockquote>
<p>vue双向绑定也依靠数据劫持：引用前文：能实现双向绑定的方式有很多，比如ng就是脏值检测，而vue还是数据劫持。KnockoutJS基于观察者模式的双向绑定，Ember基于数据模型的双向绑定。</p>
</blockquote>
<ul>
<li>所谓数据劫持，指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。
<ul>
<li>比较典型的是 <code>Object.defineProperty()</code></li>
<li>ES6 中新增的 <code>Proxy</code> 对象。</li>
<li>【可忽略】另外还有已经被废弃的 <code>Object.observe()</code>，废弃的原因正是 <code>Proxy</code> 的出现，因此这里我们就不继续讨论这个已经被浏览器删除的方法了。<a href="https://juejin.im/post/5e6cdf25e51d4526f16e6294#heading-18" target="_blank" rel="noopener">用Proxy实现Object.obserse的效果</a></li>
</ul>
</li>
</ul>
<h3 id="proxy和reflect-在数据劫持方面的知识-作为基础"><a class="header-anchor" href="#proxy和reflect-在数据劫持方面的知识-作为基础"></a>Proxy和Reflect  在数据劫持方面的知识 #作为基础</h3>
<ul>
<li>(首先，Reflect的API和Proxy的是对应的，这不是偶然，在js里面，Reflect就是Proxy的一个小跟班)</li>
<li>Reflect  ：和其他语言中的Reflect“被提出的意义”有点不同
<ul>
<li>提出原因： Reflect 的主要作用就是当你拦截重写这些方法的时候，让你能够<strong>很方便</strong>调用原方法<code>Reflect.xxxx(...arguments)</code>。js 语言内置的 Reflect 对象上的函数是<strong>为 Proxy 准备</strong>的，Proxy 的 handler 的各种 trap 分别对应 Reflect 上的同名方法。（这也是为什么与 Proxy 无关的反射相关特性将不会放到 Reflect 对象上。）  <a href="https://www.zhihu.com/question/276403215" target="_blank" rel="noopener">来自知乎hex大佬</a></li>
<li>特点1： 把对象方法和对象解耦。把对象操作都变成了函数式。</li>
<li>特点2： 填补Object API的<strong>不合理设计</strong>。以前抛出异常的操作，变成返回false。</li>
</ul>
</li>
</ul>
<h3 id="评价vue2数据劫持这种方式-主要-vs-reflect：-更健全更强大的拦截"><a class="header-anchor" href="#评价vue2数据劫持这种方式-主要-vs-reflect：-更健全更强大的拦截"></a>评价vue2数据劫持这种方式 主要 vs reflect：  更健全更强大的拦截</h3>
<ul>
<li>Proxy，与其说是代理，还不如说代理是基于<strong>拦截</strong>的，<strong>在功能定位上，和defineProperty是不一样的</strong>。只是恰好Proxy覆盖了defineProperty的getter和setter两个api。
<ul>
<li>我们可以这样认为，Proxy提供比较健全的<strong>拦截</strong>机制</li>
<li>问：Proxy 也是需要递归遍历的吧，它只能代理一层对象？    答:需要。但是不需要一开始就递归遍历，啥时候触发了深层对象的getter，啥时候对它进行一次 observed 即可。   <a href="https://juejin.im/post/5da29a87518825094e37301c" target="_blank" rel="noopener">via</a></li>
</ul>
</li>
</ul>
<p><strong>Object.defineProperty的缺点：</strong> 劫持机制不太完整：</p>
<ul>
<li>1 拦截数组的变化不太方便
<ul>
<li>拦截直接修改数组元素：因为性能而在vue中放弃实现 <a href="https://juejin.im/post/5da29a87518825094e37301c" target="_blank" rel="noopener">只是性能问题</a></li>
<li>defineProperty无法监听push等数组方法：hack方法就是“数组变异”：本质，还是需要重写这些方法</li>
</ul>
</li>
<li>2 (get和set)劫持的是 对象的属性， 而不是整个对象。</li>
</ul>
<p>以上缺点，Proxy都没有。</p>
<p><strong>Proxy的缺陷：</strong></p>
<p>1 浏览器支持不足，IE全军覆没。</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【6】数据代理]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-4-data-proxy/</url>
      <content type="html"><![CDATA[<p>经过对概念的区分，我认为：数据代理，其原理是数据劫持。数据代理的原理是最简单的。</p>
<a id="more"></a>
<h2 id="数据代理-其原理是数据劫持"><a class="header-anchor" href="#数据代理-其原理是数据劫持"></a>数据代理，其原理是数据劫持</h2>
<p><strong>实现效果</strong>：让 <code>this['某属性']</code> 代理 <code>this._data['某属性']</code></p>
<p><strong>原理：</strong> 数据劫持。可以选择去使用 <code>Object.defineProperty</code> api。</p>
<p>我们可以在Vue的构造函数中执行一个 <a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js" target="_blank" rel="noopener"><code>_proxy</code> 函数</a>。</p>
<pre><code class="language-JavaScript">_proxy.call(this, options.data);/*构造函数中*/

function _proxy (data) {
    const that = this;
    Object.keys(data).forEach(key =&gt; {
        Object.defineProperty(that, key, {
            configurable: true,
            enumerable: true,
            get: function proxyGetter () {
                return that._data[key];
            },
            set: function proxySetter (val) {
                that._data[key] = val;
            }
        })
    });
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【5】异步更新和nextTick的原理]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-3-next-tick/</url>
      <content type="html"><![CDATA[<p>nextTick这个api，并不是直接就帮你发起微任务的，只不过是把你传进来的回调加入到微任务的回调数组中，即作为一部分。</p>
<a id="more"></a>
<p><img src="https://cloud.az22c.top/vue_next-tick.png-az22cgithub" alt="vue_next-tick"></p>
<h2 id="异步更新的原理"><a class="header-anchor" href="#异步更新的原理"></a>异步更新的原理</h2>
<p>(经历响应式原理的派发更新)在每个watcher的update函数里面，主要就是 <code>queueWatcher(this)</code>。在同一个nextTick里面，对这些watcher去掉重复多余的。然后走<code>nextTick(flushSchedulerQueue)</code>。也就是尽量作为微任务的一部分去执行 flushSchedulerQueue。</p>
<ul>
<li>flushSchedulerQueue
<ul>
<li>一开始基于id来排序，是为了父的在子的前面处理；也为了让用户设置的 watcher 排在 render watcher的前面</li>
<li>【核心】然后循环遍历，挨个执行 watcher.before (这里有执行 beforeUpdate钩子函数)    和 watcher.run
<ul>
<li>watcher.run会走一个 <code>getAndInvoke(回调的逻辑)</code>。
<ul>
<li>对于 渲染watcher，这个回调参数为空，其实走的是 <code>watcher.get() === updateComponent回调函数</code>，也就是patch；</li>
<li>对于用户设置的wacther回调，才有这个回调。</li>
<li><strong>也就是用户设置的watch回调，和 updateComponent 回调的地位是差不多的。</strong></li>
</ul>
</li>
<li>(在 watcher.run的过程，有可能会再执行更新 <code>queueWatcher(this)</code>)(也就是还是更新「改变数据」这个流程的watcher的数组，比如有时候是插队) 【面试的时候不用答出来】</li>
</ul>
</li>
<li>调用updated等生命周期钩子</li>
<li>【重置数据】</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p>派发更新就是当数据发生改变后，通知所有订阅了这个数据变化的 watcher 执行 update。
对于渲染watcher，派发更新的工作是把所有要执行 run方法 的 watcher 推入到队列中，在 nextTick函数执行的时候执行 flushSchedulerQueue，简而言之就是各个渲染watcher的回调。</p>
<h2 id="nexttick的原理"><a class="header-anchor" href="#nexttick的原理"></a>nextTick的原理</h2>
<p>定义在src/core/util/next-tick.js中。</p>
<pre><code class="language-JavaScript">function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() =&gt; {
    if (cb) { // 并且try catch
        cb.call(ctx)
    } else if (_resolve) { _resolve(ctx) } // 这个是处理 Promise的情况的
  })
  if (!pending) {
    pending = true
    if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() }
  }
  // $flow-disable-line
  if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise(resolve =&gt; { _resolve = resolve })
  }
}
</code></pre>
<p><strong>nextTick这个api，并不是直接就帮你发起微任务的，只不过是把你传进来的回调加入到微任务的回调数组中，即作为一部分。</strong>  当不再 pending 的时候发起一个异步回调去执行 flushCallbacks。</p>
<p>而 flushCallbacks 就是把 callbacks 数组逐个执行。</p>
<ul>
<li>如果是传入回调函数，都放入 callbacks，这个很好理解</li>
<li>如果不是回调函数，就是首先返回一个Promise，然后Promise将在 flushCallbacks 执行的之后都 resolve，这样就会走 Promise.then。</li>
</ul>
<p>效果：也就是可以通过 this.$nextTick(callback) 或者 this.$nextTick.then 拿到最新的data。</p>
<h6 id="反例-但是一定要注意这种反例：-重要"><a class="header-anchor" href="#反例-但是一定要注意这种反例：-重要"></a>【反例】但是一定要注意这种反例： #重要</h6>
<pre><code class="language-JavaScript">methods {
  change() {
    this.$nextTick(() =&gt; { // api+这个回调发起1个nextTick(/**/)
      console.log(this.$refs.msg.innerText) // 【1】间接获取 this.msg， 
    })
    this.msg = 'new Value' // 本身就是响应式的 【2】
    // 响应式的派发更新也能发起1个nextTick(/**/)
  }
}
</code></pre>
<p>首先【1】和【2】都会加入某个异步任务的待执行队列，但是因为【1】先加入队列，所以先执行，所以当时获取的&quot;this.msg&quot;还是旧值，而不是 new Value。</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4-6】响应式原理 之 哪些api是响应式的，哪些不是响应式的]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-24-whether-responsive/</url>
      <content type="html"><![CDATA[<p>《哪些api是响应式的，哪些不是响应式的》：</p>
<p>总结一下 Vue 体系内，哪些api是响应式的，哪些不是响应式的。对于个别原理，如provide inject做出一些详细解释。</p>
<a id="more"></a>
<h2 id="响应式-vs-非响应式"><a class="header-anchor" href="#响应式-vs-非响应式"></a>响应式 vs 非响应式</h2>
<blockquote>
<p>不是响应式的，有些的原理就是利用forceUpdate绕过响应式来实现重新渲染</p>
</blockquote>
<ul>
<li>哪些是响应式的：
<ul>
<li>原理：definedReactive + 渲染watcher、computed watcher、用户watcher (即Dep.target。搜索了源码，结果只有这几种 watcher)</li>
<li>data</li>
<li>props</li>
<li>vuex的state(本质上是data)</li>
<li>vue-router注入的 this.$route：使用mixin在created时机之前调用defineReactive</li>
</ul>
</li>
<li>哪些不是响应式的
<ul>
<li><strong><code>vm.$children</code>需要注意：并不保证顺序，也不是响应式的</strong></li>
<li>官网说了插槽不是响应式的
<ul>
<li>插槽的更新原理基于forceUpdate</li>
<li>keep-alive的更新原理基于插槽</li>
</ul>
</li>
<li>provide inject 【后有介绍】</li>
<li>经过研究，认为 指令 不是响应式的，尤其自定义指令不是响应式的  【具体看指令的源码解析。不涉及任何响应式的代码】</li>
<li><code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。
<ul>
<li>(因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 – 它们还不存在)</li>
<li>用法：这仅作为一个用于直接操作子组件的“逃生舱”</li>
<li>因为不是响应式的，避免误用：你应该避免在模板或计算属性中访问 <code>$refs</code>。</li>
</ul>
</li>
<li>冻结对象：data加上<code>Object.freeze()</code></li>
</ul>
</li>
</ul>
<h2 id="vuex是响应式的"><a class="header-anchor" href="#vuex是响应式的"></a>vuex是响应式的</h2>
<blockquote>
<p>vuex的state是响应式的：响应式主要是针对state，作为new Vue的data是有被 defineReactive 数据劫持的，再加上可被watcher监测</p>
</blockquote>
<h2 id="provide-inject-非响应式：-是否响应式-主要由其他机制决定"><a class="header-anchor" href="#provide-inject-非响应式：-是否响应式-主要由其他机制决定"></a>provide inject 非响应式：#是否响应式，主要由其他机制决定</h2>
<ul>
<li>通过$parent向上查找(持有该key-value的且)最近的祖先节点的数据。</li>
<li><code>toggleObserving(false)</code> + definedReactive &quot;inject属性&quot;设置1次就完事了
<ul>
<li><code>toggleObserving(false)</code>作用于defineReactive，即<strong>对于深层嵌套的属性不做重复的defineReactive处理</strong>。
<ul>
<li>如果在父组件中作为data，已经被defineReactive过了：那就是响应式的</li>
<li>如果祖先组件所提供的 provide项 本身非响应式的，那么这里也就非响应式的</li>
</ul>
</li>
<li>之所以在子孙组件defineReactive某inject属性，大概是为了能在 该inject属性变化 或者 该inject属性的引用变化 时，当前子组件的视图能相应地更新。响应式的效果还是由提供的组件那边来实现</li>
</ul>
</li>
</ul>
<h3 id="provide-inject-vs-vuex-即为什么它不适合做中心化规模化的数据存储"><a class="header-anchor" href="#provide-inject-vs-vuex-即为什么它不适合做中心化规模化的数据存储"></a>provide inject vs vuex，即为什么它不适合做中心化规模化的数据存储</h3>
<blockquote>
<p>【官网】使用provide inject来创建一个中心化规模化的数据跟使用 <code>$root</code>做这件事都是不够好的。</p>
</blockquote>
<ul>
<li>provide inject不能追溯变量改变，代码可维护性问题</li>
<li>provide inject的定位更专注于插件/自定义组件内部的各组件间的通信，更偏向于一次性地传递数据或者方法</li>
<li>(默认让视图不响应其数据变化)</li>
</ul>
<h3 id="provide-inject想弄成响应式的怎么办"><a class="header-anchor" href="#provide-inject想弄成响应式的怎么办"></a>provide inject想弄成响应式的怎么办</h3>
<ul>
<li>下面一级的字段在父组件中作为data，已经被defineReactive过了，也是可以的</li>
<li>computed监听它，然后可再渲染watcher监听它</li>
</ul>
<h3 id="下面一级的字段在父组件中作为data-已经被definereactive过了-例子"><a class="header-anchor" href="#下面一级的字段在父组件中作为data-已经被definereactive过了-例子"></a>下面一级的字段在父组件中作为data，已经被defineReactive过了  例子</h3>
<pre><code class="language-JavaScript">// 祖先组件：
provide() {
  return { foo: this.bar }
}
data() {
  return {
    bar: { a: 'a of bar' }
  }
}
// 子孙组件
// 视图上使用this.foo.a即可
inject:['foo']
</code></pre>
<h3 id="provide-inject的值可以作为子孙组件的props或者data的初始值：-暂时不研究"><a class="header-anchor" href="#provide-inject的值可以作为子孙组件的props或者data的初始值：-暂时不研究"></a>provide inject的值可以作为子孙组件的props或者data的初始值： #暂时不研究</h3>
<p>使用一个注入的值作为一个 property 的默认值：</p>
<pre><code class="language-JavaScript">const Child = {
  inject: ['foo'],
  props: {
    bar: { default () { return this.foo } }
  }
}
</code></pre>
<pre><code class="language-JavaScript">// 可能相关：
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
</code></pre>
<h2 id="冻结对象object-freeze-非响应式"><a class="header-anchor" href="#冻结对象object-freeze-非响应式"></a>冻结对象<code>Object.freeze()</code> 非响应式</h2>
<blockquote>
<p><a href="https://github.com/vuejs/vue/issues/10110" target="_blank" rel="noopener">https://github.com/vuejs/vue/issues/10110</a></p>
<p><a href="https://github.com/vuejs/vue/issues/2637" target="_blank" rel="noopener">https://github.com/vuejs/vue/issues/2637</a></p>
</blockquote>
<p>有时候应为性能问题，我们需要声明非响应式。</p>
<p>办法就是给data加上<code>Object.freeze()</code>，或者在created之后再加到data上面。</p>
<blockquote>
<p>但是要注意，freeze这招冻结不了子属性的引用的。之所以这样做，这个主要是为了减少vue无用的数据observe，尤其是一个data对象有很多字段并且不需要被监听和检查。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4-5】响应式原理 之 props 是响应式的证明]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-23-props/</url>
      <content type="html"><![CDATA[<p>《props 是响应式的证明》：</p>
<p>这一篇主要从源码的执行层面，解释为何 props 是响应式的。</p>
<a id="more"></a>
<p>本质仍是<code>defineReactive(props, key, value)</code>，配合上在访问props时候如果有<code>Dep.target</code>的指向，那么就满足响应式的条件。</p>
<ul>
<li>为什么说props是响应式的：
<ul>
<li>从props相关源码里我们发现有两处地方作了响应式相关的处理。
<ul>
<li>第一处是在调用<code>validateProp</code>来校验并获取<code>prop</code>的值时，针对默认值提供的数据进行的响应式处理。</li>
<li>第二处是在获取到<code>prop</code>的值后，将<code>prop</code>属性定义为响应式属性。</li>
<li>学习了响应式原理的<code>Observer</code>之后我们知道，经过<code>observe</code>处理后的响应式对象，仅在其子孙属性改变之后才能通知订阅者。而经过<code>defineReactive(props, key, value)</code>处理后，<code>prop</code>值自身改变时，也能通知订阅者。<strong>这二者一结合，就能保证，无论是<code>prop</code>自身改变，还是其子孙元素改变，都能通知到订阅者。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>具体的相关代码和运作机制如下：</p>
<ul>
<li>(props之所以支持那么多的书写格式，是因为初始化的时候会执行normalizeProps，即在经历规范化之后，格式结果都是统一一致的，方便后面的流程处理)</li>
<li>基于响应式这个话题，在initState 中重点看 Props 和 data的部分。
<ul>
<li><strong>( data 和 props 都会弄成响应式的)</strong></li>
<li><code>initProps</code> 主要做 3 件事情：校验、响应式和数据代理(this.xxx访问)。
<ul>
<li>defineReactive</li>
</ul>
</li>
<li>initData 略</li>
</ul>
</li>
<li>----------数据变化阶段(尤其是父组件传入的props变化)： ----------
<ul>
<li>反正父组件保证把变化更新到子组件的<code>vm._props</code>
<ul>
<li>记录性质【详细过程可不看】
<ul>
<li>父组件<code>patch</code>过程执行<code>patchVnode</code>。<code>patchVnode</code> 通常是一个递归过程，当它遇到组件 <code>vnode</code> 的时候，会执行组件更新过程的 <code>prepatch</code> 钩子函数</li>
<li>即执行到<code>updateChildComponent</code>更新，即<code>props[key] = validateProp(key, propOptions, propsData, vm)</code></li>
</ul>
</li>
</ul>
</li>
<li>只要是视图模板访问过props的属性以及下级的那些字段，都是响应式的，这个按照一般情况的理解就行了</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4-4】【附录】响应式原理 之 数据劫持之computed和watch的具体源码]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-222-computed-n-watch/</url>
      <content type="html"><![CDATA[<p>《数据劫持之computed和watch的具体源码》：</p>
<p>这一篇是【附录】，比较细地记录computed和watch具体的执行过程。其实还是有利于理解依赖收集和派发更新具体是什么时候发生了，能和 mvvm “首次构建” 和 “重新渲染” 的流程结合起来看。</p>
<p>说是附录，其实如果掌握了其中一些核心的时间点，对于对vue的源码理解是有帮助的。</p>
<a id="more"></a>
<blockquote>
<p>初始化阶段initState ==&gt; initComputed / initWatch</p>
</blockquote>
<ul>
<li>initWatch
<ul>
<li>==&gt; createWatcher ==&gt; <code>vm.$watch</code>两层封装，兼容各种传入 格式，上了typescript之后可能不同了</li>
<li>【本质】<code>vm.$watch(expOrFn, handler, options)</code></li>
<li>【本质的本质】 <code>new Watcher(vm, expOrFn, cb, { user: true })</code>
<ul>
<li>this.getter = parsePath(expOrFn)</li>
</ul>
</li>
<li>可选immediate</li>
<li>返回一个unwatcherFn  ==&gt; watcher.teardown</li>
</ul>
</li>
<li>更多复杂的如deep watcher 和sync watcher的解释，可以基于此自行理解</li>
</ul>
<p>-----------  初始化阶段 -------------------------</p>
<ul>
<li>initComputed 【计算属性有被重构优化过，具体流程没认真看】
<ul>
<li>new Watcher()， <strong>用户定义的函数作为getter</strong>
<ul>
<li>(isRenderWatcher为false，配置构造函数的options为<code>computed:true</code>)</li>
<li>(注意vm已经挂载了计算属性了：在执行Vue.extend的时候已经 <code>defineComputed$1</code> 在该组件对象的原型对象上。这个主要是想利用原型链机制共享数据，减少重复创建，多组件实例间共享)</li>
<li>(watcher getter和 computed的getter一致，前者是为了以后求值用的)</li>
<li>vm._watchers.push(this);</li>
<li><strong>并没有this.get()， 而是 new Dep()</strong></li>
</ul>
</li>
<li><code>defineComputed</code>
<ul>
<li>Object.defineProperty getter  【回头执行，又 createComputedGetter 返回】</li>
</ul>
</li>
</ul>
</li>
<li>-----------------  在渲染等时机，创建vnode需要获取 该计算属性  -----------------</li>
<li>获取 该计算属性的时候，就会触发它的getter。 在 <code>createComputedGetter</code>中定义的
<ul>
<li><code>watcher.depend(); return watcher.evaluate()</code>
<ul>
<li>watcher.depend()，把渲染watcher放到this.dep.subs中。依赖收集 ：相当于渲染 <code>watcher</code> 等等订阅了这个 <code>computed watcher</code> 的变化</li>
<li>watcher.evaluate === 根据dirty来调用<code>this.get()</code>，并返回该计算属性值         (判断 <code>this.dirty</code>，如果为 <code>true</code> 则通过 <code>this.get()</code> 求值，然后把 <code>this.dirty</code> 设置为 false)
<ul>
<li>执行用户定义的getter，该computed里面所依赖的data(比如此例中的this.useless) 的getter也会触发
<ul>
<li>依赖收集，把该computed的watcher加入到对应 data的依赖订阅数组里面</li>
</ul>
</li>
</ul>
</li>
<li>(当computed所依赖的data变化的时候，才会重新计算)</li>
</ul>
</li>
</ul>
</li>
<li>----------(首次构建，页面渲染出来了)----------</li>
<li>----------当computed所依赖的data数据变化，比如click事件回调处理中，让所依赖的data如<code>this.useless++</code>-------------</li>
<li>拿用户定义的computed函数重新生成一个computed，并且重新订阅所依赖的data。另外，如果computed计算结果前后不一样，就也派发更新视图更新updateComponent回调执行。此后渲染watcher也会重新依赖收集该computed。
<ul>
<li>调用<code>dep.notify</code>。也就是调用所有“订阅该计算属性的”的 <code>subs[i].update()</code>
<ul>
<li>其中就包括通知依赖这个data的 computed的渲染watcher做update</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4-3】响应式原理 之 数据劫持之observe的细节]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-221-deepin-observe/</url>
      <content type="html"><![CDATA[<p>《数据劫持之observe的细节》：</p>
<p>之前一个章节讲数据劫持，主要是讲 defineReactive，以支持理解整个宏观的流程。</p>
<p>这里特别讲 observe 和其所调用的 Observer构造函数，就是想探讨一下<strong>细节和各种特殊情况</strong>的。</p>
<a id="more"></a>
<ul>
<li>大概总结一些这个章节：
<ul>
<li>数组是响应式的：通过重写数组的原型对象上的数组方法(所以同时还有一些没有用响应式覆盖的地方)
<ul>
<li>在数组中<strong>通过数组索引对项进行修改时，是不会触发更新的</strong></li>
</ul>
</li>
<li>包括数组，还有一些响应式没有覆盖到的地方怎么处理？   – 通过Vue.$set(包括类似的Vue.$del)和“数组变异”来补足。<strong>他们都是内部手动做了依赖更新的派发。</strong></li>
</ul>
</li>
</ul>
<p>observe函数，尝试调用<code>ob = new Observer(obj)</code>，如果发现已经调用过了则直接返回<code>ob</code>。<code>__ob__</code>属性保存的就是 observer实例。</p>
<p><code>new Observer(obj)</code>主要接收一系列数据劫持所属的根对象，还有作为入口兼容一些特殊情况。其中每一个属性交由 defineReactive 来具体实现数据劫持，所以 <code>defineReactive(obj, key, val)</code> 的函数参数签名会有key。</p>
<h2 id="observe-详解"><a class="header-anchor" href="#observe-详解"></a>observe 详解</h2>
<ul>
<li>如果data不是 object 类型则无效果</li>
<li>从<code>__ob__</code>属性复用返回 observer</li>
<li>ob = new Observer(value)</li>
</ul>
<h2 id="new-observer"><a class="header-anchor" href="#new-observer"></a>new Observer</h2>
<ul>
<li><code>this.dep = new Dep()</code></li>
<li><code>def(value, '__ob__', observer)</code>
<ul>
<li>def 函数是对 Object.defineProperty 进行一定的封装</li>
</ul>
</li>
<li>如果value是数组，尝试“通过改变原型对象”<strong>重写数组方法</strong>，不行就“遍历要重写的属性”来<strong>重写数组方法</strong>； 然后每个数组元素也递归observe</li>
<li>如果value是普通对象则用walk实例方法，即遍历并observe每一对key value
<ul>
<li>若先前已 <code>Object.defineProperty</code> 一次，则在walk的时候就遍历不到它</li>
</ul>
</li>
<li>defineReactive上一章已经说了，就是defineProperty getter和setter，实现响应式原理
<ul>
<li>getter
<ul>
<li>childOb.dep.depend()   针对child更新依赖收集</li>
<li>dependArray(value)  兼容针对value是数组依赖收集</li>
</ul>
</li>
<li>setter
<ul>
<li>【重要】新设置的值是 newVal，也observe(newVal)  ：<code>childOb = !shallow &amp;&amp; observe(newVal)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="剩下的observer文件的一些闭包变量和方法-了解一下即可"><a class="header-anchor" href="#剩下的observer文件的一些闭包变量和方法-了解一下即可"></a>剩下的observer文件的一些闭包变量和方法 #了解一下即可</h2>
<p>还有文件内的3个函数(在该文件都没有调用过)，直接把源码的函数注释抄下来：</p>
<ul>
<li><code>set</code>：Adds the new property and triggers change notification if the property doesn’t already exist. 应该就是对应Vue.set</li>
<li><code>del</code>：Delete a property and trigger change if necessary. 应该就是对应Vue.delete</li>
<li><code>function toggleObserving (value) { shouldObserve = value }</code></li>
</ul>
<h2 id="响应式所没有覆盖到的地方-包括数组-面试会问"><a class="header-anchor" href="#响应式所没有覆盖到的地方-包括数组-面试会问"></a>响应式所没有覆盖到的地方 #包括数组 #面试会问</h2>
<ul>
<li>没有事先声明的data属性，不是响应式的，因为没有被数据劫持。</li>
<li>其他的没覆盖到的地方：通过Vue.$set(包括类似的Vue.$del)和“数组变异”来补足。<strong>他们都是内部手动做了依赖更新的派发。</strong></li>
</ul>
<h3 id="数组变异的原理-：重写操作数组的方法"><a class="header-anchor" href="#数组变异的原理-：重写操作数组的方法"></a>数组变异的原理 ：重写操作数组的方法</h3>
<pre><code class="language-JavaScript">export class Observer {
  constructor (value) {
    // 【一些初始化】
    if (Array.isArray(value)) {
      const augment = hasProto // 对于多数浏览器 hasProto为true
        ? protoAugment // 单纯设置__proto__属性
        : copyAugment // 复制数组的元素
      augment(value, arrayMethods, arrayKeys) // arrayMethods
      this.observeArray(value)
    } else {
      // ....
    }
  }
</code></pre>
<p>拦截并且重写了数组的方法，做了些增强，并且会调用 <code>ob.dep.notify</code>。也是notify手动通知。(之所以能通知到，也是因为先前 defineReactive 的时候，对child做了一次依赖收集<code>childOb.dep.depend</code>。)</p>
<h3 id="vue-set"><a class="header-anchor" href="#vue-set"></a>Vue.$set</h3>
<p>Vue.$set：（因为defineProperty是不支持<code>=</code>的，所以必须暴露$set来包装）</p>
<p>【1】针对数组， 更新数组的length并且用splice来插入。
【2】针对object，也是手动“依赖收集”和“派发更新”</p>
<pre><code class="language-JavaScript">function set (target: Array&lt;any&gt; | Object, key, val) {
  // 校验
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  // 不用干什么：
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) { // 有vmCount就是root $data
    // 这种情况警告
    return val
  }
  if (!ob) { target[key] = val; return val } // 普通对象
  defineReactive(ob.value, key, val) // 里面调用childOb.dep.depend ，做一个渲染watcher的依赖收集
  ob.dep.notify() // 触发重新渲染
  return val
}
</code></pre>
<h6 id="思考数组为啥不同-可略"><a class="header-anchor" href="#思考数组为啥不同-可略"></a>思考数组为啥不同 #可略</h6>
<p>对于数组类型观测，会调用 <code>observeArray</code> 方法：</p>
<pre><code class="language-js">observeArray(data) {
  data.forEach(item =&gt; {
    observe(item)
  })
}
</code></pre>
<p>与对象不同，它执行 <code>observe</code> 对数组内的对象类型进行观测，并没有对数组的每一项进行 <code>Object.defineProperty</code> 的定义，也就是说数组内的项是没有 <code>dep</code> 的。</p>
<p>所以，我们<strong>通过数组索引对项进行修改时，是不会触发更新的</strong>【看代码演示】。但可以通过 <code>this.$set</code> 来修改触发更新。那么问题来了，为什么 <code>Vue</code> 要这样设计？</p>
<p>结合实际场景：</p>
<ul>
<li>【1】数组中通常会存放多项数据，比如列表数据。这样观测起来会消耗性能。</li>
<li>【2】一般修改数组元素很少会直接通过索引将整个元素替换掉。例如：</li>
</ul>
<pre><code class="language-js">export default {
    data() {
        return {
            list: [
                {id: 1, name: 'Jack'},
                {id: 2, name: 'Mike'}
            ]
        }
    },
    created() {
        // 如果想要修改 name 的值，一般是这样使用
        this.list[0].name = 'JOJO'
        // 而不是以下这样
        // this.list[0] = {id:1, name: 'JOJO'}
        // 当然你可以这样更新
        // this.$set(this.list, '0', {id:1, name: 'JOJO'})
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4-2】响应式原理 之 数据劫持]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-220-data-hijack/</url>
      <content type="html"><![CDATA[<p><strong>响应式原理 = 数据劫持 + 观察者模式</strong>。另，我们知道可以用数据劫持实现数据代理。即：响应式原理不是全包含了数据劫持。</p>
<a id="more"></a>
<ul>
<li>先把几个关键的逻辑搞通，就很容明白后面的内容：
<ul>
<li><strong>响应式原理 = 数据劫持 + 观察者模式</strong></li>
<li>observe函数：处理各种情况，核心还是defineReactive
<ul>
<li>defineReactive 做了什么工作？    – 除了执行本分的gettter和setter的工作之余，主要就是触发依赖收集派发更新
<ul>
<li>是怎么联系到<code>Dep.target</code>的？    –  dep.depend()</li>
<li><code>Dep.target</code>若不存在，就谈不上响应式，访问data的操作本身就很多，不可能每个都搞响应式</li>
</ul>
</li>
</ul>
</li>
<li><strong>通常都是在获取目标的值的时候，目标同时会依赖收集。</strong></li>
<li>vue里面主要有3种watcher，结合若有<code>Dep.target</code>则构成响应式原理。也就是三种watcher的响应式原理都是：数据劫持+响应式原理</li>
</ul>
</li>
</ul>
<p>observe函数，尝试调用<code>ob = new Observer(obj)</code>，如果发现已经调用过了则直接返回<code>ob</code>。</p>
<p><code>new Observer(obj)</code>主要接收一系列数据劫持所属的根对象，还有作为入口兼容一些特殊情况。其中每一个属性交由 defineReactive 来具体实现数据劫持，所以 <code>defineReactive(obj, key, val)</code> 的函数参数签名会有key。<strong>另外单独开辟一章节来讲observer函数的细节和如何处理特殊情况，在本章节主要讲 defineReactive，以支持理解整个宏观的流程。</strong></p>
<h2 id="definereactive"><a class="header-anchor" href="#definereactive"></a>defineReactive ()</h2>
<blockquote>
<p><code>Dep.target</code>：因为访问 this.data的事务有很多，所以<code>Dep.target</code>的作用在于<strong>标志是由哪一个 watcher 发起的访问data</strong>，这时候才有必要“依赖收集”。</p>
</blockquote>
<p>先看看 defineReactive 做了什么工作：</p>
<ul>
<li>对应每一对key value都有闭包dep对象</li>
<li>getter，若存在<code>Dep.target</code>(即某Watcher实例)，则额外去“依赖收集”</li>
<li>setter，首先拿到value，多数情况会触发getter。比对新旧value，如果跟一样则不用任何操作。否则新旧value不同则更新该value，并且额外去“派发更新”</li>
</ul>
<pre><code class="language-JavaScript">// #摘取自vue #基本能用：
export function defineReactive (
  obj, key, val, customSetter?: ?Function, shallow?: boolean
) {
  const dep = new Dep() // 对应每一个key都有闭包dep对象

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // 如果之前该对象已经预设了getter/setter则将其缓存，新定义的getter/setter中会将其执行
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] }

  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val // 如果原本对象拥有getter方法则执行，不论如何拿到value
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val // 如果原本对象拥有getter方法则执行，不论如何拿到value
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return // 如果跟原来值一样则不用任何操作
      }

      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre>
<h2 id="从高维度来看流程"><a class="header-anchor" href="#从高维度来看流程"></a>从高维度来看流程</h2>
<p>Watcher就3种使用方式： (尤其是在判断区分expOrFn转成watcher.getter的时候注意一下)</p>
<ul>
<li>侦听器 watcher：<code>this.$watch('include', cb) ==&gt; new Watcher(vm, 'include', cb, options)</code></li>
<li>计算属性 watcher：<code>new Watcher(vm, computed[key] || noop, noop, options)</code></li>
<li>渲染 watcher：<code>new Watcher(vm, updateComponent || noop, noop, options)</code></li>
</ul>
<p>最简单的还是侦听器 watcher。而渲染 watcher 的流程，还包含了对计算属性的 获取。</p>
<blockquote>
<p><strong>应用场景的出发点是不同的：</strong> 计算属性适合用在模板渲染中，某个值是依赖了其它的响应式data甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<p>它们3者的原理都是 数据劫持+响应式原理</p>
</blockquote>
<p><strong>侦听器 watcher</strong>：用户更新数据，data的setter触发，“派发更新”，触发用户设置的回调即可。   (它还支持deep、sync、immediate等配置)</p>
<p><strong>计算属性 watcher</strong>：</p>
<ul>
<li><strong>首次获取该计算属性的时候，触发该计算属性的getter，“依赖收集”比如渲染watcher订阅了这个计算属性，</strong></li>
<li>另需要触发所依赖数据的 getter，更新了一次“依赖收集”比如该计算属性订阅某些data的变化。</li>
<li>数据更新的时候，触发所依赖data的setter，导致拿“用户定义的computed函数”重新生成一个computed值，并且重新订阅所依赖的data。</li>
<li>另外，如果computed计算结果前后不一样，就也派发更新视图更新updateComponent回调执行。此后渲染watcher也会重新依赖收集该computed。</li>
</ul>
<p><strong>渲染 watcher</strong>：</p>
<p>因为vue在调用每个vm.$mount都会执行<code>new Watcher</code>，意味着每个视图组件实例都有渲染 watcher。</p>
<p>传入的 <code>expOrFn</code> 是 <code>updateComponent = () =&gt; { vm._update(vm._render(), hydrating) }</code>。</p>
<p>首次构建，需要构建vnode触发数据的getter，有时候也需要获取computed，再最后才传给<code>vm._update</code>去patch。在这个过程其中，渲染watcher更新了一次“依赖收集”。</p>
<p>数据更新的时候，由setter派发更新，触发watcher.update，也就是在未来触发 watcher.run。其中触发 watcher.get，对于渲染 watcher而言，也就是触发<code>updateComponent</code>。<code>updateComponent</code>，这里又要<code>vm._render()</code>生成vnode，所以又访问vm上的数据，所以触发数据的getter(为下一次重新渲染视图更新“依赖收集”)，再最后才传给<code>vm._update</code>去patch。</p>
<blockquote>
<p>也就是已考虑到了v-if false导致离线一大堆视图的情景。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4-1】响应式原理 之 观察者模式]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-21-observe-mode/</url>
      <content type="html"><![CDATA[<p>Vue2的响应式原理，网上的资料太多了。这篇主要是把脉络梳理清楚，并且明确一些核心的概念是怎么实现的。比如依赖收集和派发更新具体指的是什么，还有一些细节处理，才造就了 Vue的合理运作。</p>
<p>总之，<strong>响应式原理 = 数据劫持 + 观察者模式 = 依赖收集 + 派发更新 = defineReactive + 同时存在Dep.target</strong></p>
<a id="more"></a>
<h2 id="dep：维护观察者队列"><a class="header-anchor" href="#dep：维护观察者队列"></a>Dep：维护观察者队列</h2>
<p>其实Dep类职责很简单：</p>
<ul>
<li>【1】维护dep.subs这个wathcer数组，即订阅者的数组
<ul>
<li>dep.addSub 和 dep.removeSub 作为针对数组 dep.subs 的工具方法，不会作为一个事务的起始。</li>
</ul>
</li>
<li>【2】dep.notify：遍历执行watcher.update</li>
<li>额外：用 id 标识 dep实例，方便优化这个过程。</li>
</ul>
<blockquote>
<p><code>Dep.target</code>：因为访问 this.data的事务有很多，所以<code>Dep.target</code>的作用在于<strong>标志是由哪一个 watcher 发起的访问data</strong>，这时候才有必要“依赖收集”。</p>
</blockquote>
<ul>
<li>Dep文件闭包作用域内，“全局唯一的 Dep.target” 是怎么维护的：
<ul>
<li>Dep.target 和 targetStack都是闭包变量。而pushTarget函数和popTarget函数都是用于同时更新该2者。
<ul>
<li>也就是在 watcher.get 执行 watcher.getter的前后，会push和pop，致使Dep.target指向的是当前执行watcher.getter的watcher。</li>
<li>而targetStack的作用：维护一个栈结构，并且方便恢复上一个 Dep.target。(因为可能会递归child走相同流程，或者渲染watcher依赖计算属性watcher等等)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>至此，对于 src/core/observer/dep.js 的所有模块都介绍完了，足以看懂源码。</p>
<pre><code class="language-JavaScript">// #摘取自vue #基本能用：
let uid = 0;
export default class Dep {
  // Dep就3属性：
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }
  addSub (sub) {
    this.subs.push(sub)
  }
  removeSub (sub) {
    remove(this.subs, sub)
  }
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
  notify () {
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}
// Dep.target 是全局唯一的观察者，因为在任何时候只有一个观察者被处理。
Dep.target = null
const targetStack = []

export function pushTarget (_target: ?Watcher) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}

export function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
</code></pre>
<h2 id="watcher：观察者"><a class="header-anchor" href="#watcher：观察者"></a>Watcher：观察者</h2>
<p>作为观察者，职责就是【1】初始化的时候载入相关数据或者方法 【2】加入观察者队列 【3】等通知执行： watcher.update被通知调用，在未来执行 watcher.run。额外还有优化dep实例中的watcher队列。</p>
<h3 id="初始化-和-watcher-get"><a class="header-anchor" href="#初始化-和-watcher-get"></a>初始化 和 watcher.get</h3>
<p>就3种使用方式： (尤其是在判断区分expOrFn转成watcher.getter的时候注意一下)</p>
<ul>
<li>渲染 watcher：<code>new Watcher(vm, updateComponent || noop, noop, options)</code></li>
<li>计算属性 watcher：<code>new Watcher(vm, computed[key] || noop, noop, options)</code></li>
<li>侦听器 watcher：<code>this.$watch('include', cb) ==&gt; new Watcher(vm, 'include', cb, options)</code></li>
</ul>
<h3 id="剩下的实例方法"><a class="header-anchor" href="#剩下的实例方法"></a>剩下的实例方法</h3>
<p>由 Watcher 的职责决定，其多数的实例方法都不会作为一个“事务”的起始。</p>
<p>watcher.addDep 和 watcher.update都是等dep实例来调用的。搞得这么复杂就是为了解耦。</p>
<ul>
<li>【解释 dep.depend 和 watcher.addDep】：dep.depend ==&gt; Dep.target.addDep(this)。核心逻辑是<code>dep.addSub(this/*即该watcher*/)</code>，这就是依赖收集。【记住这里绕了一圈，即还要绕去watcher那边搞点优化】</li>
<li>【解释 dep.notify 和 watcher.update】：dep.notify ==&gt; subs[i].update()。核心逻辑就是 在未来执行 watcher.run()，也就是调用一开始存在 watcher的cb和watcher.get</li>
</ul>
<blockquote>
<p>在整体雏形的基础上，需要针对实际场景来进行优化：</p>
</blockquote>
<ul>
<li>优化dep实例中的watcher队列
<ul>
<li><strong>从源码角度看：</strong> 就是watcher中，<code>[deps, depIds] vs [newDeps, newDepIds]</code> 和 <code>watcher.cleanupDeps()</code> 等等</li>
<li>【1】以防止视图上已经不需要的watcher被触发
<ul>
<li>【在watcher.get()的末尾触发】watcher.cleanupDeps()：防止视图上已经不需要的watcher被触发：对比 newDeps，把deps中已经不需要的watcher从“dep实例的subs”中移除</li>
<li>(比如有一个 data msg，一开始v-if = true，能响应式，后来v-if = false，那么就没有必要响应式(收集依赖)这个 msg字段了，也就是没必要去订阅这个msg的变化)</li>
</ul>
</li>
<li>【2】在 watcher.addDep的时候，防止重复添加本 watcher 进dep实例中的队列</li>
</ul>
</li>
</ul>
<pre><code class="language-JavaScript">// #摘取自vue #基本能用：
export default class Watcher {
  constructor (
    vm: Component, // 组件实例对象
    expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作
    cb: Function, // 被观察者发生变化后的回调
    options?: ?Object, // 参数
    isRenderWatcher?: boolean // 是否是渲染函数的观察者
  ) {
    {
      /* 和 vm 互相保存对方引用： */
      this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的
      if (isRenderWatcher) {
        vm._watcher = this
      }
      vm._watchers.push(this) // 给组件实例的_watchers属性添加观察者实例
    }

    // 根据 options 更新 this.deep this.user this.lazy this.sync
    // this.sync = !!options.sync // 同步执行

    // 优化 watcher 队列相关：
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()

    // 【略去兼容各种情况】设置 getter，最终this.getter系一个函数。
    this.getter = expOrFn
    // 【略去选择性调用】this.get()：
    this.value = this.get()
  }
  get () { // 触发取值操作：调用 watcher.getter，同时更新 Dep.target
    pushTarget(this) // 给 Dep.target 赋值
    
    const vm = this.vm
    // 执行getter，即执行观察者表达式
    let value = this.getter.call(vm, vm) // 略掉try catch的逻辑

    // if (this.deep) { traverse(value) }// 如果要深度监测，再对 value 执行操作

    popTarget()
    this.cleanupDeps() // 防止视图上已经不需要的watcher被触发
    return value
  }
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) { // 避免重复添加
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this) // 【核心逻辑】dep 添加订阅者
      }
    }
  }
  update () {
    if (this.sync) {
      this.run() // 若同步直接运行
    } else { // 否则加入异步队列等待执行，也是执行 watch.run
      queueWatcher(this)
    }
  }
}
</code></pre>
<h2 id="依赖收集-和-派发更新"><a class="header-anchor" href="#依赖收集-和-派发更新"></a>依赖收集 和 派发更新</h2>
<p>前面一直没有讲“依赖收集”和“派发更新”，因为这是人造的概念，若在其间加上只不过是增加理解负担。</p>
<p>在理解观察者模式后，其实“发布订阅模式”也是很类似的，只不过“发布订阅模式”更加强大一点，后者改由增设“调度中心”来收集订阅的回调函数，这样解耦使得发布方也能订阅。</p>
<p>而“依赖收集”和“派发更新”主要用于描述观察者模式：</p>
<ul>
<li><code>dep.depend()</code>即<code>dep.addSub(watcher)</code>即为“依赖收集”；</li>
<li><code>dep.notify()</code>，即把订阅的回调全都执行一遍，即为“派发更新”</li>
</ul>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>响应式原理 = 数据劫持 + 观察者模式 = 依赖收集 + 派发更新 = defineReactive + 同时存在Dep.target</p>
<p>剩余未解释的部分将于后面的文章中解释。</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【3】patch的原理]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-12-patch/</url>
      <content type="html"><![CDATA[<p><strong>从最高视角看：</strong> 已知patch阶段也是 vm.$mount 下的逻辑，但从patch这里开始，首次构建阶段和“数据变化驱动视图改变update阶段”的逻辑才开始明显出现区别。所以单独拿出一个章节来讲patch。</p>
<p><strong>从源码层面看：</strong> 可搜索<code>return function patch (oldVnode, vnode, hydrating, removeOnly)</code>，找到patch函数的源码。而 patch 函数，实际是由 createPatchFunction 这个工厂函数所返回的：createPatchFunction利用闭包，为 patch 缓存了一些对应运行环境的接口。因此 createPatchFunction 的具体实现先可以不用看，后面也会讲到。</p>
<a id="more"></a>
<p>首先，<strong><code>__patch__</code>其实就是<code>patch</code>函数</strong>，记住结论，其证明见于后文。对于浏览器环境，<code>__patch__</code>的作用就是<strong>对比新旧vnode更新vm.$el，并完成真实dom更新</strong>。而其职责，选择性由 createElm(若组件则为createComponent) + patchVnode + “销毁函数” 来完成。</p>
<h2 id="patch的宏观实现：是如何选择走-createelm-若组件则为createcomponent-还是-patchvnode-还是-销毁函数-的？"><a class="header-anchor" href="#patch的宏观实现：是如何选择走-createelm-若组件则为createcomponent-还是-patchvnode-还是-销毁函数-的？"></a>patch的宏观实现：是如何选择走 createElm(若组件则为createComponent) 还是 patchVnode 还是“销毁函数” 的？</h2>
<p>已知条件是 oldVnode 和 vnode，所以有：</p>
<ul>
<li>【1】如果新节点不存在, 旧节点也不存在, 则patch无需任何操作；</li>
<li>【2】如果新节点不存在,但旧节点存在, 说明需要删除旧节点, 调用一个销毁钩子</li>
<li>【3】旧节点不存在，需要创建一个新节点，用到 createElm</li>
<li>【4】新旧节点都存在
<ul>
<li>【4-1】新旧节点是相似节点, 对新旧节点做详细的对比操作，比如检查children的不同，也就是 patchVnode</li>
<li>【4-2】新旧节点不是相似节点。一增一删，合计为替换。其中用到 createElm</li>
</ul>
</li>
</ul>
<p>所以 patch 的功能，就是对比新旧vnode来计算。<strong>选择性</strong>由 createElm(若组件则为createComponent) + patchVnode + “销毁函数” 来完成。注意一下如果vnode是组件类型，craeteElm 会完全切换为 createComponent，后面有解释。</p>
<ul>
<li>createElm 的逻辑：通过虚拟节点创建真实的 DOM (通过递归子节点)并插入到它的父节点中 @非组件类型</li>
<li><code>vnode.elm = /*判断得出*/nodeOps.createElement(tag, vnode)</code> @非组件类型
<ul>
<li>此时会创建“占位符”节点</li>
<li>占位符：比如<code>&lt;HelloWorld&gt;</code>出现在父模板上就是一个HelloWorld的占位符，它里面的实现HelloWorld.vue里面的模板才是“渲染vnode”。</li>
</ul>
</li>
<li>总之无论是对应真实元素的vnode还是组件类型的vnode，他们通过插入顺序是一致的，所以整个 <code>vnode</code> 树节点的插入顺序是先子后父。非常巧妙。</li>
</ul>
<p>以上其实就把patch的大致工作流程梳理清楚，不交代清楚没法往下讲啊。下面可以讲讲这其中一些厉害的编写代码的技法：</p>
<h2 id="patch其中的一些编写代码的技巧：-其实都可以当做是附录内容了"><a class="header-anchor" href="#patch其中的一些编写代码的技巧：-其实都可以当做是附录内容了"></a>patch其中的一些编写代码的技巧：(其实都可以当做是附录内容了)</h2>
<h3 id="patch-其实就是patch-可不看证明过程"><a class="header-anchor" href="#patch-其实就是patch-可不看证明过程"></a><code>__patch__</code>其实就是<code>patch</code> #可不看证明过程</h3>
<pre><code class="language-js">// 调用时机和函数签名：
    if (!prevVnode) {
      // 首次render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // 生命周期的updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
</code></pre>
<p>函数签名：<code>vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</code>，<strong>(即patch的)作用：根据vnode更新vm.$el，并完成真实dom更新</strong></p>
<p><code>Vue.prototype.__patch__ = inBrowser ? patch : noop</code>  ：因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 <code>patch</code> 方法，这个方法又是由 createPatchFunction 函数 创建的：</p>
<p><code>const patch = createPatchFunction({ nodeOps, modules })</code></p>
<p><code>createPatchFunction</code>这个像是高阶函数，返回一个名为patch的函数，也就是利用闭包的特性，先把一部分参数或者配置，载入到patch中。</p>
<h3 id="记录-patch-函数的工厂函数-createpatchfunction-的一些信息-不太重要"><a class="header-anchor" href="#记录-patch-函数的工厂函数-createpatchfunction-的一些信息-不太重要"></a>记录 patch 函数的工厂函数 createPatchFunction 的一些信息 #不太重要</h3>
<blockquote>
<p>直接看src/core/vdom/patch.js的 createPatchFunction 这个大函数。它这里就是反复import。</p>
</blockquote>
<p>【1】<code>const patch = createPatchFunction({ nodeOps, modules })</code>返回一个名为patch的函数</p>
<ul>
<li>nodeOps是一个对象，上面的那些方法，都是对web平台dom操作的简单封装和增强。 (src/core/vdom/patch)</li>
<li>modules：定义了一些模块的钩子函数的实现
<ul>
<li>attrs</li>
<li>klass</li>
<li>events</li>
<li>domProps</li>
<li>style</li>
<li>transition</li>
</ul>
</li>
</ul>
<p>【2】定义了一大堆辅助函数。</p>
<h3 id="createpatchfunction-的柯里化实现-动静分离-一些启发"><a class="header-anchor" href="#createpatchfunction-的柯里化实现-动静分离-一些启发"></a>createPatchFunction 的柯里化实现“动静分离” #一些启发</h3>
<blockquote>
<p><a href="https://juejin.im/post/6844904142469595143" target="_blank" rel="noopener">【注入函数参数的方式】比如这个腾讯的用nuxt，前后端都能用axios；但在服务端渲染的时候，调用的是 Nuxt 的 asyncData 方法进行请求；而在客户端的时候，是直接请求后台 API</a></p>
</blockquote>
<p>我们可以思考一下为何 Vue 源码绕了这么一大圈，把相关代码分散到各个目录：</p>
<p>前面也介绍过，<code>patch</code> 是平台相关的，在 Web 和 Weex 环境，它们把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。**因此每个平台都有各自的 <code>nodeOps</code> 和 <code>modules</code>，**它们的代码需要托管在 <code>src/platforms</code> 这个大目录下。</p>
<p>而不同平台的 <code>patch</code> 的主要逻辑部分是相同的，所以这部分公共的部分托管在 <code>core</code> 这个大目录下。</p>
<p>综上所述：<strong>差异化部分</strong>只需要通过参数来区别，这里利用闭包实现函数柯里化，通过 <code>createPatchFunction</code> 把差异化参数提前传入固化。好处是：</p>
<p>1、先在外部<strong>判断</strong>需要什么类型的patch，然后选择把一些依赖通过参数传递进去。而不是在patch函数内部实现一大堆<strong>判断逻辑</strong></p>
<p>2、不用每次调用 <code>patch</code> 的时候都传入 <code>nodeOps</code> 和 <code>modules</code>。</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【2】Vue MVVM 的工作流程]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-11-mvvm/</url>
      <content type="html"><![CDATA[<p>整个 Vue 的运作其实始于 <code>import Vue from 'vue'</code> 执行的那一刻，一开始只是执行一些准备工作，然后到 <code>new Vue</code> 才开始执行核心的流程，也就是开始构建 MVVM。</p>
<p>在上一篇博客有讲到， MVVM 其实就可以划分为2个阶段，“首次构建”+“重新渲染”。之所以会有“重新渲染”，是因为利用了响应式原理，当数据变化时需要重新渲染，还有强制重新渲染也是类似的。</p>
<a id="more"></a>
<p>运行时的首次构建会走这个逻辑：</p>
<p><code>new Vue ==&gt; init ==&gt; $mount ==&gt; compile(如果是带编译的版本会走这步；而如果你直接写render函数则会忽略这步) ==&gt; render(得到vnode) ==&gt; patch(根据vnode操作DOM)</code></p>
<p>下面这个过程，经过我多番勘正，应该是正确的。即便看不懂也没关系，之后我会拎出几个点来说一下。</p>
<p>我们以最简单的案例为例：【尚无使用组件、显式写render函数】 来分析首次构建的流程，其他情况只是稍有区别：</p>
<ul>
<li>import Vue 的时候发生 【预定义】
<ul>
<li>initMixin函数：预先定义<code>Vue.prototype._init</code>。【<code>_init</code>和vm实例一对一】</li>
<li>其他函数的执行，主要是用于预定义vm等</li>
</ul>
</li>
<li>------------ 在new Vue的时候执行： (src/core/instance/init.js) -----------</li>
<li>_init () 【在刚刚创建vm时，各模块给vm预设一些属性或者功能】
<ul>
<li>合并配置：merge options 赋值给vm.$options</li>
<li>initLifecycle</li>
<li>initEvents 事件中心</li>
<li>initRender： vm.$createElement就是它定义的</li>
<li>initState 初始化 data、props、computed、watcher 等等
<ul>
<li>initData
<ul>
<li>getData简单调用 <code>用户data函数.call(vm, vm)</code>。data的结果赋值给vm._data</li>
<li>然后就是用数据劫持，让this[‘某属性’]代理vm._data[‘某属性’]</li>
<li>然后observe data，也就是《响应式的原理 之 观察者模式》</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>调用vm.$mount：利用观察者设计模式：Watcher 在首次构建和数据变化的时候调用<code>vm._update(vm._render())</code>
<ul>
<li><code>vm._render()</code>：得到vnode
<ul>
<li><code>vm._render</code>其中比较关键节点的是 $createElement 和 createComponent 函数，分别针对不同的类型</li>
</ul>
</li>
<li><code>vm._update(vm._render())</code>：根据vnode更新vm.$el，并完成真实dom更新。其中比较关键的函数是 <code>vm.__patch__</code></li>
</ul>
</li>
</ul>
<h6 id="src-core-instance-init-js"><a class="header-anchor" href="#src-core-instance-init-js"></a>src/core/instance/init.js</h6>
<p>import Vue的时候就会执行下面代码。而<code>_init</code>是在执行new Vue的时候执行的。</p>
<pre><code class="language-js">function Vue (options) {
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
</code></pre>
<h2 id="vm-mount"><a class="header-anchor" href="#vm-mount"></a>vm.$mount</h2>
<p>vm.$mount 的执行，是构建整个 MVVM 的核心。</p>
<pre><code class="language-js">// 实现形式：自己包装自己
const mount = Vue.prototype.$mount // 【子组件的挂载】被包装vm.$mount，约等于 mountComponent 函数，来自src/platforms/web/runtime/index.js
Vue.prototype.$mount = function () {
  // 【铺垫变量，略】option.render/option.template等等 ==&gt; template变量 ==&gt; compileToFunctions函数(得出vm.$options.render和vm.$options.staticRenderFns
  return mount.call(this, el, hydrating)
}
</code></pre>
<p><strong>综上所述，<code>vm.$mount</code> 约等于 调用 <code>mountComponent</code> 函数  约等于Watcher结合updateComponent回调 + 调用 beforeMount 和 mounted 钩子 。</strong>
<strong>而 updateComponent 回调 的核心就是 <code>vm._update(vm._render())</code>(外层函数即 <code>vm.__patch__</code>)</strong> 也就是一个观察者模式，会首次调用1次回调，(不考虑优化)然后观察每当“数据改变需要驱动视图更新”又会调用1次回调，即在初始化和update阶段调用<code>vm._update(vm._render())</code>。</p>
<ul>
<li><code>updateComponent = () =&gt; { vm._update(vm._render())}</code> 回调，用于订阅观察者模式，在稍后发布事件时调用。
<ul>
<li>【核心】<code>vm._update(vm._render())</code>。其中，<code>vm._render 约等于 vm.$options.render+vm.$createElement回调</code>  【生成vnode】</li>
<li><code>vm._update</code> 用于执行一次真实的DOM更新。主要通过<code>vm.__patch__</code> 【根据传进来的vnode更新vm.$el，并且完成真实dom更新】</li>
</ul>
</li>
</ul>
<p>updateComponent负责逻辑，而<code>new Watcher</code>负责控制执行它的时机：</p>
<ul>
<li>【略】(callHook 调用beforeMount还有 mounted生命周期钩子。之后mark那些函数都是性能埋点)</li>
<li><code>new Watcher(vm, updateComponent, noop, {</code>  一个服务于“渲染”的观察者模式 决定了什么时候调用updateComponent回调
<ul>
<li><code>Watcher</code> 的效果：<strong>一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数</strong>  后者就是一个“响应式原理”</li>
<li>只要是能用上的组件，都会执行其<code>vm.$mount</code>，那么就会执行<code>new Watcher</code>，这就是为什么“视图组件实例基本上都配备有渲染watcher”</li>
</ul>
</li>
</ul>
<p>几个要点：</p>
<h3 id="vdom-vnode"><a class="header-anchor" href="#vdom-vnode"></a>vdom / vnode</h3>
<p>其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。</p>
<h3 id="vm-createelement"><a class="header-anchor" href="#vm-createelement"></a>vm.$createElement</h3>
<p><strong>一句话总结：vm.$createElement：返回vnode，其间规范化children，其间处理了一堆它责任范围内的edge case。其核心是createElement也就是_createElement。</strong>_createElement，也就是<code>children</code> 的规范化以及 VNode 的创建。</p>
<h3 id="createelement-之-createcomponent"><a class="header-anchor" href="#createelement-之-createcomponent"></a>$createElement 之 createComponent</h3>
<p>一句话总结，也是返回vnode：【1】构造子类构造函数  【2】安装组件钩子函数  【3】实例化 <code>vnode</code></p>
<p>在 <code>$createElement</code> 的时候，如果发现是组件类型，就直接跑 createComponent 的逻辑，以取代 <code>$createElement</code> 其本身。</p>
<blockquote>
<p><strong>和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>children</code> 的。</strong></p>
</blockquote>
<p>可以看到，<code>createComponent</code> 的逻辑也会有一些复杂，但是分析源码比较推荐的是只分析核心流程，分支流程可以之后针对性的看，所以这里针对组件渲染这个 case 主要就 3 个关键步骤：</p>
<ul>
<li>【1】构造子类构造函数</li>
<li>【2】安装组件钩子函数</li>
<li>【3】实例化 <code>vnode</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2源码【1】Vue 的整体架构]]></title>
      <url>https://blog.az22c.top/2020/09/04/vue2-src-code-00-data-drive/</url>
      <content type="html"><![CDATA[<p>本系列文章，主要是梳理一下 Vue 2.x 源码的一些脉络和总结一些值得学习的点。并不是像同话题下的文章带读者从0到1读懂源码。</p>
<p>如题首先讲讲 Vue 的整体架构。</p>
<a id="more"></a>
<p>Vue的核心就是数据驱动，而响应式等等机制只不过是其中的组成部分。</p>
<p><strong>数据驱动的动机：</strong> 只关心数据的修改，让代码的逻辑更加清晰。Vue 根据数据的变动，代为去操作dom。</p>
<ul>
<li>整个vue整体架构就是想实现“数据驱动”：
<ul>
<li>而响应式原理只是其中的一个重要模块。</li>
<li>另外mvvm根据vnode更新视图也可以算是“数据驱动”的一部分
<ul>
<li>比如首次构建+“异步更新”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>基于此，我们再从一个更大的视角来看 Vue 的架构设计：</p>
<ul>
<li>【数据驱动】
<ul>
<li>【mvvm】
<ul>
<li>首次构建阶段</li>
<li>异步更新</li>
</ul>
</li>
<li>【响应式原理】 = 数据劫持 + 观察者模式 = 依赖收集 + 派发更新 = defineReactive + 同时存在Dep.target</li>
<li>【data以外的响应式原理】 原理同上
<ul>
<li>比如props是响应式的</li>
<li>另见我另外一篇博客，详细讲解各种</li>
</ul>
</li>
<li>【双向绑定】数据劫持，更新到input控件上 + 监听input控件的键入事件，同步到数据上</li>
<li>【数据代理】(原理极其简单)：数据劫持</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-Router3源码拾遗【6】配套组件的实现]]></title>
      <url>https://blog.az22c.top/2020/09/02/vue-router3-src-code-6-component/</url>
      <content type="html"><![CDATA[<p>如下面章节标题所示：router-view 首次渲染和重新渲染的原理 和 router-link 的原理。</p>
<p>至此，vue-router3 源码系列文章，完结。</p>
<a id="more"></a>
<h2 id="router-view-首次渲染的逻辑"><a class="header-anchor" href="#router-view-首次渲染的逻辑"></a>router-view 首次渲染的逻辑</h2>
<p><strong>router-view 只不过是实现了render函数，算出要渲染哪个组件即可，没有黑科技。</strong></p>
<p>路由最终的渲染离不开组件，Vue-Router 内置了 <code>&lt;router-view&gt;</code> 组件，它的定义在 <code>src/components/view.js</code> 中。</p>
<ul>
<li>前置知识：
<ul>
<li>用到的数据：<code>$route</code> 是定义在 <code>Vue.prototype</code> 上。<strong>每个组件实例访问 <code>$route</code> 属性，就是访问根实例的 <code>_route</code>，也就是当前的路由线路</strong>。(即数据代理：先前已Object.defineProperty定义Vue.prototype的$route为this._routerRoot._route)</li>
<li><code>&lt;router-view&gt;</code> 是一个 <code>functional</code> 组件，它的渲染也是依赖 <code>render</code> 函数</li>
</ul>
</li>
</ul>
<p>因此直接看render即可：</p>
<ul>
<li><strong>router-view的render函数，即整体架构：</strong>
<ul>
<li>(props name 也就是 <code>&lt;router-view name=&quot;xxxx&quot; /&gt;</code>)</li>
<li>【首先获取当前的路径】<code>route = parent.$route</code>  也就是可以粗浅理解为是当前路径 【见前面解释】</li>
<li>【得出应该渲染哪个组件，支持嵌套】因为router-view和 路由配置表(和routerRecord)是映射关系，所以要根据它计算出对应显示的是啥组件
<ul>
<li>( 面向结果编程即可，循环判断父节点是否符合条件，没有黑科技就不看了 )</li>
</ul>
</li>
<li>定义一个回调函数，以备之后更新 <code>matched.instances[name]</code>
<ul>
<li>(定义data.registerRouteInstance，方便后面实现<code>matched.instances[name] = val</code>。这样每个组件的导航钩子，都能拿到对应的组件实例)</li>
</ul>
</li>
<li>调用h函数渲染</li>
</ul>
</li>
</ul>
<pre><code class="language-js">export default {
  name: 'RouterView',
  functional: true,
  props: { /**/name },
  render (_, { props, children, parent, data }) {
    data.routerView = true

    // 定义变量，飞速略过：
    const h = parent.$createElement
    const name = props.name
    const route = parent.$route
    const cache = parent._routerViewCache || (parent._routerViewCache = {})

    // while (parent &amp;&amp; parent._routerRoot !== parent) {

    // 【直接看到这里】
    const matched = route.matched[depth]
    if (!matched) {
      cache[name] = null
      return h()
    }

    const component = cache[name] = matched.components[name]
    // 搞 matched.instances[name]
    data.registerRouteInstance = (vm, val) =&gt; {/*  */ matched.instances[name] = val }
    ;(data.hook || (data.hook = {})).prepatch = (_, vnode) =&gt; { matched.instances[name] = vnode.componentInstance }

    // 关于data.props的逻辑先略过 
    return h(component, data, children)
  }
}
</code></pre>
<p>整体架构就是这样，其中个别模块内容即便展开也没有黑科技，就不作详解了。</p>
<h2 id="vue-router-中的响应式的实现-及-router-view-重新渲染"><a class="header-anchor" href="#vue-router-中的响应式的实现-及-router-view-重新渲染"></a>vue-router 中的响应式的实现 及 router-view 重新渲染</h2>
<ul>
<li>router-view和普通视图template都是调用了渲染watcher。</li>
<li>$route：defineReactive + 可以有Dep.target</li>
</ul>
<p><strong>router-view同样有响应式原理(组件的渲染watcher)，这就是它 重新渲染 的原理：</strong></p>
<p>在我们混入的 <code>beforeCreate</code> 钩子函数中有这么一段逻辑：</p>
<pre><code class="language-js">Vue.mixin({
  beforeCreate () {
    if (isDef(this.$options.router)) {
      Vue.util.defineReactive(this, '_route', this._router.history.current)
    }
    // ...
  }
})
</code></pre>
<ul>
<li>依赖收集：我们在每个 <code>&lt;router-view&gt;</code> 执行 <code>render</code> 函数的时候，都会访问  <code>parent.$route</code>，如我们之前分析会访问 <code>this._routerRoot._route</code>，触发了它的 <code>getter</code>，相当于 <code>&lt;router-view&gt;</code> 对它有依赖</li>
<li>派发更新：在执行完 <code>transitionTo</code> 后，修改 <code>app._route</code> 的时候，又触发了<code>setter</code>，因此会通知 <code>&lt;router-view&gt;</code> 的渲染 <code>watcher</code> 更新，重新渲染组件，也就是调用它的render函数。
<ul>
<li>因为vue在调用每个vm.$mount都会执行new Watcher，意味着每个普通视图组件实例都有渲染watcher</li>
</ul>
</li>
</ul>
<p>另，可以证明是，<strong>每个组件实例访问 <code>$route</code> 属性，就是访问根实例的 <code>_route</code>，也就是当前的路由线路</strong>，这是通过数据代理实现的。</p>
<h2 id="router-link-内置组件"><a class="header-anchor" href="#router-link-内置组件"></a>router-link 内置组件</h2>
<p>首先看看“官方文档”是怎么对比router-link和a标签的选择的：</p>
<ul>
<li>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。</li>
<li>在 HTML5 history 模式下，<code>router-link</code> 会守卫点击事件，让浏览器不再重新加载页面。</li>
<li>当你在 HTML5 history 模式下使用 <code>base</code> 选项之后，所有的 <code>to</code> 属性都不需要写 (基路径) 了。</li>
</ul>
<p>总结成1句话就是，<strong>router-link底层利用 HTML5 browser history 或者 hash history，这样能够维持提供单页应用并且可实现页面局部更新。</strong></p>
<p>再用文本总结下router-link的源码：(具体源码可以自行翻阅，里面没有复杂的东西)</p>
<ul>
<li>作为vue组件，实现了option render函数
<ul>
<li>router.resolve：计算出最终跳转的 <code>href</code></li>
<li>“未来的html元素”的class处理</li>
<li>按要求绑定click等事件回调，对于一般click回调有些细节处理，最终执行 <code>this实例.history</code> 的 <code>push</code> 和 <code>replace</code></li>
</ul>
</li>
</ul>
<p>源码的定义在 <code>src/components/link.js</code> 中：(render属性其实就是h(this.tag, data, this.$slots.default))</p>
<pre><code class="language-js">export default {
  name: 'RouterLink',
  props: {
    to, tag, exact, append, replace, event: /**/
    activeClass: String,
    exactActiveClass: String
  },
  render (h: Function) {
    const [router, current] = [this.$router, this.$route]
    const { location, route, href } = router.resolve(this.to, current, this.append)

    // 对于class做处理
    const classes = {}
    const globalActiveClass = router.options.linkActiveClass // 全局配置
    const globalExactActiveClass = router.options.linkExactActiveClass // 全局配置
    // 降级：
    const activeClassFallback = globalActiveClass == null
            ? 'router-link-active'
            : globalActiveClass
    const exactActiveClassFallback = globalExactActiveClass == null
            ? 'router-link-exact-active'
            : globalExactActiveClass
    const activeClass = this.activeClass == null
            ? activeClassFallback
            : this.activeClass
    const exactActiveClass = this.exactActiveClass == null
            ? exactActiveClassFallback
            : this.exactActiveClass


    const compareTarget = location.path
      ? createRoute(null, location, null, router)
      : route

    classes[exactActiveClass] = isSameRoute(current, compareTarget)
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget) // 是否是包含关系
    // 以上都是处理 activeClass和 exactActiveClass

    const handler = e =&gt; {
      if (guardEvent(e)) {
        if (this.replace) {
          router.replace(location) // 里面就是this.history.replace
        } else {
          router.push(location) // 里面就是this.history.push
        }
      }
    }

    const on = { click: guardEvent }
    if (Array.isArray(this.event)) {
      this.event.forEach(e =&gt; { on[e] = handler })
    } else {
      on[this.event] = handler
    }

    const data: any = {
      class: classes
    }


    // 最后判断当前 `tag` 是否是 `&lt;a&gt;` 标签，`&lt;router-link&gt;` 默认会渲染成 `&lt;a&gt;` 标签，当然我们也可以修改 `tag` 的 `prop` 渲染成其他节点，这种情况下会尝试找它子元素的 `&lt;a&gt;` 标签，如果有则把事件绑定到 `&lt;a&gt;` 标签上并添加 `href` 属性，否则绑定到外层元素本身。
    if (this.tag === 'a') {
      data.on = on
      data.attrs = { href }
    } else {
      const a = findAnchor(this.$slots.default)
      if (a) {
        a.isStatic = false
        const extend = _Vue.util.extend
        const aData = a.data = extend({}, a.data)
        aData.on = on
        const aAttrs = a.data.attrs = extend({}, a.data.attrs)
        aAttrs.href = href
      } else {
        data.on = on
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-Router3源码拾遗【5】改变url]]></title>
      <url>https://blog.az22c.top/2020/09/02/vue-router3-src-code-5-api-n-url/</url>
      <content type="html"><![CDATA[<p>上一篇文章已经介绍了核心模块。这篇文章介绍外围的提供给用户的 api 是怎么实现的，还有如何将变化同步到浏览器 url 的。</p>
<p>对于外围 api，会考虑兼容降级调用浏览器提供的 BOM api，所以先要对这部分知识有一个基本的理解，可以参考本系列文章的第一篇。</p>
<p>这部分代码是真的难读，<code>某某某.push</code>、<code>某某某.history</code>满屏幕都是，字段名又是命名得类似而且一词用于多义，有时候都分不清谁是谁了。再者考虑了兼容性问题，就算是搜出来的字段，经常不知道要点进哪个文件去看。</p>
<a id="more"></a>
<p>特别提醒：HTML5 history的 pushState 和 replaceState，可以<strong>设置history.state并改变 url 地址，但不会刷新页面</strong>。其被提出的目的，就是想像 hash History 一样，能实现类似单页应用的效果并且局部刷新页面。</p>
<h2 id="router-push"><a class="header-anchor" href="#router-push"></a>router.push</h2>
<p>当我们点击 <code>router-link</code> 的时候，或者直接函数式调用<code>this.$router.push</code>，实际上最终会执行 <code>router.push</code>，如下：</p>
<pre><code class="language-js">push (location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort)
}
</code></pre>
<p><strong><code>this.history.push</code> 函数，这个函数是子类实现的，不同模式下该函数的实现略有不同，我们来看一下平时使用比较多的 <code>hash</code> 模式该函数的实现，</strong> 在 <code>src/history/hash.js</code> 中：</p>
<pre><code class="language-js">push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
  const { current: fromRoute } = this
  this.transitionTo(location, route =&gt; {
    pushHash(route.fullPath)
    // handleScroll(this.router, route, fromRoute, false)
    onComplete &amp;&amp; onComplete(route)
  }, onAbort)
}
</code></pre>
<blockquote>
<p>history.replaceState 和 history.pushState 的区别的表现，就是 浏览器回退的时候，回退到上一条记录去哪</p>
</blockquote>
<p>其实主干逻辑很纯粹，复杂的代码就是在遇到需要兼容或者降级的时候区分执行的逻辑就行了。</p>
<p><code>push</code> 函数会先执行 <code>this.transitionTo</code> 做路径切换，在其的回调函数中，执行 <code>pushHash</code> 函数：</p>
<ul>
<li>(<code>hash</code> 模式下的)push
<ul>
<li>this.transitionTo 做路径切换   (可能会调用 onComplete 或 onAbort。它们就类似于Promise的 resolve和 reject 回调 )</li>
<li>在回调中执行 pushHash       (还有执行并列的handleScroll)。
<ul>
<li>(<code>supportsPushState</code>如果支持这个api则返回。 (其实是对ua的判断，也就是 <code>window.navigator.userAgent</code>))</li>
<li>【判断浏览器如果支持 pushState】则获取当前完整的 <code>url</code>，执行 <code>pushState</code> 这个包装方法
<ul>
<li>调用浏览器原生的 <code>history</code> 的 <code>pushState</code> 接口或者 <code>replaceState</code> 接口，更新浏览器的 url 地址</li>
</ul>
</li>
<li>【判断浏览器如果不支持 pushState】 则直接替换：<code>window.location.hash = path</code></li>
</ul>
</li>
<li>(若有则)调用 onComplete</li>
</ul>
</li>
</ul>
<h2 id="点击浏览器前进或后退按钮的响应-即监听历史栈的变化"><a class="header-anchor" href="#点击浏览器前进或后退按钮的响应-即监听历史栈的变化"></a>点击浏览器前进或后退按钮的响应，即监听历史栈的变化</h2>
<p><code>history</code> 的初始化中，会设置一个监听器，监听历史栈的变化：</p>
<pre><code class="language-js">setupListeners () {
  const router = this.router
  // scroll相关....
  window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', () =&gt; {
    if (!ensureSlash()) return;
    this.transitionTo(getHash(), route =&gt; {
      // scroll相关....
      if (!supportsPushState) {
        replaceHash(route.fullPath)
      }
    })
  })
}
</code></pre>
<p>当点击浏览器前进或后退按钮的时候，如果已经有 url 被压入历史栈，则会触发 <code>popstate</code> 事件，然后拿到当前要跳转的 <code>hash</code>，执行 <code>transtionTo</code> 方法做一次路径转换。</p>
<h6 id="ensureslash-："><a class="header-anchor" href="#ensureslash-："></a>ensureSlash ：</h6>
<p>同学们在使用 Vue-Router 开发项目的时候，打开调试页面 <code>http://localhost:8080</code> 后会自动把 url 修改为 <code>http://localhost:8080/#/</code>，这是怎么做到呢？原来在实例化 <code>HashHistory</code> 的时候，构造函数会执行 <code>ensureSlash()</code> 方法：</p>
<p>原理：基于兼容包装replaceHash函数，也就是 <code>history.replaceState</code> 或者 <code>window.location.replace</code>。</p>
<p>原理和实现的代码其实都很简单，就是正如开篇所说的兼容、函数套娃等原因，搞得很难读懂。</p>
<pre><code class="language-js">function ensureSlash (): boolean {
  const path = getHash()
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path)
  return false
}

export function getHash (): string {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  const href = window.location.href
  const index = href.indexOf('#')
  return index === -1 ? '' : href.slice(index + 1)
}

function getUrl (path) {
  const href = window.location.href
  const i = href.indexOf('#')
  const base = i &gt;= 0 ? href.slice(0, i) : href
  return `${base}#${path}`
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path))
  } else {
    window.location.replace(getUrl(path))
  }
}

export function replaceState (url?: string) {
  pushState(url, true)
}
</code></pre>
<h2 id="总结："><a class="header-anchor" href="#总结："></a>总结：</h2>
<p>还是利用浏览器的api：</p>
<ul>
<li>(不严谨统计)</li>
<li>history.replaceState</li>
<li>history.pushState</li>
<li>window.location.replace</li>
<li>window.location.assign</li>
<li>window.addEventListener(‘popstate’, function () {})</li>
<li>window.addEventListener(‘hashchange’, function () {})</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【4运作核心】路径切换和路由守卫]]></title>
      <url>https://blog.az22c.top/2020/09/02/vue-router3-src-code-4-switch-n-guard/</url>
      <content type="html"><![CDATA[<p>如果没有处理路径切换，整个路由器就没法运作，就跟没用一样。可见路径切换模块在其中的核心地位。</p>
<p>讲到“路径切换”，<code>history.transitionTo</code>是位于内部的核心。也就是绝大多数提供给用户的函数，最终都会执行到这里，开启路径切换的流程。</p>
<p>其间值得注意的是，利用迭代器设计模式，可简洁实现路由守卫，是非常巧妙的代码设计，会提前详细介绍。</p>
<p>到文章最后，文字描述路径切换的流程骨架。再剩余每个繁杂具体的 queue 钩子函数没有介绍，留给读者自行仔细研读。</p>
<a id="more"></a>
<p><strong>【<code>history.transitionTo</code>的架构地位：】</strong></p>
<p>前言：<code>history.transitionTo</code> 是 Vue-Router 中非常重要的方法，当我们切换路由线路的时候，就会执行到该方法。</p>
<p>history.push、history.replace实际上也会执行history.transitionTo。函数里的this.confirmTrasition 完成一次真正的路径切换(也是当前话题下的重点)。</p>
<p><strong>【<code>history.transitionTo</code>的职责：】</strong></p>
<p>(前一节我们分析了 <code>matcher</code> 的相关实现，知道它是如何找到匹配的新线路)，那么匹配到新线路后发生的事，就是要研究<code>history.transitionTo</code>。</p>
<p>其实路径切换函数是作为回调传入<code>history.transitionTo</code>，只要实现路径切换和在其前后调用路由守卫就行了。</p>
<p><strong>【内部真正执行路径切换的函数】</strong>：<code>history.transitionTo</code>内部会执行<code>confirmTrasition</code>，后者的代码才是真正去完成其职责。</p>
<blockquote>
<p>“里面那么多不止用于路由守卫的钩子函数具体是怎么样实现处理相应事务的?” 这么枯燥，相信绝大多数人都不需要去关心。在这里先上一点干货，来点有意思的，最后才去贴枯燥的流程解释。</p>
</blockquote>
<h2 id="迭代器-设计模式-敲黑板-划重点"><a class="header-anchor" href="#迭代器-设计模式-敲黑板-划重点"></a>迭代器 设计模式 #敲黑板，划重点</h2>
<p>我们知道路径切换的时候，会依次执行路由守卫钩子，同时路由守卫有“拦截”的作用。实际上 Vue-Router 在此时执行的钩子函数远不止这么少，只是很多内部的钩子函数没有暴露给用户而已。</p>
<p>“路由守卫”这个机制的实现，其实就是迭代器设计模式。在之后看源码的时候就会看到。</p>
<p>先来一个“最简版”迭代器模式，作为demo跑一下，发现设计得挺巧妙的：(其中注释掉的代码是可以去掉的，“注释代码”其作用就是等整个迭代器执行完之后再调用cbOfQueue而已)</p>
<pre><code class="language-JavaScript">function runQueue (queue, iterator, /* cbOfQueue */) {
  var step = function (index) {
    // if (index &gt;= queue.length) {
      // cbOfQueue();
    // } else {
      if (queue[index]) {
        iterator(queue[index], function () {
          step(index + 1);
        });
      } else { step(index + 1); } // edge case:万一这下标没对应的数组元素
    // }
  };
  step(0);
}
async function iterator (fn, next) {
  await fn(); await /* 可以添加代码 */; next();
}
</code></pre>
<p>我们需要把要执行的各种“事务”(也就是回调函数)放入queue这个数组就行了。</p>
<p>我们看到iterator函数第2个参数是一个回调函数，我们称之为next，只要iterator执行了这个next回调，迭代器就能继续往下走。</p>
<p>而iterator函数在每一次循环中的职责就是把第1个传入参数(即其也是一个函数)执行掉，就能去执行next回调了。next本身就是一个<code>() =&gt; step(index + 1)</code>，再通过下标来判断迭代器是否执行完毕即可。这就是满足实现迭代器的需要。</p>
<p>可见如果不执行next，迭代器就不能往下走了，这就是“路由守卫”的原理。(如果不想执行next就可以注入一个abort回调函数供执行以通知外界，这也是官方源码所实现的)</p>
<p>传入的钩子函数fn执行next回调之前，可以在fn中添加任意逻辑，这部分逻辑的载体又是一个回调函数，通常就是 Vue-Router 提供给用户自定义的钩子函数了。</p>
<p><strong>如果能看懂代码，完全不需要看文字描述了！！！！！！！！！！</strong> “摘自源码的对应代码”如下，阅读难度稍稍提高了一点点：</p>
<pre><code class="language-JavaScript">// runQueue摘自源码原文：
/**
 * @param {Array&lt;Function&gt;} queue 将要执行的函数 的队列
 * @param {Function} iterator 传入 函数 给 iterator，iterator内可以执行函数，然后在合适的时候执行其回调(即step(index + 1)) 就能继续这个 runQueue。
 * @param {*} cbOfQueue 队列执行完毕后的回调
 */
function runQueue (queue, fn, cbOfQueue) {
  var step = function (index) {
    if (index &gt;= queue.length) {
      cbOfQueue();
    } else {
      if (queue[index]) {
        fn(queue[index], function () { // fn === iterator
          step(index + 1);
        });
      } else { step(index + 1); } // edge case:万一这下标没对应的数组元素
    }
  };
  step(0);
}
// async function iterator (fn, next) {
//   await fn(); await /* 可以添加代码 */; next();
// }
// change to:
function iterator (fn, next) {
  fn(function cbOfFn() { // 如果想中间插入任务，就把fn弄成可以接收回调的，最后“延迟”到在回调中执行next即可
    next()
  })
};
</code></pre>
<p>经进一步理解之后，再把设计哲学上升一个高度：<strong>其实就是回调函数嵌套+哨兵变量 完成一个迭代器的逻辑。</strong></p>
<blockquote>
<p>好了，后面又是枯燥的“具体业务”解析环节：</p>
</blockquote>
<h2 id="传给-matcher-match-的-this-current-前置知识"><a class="header-anchor" href="#传给-matcher-match-的-this-current-前置知识"></a>传给 matcher.match 的 this.current #前置知识</h2>
<p><code>this.current</code> 是 <code>history</code> 维护的当前路径，它的初始值是在 <code>history</code> 的构造函数中初始化的。</p>
<pre><code class="language-js">this.current = START
</code></pre>
<p><code>START</code> 的定义在 <code>src/util/route.js</code> 中：</p>
<pre><code class="language-js">export const START = createRoute(null, {
  path: '/'
})
</code></pre>
<p>这样就创建了一个初始的 <code>Route</code>，而 <code>transitionTo</code> 实际上也就是在切换 <code>this.current</code>，稍后我们会看到。</p>
<h2 id="confirmtrasition-去做真正的路径切换且调用前后路由守卫"><a class="header-anchor" href="#confirmtrasition-去做真正的路径切换且调用前后路由守卫"></a>confirmTrasition 去做真正的路径切换且调用前后路由守卫</h2>
<p>由于这个过程可能有一些异步的操作（如异步组件），所以整个 <code>confirmTransition</code> API 设计成带有成功回调函数和失败回调函数。</p>
<ul>
<li>confirmTransition
<ul>
<li>(首先定义了 <code>abort</code> 函数)</li>
<li>然后判断如果满足计算后的 <code>route</code> 和 <code>current</code> 是相同路径的话，则直接调用 <code>this.ensureUrl</code> 和 <code>abort</code>。<code>ensureUrl</code> 这个函数我们之后会介绍。</li>
<li>接着又根据 <code>current.matched</code> 和 <code>route.matched</code> 执行了 <code>resolveQueue</code> 方法解析出 3 个队列</li>
<li>3组钩子外加其他钩子放入到queue数组</li>
<li>runQueue(queue, iterator, callback) 迭代执行</li>
</ul>
</li>
</ul>
<h6 id="resolvequeue："><a class="header-anchor" href="#resolvequeue："></a>resolveQueue：</h6>
<pre><code class="language-js">function resolveQueue (
  current: Array&lt;RouteRecord&gt;,
  next: Array&lt;RouteRecord&gt;
): {
  updated: Array&lt;RouteRecord&gt;,
  activated: Array&lt;RouteRecord&gt;,
  deactivated: Array&lt;RouteRecord&gt;
} {
  let i
  const max = Math.max(current.length, next.length)
  for (i = 0; i &lt; max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}
</code></pre>
<p>因为 <code>route.matched</code> 是一个 <code>RouteRecord</code> 的数组，由于路径是由 <code>current</code> 变向 <code>next</code>，那么就遍历对比 2 边的 <code>RouteRecord</code>，找到一个不一样的位置 <code>i</code>：</p>
<ul>
<li>那么 <code>next</code> 中从 0 到 <code>i</code> 的 <code>RouteRecord</code> 是两边都一样，则为 <code>updated</code> 的部分；</li>
<li>从 <code>i</code> 到最后的 <code>RouteRecord</code> 是 <code>next</code> 独有的，为 <code>activated</code> 的部分；</li>
<li>而 <code>current</code> 中从 <code>i</code> 到最后的 <code>RouteRecord</code> 则没有了，为 <code>deactivated</code> 的部分。</li>
</ul>
<p>拿到 <code>updated</code>、<code>activated</code>、<code>deactivated</code> 3 个 <code>ReouteRecord</code> 数组后，接下来就是路径变换后的一个重要部分，执行一系列的钩子函数。</p>
<p>这个计算很简洁，但是有点巧妙，比较典型的例子 foo/bar 切换 到 foo： current是<code>[{/*foo*/}, {/*bar*/}]</code> ； 而 next 是 <code>[{/*foo*/}]</code>。</p>
<h6 id="反正就是3者算好之后-再和其他钩子放入到queue数组："><a class="header-anchor" href="#反正就是3者算好之后-再和其他钩子放入到queue数组："></a>反正就是3者算好之后，再和其他钩子放入到queue数组：</h6>
<pre><code class="language-js">const queue: Array&lt;?NavigationGuard&gt; = [].concat(
  extractLeaveGuards(deactivated),
  this.router.beforeHooks,
  extractUpdateHooks(updated),
  activated.map(m =&gt; m.beforeEnter),
  resolveAsyncComponents(activated)
)
</code></pre>
<p>5步骤按照顺序如下：</p>
<ol>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫</li>
<li>在激活的路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
</ol>
<h6 id="runqueue"><a class="header-anchor" href="#runqueue"></a>runQueue</h6>
<p><code>NavigationGuard(to, from, next)</code>，原理参考前面已经提前介绍的“迭代器”设计模式，只是把变量名改改而已。</p>
<p>再看可自定义的iterator，源码的实现，会根据一些条件执行 <code>abort</code> 或 <code>next</code>。</p>
<pre><code class="language-JavaScript">  var iterator = function (hook, next) {
    // 先不看pending相关逻辑
    try {
      hook(route, current, function (to) {
        if (to === false) {
          // next(false) -&gt; abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(createNavigationAbortedError(current, route));
        } else if (isError(to)) {
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' &amp;&amp;
            (typeof to.path === 'string' || typeof to.name === 'string'))
        ) {
          // next('/') or next({ path: '/' }) -&gt; redirect
          abort(createNavigationRedirectedError(current, route));
          if (typeof to === 'object' &amp;&amp; to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);  // 其实就是 step(index + 1)
        }
      });
    } catch (e) {
      abort(e);
    }
  };
</code></pre>
<blockquote>
<p>大的流程骨架讲完了。剩下的就是“一个一个放入queue中的每个导航守卫是怎么实现的”讲解。首先它们的书写格式，为了满足迭代器的需要，格式已经被限制死了。无非就是其间想实现什么业务的区别而已。</p>
<p>再讲到业务，其实笔者是有研读过导航守卫的具体内容的，这里面还有有一些有意思的代码，但是就算是你想实现相同的业务，这源码的可参考意义也不算很大，所以这里就不贴这些繁琐的代码了。所以本章节就在这里戛然结束了吧。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-Router3源码拾遗【3】matcher匹配器]]></title>
      <url>https://blog.az22c.top/2020/09/02/vue-router3-src-code-3-matcher/</url>
      <content type="html"><![CDATA[<p>方法论：只要明白了某个模块的目的或者功能(或者函数签名、函数参数和返回)，在多数情况下都不用关心其繁杂的具体实现。</p>
<p>以本文内容为例，只要掌握了核心模块<code>createMatcher</code>函数，及其返回的方法<code>matcher.match</code> 二者的作用和原理，就能理清相关模块的整体架构。</p>
<p>再后面就是枯燥的具体实现。如果你也想实现一个前端路由库并且想参考其源码，后半部分姑且可以当做字段字典来查阅。</p>
<a id="more"></a>
<h2 id="该模块的架构总结："><a class="header-anchor" href="#该模块的架构总结："></a>该模块的架构总结：</h2>
<blockquote>
<p>从“函数”的视角入手，掌握关键的函数，用自己的话赋予之“函数签名”，对整个架构的设计的理解就豁然开朗！</p>
</blockquote>
<p><strong>【核心模块：】</strong></p>
<ul>
<li><code>createMatcher</code> 接收 2 个参数，一个是 <code>router</code>，一个是 <code>routes</code>，它是用户定义的路由配置。<strong>内容就是根据路由表来创建各种映射表xxxMap，</strong> 返回(本身是matcher)参数有 match 和 addRouters。</li>
<li><code>matcher.match</code> 会根据传入的位置和路径计算出新的位置，并匹配到对应的路由 record，然后根据新的位置和 record 创建新的路径并返回。</li>
</ul>
<p><strong>【还有周边的一些提供支持的模块：】</strong></p>
<ul>
<li>数据结构模块：Loaction、Route</li>
<li>RouteRecord：抽象成数据结构，还是对路由表的数据做点增强，方便用于匹配</li>
<li>addRoutes： createMatcher的返回结果：<code>addRoutes</code> 方法的作用是动态添加路由配置，因为在实际开发中有些场景是不能提前把路由写死的，需要根据一些条件动态添加路由，所以 Vue-Router 也提供了这一接口。</li>
</ul>
<blockquote>
<p>后文就是枯燥的具体实现的解释了：</p>
</blockquote>
<h2 id="基础数据结构作为前置模块"><a class="header-anchor" href="#基础数据结构作为前置模块"></a>基础数据结构作为前置模块</h2>
<h3 id="loaction-数据结构定义在-flow-declarations-js-中"><a class="header-anchor" href="#loaction-数据结构定义在-flow-declarations-js-中"></a>Loaction 数据结构定义在 <code>flow/declarations.js</code> 中</h3>
<pre><code class="language-js">declare type Location = {
  _normalized?: boolean;
  name?: string;
  path?: string;
  hash?: string;
  query?: Dictionary&lt;string&gt;;
  params?: Dictionary&lt;string&gt;;
  append?: boolean;
  replace?: boolean;
}
</code></pre>
<p>Vue-Router 中定义的 <code>Location</code> 数据结构和浏览器提供的 <code>window.location</code> 部分结构有点类似，它们都是对 <code>url</code> 的结构化描述。举个例子：<code>/abc?foo=bar&amp;baz=qux#hello</code>，它的 <code>path</code> 是 <code>/abc</code>，<code>query</code> 是 <code>{foo:'bar',baz:'qux'}</code>。<code>Location</code> 的其他属性我们之后会介绍。</p>
<h3 id="route-数据结构定义在-flow-declarations-js-中"><a class="header-anchor" href="#route-数据结构定义在-flow-declarations-js-中"></a>Route 数据结构定义在 <code>flow/declarations.js</code> 中</h3>
<pre><code class="language-js">declare type Route = {
  path: string;
  name: ?string;
  hash: string;
  query: Dictionary&lt;string&gt;;
  params: Dictionary&lt;string&gt;;
  fullPath: string;
  matched: Array&lt;RouteRecord&gt;;
  redirectedFrom?: string;
  meta?: any;
}
</code></pre>
<p><code>Route</code> 表示的是路由中的一条线路，它除了描述了类似 <code>Loctaion</code> 的 <code>path</code>、<code>query</code>、<code>hash</code> 这些概念，还有 <code>matched</code> 表示匹配到的所有的 <code>RouteRecord</code>。<code>Route</code> 的其他属性我们之后会介绍。</p>
<h2 id="routerecord：还是对路由表的数据做点增强-方便用于匹配"><a class="header-anchor" href="#routerecord：还是对路由表的数据做点增强-方便用于匹配"></a>RouteRecord：还是对路由表的数据做点增强，方便用于匹配</h2>
<ul>
<li><code>path</code> 是规范化后的路径，它会根据 <code>parent</code> 的 <code>path</code> 做计算</li>
<li><code>regex</code> 是一个正则表达式的扩展，它利用了<code>path-to-regexp</code> 这个工具库，把 <code>path</code> 解析成一个正则表达式的扩展</li>
<li><code>components</code> 是一个对象，通常我们在配置中写的 <code>component</code> 实际上这里会被转换成 <code>{components: route.component}</code>；</li>
<li><code>instances</code> 表示组件的实例，也是一个对象类型；</li>
<li><code>parent</code> 表示父的 <code>RouteRecord</code>，因为我们配置的时候有时候会配置子路由，所以整个 <code>RouteRecord</code> 也就是一个树型结构。</li>
<li></li>
</ul>
<pre><code class="language-js"> const record: RouteRecord = {
  path: normalizedPath,
  regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
  components: route.components || { default: route.component },
  instances: {},
  name,
  parent,
  matchAs,
  redirect: route.redirect,
  beforeEnter: route.beforeEnter,
  meta: route.meta || {},
  props: route.props == null
    ? {}
    : route.components
      ? route.props
      : { default: route.props }
}
</code></pre>
<h2 id="creatematcher-返回的正是-matcher-是做匹配用的"><a class="header-anchor" href="#creatematcher-返回的正是-matcher-是做匹配用的"></a>createMatcher 返回的正是 matcher，是做匹配用的</h2>
<blockquote>
<p><code>createRouteMap</code> 的定义在<code>src/create-route-map</code></p>
</blockquote>
<ul>
<li><code>pathList</code> 是为了记录路由配置中的所有 `path</li>
<li><code>pathMap</code> 和 <code>nameMap</code> 都是为了通过 <code>path</code> 和 <code>name</code> 能快速查到对应的 <code>RouteRecord</code>。</li>
<li>(由于 <code>pathList</code>、<code>pathMap</code>、<code>nameMap</code> 都是引用类型，所以在遍历整个 <code>routes</code> 过程中去执行 <code>addRouteRecord</code> 方法，会不断给他们添加数据。)</li>
</ul>
<blockquote>
<p><code>createMatcher</code> 接收 2 个参数，一个是 <code>router</code>，一个是 <code>routes</code>，它是用户定义的路由配置。**内容就是根据路由表来创建各种映射表xxxMap，**返回(本身是matcher)参数有 match 和 addRouters。</p>
</blockquote>
<ul>
<li>createMathcer 把用户的路由配置转换成一张路由映射表
<ul>
<li><code>const { pathList, pathMap, nameMap } = createRouteMap(routes)</code> 创建一个路由映射表
<ul>
<li>递归遍历路由配置表，调用 addRouteRecord
<ul>
<li>normalizePath 略</li>
<li>(省略)</li>
<li><strong>如果配置了 <code>children</code>，那么递归执行 <code>addRouteRecord</code> 方法，并把当前的 <code>record</code> 作为 <code>parent</code> 传入，通过这样的深度遍历，我们就可以拿到一个 <code>route</code> 下的完整记录。</strong></li>
<li>RouteRecord 添加到各种对应 xxxMap</li>
<li>alias的逻辑就不看了</li>
</ul>
</li>
<li>通配符<code>*</code>优先级问题</li>
</ul>
</li>
</ul>
</li>
<li>match相关的函数和逻辑，最终返回一条 <code>Route</code> 路径</li>
</ul>
<h2 id="addroutes：-creatematcher的返回结果"><a class="header-anchor" href="#addroutes：-creatematcher的返回结果"></a>addRoutes： createMatcher的返回结果</h2>
<p><code>addRoutes</code> 方法的作用是动态添加路由配置，因为在实际开发中有些场景是不能提前把路由写死的，需要根据一些条件动态添加路由，所以 Vue-Router 也提供了这一接口。</p>
<pre><code class="language-js">function addRoutes (routes) {
  createRouteMap(routes, pathList, pathMap, nameMap)
}
</code></pre>
<p><code>addRoutes</code> 的逻辑十分简单：再次调用 <code>createRouteMap</code> 即可，传入新的 <code>routes</code> 配置。由于 <code>pathList</code>、<code>pathMap</code>、<code>nameMap</code> 都是引用类型，执行 <code>addRoutes</code> 后会修改它们的值。</p>
<h2 id="match：-creatematcher的返回结果"><a class="header-anchor" href="#match：-creatematcher的返回结果"></a>match： createMatcher的返回结果</h2>
<p><code>match</code> 方法接收 3 个参数，其中 <code>raw</code> 是 <code>RawLocation</code> 类型，它可以是一个 <code>url</code> 字符串，也可以是一个 <code>Location</code> 对象；<code>currentRoute</code> 是 <code>Route</code> 类型，它表示当前的路径；<code>redirectedFrom</code> 和重定向相关，这里先忽略。</p>
<p><code>match</code> 方法返回的是一个路径，它的作用是根据传入的 <code>raw</code> 和当前的路径 <code>currentRoute</code> 计算出一个新的路径(并返回)。加之通过这个心的路径找到它对应的Record，然后返回<code>_createRoute(...args) =&gt; createRoute(/*对应的Record*/, /*新的路径*/)</code></p>
<blockquote>
<p>在_createRoute中，我们先不考虑 <code>record.redirect</code> 和 <code>record.matchAs</code> 的情况。</p>
</blockquote>
<p>**createRoute返回的是一条 <code>Route</code> 路径，这个对 <code>Route</code> 的切换，组件的渲染都有非常重要的指导意义。**在 Vue-Router 中，所有的 <code>Route</code> 最终都会通过 <code>createRoute</code> 函数创建，并且它最后是不可以被外部修改的。</p>
<p>【非常重要】<code>Route.matched</code> ，它通过 <code>formatMatch(record)</code> 计算而来：可以看它是通过 <code>record</code> 循环向上找 <code>parent</code>，直到找到最外层，并把所有的 <code>record</code> 都 push 到一个数组中，最终返回的就是 <code>record</code> 的数组，它记录了一条线路上的所有 <code>record</code>。<code>matched</code> 属性非常有用，它为之后渲染组件提供了依据。</p>
<blockquote>
<p>总结： match会根据传入的位置和路径计算出新的位置，并匹配到对应的路由 record，然后根据新的位置和 record 创建新的路径并返回。</p>
</blockquote>
<ul>
<li>match
<ul>
<li>normalizeLocation 【看源码的单元测试，大概知道它的使用场景， 计算出新的 <code>location</code>】
<ul>
<li>(一些参数的处理)</li>
<li>parsePath</li>
<li>resolvePath、resolveQuery等等处理比较复杂的location</li>
</ul>
</li>
<li>根据 新location，找到对应<code>Route</code>，并且一起传入调用 _createRoute</li>
</ul>
</li>
</ul>
<h6 id="重新计算-location-详解-可不看"><a class="header-anchor" href="#重新计算-location-详解-可不看"></a>重新计算 location #详解#可不看</h6>
<p>它主要处理了 <code>raw</code> 的两种情况：</p>
<ul>
<li>有 <code>params</code> 且没有 <code>path</code></li>
<li>有 <code>path</code> 的</li>
</ul>
<p>对于第一种情况，如果 <code>current</code> 有 <code>name</code>，则计算出的 <code>location</code> 也有 <code>name</code>。</p>
<h6 id="计算出新的-location后-怎么找到对应的record-详解-可不看"><a class="header-anchor" href="#计算出新的-location后-怎么找到对应的record-详解-可不看"></a>计算出新的 <code>location</code>后，怎么找到对应的record #详解#可不看</h6>
<p>对 <code>location</code> 的 <code>name</code> 和 <code>path</code> 的两种情况做了处理。</p>
<ul>
<li><code>name</code></li>
</ul>
<p>有 <code>name</code> 的情况下就根据 <code>nameMap</code> 匹配到 <code>record</code>，它就是一个 <code>RouterRecord</code> 对象，如果 <code>record</code> 不存在，则匹配失败，返回一个空路径；然后拿到 <code>record</code> 对应的 <code>paramNames</code>，再对比 <code>currentRoute</code> 中的 <code>params</code>，把交集部分的 <code>params</code> 添加到 <code>location</code> 中，然后在通过 <code>fillParams</code> 方法根据 <code>record.path</code> 和 <code>location.path</code> 计算出 <code>location.path</code>，最后调用 <code>_createRoute(record, location, redirectedFrom)</code> 去生成一条新路径，该方法我们之后会介绍。</p>
<ul>
<li><code>path</code></li>
</ul>
<p>通过 <code>name</code> 我们可以很快的找到 <code>record</code>，但是通过 <code>path</code> 并不能，因为我们计算后的 <code>location.path</code> 是一个真实路径，而 <code>record</code> 中的 <code>path</code> 可能会有 <code>param</code>，因此需要对所有的 <code>pathList</code> 做顺序遍历， 然后通过 <code>matchRoute</code> 方法根据 <code>record.regex</code>、<code>location.path</code>、<code>location.params</code> 匹配，如果匹配到则也通过 <code>_createRoute(record, location, redirectedFrom)</code> 去生成一条新路径。因为是顺序遍历，所以我们书写路由配置要注意路径的顺序，因为写在前面的会优先尝试匹配。</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【2】路由注册和VueRouter实例]]></title>
      <url>https://blog.az22c.top/2020/09/02/vue-router3-src-code-2-instance/</url>
      <content type="html"><![CDATA[<p>如果明白了上一篇文章，Vue-Router的核心原理，那么这一篇就没啥好看的，初始化和实例化工作，就是根据原理来枯燥地具体实现还有edge case的处理。</p>
<p>枯燥预警！！！笔者也没挖掘出什么看点，如果你也想实现一个前端路由库并且想参考其源码，姑且可以当做字段字典来查阅。</p>
<a id="more"></a>
<ul>
<li>读前须知
<ul>
<li>main.js 执行大Vue的时候传入router实例，若能在 this.$options.router 中拿到它，则为根Vue组件实例。根Vue组件实例在后面简称“根组件实例”</li>
<li>变量指代思想：
<ul>
<li><code>_router</code>表示<code>router</code>实例，它是在 new实例化Vue组件 的时候传入的；</li>
<li><code>_routerRoot</code>表示 实例化时传入了 <code>router</code> 对象作为配置 的自己或者离自己最近的父实例。</li>
<li><code>this.app</code> 表示根 <code>Vue</code> 实例，<code>this.apps</code> 保存持有 <code>$options.router</code> 属性的 <code>Vue</code> 实例。</li>
</ul>
</li>
</ul>
</li>
<li>install
<ul>
<li>(标记并且防止多处重复注册自己(即vue-router))</li>
<li>【关键】vue.mixin({ beforeCreate, destroyed })    ，底层原理是 mergeOptions函数，目标是<strong>钩子函数拓展注入到每个组件的this上</strong></li>
<li>拦截Vue.prototype的$router和$route，从根组件实例上获取即可  【为了优化重复注册】</li>
<li><code>Vue.component('RouterView', View)；Vue.component('RouterLink', Link)</code></li>
<li>拿到 Vue.config.optionMergeStrategies，统一配合设置 路由钩子 的“合并策略”</li>
</ul>
</li>
<li>(-------------执行钩子函数-----------)
<ul>
<li>beforeCreate
<ul>
<li>【如果是实例化时传入router】this.$options.router.init(this)  + Vue.util.defineReactive(this, ‘_route’, this._router.history.current)， this._route是响应式的，渲染watcher可监听它；基于数据代理，this.$route是响应式的
<ul>
<li><code>this.$options.router.init(this)</code>
<ul>
<li>(存储 this.app 和 this.apps。<strong>init内，后面的逻辑，只针对根Vue组件实例</strong>)</li>
<li>【对于hash模式】执行的是 history.transitionTo (即路由过渡)
<ul>
<li>实际上是调用了 <code>this.matcher.match</code> 方法去做匹配</li>
<li>拿到结果传入this.confirmTrasition 完成一次真正的路径的切换</li>
</ul>
</li>
<li>【重要】再执行history.listen</li>
<li>【对于browser模式】  暂时略过</li>
</ul>
</li>
</ul>
</li>
<li>【如果是实例化时不传入router】设置它的 this._routerRoot 为 离它最近的传入了 <code>router</code> 对象作为配置而实例化的父实例</li>
<li>registerInstance，即调用 vm.$options._parentVnode.registerRouteInstance</li>
</ul>
</li>
<li>destroyed
<ul>
<li>registerInstance 同上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="registerinstance-也就是-beforecreate-和-destroyed-都执行了它"><a class="header-anchor" href="#registerinstance-也就是-beforecreate-和-destroyed-都执行了它"></a>registerInstance  也就是 beforeCreate 和 destroyed 都执行了它</h2>
<h2 id="new-vuerouter-和其实例"><a class="header-anchor" href="#new-vuerouter-和其实例"></a>new VueRouter 和其实例</h2>
<p><strong>构造函数：</strong></p>
<p><code>this.options</code> 保存传入的路由配置。</p>
<p><code>this.matcher</code> 表示路由匹配器。</p>
<ul>
<li>beforeHooks、resolveHooks、afterHooks</li>
</ul>
<p><code>this.mode</code> 表示路由创建的模式，<code>this.history</code> 表示路由历史的具体的实现实例，它是根据 <code>this.mode</code> 的不同实现不同，不同的History Class，都是基于<code>History</code> 基类继承实现的。</p>
<p>(<code>this.fallback</code> 表示在浏览器不支持 <code>history.pushState</code> 的情况下，根据传入的 <code>fallback</code> 配置参数，决定是否回退到hash模式)</p>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-Router3源码拾遗【1】概述]]></title>
      <url>https://blog.az22c.top/2020/09/02/vue-router3-src-code-1-overview/</url>
      <content type="html"><![CDATA[<p>若要深挖 Vue-Router 的源码，代码真的是又臭又长。本系列依旧提取源码中的核心原理并且尽量用文本概括繁杂的逻辑流程。</p>
<p>Vue-Router 实际上只适用于单页应用(其实这个结论是可以推理出来的)。而像 Nuxt 之类的看似是用到了 Vue-Router 且像是多页的，实际上是它们是用到了多个 Vue-Router。记住单页与多页的区分，这个区分贯穿了本文的脉络。</p>
<a id="more"></a>
<p>说到“前端路由”，若不懂以下浏览器 BOM api，就没法往下说了。详细介绍 api 的工作还是留给其他人好了，以后除非要debug这些库，是接触不到这些经封装的底层的 api 的。这里主要是完整地列举一下原理用到的部分，好留一个印象。</p>
<h2 id="前置知识"><a class="header-anchor" href="#前置知识"></a>前置知识</h2>
<blockquote>
<p><strong>在这一小节中，就算没掌握 api 的用法也没关系，关注的核心还是 history 系列 api ，而一起列举其他的 api 起到对比的作用。</strong></p>
</blockquote>
<p>下面比较完整地列举了一下 Vue-Router 原理可能涉及到的3大类 BOM api：</p>
<ul>
<li>location： 全是多页的模式
<ul>
<li>------------  获取url参数 或 query参数: --------------</li>
<li>url参数获取的，先略
<ul>
<li><a href="https://segmentfault.com/a/1190000009384087" target="_blank" rel="noopener">location的属性表 – 属性表，面试可先不看</a></li>
</ul>
</li>
<li>query参数：从<code>location.search</code>获取才是正解
<ul>
<li><a href="https://segmentfault.com/a/1190000009384087" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009384087</a></li>
</ul>
</li>
<li>------------  利用location，重载页面或跳转 --------------</li>
<li>【1】重新加载页面：<code>window.location.reload(/**/)</code>
<ul>
<li>如果不传任何参数 【相当于F5】</li>
<li>如果传入参数true时 【这个参数因不在规范里面已经被废弃】【相当于ctrl + F5】
<ul>
<li>( 注意：给路径加上时间戳也可以实现ctrl + F5的效果。 )</li>
</ul>
</li>
</ul>
</li>
<li>【2】跳转：window.location.assign(url)或者直接修改window.location.href</li>
<li>【3】“栈帧替换”跳转：window.location.replace(url)
<ul>
<li>用来实现过渡页面时，非常好用</li>
<li>但是有些webview却是反而不支持这个老api的，那就改用<code>history.replaceState</code>+<code>window.location.reload()</code>
<ul>
<li>比如在开发的钉钉上的微应用的时候就不支持</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>history
<ul>
<li>早期history：history.go()、history.forward()、history.back()
<ul>
<li>(等价地囊括)对应用户的点击操作</li>
<li><strong>即可用于多页，也可用于单页</strong></li>
</ul>
</li>
<li>【重要】HTML5 history
<ul>
<li>pushState 和 replaceState，可以<strong>设置history.state并改变 url 地址，但不会刷新页面</strong></li>
<li>popstate 事件，不会去监听 pushState/replaceState
<ul>
<li>无论在单页还是多页，主要作用就是监听前进后退</li>
<li>点击浏览器前进后退 或者 调用早期history的 back() go() forward()方法的时候才会触发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>hash：hash变化时不需要刷新页面
<ul>
<li>监听hashchange事件
<ul>
<li>window.onhashchange</li>
<li>window.addEventListener(hashchange, /**/)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>再来(用大白话)总结一下：</p>
<ul>
<li>location 主要有2种作用：获取各种url参数+提供api主要用来控制页面的刷新和跳转</li>
<li>location 的全部 api 就是把网页视为传统的“多页”的模式</li>
<li>histroy api可以分为“早期 history”和“HTML5 history”</li>
</ul>
<p>这里我们看到“早期 history” vs “HTML5 history”；“单页” vs “多页”。下面我们再从另外一个分类的角度来重新看它们间的关系：</p>
<h2 id="前端路由概述和对比：-重要"><a class="header-anchor" href="#前端路由概述和对比：-重要"></a>前端路由概述和对比： #重要</h2>
<blockquote>
<p><strong>vue-router只适用于单页应用</strong></p>
<p>早期history：在单页应用的时代不是主力，但是仍有作用</p>
</blockquote>
<ul>
<li>多页：后端路由返回不同html
<ul>
<li>可利用location实现跳转</li>
<li>早期history</li>
</ul>
</li>
<li>单页：【通过vue-router来了解】
<ul>
<li><strong>本质：监听url变化不刷新页面，而只更新部分内容</strong></li>
<li>类型：
<ul>
<li>hash：在改变 hash 的情况下，访问的还是同一个页面，(不会去请求新页面，)只是局部更新html。
<ul>
<li>通过改变路由的hash值并且监听hash变化</li>
</ul>
</li>
<li>HTML5 history + 早期history</li>
<li>虚拟路由</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上，就涵盖了所有互联网上的浏览器网页的“路由”的实现原理。</p>
<p>上面仅仅是基础知识，有了基础知识之后，我们再来看看相关的问题的解答：</p>
<h2 id="单页的html5-history和hash对比-已齐全-面试常问"><a class="header-anchor" href="#单页的html5-history和hash对比-已齐全-面试常问"></a>单页的HTML5 history和hash对比 #已齐全 #面试常问</h2>
<ul>
<li>原理和本质：前者不同路由是不同地址；后者不同路由其实是同一个地址
<ul>
<li>( 前者基于url的pathname段，后者基于hash段 来标识。 )</li>
<li>( 对于单页应用：api如上小节所说：HTML5 history + 早期history  vs hash )</li>
</ul>
</li>
<li>适用范围：前者可用于多页和单页；后者只能单页</li>
<li>兼容性：react更推荐前者，而后者能兼容更多浏览器</li>
<li>在实现单页时，刷新的缺陷：<strong>刷新单页HTML5 history的页面需要服务器端配合：</strong>
<ul>
<li>当用户刷新页面之类的操作时，(真正地去访问对应url，)浏览器还是会给服务器发送请求页面。</li>
<li>为了避免出现这种情况，所以这个实现需要服务器的支持：所有页面重定向到首页路由</li>
</ul>
</li>
</ul>
<p>明白了上述概念，再来看 Vue-Router的核心原理就不难了：</p>
<h2 id="vue-router的实现原理概述"><a class="header-anchor" href="#vue-router的实现原理概述"></a>vue-router的实现原理概述</h2>
<ul>
<li>api：屏蔽底层的browser history和hash history
<ul>
<li>api降级：如果不支持HTML5 history(比如IE9环境下)，就会降级成hash</li>
</ul>
</li>
<li>整体架构： 【react-router可能也不过如此???】
<ul>
<li>抽象出 route 当前路由对象，它和浏览器原生的 url 互相同步
<ul>
<li>提供路径切换的回调，承载改变url之类的操作</li>
<li>核心函数调用路径切换回调和其前后的路由守卫</li>
</ul>
</li>
<li>实现matcher</li>
<li>提供视图渲染的组件 和 封装跳转的组件</li>
</ul>
</li>
<li>设计模式
<ul>
<li>迭代器模式</li>
</ul>
</li>
<li>( 记录访问过的路由。通过计算，让vue组件调用activated或者deactivated钩子 )</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[03-跨域通信和跨tab通信]]></title>
      <url>https://blog.az22c.top/2020/05/22/cross-origin-cross-tab/</url>
      <content type="html"><![CDATA[<p>上一篇文章介绍了什么是“跨域”和“跨站”。可知，“同站”通信也是“跨域”的一种途径。</p>
<p>这次列举一下跨域通信的方法，同时对跨tab通信有启发性价值。</p>
<p>因为前人总结得实在是太齐全了！这里只是做到基本列举齐全，然后做一些小小的补充。</p>
<a id="more"></a>
<h2 id="解决跨域问题"><a class="header-anchor" href="#解决跨域问题"></a>解决跨域问题</h2>
<h3 id="同源限制：协议-主机名-端口都相同"><a class="header-anchor" href="#同源限制：协议-主机名-端口都相同"></a>同源限制：协议，主机名，端口都相同</h3>
<p>更准确地来讲，同源限制体现在2个方面：</p>
<p>1 <strong>若向工作在不同源的服务请求，限制响应的处理（client to server）</strong> 对于Ajax的影响在于，通过XMLHttpRequest实现的Ajax请求，能向不同的域提交请求，但是不允许获得响应的内容。例如，在abc.example.com下的页面，向def.example.com提交Ajax请求，响应的内容被限制 等等。</p>
<p>2 <strong>无法获取不同源的document/浏览器存储数据等BOM和DOM （client to client）</strong> 可以说任何有关另外一个源的信息都无法得到：在baidu.com下的页面中包含的js代码，不能访问在google.com域名下的页面内容；甚至不同的子域名之间的页面也不能通过js代码互相访问。</p>
<p>3 例外：但是有三个标签是允许跨域加载资源：<code>&lt;img src=xxx&gt;</code>、<code>&lt;link href=xxx&gt;</code>、<code>&lt;script src=xxx&gt;</code></p>
<ul>
<li><strong>不能忽略的事实1：</strong> 跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/java等其它环境</li>
<li><strong>不能忽略的事实2：</strong> 跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了（这也就是为什么CORS能用的原因）
<ul>
<li>其实post也可被视为“不受同源规则限制”：在请求时可跨域请求，而且如果可以提交之后不需要返回，这样只是不知道有没有请求成功而已。
<ul>
<li>如果想要知道是否成功的话，可以一个服务器通知那个提供页面的服务器（即同源的）去返回结果。</li>
</ul>
</li>
<li>post的跨域限制的解决，主要是用 nginx后端转发 或者 form提交（页面会刷新跳转到相应页面） 或者 用CORS</li>
</ul>
</li>
</ul>
<h3 id="跨域各种方法列举-9种"><a class="header-anchor" href="#跨域各种方法列举-9种"></a>跨域各种方法列举–9种</h3>
<blockquote>
<p>其实就是8种，1种被废弃
注意：单纯的iframe不能跨域，即其是有同源限制的，要结合其他方法才能实现跨域效果。</p>
</blockquote>
<ul>
<li>jsonp 只能服务于get啊
<ul>
<li><a href="https://www.zhihu.com/question/373011996/answer/1032783062" target="_blank" rel="noopener">阿里还挺常用jsonp的，跨不同的业务线</a></li>
<li>jsonp优缺点：如果只有get请求的情况下，jsonp无疑是兼容性最好的选择，尤其是支持IE6 7。</li>
</ul>
</li>
<li>CORS策略（跨域资源共享策略）：主要是后端的处理 <strong>(实质上主要用于ajax)</strong></li>
<li>利用HTML5 postMessage：postMessage(send) 和 onmessage。
<ul>
<li>想<strong>跨域</strong>则依赖另一个window对象的获取 比如window.opener或结合iframe</li>
<li><a href="https://blog.csdn.net/zhuzhupozhuzhuxia/article/details/76795472" target="_blank" rel="noopener">postmessage辨别origin等能提高安全</a></li>
</ul>
</li>
<li>【在新版本chrome和edge中行不通了】document.domain （这个页面和“另一个页面或者iframe”显式设置成同一个二级域名，服务于特定场景）
<ul>
<li>不一定要搭配iframe
<ul>
<li>不同页面之间，如果用了localstorage也可以不用iframe：<a href="https://bbs.csdn.net/topics/390829793" target="_blank" rel="noopener">https://bbs.csdn.net/topics/390829793</a></li>
<li><a href="https://blog.csdn.net/nlznlz/article/details/79506655" target="_blank" rel="noopener">搭配window.open也可以不用iframe</a></li>
</ul>
</li>
<li><a href="https://github.com/yleo77/Notes/issues/4" target="_blank" rel="noopener">麻烦的就是容易被刷新页面给刷掉，导致该策略失效。还有ie低版本会有bug。</a></li>
</ul>
</li>
<li>iframe + <code>window.name</code>
<ul>
<li>操作：iframe先引用跨域iframe再切换为引用同源的。最终iframe内外是同源，即可从iframe外读取iframe里面的<code>window.name</code></li>
<li>原理：window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）
<ul>
<li><strong>iframe就是持有window.name的“中间人”了</strong></li>
<li>切换iframe的网址：这个工作通常位于“监听iframe的onload事件”的回调中</li>
</ul>
</li>
<li>缺点：每次通信都要创建一次iframe</li>
<li><a href="https://juejin.cn/post/6844903767226351623" target="_blank" rel="noopener">参考例子</a></li>
</ul>
</li>
<li>iframe + <code>location.hash</code>
<ul>
<li>操作：多层嵌套iframe+最内层iframe是同源的+监听hash事件以驱动流程。</li>
<li>原理：因为后来同源了，所以可以使用<code>window.parent.parent</code></li>
<li>缺点：需要占用iframe的宿主的hash；每次通信都要创建2次iframe</li>
</ul>
</li>
<li>Websocket：原生 WebSocket API 使用起来不太方便，我们使用Socket.io轮子
<ul>
<li>ws协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信</li>
<li>ws是网络通信协议，所以其实现一定要经过服务器，不能直接client to client</li>
</ul>
</li>
<li>nginx反向代理 【常用，而且生产可用，就是需要沟通扯皮】
<ul>
<li>同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</li>
<li>因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。</li>
</ul>
</li>
<li>node中间层代理：和nginx反向代理同理
<ul>
<li><strong>需要大规模用node才考虑，不然不用考虑；这部分的人员职责难被有效管理</strong></li>
</ul>
</li>
</ul>
<h3 id="跨域方案的总结："><a class="header-anchor" href="#跨域方案的总结："></a>跨域方案的总结：</h3>
<blockquote>
<p>document.domain被浏览器们废弃，局限性大，而且容易被刷新页面刷掉。</p>
</blockquote>
<p><strong>nginx反向代理解决大多数问题，就是可能需要沟通扯皮。jsonp仅限get，不利于统一get post等接口字段规范，用的越来越少。</strong></p>
<ul>
<li>现代的浏览器，跨域优先考虑CORS，IE 11就全面支持了。</li>
<li>(后补充：2022年中，IE浏览器已被废弃)</li>
<li>IE8-10，结合iframe和postMessage，POST跨域不在话下。</li>
<li>IE6-7，还是iframe，利用iframe父子引用+location.hash。</li>
</ul>
<h2 id="浏览器tab间通信"><a class="header-anchor" href="#浏览器tab间通信"></a>浏览器tab间通信</h2>
<p><a href="https://juejin.cn/post/6844903811232825357" target="_blank" rel="noopener">建议直接阅读这篇文章</a></p>
<p>链接中文章的各种方法按“能否跨域”来进行划分，是比较合理的。作为基础，本文已总结出“跨域通信”的方式，这样再看链接文就没有那么困难了。</p>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 笔记副本 </tag>
            
            <tag> 跨tab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02-第三方cookie(注：将被禁用)]]></title>
      <url>https://blog.az22c.top/2020/05/22/cross-origin-cross-site-cookie/</url>
      <content type="html"><![CDATA[<p>简要解释第三方cookie的原理和相关属性。</p>
<a id="more"></a>
<blockquote>
<p>第三方cookie(即cookie跨站)被告了，2023年将被全面禁止 —<strong>!!!注意好这个前提</strong></p>
</blockquote>
<h2 id="关于cookie跨站：withcredentials-和-samesite-属性"><a class="header-anchor" href="#关于cookie跨站：withcredentials-和-samesite-属性"></a>关于cookie跨站：withCredentials 和 sameSite 属性</h2>
<blockquote>
<p>【引用一下他处】什么是“同站”：浏览器同源指的是<strong>协议，主机名，端口都相同</strong>；Cookie中的“同源”只关注域名，忽略协议和端口，也就是Cookie可以跨二级域名来访问，即也可以称为“同站”。</p>
<p>什么是“跨站”：浏览器本身是允许cookie同站通信的；而所谓的“跨站”，比如cookie跨站实现第三方cookie，实际上就是想利用浏览器更加“开放”的那些规则来突破“同站”的限制。</p>
</blockquote>
<p><img src="https://cloud.az22c.top/with-credentials-vs-same-site.jpg-az22cgithub" alt="!!!【必看 重要】概括说明图"></p>
<ul>
<li>samesite和withCredentials的对比 【个人思考】
<ul>
<li>withCredentials 和 sameSite属性都是针对cookie跨站的，所以与生俱来就都和CSRF安全相关。</li>
<li>通常需要客户端+服务端一起配合设置</li>
<li><strong>但是针对同样这件事，2者的态度是对立的</strong>：一个希望放宽(原有的规则)，一个则希望限制(原有的规则)</li>
<li>withCredentials可针对xhr；而samesite可针对xhr，也可包括a img iframe等等标签的引用http所相关的cookie。</li>
<li>(withCredentials在很早CORS的时候提出；sameSite在chrome 80中提出，算比较晚了)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>withCredentials： 客户端+服务端xhr机制
<ul>
<li>作用：如果需要跨域(包括“跨站”)AJAX发送Cookie     (不仅会<strong>发送</strong>Cookie，还可以去设置远程主机域名下的Cookie)</li>
<li>基于CORS：为了让这个属性生效，<strong>服务器</strong>必须显式返回<code>Access-Control-Allow-Credentials</code>这个头信息
<ul>
<li>备注：<code>Access-Control-Allow-Origin</code>就不能设为星号，要对应上你所允许放行的请求。同时，Cookie依然遵“同站”政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传</li>
</ul>
</li>
<li>客户端的开启：<code>xhr.withCredentials = true;</code>
<ul>
<li>(反过来看，若未开启时的效果：<code>withCredentials</code>属性是一个布尔值，默认为<code>false</code>。即向“对于<code>example.com</code>是跨域的”请求时，不会发送<code>example.com</code>设置在本机上的Cookie（如果有的话）。)</li>
</ul>
</li>
<li>(edge case：如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>浏览器sameSite属性： 客户端+服务端机制</p>
<ul>
<li>作用：该属性可分别限制整个页面中的每个http的cookie跨站情况  (即其意图和CSRF相关)</li>
<li>其<strong>默认值</strong>让 Cookie 在<strong>跨站</strong>请求时不会被发送，从而可以阻止跨站请求伪造攻击（即CSRF）</li>
<li>出现后所带来的坑：在chrome 80中提出，导致之前上线的旧网站的跨站的Cookie用不了。(其实就是针对和打击第三方Cookie)
<ul>
<li>(而避免CSRF的方式本来就有很多，所以我目前不太认同这种sameSite理念的提出)</li>
</ul>
</li>
<li><strong>旧网站</strong>临时解决sameSite默认值所带来的坑：手动设置 SameSite 为 none。</li>
</ul>
</li>
<li>
<p>注意，在开了withCredentials的环境下，此时客户端<strong>你的脚本</strong> 还是遵守“cookie同站”政策，无法 从<code>document.cookie</code>或者HTTP回应的头信息之中，<strong>读取</strong>这些Cookie。</p>
<ul>
<li>(总之，开了之后，可以发送，但仍不能读取跨站cookie)</li>
</ul>
</li>
</ul>
<h2 id="将被废弃的-第三方cookie的实现途径-本质上就是cookie跨站"><a class="header-anchor" href="#将被废弃的-第三方cookie的实现途径-本质上就是cookie跨站"></a>(将被废弃的)第三方Cookie的实现途径(本质上就是cookie跨站)</h2>
<ul>
<li><strong>第三方cookie(即cookie跨站)被告了，2023年将被全面禁止。谷歌的代替品链：</strong>
<ul>
<li><strong>第三方Cookie(废弃)   ==&gt;  FLoC(还是能确定用户身份，推行受阻)  ==&gt; Topics(2022年年初提出)</strong></li>
</ul>
</li>
<li>在过渡时期补足，可以使用浏览器指纹，但是效果当然没那么准确</li>
<li>以往的被废弃的“第三方Cookie”的实现途径
<ul>
<li>多数是比如请求<code>ad.com</code>的一张图片，这样在响应这个图片请求的时候就能设置<code>ad.com</code>的cookie
<ul>
<li>(请求图片，本身是完全可以“跨域”和“跨站”的)</li>
</ul>
</li>
<li>有些广告商会封装成一个js，你只要在你的网站引用这个js就帮你实现对应逻辑</li>
<li>但是现在各浏览器的趋势是禁止第三方Cookie。比如浏览器cookie的samesite这个配置，就是限制的态度。</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 跨站 </tag>
            
            <tag> Cookie </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 笔记副本 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01-跨域和跨站的基本概念]]></title>
      <url>https://blog.az22c.top/2020/05/22/cross-origin-cross-site/</url>
      <content type="html"><![CDATA[<p>介绍一下跨域和跨站的基本概念。</p>
<a id="more"></a>
<h2 id="一级域名-二级域名-三级域名"><a class="header-anchor" href="#一级域名-二级域名-三级域名"></a>一级域名 二级域名  三级域名</h2>
<p>一般来说就是比如<code>www.baidu.com</code>： <code>.com</code>是一级域名； <code>baidu</code>是二级域名； <code>www</code>是三级域名。其后同理。</p>
<h2 id="跨域和跨站的区别"><a class="header-anchor" href="#跨域和跨站的区别"></a>跨域和跨站的区别</h2>
<ul>
<li>首先要理解的一点就是跨站和跨域是不同的。
<ul>
<li>“站”：
<ul>
<li>同站(same-site)和第一方(first-party)是等价的。</li>
<li>跨站(cross-site)和第三方(third-party)是等价的。</li>
</ul>
</li>
<li>但是与浏览器同源策略（SOP）中的「同源(same-origin)/跨域(cross-origin)」是完全不同的概念。</li>
</ul>
</li>
</ul>
<p>同源策略的同源，是指两个 URL 的“协议+主机名+端口”3者都一致。例如，<code>https://www.taobao.com/pages/...</code>，它的协议是 https，主机名是<code>www.taobao.com</code>，端口是 443，另一个url的这3者与之都一致才能叫“同源”。</p>
<p>同源策略作为浏览器的安全基石，其“同源”判断是比较严格的，而相对而言，Cookie中的“同站”判断就比较宽松：</p>
<p><strong>只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。</strong> 其中，eTLD 表示<strong>有效顶级域名</strong>，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co、.uk、.github.io 等。而 eTLD+1 则表示，有效顶级域名+二级域名，例如taobao.com等。</p>
<p>举几个例子，www.taobao.com和www.baidu.com是跨站，www.a.taobao.com和www.b.taobao.com是同站，a.github.io和b.github.io是跨站(<strong>注意是跨站</strong>)。</p>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 跨站 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 笔记副本 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试题：改造代码，使之隔秒输出0 - 9]]></title>
      <url>https://blog.az22c.top/2020/04/02/settimeout-0-to-9/</url>
      <content type="html"><![CDATA[<p>通过一道面试题，文末总结一下js【变量快照】和【缓存变量值】的手法。原题考察的是对js作用域和对setTimeout api的理解，在本文主要给出5种解法。</p>
<a id="more"></a>
<hr>
<p><strong>题目的提出：</strong> “改造下面的代码，使之隔秒输出0 - 9，写出你能想到的所有解法：”</p>
<pre><code class="language-js">// 题目代码：
for (var i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i);
    // debugger;
  }, i * 1000)
}
</code></pre>
<p>考察的是对作用域和对setTimeout api的理解。</p>
<p><strong>首先不急着答题，若想更好地理解，我们思考一下代码未改动前打印结果和原理。</strong></p>
<h4 id="首先解释原代码的打印结果：-没有形成闭包"><a class="header-anchor" href="#首先解释原代码的打印结果：-没有形成闭包"></a>// 首先解释原代码的打印结果：【没有形成闭包】</h4>
<p>打印全都是10。<strong>没有形成闭包。</strong></p>
<p>因为计数变量 i 它还是属于全局作用域：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  // 故意不写代码，让打印测试结果更加清楚
}
console.log(window.i) // 10
console.log(i) // 10，明显没有闭包，i是全局变量啊，因为是全局变量所以驻留在内存中
setTimeout(() =&gt; {
  console.log(i) // 10
}, 2000)
</code></pre>
<p>证明：setTimeout引用计数变量i，也没有产生闭包（计数变量还是没有达到闭包的要有“外层函数”的条件）：</p>
<pre><code class="language-js">for(var i = 0; i &lt; 10; i++) {
  setTimeout(function() {
      console.log(i);
      debugger; // 在这里断点，查看是否有闭包
  }, i * 1000);
}
</code></pre>
<p><strong>回到本文的正题，这个面试题的解法有哪些呢？</strong></p>
<h2 id="方法一：let-const块级作用域-于for循环"><a class="header-anchor" href="#方法一：let-const块级作用域-于for循环"></a>方法一：let / const块级作用域 于for循环</h2>
<p>原理：利用 <code>let</code> 变量的特性 — 在每一次 <code>for</code> 循环的过程中，<code>let</code> 声明的变量会在当前的块级作用域里面（<code>for</code> 循环的 body 体，也即两个花括号之间的内容区域）创建一个词法环境（Lexical Environment），该环境里面包括了当前 <code>for</code> 循环过程中的 <code>i</code>，（也就是类似函数作用域的效果）<a href="https://javascript.info/closure#for-while" target="_blank" rel="noopener">具体链接</a></p>
<p>另外，记得曾在知乎上看到，方应杭也是这么说的。PS：chrome控制台断点debug能看到block作用域。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i);
  }, i * 1000)
}
// 等价于：
for (var i = 0; i &lt; 10; i++) {
  let _i = i;// 所以即便在本次循环中篡改_i也不会影响到i
  setTimeout(() =&gt; {
    console.log(_i);
    // console.log(++_i);
  }, i * 1000)
}
</code></pre>
<p>写法2：let tmp局部变量，需要是块级作用域。一定要let，而var tmp是不行的。</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  let tmp = i;
  setTimeout(() =&gt; {
    console.log(tmp);
  }, i * 1000)
}
</code></pre>
<h2 id="方法二：-外层函数-传入自由变量-settimeout构建闭包"><a class="header-anchor" href="#方法二：-外层函数-传入自由变量-settimeout构建闭包"></a>方法二：“外层函数”传入自由变量+setTimeout构建闭包</h2>
<p>原理： <strong>这里主要是setTimeout帮助构建闭包。</strong> 函数局部作用域在这里也是构建闭包的条件之一。另外，不会因为单纯有IIFE就会有闭包。</p>
<pre><code class="language-js">// 这个还真的是闭包，不信在chrome debug断点一下：应该是setTimeout回调函数引用了自执行函数的自由变量，导致该自由变量没被回收。
// 不信的话，可以去掉setTimeout，闭包就没了。
for (var i = 0; i &lt; 10; i++) {
  (i =&gt; {
    setTimeout(() =&gt; {
      console.log(i);
    }, i * 1000)
  })(i)
}
</code></pre>
<p>另外一种方式：（后面会补充说到，如果setTimeout的第一个参数是js语句，该语句会被同步执行）</p>
<pre><code class="language-js">for(var i = 0; i &lt; 10; i++) {
  setTimeout(
    (function(i) {
      return function() {
          console.log(i)
      }
    })(i)
  , i * 1000)
}
// 这样也是同理的：！！！！！！！！！！！
for (var i = 0; i &lt; 10; i++) {
  const cbGenerator = (i) =&gt; {
    return function() {
      console.log(i)
    }
  }
  setTimeout(cbGenerator(i), i * 1000);
}
</code></pre>
<h4 id="证明：不会因为单纯有iife就会有闭包"><a class="header-anchor" href="#证明：不会因为单纯有iife就会有闭包"></a>证明：不会因为单纯有IIFE就会有闭包。</h4>
<p><strong>IIFE 其实并不属于闭包的范畴：</strong> 参考链接如下：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/41228824/difference-between-closures-and-iifes-in-javascript" target="_blank" rel="noopener">difference-between-closures-and-iifes-in-javascript</a></li>
<li><a href="https://bit.ly/2NXNT56" target="_blank" rel="noopener">IIFE 是闭包?</a></li>
</ul>
<p><strong>记住，记住，这样是连打印结果都不符合题目要求的：</strong></p>
<pre><code class="language-js">// 没用：连打印结果都不符合题目要求
for (var i = 0; i &lt; 10; i++) {
  setTimeout(function () {
    (i =&gt; {
      console.log(i);
    })(i)
  }, i * 1000)
}
</code></pre>
<p>另外，比如这个，因为没有setTimeout，<strong>不符题目要求</strong>。另外，也因为没有setTimeout，即便有<strong>函数按值传递</strong>的变量快照的效果，也没有形成闭包：</p>
<pre><code class="language-js">// 没有形成闭包：
// 这也对照证明了setTimeout是有帮助构建闭包的作用的！！！！！！！！！
for(var i= 0; i &lt; 5; i++){
  console.log('add timeout: ', i);
  (function(index){
      console.log('imitate timeouting: ', index);
      debugger;
  })(i)
}
// 而如果基于此，给log再套多一层自执行，就又有闭包了，你懂的。
</code></pre>
<h2 id="方法三：try-catch特殊的作用域机制：-即利用其它方式构建出局部作用域"><a class="header-anchor" href="#方法三：try-catch特殊的作用域机制：-即利用其它方式构建出局部作用域"></a>方法三：try catch特殊的作用域机制： 即利用其它方式构建出<strong>局部作用域</strong></h2>
<p>对于js，一般来说只有全局作用域和函数作用域。而这个catch大括号包裹的部分，作用域链的表现类似于函数作用域。非常特别。</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  try {
    throw new Error(i);
  } catch ({
    message: i // 为了重命名解构出i变量
  }) {
    setTimeout(() =&gt; {
      console.log(i);
    }, i * 1000)
  }
}
</code></pre>
<h2 id="方法4：bind返回新函数：利用的是柯里化的缓存效果-没有闭包产生"><a class="header-anchor" href="#方法4：bind返回新函数：利用的是柯里化的缓存效果-没有闭包产生"></a>方法4：bind返回新函数：利用的是柯里化的缓存效果，没有闭包产生</h2>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(console.log.bind(Object.create(null), i), i * 1000)
  // also or: 
  // setTimeout(console.log.bind(console, i), i * 1000)
}
</code></pre>
<p>或者：(配合函数按值传递)</p>
<pre><code class="language-js">for (var i = 1; i &lt;= 5; i++) {
  setTimeout(function timer(i) {
    console.log(i);
  }.bind(null, i), i * 1000);
}
</code></pre>
<h4 id="来个demo模拟简化后的代码-反映：的确是柯里化缓存的功劳："><a class="header-anchor" href="#来个demo模拟简化后的代码-反映：的确是柯里化缓存的功劳："></a>来个demo模拟简化后的代码，反映：的确是柯里化缓存的功劳：</h4>
<pre><code class="language-js">function hey(a,b,c) {
  console.log(this)
  console.log(a,b,c)
  debugger;
}

const foo = hey.bind({}, 1)
foo() // 1 undefined undefined
</code></pre>
<h2 id="方法五：利用-settimeout-函数的第三个参数-ie9之前不兼容该api"><a class="header-anchor" href="#方法五：利用-settimeout-函数的第三个参数-ie9之前不兼容该api"></a>方法五：利用 <code>setTimeout</code> 函数的第三个参数【IE9之前不兼容该api】</h2>
<p>复习一下setTimeout api的语法：<code>setTimeout(function, milliseconds, param1, param2, ...)</code></p>
<p>第三个参数，会作为回调函数的第一个参数传入。第四第五个参数位同理，以此类推。</p>
<p>神奇的是，它的规律是：缓存这些参数，等到回调触发的时候使用。</p>
<p>代码1：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(i =&gt; {
    console.log(i);
  }, i * 1000, i)
}
</code></pre>
<p>代码2：</p>
<pre><code class="language-js">// 注意这段代码的setTimeout的第一个参数并不是完整js语句，不是同步执行的：
for (var i = 0; i &lt; 10; i++) {
  setTimeout(console.log, i * 1000, i)
}
</code></pre>
<h2 id="拓展知识一：语句作为settimeout第一个参数位-无法隔秒打印-不符合本题要求"><a class="header-anchor" href="#拓展知识一：语句作为settimeout第一个参数位-无法隔秒打印-不符合本题要求"></a>// 拓展知识一：语句作为setTimeout第一个参数位 #无法隔秒打印。不符合本题要求</h2>
<p>如果想要更好地理解setTimeout api，那么你需要看看这个章节。</p>
<p><a href="https://segmentfault.com/q/1010000009490850" target="_blank" rel="noopener">链接：提问的确是这个提问，但是没有人回答得好</a></p>
<p><del>原理：很多其它的方案只是把 <code>console.log(i)</code> 放到一个函数里面，因为 <code>setTimeout</code> 函数的第一个参数只接受函数以及字符串，如果是 <strong><code>js</code> 语句</strong>的话，<code>js</code> 引擎应该会自动在该语句外面包裹一层函数</del></p>
<p>setTimeout毕竟不是js规范里面的api，其实是属于浏览器或者node环境的范畴。所以我也没找到对应的文档的说明。经过测试，大体上就是：如果第一个参数位是js语句，就会同步执行。</p>
<p><strong>无法隔秒打印：</strong> 虽然能打印0 ~ 9，但是因为是第一个参数如果是语句就同步执行的。第二个参数的延迟时间就发挥不了作用了。因为都是同步执行完，就谈不上闭包了。</p>
<pre><code class="language-js">// 注意，这个就没法做到每隔一秒打印了，都是同步执行完的。
// 这样chrome控制台没有显示任何闭包：因为，i引用到的是计数变量，也就是这里的全局变量。
for (var i = 0; i &lt; 10; i++) {
  setTimeout(console.log(i), i * 1000)
}
// or:
for (var i = 0; i &lt; 10; i++) {
  setTimeout((() =&gt; {
    console.log(i);
  })(), i * 1000)
}
</code></pre>
<p>同理：区别只不过是i作为函数的局部变量，（即便用了setTimeout，）因为没有异步执行，没有产生闭包。</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; { // 同步代码复制了一份局部变量
    console.log(i);
  })(i), i * 1000)
}
// 换种写法：call/apply 按值传参：
for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; {
    console.log(i);
  }).call(Object.create(null), i), i * 1000)
}
// 换种写法同理：
for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; {
    console.log(i);
  }).apply(Object.create(null), [i]), i * 1000)
}
// 换种写法同理：apply类数组
for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; {
    console.log(i);
  }).apply(Object.create(null), { length: 1, '0': i }), i * 1000)
}
</code></pre>
<h2 id="总结并拓展：另一种实现-非引用数据类型的-变量快照的方式"><a class="header-anchor" href="#总结并拓展：另一种实现-非引用数据类型的-变量快照的方式"></a>总结并拓展：另一种实现(非引用数据类型的)变量快照的方式</h2>
<p>我们可以总结一下上述所有【变量快照】或者【缓存变量值】的手法：（手法和每一个解题回答一一对应）</p>
<ul>
<li><code>let</code> / <code>const</code>+<code>for</code>循环：增加块级作用域 【变量快照】</li>
<li>加中间函数，闭包维持之：增加并维持函数作用域 【变量快照】</li>
<li>try catch作用域：特殊的作用域机制 【变量快照】</li>
<li>柯里化/bind使用 【缓存变量值】</li>
<li>setTimeout第3个参数 【缓存变量值】</li>
</ul>
<p>说白了以上就是：要么增设并维持<strong>作用域</strong>，因此实现【变量快照】，要么就是【缓存变量值】。</p>
<p>而另外一种实现【变量快照】的方式是：<strong>借助能解析执行字符串的api，把变量值编进代码里面：</strong>（记得吗，eval作用域又是一种特殊的<strong>作用域</strong>）</p>
<p>代码 1：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(eval('console.log(i)'), i * 1000)
}
</code></pre>
<p>代码 2，同样的效果：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(new Function('i', 'console.log(i)')(i), i * 1000)
}
// or:
for (var i = 0; i &lt; 10; i++) {
  setTimeout(new Function('console.log(i)')(), i * 1000)
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 笔记副本 </tag>
            
            <tag> 回顾 </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-lazyload 原理和使用 个人总结]]></title>
      <url>https://blog.az22c.top/2020/04/02/vue-lazyload-summary/</url>
      <content type="html"><![CDATA[<p>Vue-lazyload 这个话题，可谓“前人之述备矣”。这里主要写写一些我认为比较重要的点，能够快速回顾这个“第三方组件”的原理和使用方法。</p>
<a id="more"></a>
<hr>
<p>Vue-lazyload 是主要由程序员界网红 hilongjw 打造的一款用于图片或Vue组件懒加载的组件。</p>
<p>它用于性能优化并且对于懒加载的一些基本的需求都有解决方案。所以选择该领域作为开源的方向，可谓非常明智，(虽说现在的issue数量还是挺多的)，另可以作为开源项目的一个范本。</p>
<p>也就是：</p>
<ul>
<li>用于图片或Vue组件懒加载优化</li>
<li>适用于没有做分页的长列表、适用于超过两三屏的内容</li>
<li>懒加载的一些基本的需求都有解决方案</li>
</ul>
<h2 id="vue-lazyload-在使用方面"><a class="header-anchor" href="#vue-lazyload-在使用方面"></a>Vue-lazyload 在使用方面</h2>
<p><strong>组件状态：</strong></p>
<ul>
<li>loading</li>
<li>loaded(即成功)</li>
<li>error</li>
<li>(兼容原生html，用到data-src，data-error，data-loading)</li>
<li>相关的api：可以设置遇error重新请求的次数。loading的图片，error的图片。对应的回调能获取该img元素。</li>
<li>样式钩子：内容没加载好之前，是需要显示loading的：loading的时候，会给img元素加上lazy=&quot;loading&quot;的属性，就用这个属性钩子来作为css的钩子就行了</li>
</ul>
<p>--------------------------------    【我是分割线】   ----------------------------------</p>
<p><strong>组件类型：</strong></p>
<ul>
<li><code>lazyImage</code> vs <code>lazyComponent</code>   最终分别转化为这2种vue自定义组件。主要是用于懒加载图片；偶尔用于懒加载组件</li>
<li>【1】懒加载图片：
<ul>
<li><code>v-lazy</code>和 它的变体<code>vue-lazy:background-image</code></li>
<li><code>v-lazy-container(v-lazy.container)</code> 指定目标图片的外层容器
<ul>
<li>更精确指定<strong>被监听滚动</strong>的容器，<strong>若未定义则为最近一个overflow值为auto或scroll的父元素，</strong> 这个规则很实用
<ul>
<li>坑点 <a href="https://www.jianshu.com/p/d6f8bf71eb11" target="_blank" rel="noopener">container图片路径的使用规则又不一样</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>【2】懒加载组件：lazyComponent该组件由库方提供，你只需要传入default slot（里面会调用this.$slots.default）就行了，这样可以<strong>随便传组件进去</strong>。</li>
</ul>
<p>这样总结，是不是比网上的很多文章的脉络清晰多了？一下就能定位到自己想要的实现效果，根据思路一下就能理解它的很多api。</p>
<h3 id="vue-lazyload-好用的地方："><a class="header-anchor" href="#vue-lazyload-好用的地方："></a>Vue-lazyload 好用的地方：</h3>
<p>主要是补足了“适用性”：</p>
<p>1、filter：比如我七牛url想要后面追加参数，可以用这个。在某种程度上和vue filter比较接近。文档原文：「filter: img未加载之前,解析到 src 的时候注册的回调函数.可以在加载图片之前,对src进行修改.注册在filter下的所有的函数都会执行。」</p>
<p>2、监听事件，可以监听的事件有很多种类型<code>['scroll', 'wheel', ..., 'animationend', 'touchmove']</code>等等，主要是监听页面的。然后按对应的模式(mode)去检查是否满足触发加载的条件。在监听方面，比较重要且有特色的一个属性是<code>preLoad</code>：「preLoad:类型Number,默认1.3. 表示lazyload的元素距离页面底部距离的百分比.计算值为(preload - 1).」</p>
<h3 id="vue-lazyload-注意的地方-坑-："><a class="header-anchor" href="#vue-lazyload-注意的地方-坑-："></a>Vue-lazyload 注意的地方(坑)：</h3>
<ul>
<li>首先有很多老 issue 没有解决</li>
<li>(error之后，不会让用户点击一下手动重新加载一次。这个需要自己实现)</li>
<li>如果组件是在布局的最后才比较适合用“vue-lazyload组件模式”，不然切换生硬、重排比较多</li>
<li>图片相对路径怎么用：
<ul>
<li>【解决办法之一】你可以将本地图片放在web-dev-server 管理的静态目录里,就可以访问了，比如 vue-cli 模板里的 dist/ (也就是所谓的publicPath)。这样的缺点是本地调试的时候可能会引用路径错误。</li>
<li>还有 <a href="https://www.jianshu.com/p/d6f8bf71eb11" target="_blank" rel="noopener">container图片路径的使用规则又不一样</a></li>
</ul>
</li>
</ul>
<h2 id="vue-lazyload-的实现原理"><a class="header-anchor" href="#vue-lazyload-的实现原理"></a>Vue-lazyload 的实现原理</h2>
<p>监听sroll等等事件，可以选择 2 种模式(mode)的其一：</p>
<blockquote>
<p>一个是先保存大量引用作为订阅，之后再批量查询、判断；另一个是观察者模式</p>
</blockquote>
<ul>
<li>event模式
<ul>
<li>给<strong>目标容器</strong>添加监听scroll等等事件</li>
<li>遍历listenerQueue，每个linster的checkInView方法判断其可见性
<ul>
<li>原理：<code>getBoundingClientRect</code>(源码中的listener.checkInView函数用的就是它，判断是否已在preload位置)
<ul>
<li><a href="https://juejin.im/post/5c76843af265da2ddd4a6dd0" target="_blank" rel="noopener">getBoundingClientRect的注意事项</a></li>
</ul>
</li>
</ul>
</li>
<li>一个很典型的毛病就是频繁查询可能触发强制重排或者强制重绘</li>
</ul>
</li>
<li>observer模式： observer模式主要是想提高性能
<ul>
<li>操作：普通的传参和调用即可：
<ul>
<li>(初始的重置工作：该&quot;模式&quot;下的函数令<strong>目标对象</strong>解除监听<strong>目标容器</strong>scroll等等事件绑定)</li>
<li>只需关注该api的“根元素”(默认就是视口viewport了)和<strong>目标对象</strong>做dom处理就够了</li>
<li>通过observerOptions提供的数据来判断是否已在preload位置</li>
</ul>
</li>
<li>原理：Intersection Observer api
<ul>
<li>(跟raf在event loop体系中触发的时机差不多)</li>
<li>(一般情况下不会设置root的指向，那么其默认值就是视口)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解文字高度和行高的设置]]></title>
      <url>https://blog.az22c.top/2019/02/06/height-calculate/</url>
      <content type="html"><![CDATA[<p>font-size设置的是什么?line-height设置的是什么?各种行高是怎么计算出来的?你真的知道吗?</p>
<a id="more"></a>
<h2 id="从font-size讲起-说文字高度："><a class="header-anchor" href="#从font-size讲起-说文字高度："></a>从font-size讲起，说文字高度：</h2>
<p>当你按住鼠标左键选中一段文字的时候，这段文字背后会有一个颜色变化的区域，这个区域可以近似的视为是这段文字的<code>content-area（内容区域）</code>。</p>
<p>又或者当我们给一行文字设置background的时候，文字背景所占的区域可以近似的视为是这段文字的<code>content-area（内容区域）</code>。</p>
<p>我们通常用content-area的高度代表<code>文字高度</code> ，这是字体设计领域的一个概念。</p>
<p>你先别质疑这种思想！我们知道有些文字的样子喜欢往上突出，有些文字喜欢往下突，再者，行与行文字之间需要一定的空间，所以content-area在上下两个区域预留出空白的区域是很正常的，如图：</p>
<p><img src="https://cloud.az22c.top/font-line.jpg-az22cgithub" alt="font-line"></p>
<p>先说结论：</p>
<p><strong>font-size 相同时，font-family 不同，得到的<code>文字高度</code>也不同</strong>：</p>
<p><img src="https://cloud.az22c.top/diff-font.jpg-az22cgithub" alt="font-family不同-得到的文字高度也不同"></p>
<p>上图表明，同样是font-size为100px，三款不同字体在浏览器画面上的高度是不同的。</p>
<p>我们再来分析一下，在font-size设置为100px时，Catamaran字体的那164px是怎么构成的：</p>
<p><img src="https://cloud.az22c.top/catamaran-font.jpg-az22cgithub" alt="catamaran-font"></p>
<p>我们假设画面由相对单位构成方便缩放拉伸，再假设现在1px对应画面上的10个相对单位。（这点你可以不用理会）</p>
<p>那么我们所能设置的<code>font-size: 100px</code>其实设置的是上图左方1000个单位(em-square)这部分的高度而已； <strong>我们可以把em-square区域视为content-area的主体区域。</strong></p>
<blockquote>
<p>(em-square这个概念的产生是有历史原因的，但是这点我们不用理会。)</p>
<p>em-square之内，图中&quot;B&quot;上方预留的小区域，大概是考虑到有些字母模仿手写体会有起笔效果，需要一定的位置；&quot;a&quot;下方预留的区域是为了写类似g这样的字母的时候，下方需要一定的区域。</p>
<p>em-square之外，上方和下方都预留了一定空白区域，这样可以防止某些字体有“头尾特性”而导致行与行间文字挤在一起。</p>
<p>事实上对于所有font-family而言，规则都是这样的，对于中文字体而言也是如此。</p>
</blockquote>
<p>我们可以得到第二个结论：</p>
<p><strong>font-size不能直接控制文字的高度(content-area的高度)，它控制的是文字主体部分的高度(em-square的高度)。</strong> 而content-area和em-square之间的比例，完全是由字体设计师决定，作为程序员是无法统一的。</p>
<p>所以再经过调查， <strong>没有属性能<code>直接</code>控制文字的高度，我们只能这样通过font-size<code>间接</code> 控制文字的实际高度。</strong></p>
<h2 id="计算一个p元素的内容高度"><a class="header-anchor" href="#计算一个p元素的内容高度"></a>计算一个p元素的<code>内容高度</code></h2>
<p>(我们既然说是<code>内容高度</code>，就直接把margin、border厚度、padding排除在外了。)</p>
<p>当 p 元素出现在屏幕上时，它可能包含了多行的内容，其内容高度由<code>每一行的高度</code>堆叠而成。这点很好理解。</p>
<h3 id="line-box的默认高度"><a class="header-anchor" href="#line-box的默认高度"></a>line-box的默认高度</h3>
<p>每一行可视为一个line-box。通常来讲，line-box的默认高度是由这一行的内容撑大的，这一行里面的元素谁的高度最大，line-box的高度就等于它，由它撑大：</p>
<p><img src="https://cloud.az22c.top/line-boxes.jpg-az22cgithub" alt="line-boxes"></p>
<pre><code class="language-HTML">&lt;p&gt;
    Good design will be better.
    &lt;span class=&quot;a&quot;&gt;Ba&lt;/span&gt;
    &lt;span class=&quot;b&quot;&gt;Ba&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;Ba&lt;/span&gt;
    We get to make a consequence.
&lt;/p&gt;
</code></pre>
<p>如图，我们给class=“a”、class=“b”、class=&quot;c&quot;设置了不同的font-family或者font-size，导致这些文字的高度各不相同。每一个line-box代表每一行的区域。一个line-box的默认高度由这行内的最大高度决定。</p>
<blockquote>
<p>补充：还记得吗?对于文字而言，文字高度就是它的content-area的高度。</p>
</blockquote>
<h2 id="line-height的作用"><a class="header-anchor" href="#line-height的作用"></a>line-height的作用</h2>
<p><strong>当我们没有设置line-height的时候，一个line-box的默认高度由这行内的最大高度决定。</strong></p>
<p>所以通常情况下（对于某个字及它所属的行）： line-box的高度 &gt;= content-area的高度 &gt; em-square的高度</p>
<hr>
<p><strong>当我们设置了line-height的时候，line-box的高度就是由line-height所设定的。</strong>  因此此时我们可以把line-box的高度设置得比content-area甚至em-square小，导致文字看上去挤在一起。</p>
<blockquote>
<p>一行内的内容，除了文字外；通常就是<code>行内块级元素</code>了，通常可以分为三类：</p>
<ul>
<li>img元素、input元素、svg元素等</li>
<li><code>display:inline-block</code>、<code>display:inline-table</code>、<code>display:inline-flex</code> 的元素</li>
<li>处于某种特殊格式化上下文的内联元素：例如 flexbox 元素中的子元素都处于 <a href="https://www.w3.org/TR/css-flexbox-1/#flex-items" target="_blank" rel="noopener">flex formatting context（弹性格式化上下文）</a>中，这些子元素的 display 值都是「blockified」</li>
</ul>
<p>这些<code>行内块级元素</code>，其所占的高度通常由height，margin，border，padding盒子模型的高度来决定。</p>
<p>如果你将其 height 设置为 auto 的话，那么其高度的取值就是 line-height，其 content-area 的取值也是 line-height。</p>
</blockquote>
<h2 id="line-height是怎么计算的"><a class="header-anchor" href="#line-height是怎么计算的"></a>line-height是怎么计算的</h2>
<p>官方对<code>line-height</code>的定义是：</p>
<blockquote>
<p><strong>两行文字基线(baseline)之间的距离。</strong></p>
</blockquote>
<h3 id="额外谈谈-基线"><a class="header-anchor" href="#额外谈谈-基线"></a>额外谈谈&quot;基线&quot;</h3>
<p>为什么是基线呢？</p>
<p>line-height可不可以定义为是两行文字的“中线”之间的距离呢？可不可以定义为是两行文字的“底线”之间的距离呢？</p>
<p>个人认为都是都可以说得通的。</p>
<p>那么为什么选基线作为定义的依据？</p>
<p>因为， <strong>基线乃其他线定义之根本也。</strong></p>
<p>了解“基线”大有好处。</p>
<p>回到刚才那幅图：</p>
<p><img src="https://cloud.az22c.top/font-line.jpg-az22cgithub" alt="font-line"></p>
<p>这么多线，都是字体设计师为了比对位置用的。这几条线，可以视为是字体设计的度衡。任何一款字体都会给出以上各种线的位置参数，<strong>所有线的位置参数都是相对于基线的位置而确定的</strong> 。我们把某款字体放到 <a href="https://fontforge.github.io/en-US/" target="_blank" rel="noopener">FontForge</a> 中，分析它的字体度量：</p>
<p><img src="https://cloud.az22c.top/font-forge.jpg-az22cgithub" alt="font-forge"></p>
<blockquote>
<p>首先说明的是HHead Ascent是针对macOS的计算值，Win Ascent是针对Windows系统的计算值，这点可以不用理会。</p>
</blockquote>
<ul>
<li>设计一款字体的时候，所有线的位置参数都是相对于基线的位置而确定的：
<ul>
<li>我们看到，Em Size设置为1000，就是<code>基线到基线以上1000个单位的那片区域</code>都是em-square的区域。</li>
<li>Ascent设置为770，就是Ascender线距离基线770个单位。</li>
<li>Descent设置为230，就是Descender线距离基线230个单位。</li>
<li>Capital Height是680，也是相对于基线的。是大写字母顶部位置的线距离基线多少。</li>
<li>X Height是485，也是相对于基线而言的。是小写字母顶部位置的线距离基线多少。</li>
<li><code>Ascender线到Descender线之间的高度</code> 加上Line Gap就是content-area的总高度。（笔者注：这点可能有误）</li>
</ul>
</li>
</ul>
<hr>
<p>所以说，我们选基线来定义line-height：line-height是两行文字基线(baseline)之间的距离。</p>
<p>但是这个定义说了等于没说，因为它不能告诉我们怎么设置line-height啊！</p>
<p>还是我们早之前做的定义比较棒！！<strong>当我们设置了line-height的时候，line-box的高度就是由line-height所设定的。</strong></p>
<h3 id="line-height的计算-画重点"><a class="header-anchor" href="#line-height的计算-画重点"></a>line-height的计算（画重点！）</h3>
<p>line-height的计算要<strong>根据这行文字的font-size多少</strong> ，即是根据em-square的高度计算。本文说的&quot;计算&quot;就是这个意思。</p>
<p>w3c说，line-height可以设置的值有5种：</p>
<ul>
<li>normal</li>
<li>数字</li>
<li>多少px(都写死了，不必计算)</li>
<li>百分数(多少%)</li>
<li>inherit(对于该元素而言，不必计算)</li>
</ul>
<h4 id="line-height-normal的时候"><a class="header-anchor" href="#line-height-normal的时候"></a>line-height:normal的时候</h4>
<p>我们来看看 Arial 字体，它的 em-square 是 2048，ascender 是 1854，descender 是 434，line gap 是 67。那么当 font-size: 100px 时：</p>
<p>line-height:normal为 100/2048*(67+1854+434) 约为 115px</p>
<h4 id="line-height设为数字-百分数的时候"><a class="header-anchor" href="#line-height设为数字-百分数的时候"></a>line-height设为数字/百分数的时候</h4>
<p>line-height设为数字/百分数的时候，line-height就是拿 数字/百分数  去乘以em-square的高度。</p>
<p>所以如果设置line-height:1或者line-height:100%肯定是有问题的啊——本来em-square基本上就比content-area要小，你还让line-height是em-square的高度的一倍？！行与行之间的文字绝对是要挤在一起了：</p>
<p><img src="https://cloud.az22c.top/set-line-height-1.jpg-az22cgithub" alt="set-line-height-1"></p>
<p>那怎么设置呢？反正line-height最终的计算结果超过content-area就应该比较符合常理了。</p>
<p>张鑫旭大神鼓励大家用数字来设置line-height。</p>
<ul>
<li>如果是博客类型的网站，line-height设置为1.5到1.6，行与行之间比较宽，适合舒适地阅读。</li>
<li>如果是研发正规的产品（并且不使用UI设计工具导出位置参数），推荐大家使用<code>20px匹配法</code> ，方便计算。 【内容可能已经过时】</li>
</ul>
<h4 id="20px匹配法-内容可能已经过时"><a class="header-anchor" href="#20px匹配法-内容可能已经过时"></a>20px匹配法 【内容可能已经过时】</h4>
<details>
<summary>20px匹配法【点击左侧箭头展开内容】</summary>
为什么是20px呢？
<p>首先我们一般来说会设置font-size在14px到16px之间，然后content-area的高度也不会比这个高太多的吧。所以我们想着让line-height设置为20px应该够用了。而且20px方便计算。像这样：</p>
<pre><code class="language-CSS">body { font-size: 14px; line-height:??? }
</code></pre>
<p>只要把???结果计算出来就行啦！</p>
<p>20除以14等于1.42857后面还有小数位。</p>
<p>如果你写line-height:1.42857，虽然它乘以14非常接近20，但是没有超过20，chrome会把它设置为19px。</p>
<p>所以我们一般设line-height为1.4286，稍微大那么一点点，chrome把它们乘起来，然后再约等于，就是20px了。</p>
<p>结果写法就像这样：</p>
<pre><code class="language-CSS">body { font-size: 14px; line-height: 1.4286; }
</code></pre>
<p>或者是这样：</p>
<pre><code class="language-CSS">body { font-size: 14px/1.4286 'microsoft yahei'; }
</code></pre>
</details>
<h4 id="补充：line-height-1-5和line-height-150-的区别？"><a class="header-anchor" href="#补充：line-height-1-5和line-height-150-的区别？"></a>补充：line-height: 1.5和line-height: 150%的区别？</h4>
<p>这是一个在网上被人讲烂了的知识点了，line-height设置为数字和百分数时之间的区别：</p>
<ul>
<li><code>line-height:1.5</code>： 所有可继承元素根据font-size重新计算行高</li>
<li><code>line-height:150%</code>： 当前元素根据font-size计算行高，继承给下面的元素</li>
<li><code>line-height: 1.5em</code> ：当前元素根据font-size计算行高，继承给下面的元素(与百分比效果相同)</li>
</ul>
<p>例如：</p>
<pre><code class="language-HTML">&lt;style&gt;
.parent { font-size: 30px; }
.child { font-size: 60px; }
.p1 { line-height: 1.5; }
.p2 { line-height: 150%; }
&lt;/style&gt;
&lt;body&gt;
&lt;div&gt;
&lt;p class=&quot;parent p1&quot;&gt;文字&lt;span class=&quot;child&quot;&gt;算出子级line-height为90px&lt;/span&gt;文字&lt;/p&gt;&lt;hr&gt;
&lt;p class=&quot;parent p2&quot;&gt;文字&lt;span class=&quot;child&quot;&gt;算出子级line-height为15px&lt;/span&gt;文字&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>可见，对于百分比这种，如果父子元素设置的font-size差别比较大，或者line-height设置不合理，会计算出不太理想的行高。</p>
<p>所以在CSS reset body元素的时候，<strong>业界普遍使用数字</strong>来设置line-height，具体怎么设置我们刚刚在上文也讲好了。</p>
<h2 id="全文总结"><a class="header-anchor" href="#全文总结"></a>全文总结</h2>
<ul>
<li>首先<code>文字高度</code>和font-size只有间接的关系</li>
<li>然后，line-height的计算是根据font-size的</li>
<li>当我们没有设置line-height的时候，一个line-box的默认高度由这行内的最大高度决定。</li>
<li>当我们设置了line-height的时候，line-box的高度就是由line-height所设定的。</li>
</ul>
<h2 id="预告：文字在一行中如何垂直居中"><a class="header-anchor" href="#预告：文字在一行中如何垂直居中"></a>预告：文字在一行中如何垂直居中?</h2>
<p>有没有发现？根据我们上面的理论，如果想要确定一段文字在一行(line-box模型)中的位置太难了！是不是垂直居中？或者文字位置偏上还是偏下？都要经过一系列计算才能得出结论。</p>
<p>继而浏览器提供了<code>vertical-align:middle</code>，对于“实现垂直居中”来说，虽然不完全、不精准，但是在掌握了一定的规律后，还是能利用起来的。详见我下一篇文章 <a href="/2019/02/05/vertical-align-middle/">vertical-align:middle近似居中和完美居中</a> 。</p>
<h2 id="参考："><a class="header-anchor" href="#参考："></a>参考：</h2>
<p><a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="noopener">css-font-metrics-line-height-and-vertical-align</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25808995?group_id=825729887779307520" target="_blank" rel="noopener">译文，部分内容有误</a></p>
<p><a href="https://www.imooc.com/video/7920" target="_blank" rel="noopener">CSS深入理解之line-height</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> 居中 </tag>
            
            <tag> line-height </tag>
            
            <tag> font-size </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vertical-align:middle近似居中和完美居中]]></title>
      <url>https://blog.az22c.top/2019/02/05/vertical-align-middle/</url>
      <content type="html"><![CDATA[<p>很多人想要垂直居中的时候，第一时间就想到了<code>vertical-align:middle</code>，用完之后，疑惑它怎么会无效呢?</p>
<p>——原来<code>vertical-align</code> 是有适用范围的限制的。</p>
<p>因为水平垂直居中直接就包括了垂直居中，本文直接给出水平垂直居中的例子，并说明其中垂直居中的原理。</p>
<p>本文前面大部分算是理论基础层面列举分析了“近似”和“完美”居中；但是考虑到实际情况，实战还是“一把梭”用的“近似”垂直居中，进而本文最后一章节推导出“普适封装垂直居中”的代码。这样一来，能解释为什么网上其他文章的居中方法看似有差异。</p>
<a id="more"></a>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<blockquote>
<p>首先需要说明<code>vertical-align</code>只能应用于两个情景：</p>
<ul>
<li>应用于inline/inline-block元素</li>
<li>应用于table-cell元素（其实就是td元素）</li>
</ul>
<p>而进一步用<code>vertical-align: middle</code>的效果是：</p>
<ul>
<li>应用于inline/inline-block元素：元素的中心线和父元素基线上方1/2 x-height处对齐</li>
<li>应用于table-cell元素：简单粗暴理解为像Excel单元格的垂直居中（原文是“使‘单元格的内边距盒模型’在该行内居中对齐”。英文原文的介词断句更加令人费解。）【注意：table-cell这种，本身就可以“完美居中”】</li>
</ul>
</blockquote>
<p>本文就不讲table-cell的例子了，因为它实质上是很简明直观的。</p>
<p>然后我们分类以例子来说明：</p>
<h2 id="大小不固定的图片-水平垂直居中"><a class="header-anchor" href="#大小不固定的图片-水平垂直居中"></a>大小不固定的图片–水平垂直居中</h2>
<h3 id="近似居中"><a class="header-anchor" href="#近似居中"></a>近似居中</h3>
<p>先给容器设置line-height维持一定的高度，然后设置图片vertical-align:middle</p>
<pre><code class="language-HTML">&lt;style&gt;
.box {
  line-height: 300px; /*对于只有图片，这里不能用height替代；对于多行文字，若想要完美居中，则要求必须选line-height来配合其他代码，多行文字若想近似居中则用height也可以*/
  text-align: center;
}
.box &gt; img {
  vertical-align: middle;
}
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;&quot; alt=&quot;图片src要设置!!&quot;/&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>而实际上这仍不是完美的垂直居中。因为我们知道，通过设置<code>vertical-align: middle;</code>，图片的中线的位置被确定为<code>从行内基线往上1/2 x-height 的位置</code> 。</p>
<blockquote>
<p>(备注：在英文字体设计中，通常以小写字母&quot;x&quot;的高度作为其他小写字母高度的设计的基础。因此x-height被用于表示一款字体中的小写字母&quot;x&quot;的高度。)</p>
<p>(备注：文字处于的位置高度和line-height之间关系的计算非常麻烦，详见我另一篇文章<a href="/2019/02/06/height-calculate/">深入理解文字高度和行高的设置</a>。只需记住绝大多数情况下是：文字&quot;x&quot;的中心高度(即基线往上1/2 x-height处) 比line-height的中线高度要低。有些人称这种现象为&quot;字符下沉&quot;)</p>
</blockquote>
<p><img src="https://cloud.az22c.top/x-height.png-az22cgithub" alt="二分之一 x-height"></p>
<p>也就是说，假如现在给img后面添加一个&quot;x&quot;作为文字，图片所处的高度不会变，图片的中线位置就穿过文字&quot;x&quot;的中心，这时，图片的中线的位置实际上是比容器行内的中线位置要低的。<strong>所以，此乃近似垂直居中。</strong></p>
<p>另外，这种垂直居中方法还要IE8及以上才能兼容。</p>
<p><strong>备注：</strong> 如果在IE7里面使用这个方法的时候，HTML结构要调整一下，例如：</p>
<pre><code class="language-HTML">&lt;div class=&quot;box&quot;&gt;
  &lt;img alt=&quot;图片src要设置!!&quot;/&gt;&lt;!-- 这里要换行或空格 --&gt;
&lt;/div&gt;
</code></pre>
<p>可以看做是在图片后面创建一个空白的文本节点。</p>
<hr>
<p>如果我们进而想要完美居中，可以有两种办法：</p>
<ul>
<li>font-size设为0</li>
<li>添加辅助元素</li>
</ul>
<h3 id="完美居中-font-size设为0"><a class="header-anchor" href="#完美居中-font-size设为0"></a>完美居中–font-size设为0</h3>
<p>完美居中：在&quot;近似居中&quot;的基础上，我们给<code>.box</code>加多一个<code>font-size:0</code> 即可。</p>
<pre><code class="language-CSS">.box {
  /* 添加： */
  font-size: 0;
}
</code></pre>
<p>如果读过<a href="/2019/02/06/height-calculate/">深入理解文字高度和行高的设置</a> 这篇文章的原理分析，我们会发现，如果设置字号为0，基线、x-height线等等线都合为一体（因为它们之间的距离为0嘛）。所以1/2 x-height 的位置也变成在行内最中间的那里，图片就完美居中了。</p>
<h3 id="完美居中-添加辅助元素"><a class="header-anchor" href="#完美居中-添加辅助元素"></a>完美居中–添加辅助元素</h3>
<p>完美居中：在&quot;近似居中&quot;的基础上，添加一个辅助元素使得其变成完美居中：</p>
<p>首先HTML结构中插入一个 i 元素；</p>
<p>然后CSS步骤有三：</p>
<ol>
<li>辅助元素inline-block化</li>
<li>辅助元素宽度为0，高度为100%</li>
<li>vertical-align:middle</li>
</ol>
<ul>
<li>注：对于父容器<code>line-height: 300px</code> ：对于只有图片，这里不能用height替代；对于多行文字，若想要完美居中，则要求必须选line-height来配合其他代码，多行文字若想近似居中则用height也可以
<ul>
<li>（如果选择用height，对于只有图片，就会“把垂直居中丢失掉”，可以跑demo试试）</li>
<li>（如果选择用height，且图片还有其他兄弟元素，可能图片能受影响以达到近似垂直居中）</li>
</ul>
</li>
<li>总之，这里若想要“完美居中”，还要再加上一个条件：使用line-height（而不是别的）来控制父容器高度。</li>
</ul>
<pre><code class="language-HTML">&lt;style&gt;
  /* 添加： */
  i {
    display: inline-block;
    height: 100%;
    vertical-align: middle;
  }
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;&quot; alt=&quot;图片src要设置!!&quot;/&gt;
    &lt;i&gt;&lt;/i&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p><strong>备注：</strong> 这个辅助元素也可以是伪元素，替代 i 元素即可：</p>
<pre><code class="language-CSS">.box:before {
    content:'';
    width: 0;

    display:inline-block;
    vertical-align:middle;
    height:100%;
}
</code></pre>
<h2 id="多行文字-水平垂直居中"><a class="header-anchor" href="#多行文字-水平垂直居中"></a>多行文字–水平垂直居中</h2>
<ul>
<li><strong>我们把多行文字统一用display:inline-block的span来包裹，该span就是相当于上文的img元素的地位，则对该span做一样的垂直居中操作。</strong></li>
<li>（一般来说，对于多行文字，需要重置外部继承的line-height属性（和text-align属性））</li>
</ul>
<p>这种方法同样还要IE8及以上才能兼容。</p>
<h3 id="近似居中-v2"><a class="header-anchor" href="#近似居中-v2"></a>近似居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.box {
  line-height: 300px; /* 前文已解释过。若想“完美”垂直居中，必要条件就是选line-height */
  text-align: center;
}
.box &gt; .text {
  display: inline-block;
  vertical-align: middle;
  
  line-height: normal;/* 重置继承 */
  text-align: left;/* 重置继承 */
  max-width: 100%; /* 优化样式 */
}
&lt;/style&gt;
&lt;body&gt;
&lt;p class=&quot;box&quot;&gt;
&lt;span class=&quot;text&quot;&gt;一行文字&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;&lt;!-- 兼容IE7,这里要换行或空格 --&gt;
&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<hr>
<p>如果我们进而想要完美居中，原理同上文的图片，可以有两种办法：</p>
<ul>
<li>父元素font-size设为0</li>
<li>添加辅助元素</li>
</ul>
<h3 id="完美居中-font-size设为0-bad"><a class="header-anchor" href="#完美居中-font-size设为0-bad"></a>完美居中–font-size设为0(bad)</h3>
<p>给父元素设置font-size为0后，由于是文本，所有子元素会继承父元素的font-size为0，所以又要再重置这多行文字的font-size回正常。相对而言麻烦，所以对于文字来说，不推荐这种方法。【这里也略去示例代码，就是父容器添加font-size:0即可】</p>
<h3 id="完美居中-添加辅助元素-good"><a class="header-anchor" href="#完美居中-添加辅助元素-good"></a>完美居中–添加辅助元素(good)</h3>
<p>原理已经在上文解释过了：</p>
<pre><code class="language-HTML">&lt;style&gt;
/* 添加： */
i {
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}
&lt;/style&gt;
&lt;body&gt;
&lt;p class=&quot;box&quot;&gt;
&lt;span class=&quot;text&quot;&gt;一行文字&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;
&lt;i&gt;&lt;/i&gt;
&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<h2 id="普适封装垂直居中：近似垂直居中"><a class="header-anchor" href="#普适封装垂直居中：近似垂直居中"></a>普适封装垂直居中：近似垂直居中</h2>
<ul>
<li>【推导过程】看完前面我们发现，
<ul>
<li>实际开发中，垂直居中如果能达到近似居中的效果就可以了</li>
<li>而<strong>完美居中要求之一是必须使用line-height而不是height</strong>，这点要求就是不普适、不快捷
<ul>
<li>解释：如果选择用line-height，影响子元素样式大，导致“居中图片”和“居中多行文字”代码不统一难封装，又不方便记忆</li>
<li>解释：完美居中只限line-height。用了line-height若想要再实现其他样式也不灵活。</li>
</ul>
</li>
<li>所以我们在实战中，直接使用近似居中来封装即可，这样可以方便统一普适封装“居中图片”和“居中多行文字”
<ul>
<li>再加上简单记忆一些其他的样式实现手段，就能快捷完成开发。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>（解释适用对象和对应代码：）
<ul>
<li>当欲设置verticial-align:middle时，img可视为一个低配版的inline-block元素。</li>
<li>当欲设置verticial-align:middle时，“居中单行文字”其实可以和“居中多行文字”使用相同的手段。</li>
</ul>
</li>
<li>普适封装： “居中图片”和“居中多行文字”（包括“居中单行文字”）皆可用它
<ul>
<li>效果已确定为近似垂直居中【原因上面已分析】</li>
<li>选择使用“添加辅助元素”方案 （仅因为比font-size方案更普适）</li>
<li>效果：这样，父容器可以选择使用line-height或者height来撑高，放宽了适用场景
<ul>
<li>（具体来讲：）
<ul>
<li>遇到最坏的情况就是对于只有图片，父容器必须选择使用line-height，不然连“居中”效果都达不到。解决办法就是增加“居中的兄弟元素”来打破“只有图片”的场景；</li>
<li>或者 图片 受兄弟元素（含父元素的伪元素）的vertical-align:middle影响而已经达到近似居中，则可不强制使用line-height</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其他代码：
<ul>
<li>（然后水平居中代码简单，另外再加代码就行了）</li>
<li><strong>如果应用完这套样式后仍然没有达到居中，则简单粗暴给所有子元素都加上vertical-align:middle</strong>（甚至给父元素也加上）
<ul>
<li>（解释：这样减少许多记忆的负担，通常即便父元素加上了vertical-align:middle也没啥损失）</li>
<li>（对比：display:table-cell的方案中， vertical-align:middle 是作用于父元素，所以粗暴都加上，省去记忆麻烦）</li>
</ul>
</li>
</ul>
</li>
<li>（备注：前文说过，这个辅助元素可以是伪元素，也可以是 i 元素。）</li>
<li>（备注：以上，能解释为什么其他人的文章的居中方法有差异）</li>
</ul>
<pre><code class="language-HTML">&lt;style&gt;
.vertical-center:before {
    content:'';
    width: 0; /* 如果为了应对各种场景而普适省事，可以加上 width: 0 */

    display:inline-block;
    vertical-align:middle;
    height:100%;
}
.vertical-center &gt; img {
  vertical-align: middle;
}
.vertical-center &gt; .vertical-center__text {
  display: inline-block;
  vertical-align: middle;
}
/* 灵活：在此垂直居中基础上，加上水平居中 */
.vertical-center { text-align: center; }
/* 【测试代码，可删】： *//* 效果是：放宽了适用场景 */
.vertical-center { height: 300px }
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;vertical-center&quot;&gt;
    &lt;img src=&quot;&quot; alt=&quot;图片src要设置!!&quot;/&gt;
    &lt;span class=&quot;vertical-center__text&quot;&gt;一行文字AAA&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;
    &lt;span class=&quot;vertical-center__text&quot;&gt;单行文字&lt;/span&gt;
    &lt;!-- 如上，单行文字，如果想垂直居中，应放入span元素里面，然后和“多行文字”的样式处理一致：一致span套上对应的class --&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> vertical-align </tag>
            
            <tag> 居中 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[总结：使单一对象水平/垂直居中]]></title>
      <url>https://blog.az22c.top/2019/02/05/centralize-one-ele/</url>
      <content type="html"><![CDATA[<p>明白单一对象的水平/垂直居中的写法和原理，有助于我们构造更加复杂的居中布局。</p>
<p>我们按照居中的“里面的内容”来分类，展开全文：</p>
<a id="more"></a>
<h2 id="里面的内容-为单行行内元素的时候-以单行文字为例"><a class="header-anchor" href="#里面的内容-为单行行内元素的时候-以单行文字为例"></a>“里面的内容”为单行行内元素的时候(以单行文字为例)</h2>
<p>由于设置<code>text-align:center</code>之后，行内的元素就会水平居中，比较简单。所以这里侧重讲垂直居中。</p>
<h3 id="a法：令line-height和height相等-垂直居中"><a class="header-anchor" href="#a法：令line-height和height相等-垂直居中"></a>A法：令line-height和height相等–垂直居中</h3>
<pre><code class="language-CSS">.parent {
  height: 300px;
  line-height: 300px;
}
</code></pre>
<p>事实上，不需要对于height属性的设置也是可以的。</p>
<ul>
<li>【缺点】：只能用于居中一行文字（否则就改为用别的方法）</li>
</ul>
<h3 id="b法：使用display-table-cell和vertical-align-middle-垂直居中"><a class="header-anchor" href="#b法：使用display-table-cell和vertical-align-middle-垂直居中"></a>B法：使用display:table-cell和vertical-align:middle–垂直居中</h3>
<pre><code class="language-html">&lt;style&gt;
.parent {
  width: 300px;
  height: 250px;
  background: green;

  display: table-cell;
  vertical-align: middle;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;parent&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>另外，常见的table-cell外面套一层<code>display:table</code>元素的作用：对table-cell元素设置百分比（如100%）的宽高值时无效的，但是可以将父元素设置display:table，再将父元素设置百分比宽高，子元素table-cell会自动撑满父元素。这就可以做相对于整个页面的水平垂直居中。</p>
<h4 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h4>
<ul>
<li>height和line-height可以自由定义，这方便内容从单行文字发展为多行文字</li>
<li>在浏览器缩放的时候表现优异</li>
</ul>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<ul>
<li>设置.parent为<code>float:left</code>或者<code>positon:absolute</code>或者<code>position:fixed</code> 时居中会失效。如需兼顾他们，此时需要外面套多一层元素。
<ul>
<li>（因为<code>vertical-align</code>只适用于inline/inline-block元素或者table-cell元素，详见 <a href="/2019/02/05/vertical-align-middle/">vertical-align:middle近似居中和完美居中</a>）</li>
</ul>
</li>
<li>IE7及以下都不支持</li>
</ul>
<h4 id="备注："><a class="header-anchor" href="#备注："></a>备注：</h4>
<ul>
<li>特点是在IE8及以上浏览器的时候，<code>.grandparent</code> 的高度其实是可以自动适应的。</li>
</ul>
<details>
<summary>兼容更老的IE的写法：【左侧角标展开见内容】</summary>
<ul>
<li>《兼容更老的IE的写法》
<ul>
<li>HTML结构需要多套两层div：<code>.grandparent</code>和<code>.child</code></li>
<li>宽度、高度和背景等属性需要转移到<code>.grandparent</code> 这一级</li>
<li>文字内容需要转移到<code>.child</code> 这一级</li>
</ul>
</li>
</ul>
<pre><code class="language-HTML">&lt;style&gt;
.grandparent {
  width: 300px;
  /*自动高度：*/
  /*height: 250px;*/
  background: green;

  display: table;
  *position:relative;
  overflow:hidden;
}
.parent {
  display: table-cell;
  vertical-align: middle;

  *position:absolute;
  *top:50%;
}
.child {
  *position:relative;
  *top:-50%;
}
.someone {
  height: 400px;
  background: yellow;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;grandparent&quot;&gt;
  &lt;div class=&quot;someone&quot;&gt;用来增大高度用来增大高度用来增大高度，可以被删掉&lt;/div&gt;
  &lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
</details>
<h3 id="c法：使用display-inline-block和vertical-align-middle-垂直居中"><a class="header-anchor" href="#c法：使用display-inline-block和vertical-align-middle-垂直居中"></a>C法：使用display: inline-block和vertical-align:middle–垂直居中</h3>
<p>这里只给出近似垂直居中的例子，在实际项目中用得最多；而如果想设置为完美垂直居中或者了解更多，详见<a href="/2019/02/05/vertical-align-middle/">vertical-align:middle近似居中和完美居中</a> ：</p>
<ul>
<li>统一封装、普适适用于“居中单行文字”、“居中图片”和“居中多行文字”（包括“居中单行文字”）：
<ul>
<li>再加上简单记忆一些其他的样式实现手段，就能快捷完成开发。</li>
<li>（当欲设置verticial-align:middle时，img可视为一个低配版的inline-block元素。）</li>
<li>效果：父容器可以选择使用line-height或者height来撑高，放宽了适用场景</li>
</ul>
</li>
<li>（备注：这个辅助元素可以是伪元素，也可以是 i 元素。）</li>
</ul>
<pre><code class="language-HTML">&lt;style&gt;
.vertical-center:before {
    content:'';
    width: 0; /* 如果为了应对各种场景而普适省事，可以加上 width: 0 */

    display:inline-block;
    vertical-align:middle;
    height:100%;
}
.vertical-center &gt; img {
  vertical-align: middle;
}
.vertical-center &gt; .vertical-center__text {
  display: inline-block;
  vertical-align: middle;
}
/* 灵活：在此垂直居中基础上，加上水平居中 */
.vertical-center { text-align: center; }
/* 【测试代码，可删】： *//* 效果是：放宽了适用场景 */
.vertical-center { height: 300px }
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;vertical-center&quot;&gt;
    &lt;img src=&quot;&quot; alt=&quot;图片src要设置!!&quot;/&gt;
    &lt;span class=&quot;vertical-center__text&quot;&gt;一行文字AAA&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;
    &lt;span class=&quot;vertical-center__text&quot;&gt;单行文字&lt;/span&gt;
    &lt;!-- 如上，单行文字，如果想垂直居中，应放入span元素里面，然后和“多行文字”的样式处理一致：一致span套上对应的class --&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h3 id="d法：flex布局-grid布局-水平垂直居中"><a class="header-anchor" href="#d法：flex布局-grid布局-水平垂直居中"></a>D法：flex布局/grid布局–水平垂直居中</h3>
<blockquote>
<p>grid布局：(对于水平垂直居中这个问题，)方式和flex布局类似。因为浏览器兼容性不如flex，且flex能满足的场景挺多的。所以一般只用flex布局就够了。</p>
</blockquote>
<pre><code class="language-HTML">&lt;style&gt;
.parent {
  width: 300px;
  height: 250px;
  background: green;

  /* display: -webkit-flex; */
  /* display: -ms-flex; *//* IE 10 */
  display: flex;
  align-items: center;
}
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;parent&quot;&gt;这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>【优点】：
<ul>
<li><code>.parent</code>元素无须定高</li>
<li>代码简单</li>
</ul>
</li>
<li>【缺点】：其实文字是可以自动换行的，这样就是多行文字了，但是需要IE11</li>
<li>【兼容性】：IE要10才支持
<ul>
<li>(兼容IE10的写法为：<code>display: -ms-flex;</code>； 而且要求<code>-ms-flex-preferred-size</code>（即第三个参数）带单位，所以必须写成<code>0px</code>或<code>0%</code>或<code>auto</code>。)</li>
</ul>
</li>
</ul>
<h2 id="里面的内容-为多行行内元素的时候-以多行文字为例"><a class="header-anchor" href="#里面的内容-为多行行内元素的时候-以多行文字为例"></a>“里面的内容”为多行行内元素的时候(以多行文字为例)</h2>
<p><strong>参考上文B法</strong></p>
<p><strong>参考上文C法</strong></p>
<p><strong>参考上文D法</strong></p>
<h2 id="里面的内容-为大小不固定的图片的时候"><a class="header-anchor" href="#里面的内容-为大小不固定的图片的时候"></a>“里面的内容”为大小不固定的图片的时候</h2>
<p><strong>参考上文B法</strong></p>
<p><strong>参考上文C法</strong></p>
<p><strong>参考上文D法</strong></p>
<h2 id="里面的内容-为定宽高的块级元素的时候"><a class="header-anchor" href="#里面的内容-为定宽高的块级元素的时候"></a>“里面的内容”为定宽高的块级元素的时候</h2>
<h3 id="定宽-margin-auto-水平居中"><a class="header-anchor" href="#定宽-margin-auto-水平居中"></a>定宽+margin auto–水平居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.child {
    width: 300px;
    background: green;

    margin: 0 auto;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>【兼容性】：IE7及以上都是可以的</li>
</ul>
<h3 id="定宽高-绝对定位-负margin-水平垂直居中"><a class="header-anchor" href="#定宽高-绝对定位-负margin-水平垂直居中"></a>定宽高+绝对定位+负margin–水平垂直居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.child {
    width: 300px;
    height: 250px;
    background: green;

    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -150px;
    margin-top: -125px;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>【兼容性】：兼容性好</li>
<li>【备注】：将<code>position: absolute;</code>改成<code>position: fixed;</code>也是可以的，相信大家都懂什么意思。
<ul>
<li>但是在老版本IE下会不支持fixed，在网上抄一下怎么兼容就行了。</li>
</ul>
</li>
</ul>
<h3 id="定宽高-绝对定位-calc"><a class="header-anchor" href="#定宽高-绝对定位-calc"></a>定宽高+绝对定位+calc</h3>
<p>思路和上面“要求定宽高+负margin”一样。</p>
<p>只不过特别之处在于，calc这个api，<strong>其实就是在这个问题中用于获取百分比数据作为临时量。</strong></p>
<p>浏览器兼容性略差：即calc的兼容性和<code>transform: translate</code>方案相当。</p>
<pre><code class="language-HTML">&lt;style&gt;
.child {
    width: 300px;
    height: 250px;
    background: green;

    position: absolute;
    top: calc(50% - 150px);
    left: calc(50% - 125px);
    /* margin-left: -150px; */
    /* margin-top: -125px; */
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2 id="里面的内容-为不定宽高的块级元素的时候"><a class="header-anchor" href="#里面的内容-为不定宽高的块级元素的时候"></a>“里面的内容”为不定宽高的块级元素的时候</h2>
<h3 id="绝对定位-margin-auto-水平垂直居中"><a class="header-anchor" href="#绝对定位-margin-auto-水平垂直居中"></a>绝对定位+margin:auto–水平垂直居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.child {
  /*宽高可以不写：*/
  width: 300px;
  height: 250px;
  background: green;

  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;

  margin: auto;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>【兼容性】：需要IE8及以上</li>
<li>【备注】：
<ul>
<li>定位改成用fixed也是可以的</li>
<li>其原理参考：
<ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" target="_blank" rel="noopener">margin-auto-absolute-绝对定位-水平垂直居中-张鑫旭</a></li>
<li><a href="https://www.zhihu.com/question/21644198" target="_blank" rel="noopener">为什么margin:auto可以让块级元素水平居中</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="绝对定位-translate-水平垂直居中"><a class="header-anchor" href="#绝对定位-translate-水平垂直居中"></a>绝对定位+translate–水平垂直居中</h3>
<pre><code class="language-CSS">&lt;style&gt;
.parent {
    width: 300px;
    height: 300px;
    background: green;

    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;parent&quot;&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>【优点】:父子元素的width和height都可以自己定</li>
<li>【兼容性】：IE8及以下不兼容</li>
</ul>
<h3 id="flex布局-grid布局-水平垂直居中"><a class="header-anchor" href="#flex布局-grid布局-水平垂直居中"></a>flex布局/grid布局–水平垂直居中</h3>
<ul>
<li>（对比grid布局：(对于水平垂直居中这个问题，)方式和flex布局类似。因为grid的浏览器兼容性不如flex，且flex能满足的场景挺多的。所以一般只用flex布局就够了。）</li>
<li>（flex布局在这个场景有点大才小用了。）</li>
</ul>
<h3 id="转换成行内块级元素-个别场景下适用-容易被忽略"><a class="header-anchor" href="#转换成行内块级元素-个别场景下适用-容易被忽略"></a>转换成行内块级元素 #个别场景下适用，容易被忽略</h3>
<p>此次我们居中的目标是一个<code>块级元素的</code>块块，而非之前的<code>行内元素</code>。</p>
<p>我们需要加上<code>display: inline-block;</code>使它变成行内块级元素，然后就可以参考行内元素的居中来弄了。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> vertical-align </tag>
            
            <tag> 居中 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[到底什么是函数式编程 精简总结]]></title>
      <url>https://blog.az22c.top/2018/02/05/js-functional-intro/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<p>到底什么是函数式编程？我将分别用一段话来总结其 特点 和 作用。</p>
<a id="more"></a>
<p><strong>特点：</strong></p>
<ul>
<li>范畴论和函子
<ul>
<li>函数是一等公民，高阶函数等概念</li>
<li>函数的组合</li>
</ul>
</li>
<li>没有副作用（函数的纯度）
<ul>
<li>引用透明(函数的传入参数就是所有的依赖)</li>
<li>柯里化是延伸出来的“补足”：<strong>在需要维持函数纯的前提下，提高可拓展性</strong></li>
<li>( 另一延伸问题是副作用的管理 )</li>
</ul>
</li>
<li>不可变量和不可变对象</li>
<li>声明式代码</li>
</ul>
<p><strong>作用：</strong></p>
<p>函数式编程，和面向对象编程一样都是用来 <strong>降低系统复杂度的</strong> ，在js里面，可以说是作为一种设计思路和其他的互相补充。</p>
<blockquote>
<p>就这样，完成了全文，有点空荡荡的。后面还补充一个简单的问题，来帮助思考的：</p>
</blockquote>
<h2 id="问题：基于函子思想改写-实现一个可reject的map"><a class="header-anchor" href="#问题：基于函子思想改写-实现一个可reject的map"></a>问题：基于函子思想改写，实现一个可reject的map</h2>
<pre><code class="language-js">// 要实现的调用效果：
const result = new MMM(1)
  .map((item, reject) =&gt; {
    return item + 2;
  })
  .map((item, reject) =&gt; {
    // reject(); // 注释开关我，重新运行
    return item + 3;
  })
  .map((item, reject) =&gt; {
    return item + 4;
  })
  .join();
console.log(result) // 期望10
</code></pre>
<p>如果在任一个map中调用了reject，后续的map就全被跳过不必执行，同时链式调用的结果直接fallback到一个“候补值”。（为了简便，这个“fallback值”定义在js文件的作用域中，也就是后文源码的<code>VIEW_INVALID</code>这个值）</p>
<h4 id="对比promise的调用代码："><a class="header-anchor" href="#对比promise的调用代码："></a>对比promise的调用代码：</h4>
<p>显然这段代码结构有点像Promise的语法，但比promise简漏的是：</p>
<ol>
<li>它不能处理异步</li>
<li>它一样可以reject，但是还没有catch的机制</li>
<li>没有办法引入函数外的副作用</li>
<li>没有Monad自动拆箱的机制</li>
</ol>
<p>而从这种代码改写，直到进化到promise需要怎么改写代码呢？是很有意思的问题，这里暂时就不讨论了。</p>
<h4 id="利用原型对象-代码实现："><a class="header-anchor" href="#利用原型对象-代码实现："></a>利用原型对象 代码实现：</h4>
<p>回到正题，一开始的实现代码是这样，<strong>还是停留在“利用js原型链上的属性”的范畴</strong> ：</p>
<pre><code class="language-js">const VIEW_INVALID = 'VIEW_INVALID';
const MMM = function(value, isInvalid) {
  this.isInvalid = isInvalid || false;
  this.value = value;
}
// MMM.prototype.of = function(value) {
//   return new MMM(value);
// }
MMM.prototype.map = function(func) {
  if (!this.isInvalid) {
    const result = func(this.value, () =&gt; {
      this.isInvalid = true;
      this.value = VIEW_INVALID;
    });
    this.value = !this.isInvalid ? result : this.value;
    return new MMM(this.value, this.isInvalid);
  } else if (this.isInvalid) {
    return new MMM(this.value, this.isInvalid);
  }
}
MMM.prototype.join = function() {
  return this.value;
}
</code></pre>
<h4 id="函子化改写的实现："><a class="header-anchor" href="#函子化改写的实现："></a>函子化改写的实现：</h4>
<p>经研究，按照either函子的思想，源码可改写为：</p>
<pre><code class="language-js">const VIEW_INVALID = 'VIEW_INVALID';
// const MMM = function(value, isInvalid) { /**/ } // 代码没变，同上回
// MMM.prototype.of = function (/**/) { /**/ } // 代码没变，同上回

// 根据容器内的flag值，选择应用哪个函数：
MMM.prototype.mapEither = function(func, fForInvalid) {
  fForInvalid = fForInvalid || function(x) {return x};
  func = func || function(x) {return x};

  const todoFN = !this.isInvalid ? func : fForInvalid;
  return new MMM(todoFN(this.value), this.isInvalid);
}
MMM.prototype.map = function(func) {
  const result = func(this.value, () =&gt; {
    this.isInvalid = true;
    this.value = VIEW_INVALID;
  });
  return this.mapEither(() =&gt; result)
}
</code></pre>
<p>代码还可以怎么改写？这种改写之后带来什么优势？其实是比较开放性的问题。</p>
<p>之后如果对函数式编程有更深入的理解，我再把这个坑填上吧。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 回顾 </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web前端性能优化概述]]></title>
      <url>https://blog.az22c.top/2018/02/04/performance-optimized-summary/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。如果想做一个系统性的归纳总结、以便查询，可以参考以下概述。</p>
<a id="more"></a>
<h2 id="性能优化的指导思想："><a class="header-anchor" href="#性能优化的指导思想："></a>性能优化的指导思想：</h2>
<ul>
<li>先从辅助工具入手
<ul>
<li>现在的辅助工具强大到会提示你如何进行优化，你可以参考着来一项一项做就行了</li>
</ul>
</li>
<li>先从性能瓶颈入手
<ul>
<li>很多性能优化的手段是相互矛盾的，所以要抓住瓶颈和重点，舍弃掉收益不明显的手段</li>
<li>性能优化是一项庞大的工作量，出于对工期的考虑，建议抓住瓶颈和重点</li>
</ul>
</li>
<li>不要过早优化
<ul>
<li>很多性能优化的手段是相互矛盾的，在编写新功能阶段过早优化可能会造成返工和工作时间的浪费</li>
<li>返工的过程又可能引入bug</li>
</ul>
</li>
<li>不要为了优化而优化：在迭代中，等到测试人员或者用户对性能不满意，才去优化
<ul>
<li>如果你的网站性能，优化到能令用户满意，就不用无端作死追求极致的性能</li>
<li>性能优化难有终点和尽头，尤其是多人协作项目，如果追求极致优化通常会引入隐性的问题和bug</li>
</ul>
</li>
<li>基于业务场景数量关系：在纯技术角度的性能优化达到瓶颈之后，尝试基于业务进行性能优化。
<ul>
<li>即，根据监控系统的数据分析，xxx量（比如展示商品数量） 和 xxx性能指标（比如首屏渲染耗时） 之间的关系，看看有没有飙升或者升到一个不合理的范围。</li>
</ul>
</li>
</ul>
<h2 id="性能优化概述"><a class="header-anchor" href="#性能优化概述"></a>性能优化概述</h2>
<p>刚刚提到“先从辅助工具入手，先从性能瓶颈入手”，这才是工作中性能优化的思路。</p>
<p>而如果是面试找思路回答“性能优化”这个问题，或者想做一个系统性的归纳总结、以便查询，可以参考以下概述：(划分的思路还算比较“正交”)</p>
<ol>
<li><strong>资源预加载</strong></li>
<li><strong>减少网络传输数量和次数</strong></li>
<li><strong>减小网络传输文件体积</strong></li>
<li><strong>减少途经的服务器数量和网络路径长度</strong></li>
<li><strong>少执行代码 和 缩短代码执行时间</strong></li>
</ol>
<p>(下面列表的5个根节点其实就是这5个大的方向。详细展开如下：)</p>
<ul>
<li><strong>资源预加载</strong>
<ul>
<li>w3c Resource Hints：dns预解析、TCP预连接、资源预加载。有一些标签属性已经可以很好的做到这些，如 dns-prefetch &amp; preconnect &amp; preload &amp; prefetch &amp; prerender(慎用)。</li>
<li>其他preload的方案或者xxx-loadable库，比如已经快过时的<code>react-loadable</code>库可以在懒加载时预加载。</li>
</ul>
</li>
<li><strong>减少网络传输数量和次数</strong>
<ul>
<li>页面懒加载、组件懒加载、图片懒加载
<ul>
<li>vue-lazyload (只支持vue2，vue3版本目前闭源待更新)</li>
<li>vue3的(实验阶段)内置组件<code>&lt;Suspense&gt;</code></li>
<li>图片异步懒加载</li>
</ul>
</li>
<li>http缓存，合理设置客户端缓存时间、利用好强缓存、协商缓存</li>
<li>数据缓存
<ul>
<li>(cookie localstroage， sessionStroage等本地存储)</li>
<li>如果频率比较高的话改用redis存图片</li>
</ul>
</li>
<li>http keep-alive(也称为“长连接”)</li>
<li>利用文件打包阶段的策略：来控制个数和大小和按使用频率分包
<ul>
<li>比如dllPlugin  【大后期】
<ul>
<li>一般是项目的大后期才用得到，收益是<strong>减小打包时间</strong>和精细化<strong>按使用频率分包</strong>提高对缓存的利用</li>
<li>而一开始建项目可以用它来处理vue和react这种代码变动频率较低的大包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>减小网络传输文件体积</strong>
<ul>
<li>gzip</li>
<li>( webpack打包策略 BundleAnalyzerPlugin 或者执行vue ui来分析 )
<ul>
<li>抽离公共模块</li>
<li>专门把js库放到cdn上，然后引用，这样就不用打包这部分了 【不一定有效，毕竟通常库都是按需引入的】</li>
</ul>
</li>
<li>按需引入模块
<ul>
<li>利用webpack按需引入</li>
</ul>
</li>
<li>取代Cookie + Cookie free (减小http包体积)</li>
<li>js、css打包压缩</li>
<li>减少字体体积</li>
<li>压缩html</li>
<li>图片优化
<ul>
<li>图片预加载</li>
<li>图片懒加载</li>
<li>将图片缓存到本地(http缓存)</li>
<li>雪碧图(更新起来麻烦，以前才流行)：减少http请求次数。webpack-spritesmith</li>
<li>picture标签和srcset</li>
<li>(图片格式选择：)
<ul>
<li>色彩丰富的小图用png（支持透明）</li>
<li>大图(背景图、轮播图)要用jpg：体积小，但不支持透明</li>
<li>webp 但兼容性不是那么好，需要调研一下
<ul>
<li>（体积小，支持透明。越来越多图片查看器支持打开）</li>
<li>微信基本用的是webp</li>
</ul>
</li>
<li>svg：矢量图体积小，因为是标签，需额外的计算，只不过不用网络请求：比如icon-font</li>
<li>base64：在webpack打包的时候file-loader自动把小图转成base64</li>
<li>CSS代替图片(减少dom)：image-background和border-image等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>减少途经的服务器数量和网络路径长度</strong>
<ul>
<li>cdn
<ul>
<li>域名分片：即域名发散。规避浏览器对一个域名的并发数限制</li>
<li>域名收敛：http2多路复用，多个http间复用tcp</li>
<li>动静分离：index.html部署在自己服务器，静态资源借助cdn。</li>
<li>cookie-free：在动静分离的基础上，同时可以实现静态资源cookie-free</li>
</ul>
</li>
</ul>
</li>
<li><strong>少执行代码 和 缩短代码执行时间</strong>
<ul>
<li>--------- 【 针对浏览器特殊运行机制： 】 ---------</li>
<li>处理阻塞css、js，异步加载组件或css、js
<ul>
<li>(css)critical和其webpack插件</li>
</ul>
</li>
<li>首屏临时显示各种的loading提示 或者懒加载
<ul>
<li>无限滚动懒加载列表：上拉加载、下拉加载</li>
<li>骨架屏：vue-skeleton-webpack-plugin</li>
<li>首屏简单loading动画</li>
<li>NProgress 顶部加载进度条</li>
</ul>
</li>
<li>减少DOM显示数（和减少DOM嵌套层级）
<ul>
<li>(移动设备内存存储数据过多dom也会崩掉)</li>
<li>《一个长度10000的商品列表，怎么显示》：1懒加载 2时间分片 3虚拟列表</li>
<li>虚拟列表(其实就保留三屏的列表)
<ul>
<li>vue-virtual-scroller和react-virtualized等等</li>
</ul>
</li>
<li>时间分片(requestAnimationFrame+DocumentFragments)</li>
</ul>
</li>
<li>减少dom操作的次数</li>
<li>减少重排重绘 <strong>(和“避免强制重排强制重绘”)</strong></li>
<li>事件委托</li>
<li>web workers分担主线程的“任务”</li>
<li>提高css选择器的效率</li>
<li>慎重选择高性能消耗的css样式
<ul>
<li>box-shadows</li>
<li>border-radius</li>
<li>transparency</li>
<li>transforms</li>
<li>CSS filters（性能杀手）</li>
</ul>
</li>
<li>--------- 【 代码逻辑层面： 】 ---------</li>
<li>防抖节流</li>
<li>算法优化
<ul>
<li>排序算法的优化等等</li>
</ul>
</li>
<li>基于框架运行机制的优化：vue react：组件重新渲染机制等等</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 笔记副本 </tag>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git暂存区知识梳理]]></title>
      <url>https://blog.az22c.top/2017/10/12/git-stage/</url>
      <content type="html"><![CDATA[<p>暂存区是git的一个重要概念，经过了一段时间的项目实践，总结一下个人对暂存区的一些理解。</p>
<p>当我们开始对git的一些知识进行梳理的时候，可以盗用以下这张图：</p>
<a id="more"></a>
<p><img src="https://cloud.az22c.top/add-commit-push.png-az22cgithub" alt="add-commit-push.png"></p>
<ul>
<li>working directory为本地的<strong>工作区</strong></li>
<li>stage area为<strong>暂存区</strong>，亦称作stage或者index</li>
<li>local branch代指某个<strong>本地分支</strong></li>
<li>remote branch代指某个<strong>远程分支</strong></li>
</ul>
<p>正常情况下，本地分支 和 远程分支 存在着对应关系，比如，我们用本地的一个 main分支 对应远程的 main分支。</p>
<p>git的作用围绕着 <code>“分支”</code> 这么一个对象来展开的。</p>
<p>很明显这张图只考虑单分支（一对对应分支）的情形，这也是我们在工作中常见的情形。如果明白了单分支的玩法，多分支的玩法也是同理可得的。</p>
<hr>
<p>使用 git 的最简单的一个流程就是：</p>
<pre><code>git add .              ::::将 对本地工作区中所有的内容变动 保存到暂存区
git commit -m &quot;描述&quot;   ::::将 暂存区的内容 提交到本地分支
git push               ::::将 本地分支的变化 同步到远程分支
</code></pre>
<h2 id="暂存区的作用-优化commit"><a class="header-anchor" href="#暂存区的作用-优化commit"></a><strong>暂存区</strong>的作用 – 优化commit</h2>
<p>git的规则是<strong>原子性提交</strong> 。原子，是化学世界不可再分的最小单位。</p>
<p>原子性提交 的意思是，由 多个文件的内容变动信息 组成一次提交(commit)后，每一个commit被视为一个不可再分的整体。</p>
<p>要么<strong>在同一个commit里的 多个文件的内容变动</strong> 全部成功提交到本地分支，要么全部失败。</p>
<p>原子性提交带来的好处是，我们能很简便地把分支还原到某个阶段或者时间节点。就像玩游戏，将游戏进度还原到某个存档的时间点上。</p>
<p>在存档形成的时候，各种各样的信息组成一个存档记录。一个存档记录在形成后，是不能再被细分的。</p>
<p>一个commit，相当于是游戏里的一个存档。</p>
<hr>
<p>暂存区的存在，使得一个commit比一个游戏存档更加牛逼：在形成的时候，游戏存档会把该时间节点上的所有信息（人物等级、背包里面的物品、游戏任务进度等等）全部记录下来；然而在git中，有了<strong>暂存区</strong>，我们可以自己<code>挑选</code>记录哪些信息形成一个commit。</p>
<p>比如，我在本地<strong>工作区</strong>修改了a.txt、b.txt、c.txt三个文件的内容，但是我只想记录提交a.txt、c.txt两个文件的变动，那么我们只需要把a.txt和c.txt两个文件的变动保存到<strong>暂存区</strong>，然后将暂存区的内容形成一个commit就可以了。</p>
<h3 id="git-add的作用-选取变动保存到暂存区"><a class="header-anchor" href="#git-add的作用-选取变动保存到暂存区"></a>git add的作用 – 选取变动保存到暂存区</h3>
<p>由上文可知，我们能挑选自己想记录提交的内容，git add就是 用来选择记录的 一个指令。刚才的操作的指令是：</p>
<pre><code>git add a.txt c.txt
</code></pre>
<p>就能把把a.txt和c.txt两个文件的变动保存到<strong>暂存区</strong>了。继而进行其他后续操作。</p>
<p>而一般情况下，就像游戏存档一样，我们会去选择保存所有的文件变动，而<code>git add .</code> 代表的就是这个意思。</p>
<p><img src="https://cloud.az22c.top/github-desktop.png-az22cgithub" alt="github-desktop"></p>
<p>用过GitHub Desktop的童鞋会发现它们是同样的道理的，只不过一个是git指令的形式，一个是图形化界面的形式，流程是一样的：</p>
<ul>
<li>挑选自己想记录提交的内容，形成一个commit</li>
<li>将一个commit作为一个整体，添加到分支上</li>
</ul>
<p><strong>在过程其中的区别就是：git指令没有操作界面，所以需要用到暂存区这么一个概念；而图形化界面只需直观地在界面上勾选文件的变动项就可以了。</strong></p>
<p>所以在GitHub Desktop上根本不存在<strong>暂存区</strong>的概念，直接在界面上勾选，就能起到同样的作用。</p>
<h2 id="暂存区的延伸作用-文件快照-便于回退"><a class="header-anchor" href="#暂存区的延伸作用-文件快照-便于回退"></a><strong>暂存区</strong>的延伸作用 – 文件快照，便于回退</h2>
<p>暂存区的作用，解释了它被发明是为了解决什么样的痛点。</p>
<p>接着，人们发现，这种理念还能够发挥出其他额外的作用，这种作用就是<code>文件快照</code>。</p>
<h3 id="git-checkout"><a class="header-anchor" href="#git-checkout"></a>git checkout</h3>
<p>比如，我对hello.js做了修改之后，<code>git add hello.js</code> ，把它的改动保存到暂存区作为一个快照。之后我们再继续对hello.js做修改，但是发现改得不满意，想回退到它上一次保存到暂存区时的状态。</p>
<p>这时候使用指令<code>git checkout hello.js</code>就可以实现回退到上一次快照了。</p>
<p>但是这个玩法就比较鸡肋了，因为我们在代码编辑器连续按 <code>ctrl + z</code> 也能实现撤销改动的嘛。</p>
<h3 id="git-diff"><a class="header-anchor" href="#git-diff"></a>git diff</h3>
<p>通常代码编辑器所做不到的功能是git diff：</p>
<p>git diff 显示当前<strong>工作区</strong>的文件和<strong>暂存区</strong>文件的差异</p>
<p>git diff --staged 显示<strong>暂存区</strong>和HEAD的文件的差异</p>
<p>git diff HEAD 显示工作区和HEAD的文件的差异</p>
<p>补充说明：</p>
<ul>
<li>HEAD 指向的是分支上最新提交的版本</li>
<li>英文stage area即为<strong>暂存区</strong>，亦称作stage或者index</li>
<li><code>git diff --cached</code>和<code>git diff --staged</code>的作用是一样的：前者是老版本git的写法，后者是新版本的写法。为了兼容老版本git，<code>git diff --cached</code>依然可以被git识别的。</li>
</ul>
<h3 id="git-reset"><a class="header-anchor" href="#git-reset"></a>git reset</h3>
<p>git reset其实是一个用于回退HEAD的指令。但是取决于它<code>--hard</code>、<code>--mixed</code>、<code>--soft</code>三个程度参数的不同，也有可以顺带地影响到<strong>暂存区</strong>。</p>
<p>例如，在用<code>git add hello.js</code> 将文件变动保存到<strong>暂存区</strong>后，之后我又想从<strong>暂存区</strong>删掉这项“保存”记录，我就可以使用git reset，而它同时不会撤销<strong>工作区</strong>中的文件改动：</p>
<pre><code>git reset hello.js
</code></pre>
<p>补充：git reset默认参数是<code>--mixed</code>，即上式等价为：<code>git reset hello.js --mixed</code> 。</p>
<ul>
<li>设置为<code>--hard</code>时会影响到HEAD、暂存区、工作区</li>
<li>设置为<code>--mixed</code>时只会影响到HEAD、暂存区</li>
<li>设置为<code>--soft</code>时只会影响到HEAD</li>
</ul>
<p>可以看到git reset和git checkout同样用于<code>回退</code>，但是它们作用是不同的。由于git reset主要针对的是HEAD，本文不展开讨论了，详情可参考其他资料。</p>
<h2 id="总结对比github-desktop："><a class="header-anchor" href="#总结对比github-desktop："></a>总结对比Github Desktop：</h2>
<p>git的<strong>暂存区</strong>的主要作用是优化commit；在Github Desktop界面上勾选记录，也能起到同样的作用。</p>
<p>而git的<strong>暂存区</strong>的延伸作用 – 文件快照：</p>
<ul>
<li>git checkout</li>
<li>git diff的部分指令</li>
<li>git reset</li>
<li>其他等等</li>
</ul>
<p>它们这些功能是GitHub Desktop所无法匹敌的。</p>
<blockquote>
<p>在后续的git主题的博文中，我们会继续总结如何使用git做一些比较实用和常见的操作，比如：</p>
<ul>
<li>如何撤销一个commit？</li>
<li>已经push到远程了，怎么撤销一个commit？</li>
<li>git merge的原理？管理多分支需要什么样的基础知识？</li>
<li>如何从一个分支抽取部分文件提交到另一个分支？</li>
<li>git submodule是什么，在项目中有什么实际的应用？</li>
</ul>
<p>敬请期待。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> git </tag>
            
            <tag> 基础 </tag>
            
            <tag> 指令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三栏式布局--IFE2017-CSS-task03笔记]]></title>
      <url>https://blog.az22c.top/2017/09/17/ife-css-task03/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="noopener">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<a id="more"></a>
<blockquote>
<p>task03任务要求：</p>
<ul>
<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>
<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。</li>
</ul>
<p>这个任务中，懒于去上网找图片素材，直接引用了别人复仇者联盟的图片素材。</p>
</blockquote>
<p>我们先总览本文内各种实现的思路：</p>
<ol>
<li>按照普通顺序编写HTML系
<ol>
<li>运用margin</li>
<li>用BFC</li>
</ol>
</li>
<li>先加载main栏的HTML系 <strong>（重点）</strong>
<ol>
<li>双飞翼布局</li>
<li>圣杯布局</li>
</ol>
</li>
</ol>
<h2 id="按普通顺序编写html系"><a class="header-anchor" href="#按普通顺序编写html系"></a>按普通顺序编写HTML系</h2>
<p>一般来说我们 <strong>按照普通顺序编写HTML</strong> ：此时先写子栏的代码，再写main栏的代码。</p>
<p>此时，如果想要形成三栏的布局，思路可再细分为二：</p>
<h3 id="要么运用margin形成三栏的布局"><a class="header-anchor" href="#要么运用margin形成三栏的布局"></a>要么运用margin形成三栏的布局</h3>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/1%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-%E7%94%A8margin%E5%88%86%E5%BC%80.html" target="_blank" rel="noopener">demo</a> 按照正常逻辑用margin拉开距离</p>
<h3 id="要么用bfc形成三栏的布局"><a class="header-anchor" href="#要么用bfc形成三栏的布局"></a>要么用BFC形成三栏的布局</h3>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/2%E4%BD%BF%E7%94%A8BFC%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/2%E4%BD%BF%E7%94%A8BFC%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">源码</a></p>
<p>这个其实比较巧妙。main栏的BFC令这个元素的“border-box区域”也受周围浮动元素的margin的排挤。</p>
<blockquote>
<p>注：这两个demo中的<code>clearfix</code>类是用来闭合浮动的。以满足“父元素的高度始终为子元素中最高的高度”这个要求。</p>
<p>下文的各种方法也是需要闭合浮动的，为了方便演示我省略不写。</p>
</blockquote>
<h2 id="先加载main栏的html系"><a class="header-anchor" href="#先加载main栏的html系"></a>先加载main栏的HTML系</h2>
<p>我们希望页面中间的main栏的内容最先被浏览器加载呈现，这样页面就更加主次合理，所以前端圈里面出现了这么种思路。</p>
<p><strong>原理：</strong></p>
<ul>
<li>定义main-content宽度为100%（如果在IE6里不定义100%，会有点小问题，亲们自己可以一试）</li>
<li>main 左浮动，宽度为100%</li>
<li>sub 左浮动，宽度190，左外边距为-100%（此处是关键：浮动情况下，负的外边距会导致DIV上移，而使用-100%可以确使它移动到最左侧。)</li>
<li>extra 左浮动，宽度230，左外边距为-230px（道理同上，注意的是，负的左外边距值一定要大于或等于该DIV的宽度，才能靠到上一行去）</li>
</ul>
<p>当只使用负左外边距的方法时，能够实现<strong>先加载main栏</strong>，但是main栏的内容会被挡住：</p>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/1main%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E6%8C%A1%E4%BD%8F.html" target="_blank" rel="noopener">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/1main%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E6%8C%A1%E4%BD%8F.html" target="_blank" rel="noopener">源码</a></p>
<blockquote>
<p>因此，解决 main栏的内容被挡住 的思路可再细分为二：</p>
<p>1.<strong>双飞翼布局</strong></p>
<p>2. <strong>圣杯布局</strong></p>
<p>而在本文的最后，会介绍其他的方式来实现 三栏等高的 先加载main栏的 三栏式布局。</p>
</blockquote>
<h3 id="双飞翼布局"><a class="header-anchor" href="#双飞翼布局"></a>双飞翼布局</h3>
<p>淘宝的双飞翼布局：在原来的基础上多套了一层div，并且增设margin。<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-1%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener">2-1淘宝双飞翼布局demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-1%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener">源码</a></p>
<h4 id="好处："><a class="header-anchor" href="#好处："></a>好处：</h4>
<ul>
<li>可以实现主要的内容先加载的优化</li>
<li>兼容目前所有的主流浏览器，包括IE6在内</li>
</ul>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<ul>
<li>位置不灵活，同时css对位置的控制很强</li>
</ul>
<h3 id="圣杯布局"><a class="header-anchor" href="#圣杯布局"></a>圣杯布局</h3>
<p>圣杯布局的特点是它使用了padding和相对定位，当然它也使用了负左外边距。<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener">2-2圣杯布局demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener">源码</a></p>
<h4 id="好处：-v2"><a class="header-anchor" href="#好处：-v2"></a>好处：</h4>
<ul>
<li>可以实现主要的内容先加载的优化</li>
<li>位置比较灵活：毕竟它是用 相对定位 实现的</li>
<li>main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。</li>
<li>任何一栏都可以是最高栏，不会出问题。</li>
<li>只需要针对ie6来hack：<code>zoom:1</code> ，兼容目前所有的主流浏览器，包括IE5.5</li>
</ul>
<h4 id="缺点：-v2"><a class="header-anchor" href="#缺点：-v2"></a>缺点：</h4>
<ul>
<li>当浏览器宽度过窄时，子栏可能会消失，extra栏的内容可能会跑到主栏里面。</li>
</ul>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2-X%E8%AF%81%E6%98%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%86%85%E9%83%A8%E7%81%B5%E6%B4%BB.html" target="_blank" rel="noopener">证明圣杯布局内部灵活的demo</a> – <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2-X%E8%AF%81%E6%98%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%86%85%E9%83%A8%E7%81%B5%E6%B4%BB.html" target="_blank" rel="noopener">证明圣杯布局内部灵活的源码</a></p>
<h2 id="实现三栏等高的其他方法"><a class="header-anchor" href="#实现三栏等高的其他方法"></a>// 实现三栏等高的其他方法</h2>
<h3 id="用左右border作为两栏背景色-background-clip"><a class="header-anchor" href="#用左右border作为两栏背景色-background-clip"></a>用左右border作为两栏背景色+background-clip</h3>
<p>.main元素的左右border区域作为两侧栏所在区域背景，实现伪等高效果；设置.main的padding实现栏间间隔。</p>
<p>可设置main的background色，然后用<code>background-clip: content-box;</code>控制背景范围。</p>
<pre><code>.main {
    box-sizing: border-box;
    width: 100%;
    border-left: 190px solid #faa;/*作为左栏背景色*/
    border-right: 230px solid #aaf;/*作为右栏背景色*/
    padding: 0 10px;
    height: 400px; /*某一高度*/

	/*main栏背景：*/
    background: #afa;
    background-clip: content-box;
}
</code></pre>
<p>两侧栏元素再通过负margin调整到.main元素的border区域上。</p>
<p>缺点: 兼容性不好，用到了CSS3的属性，应该至少要ie9</p>
<h3 id="绝对定位"><a class="header-anchor" href="#绝对定位"></a>绝对定位</h3>
<p>设置子元素的top:0;bottom:0;使得所有子元素的高度都和父元素的高度相同，实现等高效果</p>
<h3 id="flex布局"><a class="header-anchor" href="#flex布局"></a>flex布局</h3>
<p>flex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果</p>
<p>缺点: 兼容性不好</p>
<hr>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25070186?refer=learncoding" target="_blank" rel="noopener">详解 CSS 七种三栏布局技巧</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 圣杯布局 </tag>
            
            <tag> 双飞翼布局 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[border-radius属性]]></title>
      <url>https://blog.az22c.top/2017/09/07/css-border1/</url>
      <content type="html"><![CDATA[<p>border-radius，作为CSS3中经常被用及的属性，我们用一篇文章做一下总结。</p>
<a id="more"></a>
<p>先给出一个div作为演示用：</p>
<pre><code class="language-html">&lt;style&gt;
    .basic {
      /*基本样式：*/
      width: 200px;
      height: 200px;
      border: 1px solid black;
    }
&lt;/style&gt;
&lt;div id=&quot;test&quot; class=&quot;basic&quot;&gt;test&lt;/div&gt;
</code></pre>
<p>圆角边框border-radius可以为边框设置圆角(IE8-不支持)。</p>
<p>按照左上、右上、右下、左下的顺序可以设置四个角：</p>
<pre><code class="language-html">#test {
border-radius: 23px 55px 31px 15px;
}
</code></pre>
<h2 id="值的省略"><a class="header-anchor" href="#值的省略"></a>值的省略</h2>
<p>1.如果省略左下值，左下角就和右上角样式相同：</p>
<pre><code>#test {
border-radius: 23px 55px 31px;
}
</code></pre>
<p>2.如果再省略右下值，右下角就和左上角样式相同：</p>
<pre><code>#test {
border-radius: 23px 55px;
}
</code></pre>
<p>3.如果再省略到剩下一个值，那就四个角样式一样。</p>
<h2 id="值的拆分"><a class="header-anchor" href="#值的拆分"></a>值的拆分</h2>
<pre><code>#test {
border-radius: 23px 55px 31px 15px;
}
</code></pre>
<p>等价于 <strong>圆角单角</strong> 的写法：</p>
<pre><code>#test {
border-top-left-radius: 23px;
border-top-right-radius: 55px;
border-bottom-right-radius: 31px;
border-bottom-left-radius: 15px;
}
</code></pre>
<hr>
<p>所谓的&quot;圆角&quot;其实是这样获得的：</p>
<p><img src="https://cloud.az22c.top/border-radius-sh.png-az22cgithub" alt="border-radius"></p>
<p>将一个圆内切于一个直角，再把圆外的部分去掉。我们设置的就是圆的半径。</p>
<p>又或者可以：</p>
<p>将一个椭圆内切于一个直角，再把椭圆外的部分去掉。我们设置的是椭圆的 水平半径 和 垂直半径。</p>
<p>因此，每个角都可以用 <code>/</code> 符号拆分成设置 水平半径 和 垂直半径 两项：</p>
<pre><code>#test {
border-radius: 11px 22px 33px 44px / 55px 66px 77px 88px;
}
</code></pre>
<p>等价于：</p>
<pre><code>#test {
border-top-left-radius: 11px 55px;
border-top-right-radius: 22px 66px;
border-bottom-right-radius: 33px 77px;
border-bottom-left-radius: 44px 88px;
}
</code></pre>
<h2 id="内径和外径"><a class="header-anchor" href="#内径和外径"></a>内径和外径</h2>
<p>border-radius内径 = 外径 - 对应的边框宽度。</p>
<p>外径为50px，内径为40px：</p>
<pre><code>#test2 {
  border: 10px solid black;
  border-radius: 50px;
}
</code></pre>
<p>当border-radius半径值小于等于边框宽度时，元素没有内径效果：</p>
<p>外径为50px，没有内径，里面的角都是直角：</p>
<pre><code>#test2 {
  border: 50px solid black;
  border-radius: 50px;
}
</code></pre>
<h2 id="特殊图形"><a class="header-anchor" href="#特殊图形"></a>特殊图形</h2>
<h3 id="圆形"><a class="header-anchor" href="#圆形"></a>圆形</h3>
<p>元素的宽高相同，且圆角半径为宽高的一半：</p>
<pre><code>div {
    width: 100px;
    height: 100px;
    border-radius: 50%;
}
</code></pre>
<h3 id="椭圆：思路和-正圆-一样-仅仅使得宽高不同"><a class="header-anchor" href="#椭圆：思路和-正圆-一样-仅仅使得宽高不同"></a>椭圆：思路和 正圆 一样，仅仅使得宽高不同</h3>
<pre><code>div {
    width: 120px;
    height: 80px;
    border-radius: 50%;
}
</code></pre>
<h3 id="半圆"><a class="header-anchor" href="#半圆"></a>半圆</h3>
<pre><code>div {
    width: 100px;
    height: 50px;
    border-radius: 50px 50px 0 0;
}
</code></pre>
<h3 id="直角-扇形"><a class="header-anchor" href="#直角-扇形"></a>（直角）扇形</h3>
<pre><code>div {
    width: 50px;
    height: 50px;
    border-radius: 50px 0 0 0;
}
</code></pre>
<h2 id="补充说明："><a class="header-anchor" href="#补充说明："></a>// 补充说明：</h2>
<pre><code>div {
    width: 120px;
    height: 80px;
    border-radius: 120px;
}
</code></pre>
<ul>
<li>border-radius可以用具体的px值，也可以用百分比表示，但不能是负数。
<ul>
<li>如果取值为百分比，水平方向圆角百分比相对于宽度，垂直方向圆角百分比相对于高度</li>
</ul>
</li>
<li>如果需要用border-radius重置使得没有圆角：使用none无效，需要取值0</li>
<li>border-radius对<code>&lt;img&gt;</code>没有任何效果</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> radius </tag>
            
            <tag> 边框 </tag>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象属性的操作]]></title>
      <url>https://blog.az22c.top/2017/09/03/js-obj-prop1/</url>
      <content type="html"><![CDATA[<p>类似于“增删改查”的基本操作，属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<a id="more"></a>
<h2 id="属性查询"><a class="header-anchor" href="#属性查询"></a>属性查询</h2>
<p>属性查询一般有两种方法，包括点运算符和方括号运算符：</p>
<pre><code class="language-javascript">var o = {
  p: 'Hello World'
};
o.p // &quot;Hello World&quot;
o['p'] // &quot;Hello World&quot;
</code></pre>
<h3 id="点运算"><a class="header-anchor" href="#点运算"></a>点运算</h3>
<p>点运算符是很多面向对象语句的通用写法，由于其比较简单，所以较方括号运算符相比，更常用。</p>
<p>当通过点运算符访问对象的属性时，属性名用一个标识符来表示，标识符必须要符合变量命名规则。</p>
<p>标识符必须直接出现在javascript程序中，它们不是数据类型，因此程序无法修改它们。</p>
<pre><code class="language-javascript">var o = {
    a:1,
    1:2
};
console.log(o.a);//1
//由于变量不可以以数字开头，所以o.1报错
console.log(o.1);//Uncaught SyntaxError: missing ) after argument list
</code></pre>
<h3 id="方括号运算"><a class="header-anchor" href="#方括号运算"></a>方括号运算</h3>
<p>当通过方括号运算符来访问对象的属性时，<strong>属性名最终通过字符串来表示</strong>。字符串是javascript的数据类型，在程序运行中可以修改和创建它们。</p>
<p><strong>使用方括号运算符有两个优点。</strong></p>
<p>【一】可以通过变量来访问属性</p>
<pre><code>var a = 1;
var o = {
    1: 10
}
o[a];//10
</code></pre>
<p>【二】属性名称可以为  javascript无效标识符（即，不符合<strong>变量命名规则</strong>）</p>
<pre><code>var myObject = {
    123:'zero',
    class:'foo'
};
console.log(myObject['123'],myObject['class']);//'zero' 'foo'
console.log(myObject.123);//报错
</code></pre>
<h4 id="判断调用string-隐式转换"><a class="header-anchor" href="#判断调用string-隐式转换"></a>判断调用String()隐式转换</h4>
<p>【1】方括号中的值若是 字符串类型（外面有引号），就会正常按字符串访问对象的属性；</p>
<p>【2】方括号中的值若是 非字符串类型（外面没有引号），就会先判断是否符合<strong>变量命名规则</strong>，</p>
<p>【2-1】如果不符合，就会底层调用String()隐式转换成字符串再交由方括号运算；</p>
<p>【2-2】如果符合，就是变量了，被当作<strong>通过变量来访问属性</strong>的情况（这个时候，如果对应变量没有定义，当然就会报错）。</p>
<h5 id="看demo我们就很容易理解："><a class="header-anchor" href="#看demo我们就很容易理解："></a>看demo我们就很容易理解：</h5>
<pre><code class="language-javascript">var myObject = {
    123:'this is 123',
    clasz:'this is clasz'
};
console.log(myObject[&quot;123&quot;]) // 正常访问'this is 123'
console.log(myObject[&quot;clasz&quot;]) // 正常访问'this is clasz'
console.log(myObject[123]) // 123隐式转换成字符串&quot;123&quot;，访问得到'this is 123'
console.log(myObject[clasz]) // clasz符合变量命名规则，被当作变量：Error: clasz is not defined
</code></pre>
<h5 id="再细看-2-2-："><a class="header-anchor" href="#再细看-2-2-："></a>再细看【2-2】：</h5>
<pre><code class="language-javascript">var myObject = {
    123:'this is 123',
    clasz:'this is clasz',
    extra: 'this is 补充'
};
console.log(myObject[clasz]) // clasz符合变量命名规则，被当作变量：Error: clasz is not defined
</code></pre>
<p>对比：</p>
<pre><code class="language-javascript">var myObject = {
    123:'this is 123',
    clasz:'this is clasz',
    extra: 'this is 补充'
};
var clasz = &quot;extra&quot;
console.log(myObject[&quot;clasz&quot;]) // 访问得到'this is 补充'
</code></pre>
<p>现在我们就能理解为什么【2】要这么设置了。</p>
<h4 id="可计算属性名"><a class="header-anchor" href="#可计算属性名"></a>可计算属性名</h4>
<p>在方括号运算符内部可以使用表达式：</p>
<pre><code>var a = 1;
var person = {
    3: 'abc'
};
person[a + 2];//'abc'
</code></pre>
<p>但如果要在对象字面量内部对属性名使用表达式，则需要使用ES6的可计算属性名：</p>
<pre><code>var a = 1;
//Uncaught SyntaxError: Unexpected token +
var person = {
    a + 3: 'abc'
};
</code></pre>
<p>ES6增加了可计算属性名，可以在文字中使用[]包裹一个表达式来当作属性名：</p>
<pre><code>var a = 1;
var person = {
    [a + 3]: 'abc'
};
person[4];//'abc'
</code></pre>
<h3 id="属性查询错误"><a class="header-anchor" href="#属性查询错误"></a>属性查询错误</h3>
<p>【1】查询一个不存在的属性不会报错，而是返回undefined：</p>
<pre><code>var person = {};
console.log(person.a);//undefined
</code></pre>
<p>【2】如果对象不存在，试图查询这个不存在的对象的属性会报错：</p>
<pre><code>console.log(person.a);//Uncaught ReferenceError: person is not defined
</code></pre>
<p>可以利用这一点，来检查一个全局变量是否被声明：</p>
<pre><code>// 检查a变量是否被声明
if (a) {...} // 报错

//-----------------------------------------//

//所有全局变量都是window对象的属性。window.a的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错
if (window.a) {...} // 不报错
</code></pre>
<h2 id="属性设置"><a class="header-anchor" href="#属性设置"></a>属性设置</h2>
<p>属性设置又称为属性赋值，与属性查询相同，具有点运算符和方括号运算符这两种方法。</p>
<p>在给对象设置属性之前，一般要先检测对象是否存在：</p>
<pre><code>var len = undefined;
if(book){
    if(book.subtitle){
        len = book.subtitle.length;
    }
}
</code></pre>
<p>上面代码可以简化为：</p>
<pre><code>var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;
</code></pre>
<h3 id="属性设置错误"><a class="header-anchor" href="#属性设置错误"></a>属性设置错误</h3>
<p>null和undefined不是对象，给它们设置属性会报错：</p>
<pre><code>null.a = 1;//Uncaught TypeError: Cannot set property 'a' of null
undefined.a = 1;//Uncaught TypeError: Cannot set property 'a' of undefined
</code></pre>
<p>由于string、number和boolean有对应的 包装对象 ，所以给它们设置属性不会报错：</p>
<pre><code>'abc'.a = 1;//1
(1).a = 1;//1
true.a = 1;//1
</code></pre>
<h2 id="属性删除"><a class="header-anchor" href="#属性删除"></a>属性删除</h2>
<p>使用delete运算符可以删除对象属性(包括数组元素)：</p>
<pre><code>var o = {
    a : 1
};
console.log(o.a);//1
console.log('a' in o);//true
console.log(delete o.a);//true
console.log(o.a);//undefined
console.log('a' in o);//false
</code></pre>
<p><strong>而如果给对象属性置null或undefined，其实并没有删除该属性：</strong></p>
<pre><code>var o = {
    a : 1
};
o.a = undefined;
console.log(o.a);//undefined
console.log('a' in o);//true
console.log(delete o.a);//true
console.log(o.a);//undefined
console.log('a' in o);//false
</code></pre>
<p>使用delete删除<strong>数组元素</strong>时，不会改变数组长度：</p>
<pre><code>var a = [1,2,3];
delete a[2];
2 in a;//false
a.length;//3
</code></pre>
<p>delete运算符只能删除自有属性，不能删除继承属性(要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象)</p>
<pre><code>var o  = {
    a:1
}
var obj = Object.create(o);
obj.a = 2;

console.log(obj.a);//2
console.log(delete obj.a);//true
console.log(obj.a);//1
console.log(delete obj.a);//true
console.log(obj.a);//1
</code></pre>
<h3 id="返回值"><a class="header-anchor" href="#返回值"></a>返回值</h3>
<p>delete操作符的返回值是个布尔值true或false</p>
<p>【1】当使用delete操作符删除对象属性或数组元素删除成功时，返回true</p>
<pre><code>var o = {a:1};
var arr = [1];
console.log(delete o.a);//true
console.log(delete arr[0]);//true
</code></pre>
<p>【2】当使用delete操作符删除 不存在的属性 或 非左值 时，返回true</p>
<pre><code>var o = {};
console.log(delete o.a);//true
console.log(delete 1);//true
console.log(delete {});//true
</code></pre>
<p>【3】当使用delete操作符删除<strong>变量</strong>时，返回false，严格模式下会抛出ReferenceError错误</p>
<pre><code>var a = 1;
console.log(delete a);//false
console.log(a);//1

'use strict';
var a = 1;
//Uncaught SyntaxError: Delete of an unqualified identifier in strict mode
console.log(delete a);
</code></pre>
<p>【4】当使用delete操作符删除不可配置的属性时，返回false，严格模式下会抛出TypeError错误</p>
<pre><code>var obj = {};
Object.defineProperty(obj,'a',{configurable:false});
console.log(delete obj.a);//false

'use strict';
var obj = {};
Object.defineProperty(obj,'a',{configurable:false});
//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;
console.log(delete obj.a);
</code></pre>
<h2 id="属性继承"><a class="header-anchor" href="#属性继承"></a>属性继承</h2>
<p>每一个javascript对象都和另一个对象相关联。“另一个对象”就是我们熟知的原型，每一个对象都从原型继承属性。</p>
<p>对象本身具有的属性叫自有属性(own property)，从原型对象继承而来的属性叫继承属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
//继承自原型对象o的属性a
console.log(obj.a);//1
//自有属性b
console.log(obj.b);//2
</code></pre>
<h3 id="hasownproperty"><a class="header-anchor" href="#hasownproperty"></a>hasOwnProperty()</h3>
<p>通过hasOwnProperty()方法可以确定该属性是自有属性还是继承属性</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log(obj.hasOwnProperty('a'));//false
console.log(obj.hasOwnProperty('b'));//true
</code></pre>
<h3 id="in"><a class="header-anchor" href="#in"></a>in</h3>
<p>in操作符可以判断属性在不在该对象上，但无法区别自有还是继承属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log('a' in obj);//true
console.log('b' in obj);//true
console.log('b' in o);//false
</code></pre>
<h3 id="for-in"><a class="header-anchor" href="#for-in"></a>for-in</h3>
<p>通过for-in循环可以遍历出该对象中所有可枚举属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
for(var i in obj){
    console.log(obj[i]);//2 1
}
</code></pre>
<h3 id="object-keys"><a class="header-anchor" href="#object-keys"></a>Object.keys()</h3>
<p>Object.keys()方法返回所有可枚举的自有属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o,{
    c:{value:3,configurable: false}
});
obj.b = 2;
console.log(Object.keys(obj));//['b']
</code></pre>
<h3 id="object-getownpropertynames"><a class="header-anchor" href="#object-getownpropertynames"></a>Object.getOwnPropertyNames()</h3>
<p>与Object.keys()方法不同，Object.getOwnPropertyNames()方法返回所有自有属性(包括不可枚举的属性)</p>
<pre><code>var o = {a:1};
var obj = Object.create(o,{
    c:{value:3,configurable: false}
});
obj.b = 2;
console.log(Object.getOwnPropertyNames(obj));//['c','b']
</code></pre>
<hr>
<h2 id="相关话题："><a class="header-anchor" href="#相关话题："></a>// 相关话题：</h2>
<p>【1】对象属性的操作： “内容即本文。”</p>
<p>属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<p>【2】对象属性描述符： <a href="/2017/09/02/js-obj-prop2/">链接</a></p>
<p>属性描述符用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<p>【3】对象状态： <a href="/2017/09/01/js-obj-prop3/">链接</a></p>
<p>属性描述符只能用来控制对象中一个属性的状态，而如果要控制整个对象的状态，就要用到6种对象状态。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 对象属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象属性描述符]]></title>
      <url>https://blog.az22c.top/2017/09/02/js-obj-prop2/</url>
      <content type="html"><![CDATA[<p>对于操作系统中的文件，我们可以驾轻就熟将其设置为只读、隐藏、系统文件或普通文件。</p>
<p>于对象来说，属性描述符提供类似的功能，用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<a id="more"></a>
<p><strong>描述符类型：</strong></p>
<p>对象属性描述符的类型分为两类：<strong>数据属性</strong>和<strong>访问器属性</strong> 。</p>
<h2 id="数据属性"><a class="header-anchor" href="#数据属性"></a>数据属性</h2>
<p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值。</p>
<p>数据属性有4个特性：</p>
<p>【1】Configurable(可配置性)</p>
<p>【2】Enumerable(可枚举性)</p>
<p>【3】Writable(可写性)</p>
<p>【4】Value(属性值)</p>
<p>属性值 包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined</p>
<h2 id="访问器属性"><a class="header-anchor" href="#访问器属性"></a>访问器属性</h2>
<p>对象属性是名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter。而这种属性类型叫访问器属性：</p>
<p>【1】Configurable(可配置性)</p>
<p>【2】Enumerable(可枚举性)</p>
<p>【3】getter</p>
<p>【4】setter</p>
<p><strong>和数据属性不同，访问器属性不具有可写性(Writable)。</strong></p>
<p><strong>如果属性同时具有getter和setter方法，那么它是一个读/写属性；如果它只有getter方法，那么它是一个只读属性；如果它只有setter方法，那么它是一个只写属性。读取只写属性总是返回undefined</strong></p>
<hr>
<h2 id="描述符方法"><a class="header-anchor" href="#描述符方法"></a>描述符方法</h2>
<p>前面介绍了属性描述符，要想设置它们，就需要用到描述符方法。描述符方法总共有以下4个：</p>
<blockquote>
<p>【1】Object.getOwnPropertyDescriptor()</p>
<p>【2】Object.defineProperty()</p>
<p>【3】Object.defineProperties()</p>
<p>【4】Object.create()</p>
</blockquote>
<h3 id="object-getownpropertydescriptor"><a class="header-anchor" href="#object-getownpropertydescriptor"></a>Object.getOwnPropertyDescriptor()</h3>
<p>Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回：</p>
<pre><code>var obj = {a:1};
//Object {value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
//undefined
console.log(Object.getOwnPropertyDescriptor(obj,'b'));
</code></pre>
<p>查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1</p>
<p>查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined</p>
<h3 id="object-defineproperty"><a class="header-anchor" href="#object-defineproperty"></a>Object.defineProperty()</h3>
<p>Object.defineProperty(o,name,desc)方法用于创建或配置对象的一个属性的描述符，返回配置后的对象。</p>
<p><strong>使用该方法创建或配置对象属性的描述符时，如果不针对该属性进行描述符的配置，则该项描述符默认为false：</strong></p>
<pre><code>var obj = {};
//{a:1}
console.log(Object.defineProperty(obj,'a',{
        value:1,
        writable: true
    }));

//由于没有配置enumerable和configurable，所以它们的值为false
//{value: 1, writable: true, enumerable: false, configurable: false}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
</code></pre>
<h3 id="object-defineproperties"><a class="header-anchor" href="#object-defineproperties"></a>Object.defineProperties()</h3>
<p>Object.defineProperty(o,descriptors)方法用于创建或配置对象的多个属性的描述符，返回配置后的对象：</p>
<pre><code>var obj = {
    a:1
};
//{a: 1, b: 2}
console.log(Object.defineProperties(obj,{
        a:{writable:false},
        b:{value:2}
    }));

//{value: 1, writable: false, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
//{value: 2, writable: false, enumerable: false, configurable: false}
console.log(Object.getOwnPropertyDescriptor(obj,'b'));
</code></pre>
<h3 id="object-create"><a class="header-anchor" href="#object-create"></a>Object.create()</h3>
<p>Object.create(proto,descriptors)方法使用指定的原型和属性<strong>来创建一个对象</strong>：</p>
<pre><code>var o = Object.create(Object.prototype,{
    a:{writable: false,value:1,enumerable:true}
});
//{value: 1, writable: false, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
</code></pre>
<h2 id="描述符-详细说明"><a class="header-anchor" href="#描述符-详细说明"></a>描述符–详细说明</h2>
<p>前面分别介绍了数据属性和访问器属性的描述符，但没有详细说明其含义及使用，接下来逐一进行说明：</p>
<h3 id="可写性-writable"><a class="header-anchor" href="#可写性-writable"></a>可写性(writable)</h3>
<p>可写性决定是否可以修改属性的值，默认值为true；设置writable:false后，赋值语句会静默失效：</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    writable:false
});
console.log(o.a);//1
//由于设置了writable为false，所以o.a=2这个语句会静默失效
o.a = 2;
console.log(o.a);//1
Object.defineProperty(o,'a',{
    writable:true
});
//由于writable设置为true，所以o.a可以被修改为2
o.a = 2;
console.log(o.a);//2
</code></pre>
<p><strong>设置writable:false后，能通过Object.defineProperty()方法改变属性value的值，这过程不会影响到writable的值，因为这也意味着再重置writable的属性值为false：</strong></p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    writable:false
});
console.log(o.a);//1
Object.defineProperty(o,'a',{
    value:2
});
console.log(o.a);//2,writable依然是false
</code></pre>
<blockquote>
<p>在<strong>严格模式</strong>下通过赋值语句为writable为false的属性赋值，会提示类型错误TypeError：</p>
<pre><code class="language-javascript">'use strict';
var o = {a:1};
Object.defineProperty(o,'a',{
    writable:false
});
//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'
o.a = 2;
</code></pre>
</blockquote>
<h3 id="可配置性-configurable"><a class="header-anchor" href="#可配置性-configurable"></a>可配置性(Configurable)</h3>
<p>可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true</p>
<p>【1】设置Configurable:false后，无法使用delete删除属性</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false
});
delete o.a;//false
console.log(o.a);//1
</code></pre>
<p><strong>使用var命令声明变量时，变量的configurable为false：</strong></p>
<pre><code>var a = 1;
//{value: 1, writable: true, enumerable: true, configurable: false}
Object.getOwnPropertyDescriptor(this,'a');
</code></pre>
<blockquote>
<p>在严格模式下删除为configurable为false的属性，会提示类型错误TypeError</p>
<pre><code class="language-javascript">'use strict';
var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false
});
//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;
delete o.a;
</code></pre>
</blockquote>
<p>【2】一般地，设置Configurable:false后，将无法再使用defineProperty()方法来修改属性描述符</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false
});
//Uncaught TypeError: Cannot redefine property: a
Object.defineProperty(o,'a',{
    configurable:true
});
</code></pre>
<p>有一个例外，设置Configurable:false后，只允许writable的状态从true变为false</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false,
    writable:true
});
o.a = 2;
console.log(o.a);//2
Object.defineProperty(o,'a',{
    writable:false
});
//由于writable:false生效，对象a的o属性无法修改值，所以o.a=3的赋值语句静默失败
o.a = 3;
console.log(o.a);//2
</code></pre>
<h3 id="可枚举性-enumerable"><a class="header-anchor" href="#可枚举性-enumerable"></a>可枚举性(Enumerable)</h3>
<p>可枚举性决定属性是否出现在对象的属性枚举中，具体来说就是，for-in循环、Object.keys方法、JSON.stringify方法是否会取到该属性。</p>
<p>用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的</p>
<pre><code>//由于enumerable被设置为false，在for-in循环中a属性无法被枚举出来
var o = {a:1};
Object.defineProperty(o,'a',{enumerable:false});
for(var i in o){
    console.log(o[i]);//undefined
}
</code></pre>
<h4 id="propertyisenumerable"><a class="header-anchor" href="#propertyisenumerable"></a>propertyIsEnumerable()</h4>
<p>propertyIsEnumerable()方法用于判断对象的属性是否可枚举</p>
<pre><code>var o = {a:1};
console.log(o.propertyIsEnumerable('a'));//true
Object.defineProperty(o,'a',{enumerable:false});
console.log(o.propertyIsEnumerable('a'));//false
</code></pre>
<h3 id="get和set"><a class="header-anchor" href="#get和set"></a>get和set</h3>
<p>get是一个隐藏函数，在获取属性值时调用。set也是一个隐藏函数，在设置属性值时调用，它们的默认值都是undefined。</p>
<p><strong>Object.definedProperty()中的get和set对应于对象字面量中get和set方法。</strong></p>
<p><strong>getter和setter取代了数据属性中的value和writable属性。</strong></p>
<p>【1】一般地，set和get方法是成对出现的：</p>
<pre><code>var o ={
    get a(){
        return this._a;
    },
    set a(val){
        this._a = val*2;
    }
}
o.a = 1;
console.log(o.a);//2
</code></pre>
<p>Object.definedProperty()中的get和set对应于对象字面量中get和set方法：</p>
<pre><code>Object.defineProperty(o,'a',{
    get: function(){
        return this._a;
    },
    set :function(val){
        this._a = val*2;
    }
})
o.a = 1;
console.log(o.a);//2
</code></pre>
<hr>
<p>【2】给只设置get方法，没有设置set方法的对象赋值会静默失败（在严格模式下会报错），所以为了规范起见最好同时设置getter和setter：</p>
<pre><code>var o = {
    get a(){
        return 2;
    }
}    
console.log(o.a);//2
//由于没有设置set方法，所以o.a=3的赋值语句会静默失败
o.a = 3;
console.log(o.a);//2
</code></pre>
<p>同样地：</p>
<pre><code>Object.defineProperty(o,'a',{
    get: function(){
        return 2;
    }
})
console.log(o.a);//2
//由于没有设置set方法，所以o.a=3的赋值语句会静默失败
o.a = 3;
console.log(o.a);//2
</code></pre>
<blockquote>
<p>在严格模式下，给没有设置set方法的访问器属性赋值会报错：</p>
<pre><code class="language-javascript">'use strict';
var o = {
    get a(){
        return 2;
    }
}    
console.log(o.a);//2
//由于没有设置set方法，所以o.a=3的赋值语句会报错
//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a getter
o.a = 3;
</code></pre>
<p>并且在Object.definedProperty()中也是同理。</p>
</blockquote>
<hr>
<p>【3】只设置set方法，而不设置get方法，则对象属性值为undefined：</p>
<pre><code>var o = {
    set a(val){
        return 2;
    }
}    
o.a = 1;
console.log(o.a);//undefined
</code></pre>
<p>同样地：</p>
<pre><code>Object.defineProperty(o,'a',{
    set: function(){
        return 2;
    }
})
o.a = 1;
console.log(o.a);//undefined
</code></pre>
<hr>
<h2 id="相关话题："><a class="header-anchor" href="#相关话题："></a>// 相关话题：</h2>
<p>【1】对象属性的操作： <a href="/2017/09/03/js-obj-prop1/">链接</a></p>
<p>属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<p>【2】对象属性描述符： “内容即本文。”</p>
<p>属性描述符用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<p>【3】对象状态： <a href="/2017/09/01/js-obj-prop3/">链接</a></p>
<p>属性描述符只能用来控制对象中一个属性的状态，而如果要控制整个对象的状态，就要用到6种对象状态。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 对象属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象属性之对象状态]]></title>
      <url>https://blog.az22c.top/2017/09/01/js-obj-prop3/</url>
      <content type="html"><![CDATA[<p>我们知道，属性描述符只能用来控制对象中一个属性的状态。而如果要控制对象的状态，就要用到下面的6种方法：</p>
<a id="more"></a>
<blockquote>
<p>【1】Object.preventExtensions()(禁止扩展)；【2】Object.isExtensible()(测试扩展)。</p>
<p>【3】Object.seal()(对象封印)；【4】Object.isSealed()(测试封印)。</p>
<p>【5】Object.freeze()(对象冻结)；【6】Object.isFrozen()(检测冻结)。</p>
</blockquote>
<h2 id="object-preventextensions-禁止扩展"><a class="header-anchor" href="#object-preventextensions-禁止扩展"></a>Object.preventExtensions()(禁止扩展)</h2>
<p>Object.preventExtensions()方法使一个对象<strong>无法再添加新的属性</strong> ，并返回当前对象</p>
<h2 id="object-isextensible-测试扩展"><a class="header-anchor" href="#object-isextensible-测试扩展"></a>Object.isExtensible()(测试扩展)</h2>
<p>Object.isExtensible()方法用来检测该对象是否可以扩展</p>
<pre><code>var o = {a:1};
console.log(Object.isExtensible(o));//true
o.b = 2;
console.log(o);//{a: 1, b: 2}
console.log(Object.preventExtensions(o));//{a: 1, b: 2}
//由于对象o禁止扩展，所以该赋值语句静默失败
o.c = 3;
console.log(Object.isExtensible(o));//false
console.log(o);//{a: 1, b: 2}
</code></pre>
<blockquote>
<p>在严格模式下，给禁止扩展的对象添加属性会报TypeError错误：</p>
<pre><code class="language-javascript">'use strict';
var o = {a:1};
console.log(Object.preventExtensions(o));//{a:1}
//Uncaught TypeError: Can't add property c, object is not extensible
o.c = 3;
</code></pre>
</blockquote>
<p>Object.preventExtensions()方法并不改变对象中属性的描述符状态：</p>
<pre><code>var o = {a:1};
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
Object.preventExtensions(o);
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
</code></pre>
<hr>
<h2 id="object-seal-对象封印"><a class="header-anchor" href="#object-seal-对象封印"></a>Object.seal()(对象封印)</h2>
<p>对象封印又叫对象密封，使一个对象<strong>不可扩展并且所有属性不可配置</strong> ，并返回当前对象</p>
<h2 id="object-issealed-测试封印"><a class="header-anchor" href="#object-issealed-测试封印"></a>Object.isSealed()(测试封印)</h2>
<p>Object.isSealed()方法用来检测该方法是否被封印</p>
<pre><code>var o = {a:1,b:2};
console.log(Object.isSealed(o));//false
console.log(Object.seal(o));//{a:1,b:2}
console.log(Object.isSealed(o));//true
console.log(delete o.b);//false
o.c = 3;
console.log(o);//{a:1,b:2}
</code></pre>
<blockquote>
<p>在严格模式下，删除旧属性或添加新属性都会报错</p>
<pre><code>'use strict';
var o = {a:1,b:2};
console.log(Object.seal(o));//{a:1,b:2}
//Uncaught TypeError: Cannot delete property 'b' of #&lt;Object&gt;
delete o.b;
</code></pre>
</blockquote>
<p>这个方法实际上会在现有对象上调用Object.preventExtensions()方法，并把所有现有属性的configurable描述符置为false</p>
<pre><code>var o = {a:1,b:2};
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
console.log(Object.seal(o));//{a:1,b:2}
//{value: 1, writable: true, enumerable: true, configurable: false}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
</code></pre>
<hr>
<h2 id="object-freeze-对象冻结"><a class="header-anchor" href="#object-freeze-对象冻结"></a>Object.freeze()(对象冻结)</h2>
<p>Object.freeze()方法使一个对象<strong>不可扩展，不可配置，也不可改写，变成一个仅可以枚举的只读常量</strong> ，并返回当前对象</p>
<h2 id="object-isfrozen-检测冻结"><a class="header-anchor" href="#object-isfrozen-检测冻结"></a>Object.isFrozen()(检测冻结)</h2>
<p>Object.isFrozen()方法用来检测一个对象是否被冻结</p>
<pre><code>var o = {a:1,b:2};
console.log(Object.isFrozen(o));//false
console.log(Object.freeze(o));//{a:1,b:2}
console.log(Object.isFrozen(o));//true
o.a = 3;
console.log(o);//{a:1,b:2}
</code></pre>
<blockquote>
<p>在严格模式下，删除旧属性、添加新属性、更改现有属性都会报错</p>
<pre><code>'use strict';
var o = {a:1,b:2};
console.log(Object.freeze(o));//{a:1,b:2}
//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'
o.a = 3;
</code></pre>
</blockquote>
<p>这个方法实际上会在现有对象上调用Object.seal()方法，并把所有现有属性的writable描述符置为false</p>
<pre><code>var o = {a:1};
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
console.log(Object.freeze(o));//{a:1}
//{value: 1, writable: false, enumerable: true, configurable: false}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
</code></pre>
<hr>
<h2 id="相关话题："><a class="header-anchor" href="#相关话题："></a>// 相关话题：</h2>
<p>【1】对象属性的操作： <a href="/2017/09/03/js-obj-prop1/">链接</a></p>
<p>属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<p>【2】对象属性描述符： <a href="/2017/09/02/js-obj-prop2/">链接</a></p>
<p>属性描述符用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<p>【3】对象状态： “内容即本文。”</p>
<p>属性描述符只能用来控制对象中一个属性的状态，而如果要控制整个对象的状态，就要用到6种对象状态。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 对象属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es5实现继承的6种方式]]></title>
      <url>https://blog.az22c.top/2017/08/12/js-inherit/</url>
      <content type="html"><![CDATA[<p>对关于继承的内容做一番整理。是早期编写的文章，直接看到最后的结论即可。后面可以优化一下行文的思路。</p>
<a id="more"></a>
<p>把结论图拷贝放到本文的最前面：</p>
<p>寄生组合式继承 才是最终的主角；而其余的几个“继承方式”，都被它借鉴了优点，所以仅仅是作为铺垫介绍。</p>
<p><img src="https://cloud.az22c.top/js-inherit-sumary.png-az22cgithub" alt="js-inherit-sumary"></p>
<h2 id="原型链继承"><a class="header-anchor" href="#原型链继承"></a>原型链继承</h2>
<ul>
<li>优点：js 原型链继承 适用于存放父类的方法</li>
<li>缺点：
<ul>
<li>【缺点1】不适合存放父类的属性。即，子类实例之间共享属性就容易造成属性混淆使用。
<ul>
<li>（参考更多的方式，我们知道定义属性应改进为在构造函数中，而不是在原型对象中。）</li>
</ul>
</li>
<li>【缺点2】（因为创造链条是 父构造函数-&gt;父实例（即子类原型）-&gt;子实例，）子类原型上存在父构造函数定义的属性（这部分属性若改为由子构造函数控制定义，会好一点）</li>
</ul>
</li>
</ul>
<p>该式的典型代码：</p>
<pre><code class="language-javascript">function Super(){
    this.value = true;
}
Super.prototype.getValue = function(){
    return this.value;
};
function Sub(){}
//Sub继承了Super：
Sub.prototype = new Super();
Sub.prototype.constructor = Sub;

var instance = new Sub();
console.log(instance.getValue());//true
</code></pre>
<p>再而，缺点1 演示：</p>
<pre><code class="language-javascript">function Super(){
    this.colors = ['red','blue','green'];
}
function Sub(){};
//Sub继承了Super
Sub.prototype = new Super();
var instance1 = new Sub();
instance1.colors.push('black');
console.log(instance1.colors);//'red,blue,green,black'
var instance2 = new Sub();
console.log(instance2.colors);//'red,blue,green,black'
</code></pre>
<h3 id="原型式继承"><a class="header-anchor" href="#原型式继承"></a>原型式继承</h3>
<p>我们先来介绍<code>Object.create</code>：<code>Object.create</code>前后，2者从表现上看好像是“浅拷贝”，但是“属性位于哪个对象上”，这点明显和“浅拷贝”不同。</p>
<pre><code class="language-javascript">function mycreate(o){ // Object.create的实现原理
    function F(){};
    F.prototype = o;
    return new F();
}

var superObj = { // 基于已有的对象创建新对象
    colors: ['red','blue','green']
};
var subObj1 = mycreate(superObj); // 等价于：subObj1 = Object.create(superObj)
subObj1.colors.push(&quot;black&quot;);

var subObj2 = object(superObj);
subObj2.colors.push(&quot;white&quot;);

console.log(superObj.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
console.log(subObj1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
</code></pre>
<p>前面只是使用<code>Object.create</code>实现「实例对象“浅拷贝”实例对象」；我们也可以应用到「原型对象“浅拷贝”原型对象」以实现“类”之间的继承，而这就是“原型式继承”：</p>
<pre><code class="language-js">function Parent() {}
function Child() {}

Child.prototype = Object.create(Parent.protoptype);
child.prototype.constructor = Child; // 要补上的。同时应改为 defineProperty 设置该 constructor 属性

var child = new Child();
</code></pre>
<p>实际上，<code>Object.create()</code>方法规范化了原型式继承：</p>
<ul>
<li>（原型式继承只是将原型链继承进行简单的改造：改造了1个缺点，仍剩下另1个缺点：）
<ul>
<li>改造了1个缺点后：<code>Child.prototype = Object.create(Parent.protoptype)</code>：没有调用<code>new Parent</code>，因而<strong>对于<code>Child.prototype</code></strong> ，可以不继承父类的实例上的属性(包括Parent构造函数将赋予的属性)</li>
<li>仍然残留1个缺点：子类实例之间共享属性就容易造成属性混淆使用</li>
</ul>
</li>
</ul>
<h2 id="寄生式继承"><a class="header-anchor" href="#寄生式继承"></a>寄生式继承</h2>
<p>寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以各种定义属性来增强对象，最后返回对象：</p>
<pre><code class="language-javascript">function parasite(original){
    var clone = Object.create(original);//通过调用函数创建一个新对象
    clone.sayHi = function(){ //以各种定义属性来增强这个对象。（若再参考其他方式，更适合改为抽取到其他地方来定义属性）
        console.log(&quot;hi&quot;);
    };
    return clone;//返回这个对象
}
var superObj = {
    colors: ['red','blue','green']
};
var subObj1 = parasite(superObj);
// 上一句，2者都在原型链上平移1位。即相当于 Child.prototype = Object.create(Parent.protoptype)
subObj1.colors.push('black');
var subObj2 = parasite(superObj);
subObj2.colors.push('white');

console.log(superObj.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
console.log(subObj1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
</code></pre>
<ul>
<li>寄生式继承实际上只是原型式继承的再包装，缺点依旧。
<ul>
<li>总而言之，现有改进链条为： 原型链式继承 --&gt; 原型式继承 --&gt; 寄生式继承</li>
</ul>
</li>
<li>（ 随着之后的代码改造，将<code>clone.sayHi</code>抽取到其他地方来定义，才会效果更好）</li>
</ul>
<h2 id="借用构造函数"><a class="header-anchor" href="#借用构造函数"></a>借用构造函数</h2>
<p>借用构造函数(constructor stealing)的技术(有时候也叫做伪类继承或经典继承)。</p>
<p>基本思想相当简单，即在子类构造函数的内部调用父类构造函数。</p>
<p>在代码层面，通过使用apply()和call()方法令新创建的对象this上调用构造函数：</p>
<pre><code class="language-javascript">function Super(){
    this.colors = ['red','blue','green'];
}
function Sub(){
    //继承了Super
    Super.call(this);
}
var instance1 = new Sub();
instance1.colors.push('black');
console.log(instance1.colors);// ['red','blue','green','black']
var instance2 = new Sub();
console.log(instance2.colors);// ['red','blue','green']
</code></pre>
<p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类构造函数中向父类构造函数传递参数：</p>
<pre><code class="language-javascript">function Super(name){
    this.name = name;
}
function Sub(){
    //继承了Super，同时还传递了参数
    Super.call(this,&quot;bai&quot;);
    //实例属性
    this.age = 29;
}
var instance = new Sub();
console.log(instance.name);//&quot;bai&quot;
console.log(instance.age);//29 
</code></pre>
<p>缺点：但是，如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——“方法”都在构造函数中定义，每创建一次实例就重复创建一次实例“方法”，没有复用“方法”。</p>
<h2 id="组合继承"><a class="header-anchor" href="#组合继承"></a>组合继承</h2>
<p>组合继承(combination inheritance)有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</p>
<ul>
<li>（具体步骤：）
<ul>
<li>通过原型链实现对原型属性和方法的继承</li>
<li>通过借用构造函数来实现对实例属性的继承</li>
</ul>
</li>
<li>具体的效果：
<ul>
<li>既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己独自的属性：【下方代码】</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">function Super(name){
    this.name = name;
    this.colors = ['red','blue','green'];
}
Super.prototype.sayName = function(){
    console.log(this.name);
};
function Sub(name,age){
    //继承属性
    Super.call(this,name);// 子类构造函数内部，调用了一次父类的构造函数
    this.age = age;
}
//继承方法
Sub.prototype = new Super(); // 创建子类原型，调用了一次父类的构造函数
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
    console.log(this.age);
}
var instance1 = new Sub(&quot;bai&quot;,29);
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//&quot;bai&quot;
instance1.sayAge();//29

var instance2 = new Sub(&quot;hu&quot;,27);
console.log(instance2.colors);//['red','blue','green']
instance2.sayName();//&quot;hu&quot;
instance2.sayAge();//27
</code></pre>
<ul>
<li>“寄生组合继承”相当于是它的进化版，取其优点去其缺点
<ul>
<li>取 组合继承 的优点：组合了原型链和构造函数式。</li>
<li>也消除了 组合继承 的缺点：
<ul>
<li>【缺点1】会调用两次父类构造函数：<strong>一次是在创建子类原型的时候，另一次是在子类构造函数内部。</strong>
<ul>
<li>子类最终会包含父类对象的全部实例属性，因而不得不在调用子类构造函数时重写这些属性【见代码】</li>
</ul>
</li>
<li>【缺点2】利用了原型链继承。即没有用到它的升级版–寄生式继承（即原型式继承+小包装得来） 来取缔原型链继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">function Super(name){
    this.name = name;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
Super.prototype.sayName = function(){
    return this.name;
};
function Sub(name,age){
     // 第二次调用Super()，Sub.prototype又得到了name和colors两个属性，并对上次得到的属性值进行了覆盖
    Super.call(this,name);
    this.age = age;
}
//第一次调用Super()，Sub.prototype得到了name和colors两个属性
Sub.prototype = new Super(); 
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
    return this.age;
};  
var instance1 = new Sub(&quot;bai&quot;,29);// 第二次调用Super()
</code></pre>
<h2 id="寄生组合式继承"><a class="header-anchor" href="#寄生组合式继承"></a>寄生组合式继承</h2>
<ul>
<li>（前文提到：寄生式继承=原型式继承+小包装 ）</li>
<li>寄生组合式继承，可以从各自2个角度理解它的产生：
<ul>
<li>可以说是 寄生式继承，参考 组合式继承的形式，而与 构造函数式继承组合，得到</li>
<li>也可以说是，基于组合式继承，将其中的 原型链式继承 改造为 寄生式继承（或原型式继承），得到</li>
</ul>
</li>
<li>寄生组合式继承 受以上各种“方式”的启发，又消除了 以上各种“方式”的缺点</li>
</ul>
<pre><code class="language-javascript">function parasite(original){
    var clone = Object.create(original);//通过调用函数创建一个新对象
    return clone;//返回这个对象
}

function Super(name){
    this.name = name;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
Super.prototype.sayName = function(){
    return this.name;
};
function Sub(name,age){
    Super.call(this,name);
    this.age = age;
}
Sub.prototype = parasite(Super.prototype);
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
    return this.age;
}
var instance1 = new Sub(&quot;bai&quot;,29);
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//&quot;bai&quot;
instance1.sayAge();//29

var instance2 = new Sub(&quot;hu&quot;,27);
console.log(instance2.colors);//['red','blue','green']
instance2.sayName();//&quot;hu&quot;
instance2.sayAge();//27
</code></pre>
<p>精简一点，则如下所示：</p>
<pre><code class="language-javascript">function Super(name){
  	// 父类的实例属性：
    this.name = name; 
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
Super.prototype.sayName = function(){// 父类的原型属性
    return this.name;
};


function Sub(name,age){
    Super.call(this,name); // 得到父类的实例属性
    this.age = age;
}
if(!Object.create){
　　Object.create = function(proto){
　　　　function F(){};
　　　　F.prototype = proto;
　　　　return new F;
　　}
}
Sub.prototype = Object.create(Super.prototype);// 只继承了父类的原型属性
Sub.prototype.constructor = Sub;

var instance1 = new Sub(&quot;bai&quot;,29);// 得到父类的实例属性
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//&quot;bai&quot;

var instance2 = new Sub(&quot;hu&quot;,27);
console.log(instance2.colors);//['red','blue','green']
instance2.sayName();//&quot;hu&quot;
</code></pre>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p><img src="https://cloud.az22c.top/js-inherit-sumary.png-az22cgithub" alt="js-inherit-sumary"></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[new创建对象的过程发生了什么]]></title>
      <url>https://blog.az22c.top/2017/08/12/js-new-happen/</url>
      <content type="html"><![CDATA[<p>用面向对象语言们通用的观点来看：new 是用来实例化一个类，从而在内存中分配一个实例对象。</p>
<a id="more"></a>
<p>我们通过一个例子来讨论<strong>new的过程中发生了什么</strong> ：</p>
<pre><code class="language-javascript">function Person(name) {
    this.name = name;
}
Person.hairColor = &quot;black&quot;;
Person.prototype.say = function() {
    console.log(&quot;My name is &quot; + this.name);
};
var john = new Person(&quot;John&quot;);

console.log(
	john.name, // &quot;John&quot;,
  	john.hairColor, // undefined
  	john.height // undefined
);
john.say(); // &quot;My name is John&quot;

console.log(
	Person.name, // &quot;Person&quot;
  	Person.hairColor // &quot;black&quot;
);
Person.say(); // Person.say is not a function
</code></pre>
<h2 id="重点解析"><a class="header-anchor" href="#重点解析"></a>重点解析</h2>
<p>第8行代码是关键：</p>
<pre><code class="language-javascript">var john = new Person(&quot;John&quot;);
</code></pre>
<p>Person本身是一个普通函数，但当通过new来创建对象时，Person就是构造函数了。</p>
<p>JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：</p>
<pre><code class="language-javascript">new Person(&quot;John&quot;) = {
  var obj = {};
	obj.__proto__ = Person.prototype;
	// 此时便建立了obj对象的原型链：
	// obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null

	var result = Person.call(obj,&quot;John&quot;); // 相当于obj.Person(&quot;John&quot;)

	// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：
	return typeof result === 'object' ? result || obj : obj;
}
</code></pre>
<p>可以看到，这里的obj经返回后会被赋给<code>var john</code>变量：</p>
<p>obj.name是在<code>Person.call(obj,&quot;John&quot;)</code>这句话执行之后就有了“John”这个值；</p>
<p>等到obj经返回被赋给john之后，john.name就是“John”了。</p>
<p>画出最终<code>var john = new Person(&quot;John&quot;);</code>这一句代码涉及到的对象和它们间的关系：</p>
<p><img src="https://cloud.az22c.top/js-new-process-1.png-az22cgithub" alt="js-new-process-1"></p>
<blockquote>
<p>如果看不懂图，可以先看我以往文章的介绍： <a href="/2017/08/08/js-proto/">理解prototype、proto和constructor等关系</a></p>
</blockquote>
<h2 id="控制台结果解析"><a class="header-anchor" href="#控制台结果解析"></a>控制台结果解析</h2>
<p>分析完了 john 的产生过程，我们再分析一下控制台输出结果：</p>
<p>这个例子的代码全部执行完，最终涉及到的对象和它们间的关系如图：</p>
<p><img src="https://cloud.az22c.top/js-new-process-2.png-az22cgithub" alt="js-new-process-2"></p>
<ul>
<li><a href="http://john.name" target="_blank" rel="noopener">john.name</a>： 临时变量obj有name，obj经返回被赋给john，john的一些属性由此而来。</li>
<li>john.hairColor：john实例对象 先查找自身的 hairColor，<strong>没有找到便会沿着原型链查找</strong>，在上述例子中，我们仅在 Person 对象上定义了 hairColor，并没有在其原型链上定义，因此找不到。</li>
<li>john.height：john实例对象 先查找自身的 height，<strong>没有找到便会沿着原型链查找</strong>，原型链上也没有，因此找不到。</li>
<li>john.say：john会先查找自身的 say 方法，没有找到便会沿着原型链查找，在上述例子中，我们在 Person.prototype上定义了say，因此在原型链上找到了say 方法。</li>
</ul>
<p>另外，在 say 方法中还访问<code>this.name</code>，这里的 this 指的是其调用者。如果john调用say，john就是调用者，因此输出john.name的值。</p>
<hr>
<p>对于Person来说，它本身也是一个对象，因此它在访问属性和方法时也遵守上述查找规则，所以：</p>
<ul>
<li><code>Person.name</code> —&gt; Person   <strong>// 这是特殊情况</strong></li>
<li>Person.hairColor —&gt; “black”</li>
<li>Person.say() —&gt; Person.say is not a function</li>
</ul>
<p>需要注意的是，Person 先查找自身的 name，找到了 name，<strong>但这个 name 并不是我们定义的 name，而是函数对象内置的属性</strong>，一般情况下，函数对象在产生时会内置 name 属性并将函数名作为赋值（仅函数对象）。</p>
<p>另外，Person 在自身没有找到 say() 方法，也会沿着其原型链查找：</p>
<p>Person 的原型链： <strong>Person-&gt;Function.prototype-&gt;Object.prototype-&gt;null</strong> ，这原型链在 <a href="/2017/08/08/js-proto/">往期文章</a> 里面我有介绍到。</p>
<p>由于 Person 的原型链上也没有定义 say 方法，因此返回异常提示。</p>
<h2 id="总结new的过程中发生了什么"><a class="header-anchor" href="#总结new的过程中发生了什么"></a>总结new的过程中发生了什么</h2>
<p>[1] 导致john继承了Person.prototype：</p>
<p>令john的<code>__proto__属性</code>指向Person.prototype，确立了这条原型链， 导致 john 能通过原型链继承Person.prototype 中的部分属性，可以简单地视john和Person.prototype是继承关系。</p>
<p>[2] john是 Person构造函数 的实例：</p>
<pre><code class="language-javascript">// instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上：
john instanceof Person; //true
</code></pre>
<p>这个过程中Person构造函数被调用并发挥了作用。其结果是，经过new创建实例对象后，实例对象可以拥有自己的属性和方法。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型对象 实战使用]]></title>
      <url>https://blog.az22c.top/2017/08/09/js-prototype-practice/</url>
      <content type="html"><![CDATA[<p>一般地，javascript使用构造函数和原型对象来进行面向对象编程，它们的表现与其他面向对象编程语言中的“类”相似而又不同。</p>
<p>在 <a href="/2017/08/08/js-proto/">上一篇文章</a> 已经做过对 构造函数 和 原型对象 的简单介绍。在这篇文章主要介绍使用实战，你可不要小看“实战”，坑点还是挺多的。</p>
<a id="more"></a>
<h2 id="原型对象-属性的查找"><a class="header-anchor" href="#原型对象-属性的查找"></a>原型对象 属性的查找</h2>
<p>对象属性查找，经常会查找到原型对象上：</p>
<p>当读取一个对象的属性时，javascript引擎首先在该对象的自有属性中查找属性名字。如果找到则返回。如果自有属性不包含该名字，则javascript会沿着<code>__proto__</code>从原型对象上找。如果找到则返回。如果一直往上都找不到，则返回undefined</p>
<pre><code class="language-JavaScript">var o = {};
console.log(o.toString());//'[object Object]'

o.toString = function(){
    return 'o';
}
console.log(o.toString());//'o'

delete o.toString;
console.log(o.toString());//'[objet Object]'
</code></pre>
<h3 id="in"><a class="header-anchor" href="#in"></a>in</h3>
<p>in操作符可以判断属性在不在该对象上，但无法区别自有还是继承属性：</p>
<pre><code class="language-JavaScript">function Test(){};
var obj = new Test;
Test.prototype.a = 1;
obj.b = 2;
console.log('a' in obj);//true
console.log('b' in obj);//true
console.log('b' in Test.prototype);//false
</code></pre>
<h3 id="hasownproperty"><a class="header-anchor" href="#hasownproperty"></a>hasOwnProperty()</h3>
<p>通过hasOwnProperty()方法可以确定该属性是自有属性还是继承属性：</p>
<pre><code class="language-JavaScript">var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log(obj.hasOwnProperty('a'));//false
console.log(obj.hasOwnProperty('b'));//true
</code></pre>
<p>于是可以将hasOwnProperty方法和in运算符结合起来使用，用来鉴别原型属性</p>
<pre><code class="language-JavaScript">function hasPrototypeProperty(object,name){
    return name in object &amp;&amp; !object.hasOwnProperty(name);
}
</code></pre>
<h2 id="原型对象-属性的添加"><a class="header-anchor" href="#原型对象-属性的添加"></a>原型对象 属性的添加</h2>
<h3 id="点运算添加属性"><a class="header-anchor" href="#点运算添加属性"></a>点运算添加属性</h3>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
Person.prototype.sayName = function(){
    console.log(this.name);
}
var person1 = new Person('bai');
var person2 = new Person('hu');

person1.sayName();//'bai'
</code></pre>
<h3 id="用对象字面形式添加属性-警惕constructor属性的丢失"><a class="header-anchor" href="#用对象字面形式添加属性-警惕constructor属性的丢失"></a>用对象字面形式添加属性 #警惕constructor属性的丢失</h3>
<p>虽然可以在原型对象上一一添加属性，但是直接用一个对象字面形式替换原型对象更简洁：</p>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
//对象字面形式：
Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString : function(){
        return '[person ' + this.name + ']'
    }
};

var person1 = new Person('bai');

console.log(person1 instanceof Person);//true
console.log(person1.constructor === Person);//false，解释见下一个demo：
console.log(person1.constructor === Object);//true
</code></pre>
<p>一般而言，当一个构造函数Person（即普通函数）被创建时，它的原型对象（Person.prototype）的constructor属性将自动创建，并指向回该函数。而当使用对象字面形式改写原型对象Person.prototype时，需要在改写原型对象时手动重置其constructor属性：</p>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
Person.prototype = {
    constructor: Person, // 只加了这一行代码
    sayName: function(){
        console.log(this.name);
    },
    toString : function(){
        return '[person ' + this.name + ']'
    }
};

var person1 = new Person('bai');

console.log(person1 instanceof Person);//true
console.log(person1.constructor === Person);//true
console.log(person1.constructor === Object);//false
</code></pre>
<h4 id="defineproperty-设置constructor不可遍历"><a class="header-anchor" href="#defineproperty-设置constructor不可遍历"></a>defineProperty，设置constructor不可遍历</h4>
<p>由于默认情况下，原生的constructor属性是不可枚举的，更妥善的解决方法是使用Object.defineProperty()方法，改变其属性描述符中的枚举性enumerable：</p>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString : function(){
        return '[person ' + this.name + ']'
    }
};
Object.defineProperty(Person.prototype,'constructor',{
    enumerable: false,
    value: Person
});
var person1 = new Person('bai');
console.log(person1 instanceof Person);//true
console.log(person1.constructor === Person);//true
console.log(person1.constructor === Object);//false
</code></pre>
<h2 id="构造函数-原型对象和实例对象之间的-关系-和-其指向判断"><a class="header-anchor" href="#构造函数-原型对象和实例对象之间的-关系-和-其指向判断"></a>构造函数、原型对象和实例对象之间的 关系 和 其指向判断</h2>
<blockquote>
<p>如果没有了解基础知识，可参考我的上一篇文章： <a href="/2017/08/08/js-proto/">理解prototype、proto和constructor等关系</a></p>
</blockquote>
<p>构造函数、原型对象和实例对象之间的关系是<strong>实例对象和构造函数之间没有直接联系。</strong></p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
</code></pre>
<p>以上代码的原型对象是Foo.prototype，实例对象是f1，构造函数是Foo</p>
<p>原型对象和实例对象的关系：</p>
<pre><code class="language-JavaScript">console.log(Foo.prototype === f1.__proto__);//true
</code></pre>
<p>原型对象和构造函数的关系 ：</p>
<pre><code class="language-JavaScript">console.log(Foo.prototype.constructor === Foo);//true
</code></pre>
<p>而实例对象和构造函数则没有直接关系，间接关系是实例对象可以继承原型对象的constructor属性：</p>
<pre><code class="language-JavaScript">console.log(f1.constructor === Foo);//true
</code></pre>
<hr>
<p>如果非要扯实例对象和构造函数的关系，那只能是下面这句代码：</p>
<pre><code class="language-JavaScript">// new操作的过程中，会调用构造函数来塑造返回的实例对象
var f1 = new Foo();
</code></pre>
<p><strong>当这句代码执行以后，</strong> 如果重置原型对象，则会打破它们三者间的关系：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype === f1.__proto__);//true
console.log(Foo.prototype.constructor === Foo);//true

Foo.prototype = {}; // 此时重置原型对象
console.log(Foo.prototype === f1.__proto__);//false
console.log(Foo.prototype.constructor === Foo);//false
</code></pre>
<p>所以，对于 <strong>改写<code>Foo.prototype</code></strong> 这种操作，代码顺序很重要。它所遵循的规律还是脱离不了操作js对象的基本规律。</p>
<p>一是谨慎重置原型对象，二是要警惕constructor属性的丢失。（恰巧constructor是原型对象的唯一自有属性，所以2个问题是可以同时预防的）</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解prototype、__proto__和constructor等关系]]></title>
      <url>https://blog.az22c.top/2017/08/08/js-proto/</url>
      <content type="html"><![CDATA[<p>理解对象和函数的prototype、__proto__和constructor等关系：</p>
<a id="more"></a>
<p>结论在本文的最后。</p>
<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<p>先给出 构造函数 实例对象 原型对象 三者的关系：</p>
<pre><code class="language-JavaScript">//  概述demo：
function Foo() {};
var f1 = new Foo;
</code></pre>
<p><img src="https://cloud.az22c.top/js-prototype-1.png-az22cgithub" alt="js-prototype-1"></p>
<p>如图，</p>
<p><strong>[1]构造函数有一个prototype属性，指向实例对象的原型对象。</strong></p>
<p><strong>[2]原型对象有一个constructor属性，指向该原型对象对应的构造函数。</strong></p>
<p><strong>[3]由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数。</strong></p>
<p><strong>[4]实例对象有一个__proto__属性，指向该实例对象对应的原型对象。</strong></p>
<blockquote>
<p>由于constructor属性是可以继承而来。如果是继承的，我们在图中用虚线来表示。后面所有图同理。</p>
</blockquote>
<h3 id="构造函数"><a class="header-anchor" href="#构造函数"></a>构造函数</h3>
<p>用来初始化新创建的对象的函数是构造函数。在上面例子中，Foo()函数是构造函数。</p>
<h3 id="实例对象"><a class="header-anchor" href="#实例对象"></a>实例对象</h3>
<p>可以用一个构造函数，构造多个实例对象。在上面例子中，f1是一个Foo的实例对象。再如：</p>
<pre><code class="language-JavaScript">// 补充demo：
function Foo(){};
var f1 = new Foo;
var f2 = new Foo;
console.log(f1 === f2);//false
</code></pre>
<h3 id="原型对象及prototype"><a class="header-anchor" href="#原型对象及prototype"></a>原型对象及prototype</h3>
<p><strong>[1]构造函数有一个prototype属性，指向实例对象的原型对象。</strong> 构造函数Foo()的原型对象是Foo.prototype。</p>
<p>通过同一个构造函数实例化的多个对象具有相同的原型对象。经常使用原型对象来实现继承：</p>
<pre><code class="language-JavaScript">function Foo(){};
Foo.prototype.a = 1;
var f1 = new Foo;
var f2 = new Foo;

console.log(Foo.prototype.a);//1
console.log(f1.a);//1
console.log(f2.a);//1
</code></pre>
<h3 id="constructor"><a class="header-anchor" href="#constructor"></a>constructor</h3>
<p><strong>[2]原型对象有一个constructor属性，指向该原型对象对应的构造函数。</strong></p>
<pre><code class="language-JavaScript">function Foo(){};
console.log(Foo.prototype.constructor === Foo);//true
</code></pre>
<p><strong>[3]由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数。</strong></p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(f1.constructor === Foo);//true
</code></pre>
<h3 id="proto"><a class="header-anchor" href="#proto"></a><strong>proto</strong></h3>
<p><strong>[4]实例对象有一个__proto__属性，指向该实例对象对应的原型对象。</strong> 实例对象f1通过<code>__proto__属性</code>也指向原型对象Foo.prototype。</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true
</code></pre>
<h2 id="视foo-prototype为实例对象"><a class="header-anchor" href="#视foo-prototype为实例对象"></a>视Foo.prototype为实例对象</h2>
<p>Foo.prototype是f1的原型对象，同时它也可以是实例对象。实际上，任何对象都可以看做是通过Object()构造函数的new操作实例化的对象。</p>
<p><strong>所以，Foo.prototype作为实例对象时，它的构造函数是Object()，原型对象是Object.prototype。</strong></p>
<p><img src="https://cloud.az22c.top/js-prototype-2.png-az22cgithub" alt="js-prototype-2"></p>
<p>相应地，构造函数Object()的prototype属性指向原型对象Object.prototype；</p>
<p>Object.prototype的constructor属性指向构造函数Object()</p>
<p>实例对象Foo.prototype本身具有constructor属性，所以它会覆盖继承自原型对象Object.prototype的constructor属性：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype.constructor === Foo);//true
console.log(Object.prototype.constructor === Object);//true
console.log(Foo.prototype.hasOwnProperty('constructor'));//true
</code></pre>
<p>实例对象Foo.prototype的__proto__属性同样指向原型对象Object.prototype：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype.__proto__ === Object.prototype);//true
</code></pre>
<h2 id="视object-prototype为实例对象"><a class="header-anchor" href="#视object-prototype为实例对象"></a>视Object.prototype为实例对象</h2>
<p>如果Object.prototype作为实例对象的话，其原型对象是什么？结果是null。</p>
<p><img src="https://cloud.az22c.top/js-prototype-3.png-az22cgithub" alt="js-prototype-3"></p>
<pre><code class="language-JavaScript">console.log(Object.prototype.__proto__ === null);//true
</code></pre>
<h2 id="函数foo和函数object也可以被视为实例对象"><a class="header-anchor" href="#函数foo和函数object也可以被视为实例对象"></a>函数Foo和函数Object也可以被视为实例对象</h2>
<p>任何函数都可以看做是通过Function()构造函数的new操作实例化的结果。</p>
<p>如果把函数Foo当成实例对象的话，其构造函数是Function()，其原型对象是Function.prototype；类似地，函数Object的构造函数也是Function()，其原型对象是Function.prototype</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.__proto__ === Function.prototype);//true
console.log(Object.__proto__ === Function.prototype);//true
</code></pre>
<p>原型对象Function.prototype的constructor属性指向构造函数Function()；实例对象Object和Foo本身没有constructor属性，需要继承原型对象Function.prototype的constructor属性：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Function.prototype.constructor === Function);//true
console.log(Foo.constructor === Function);//true
console.log(Foo.hasOwnProperty('constructor'));//false
console.log(Object.constructor === Function);//true
console.log(Object.hasOwnProperty('constructor'));//false
</code></pre>
<blockquote>
<p>“构造函数Foo的constructor”和“构造函数Object的constructor”都是继承而来的，所以都在图中用虚线来表示。</p>
</blockquote>
<p><img src="https://cloud.az22c.top/js-prototype-4.png-az22cgithub" alt="js-prototype-4"></p>
<h2 id="视function为实例对象"><a class="header-anchor" href="#视function为实例对象"></a>视Function为实例对象</h2>
<p><strong>所有的函数都可以看成是构造函数Function()的new操作而产生的实例对象。</strong> 那么，Function可以看成是调用其自身的new操作的实例化的结果</p>
<p>所以，如果Function作为实例对象，其构造函数是Function，其原型对象是Function.prototype</p>
<pre><code class="language-js">console.log(Function.__proto__ === Function.prototype);//true
console.log(Function.prototype.constructor === Function);//true
console.log(Function.prototype === Function.prototype);//true
</code></pre>
<p>还有一个隐藏关系是<code>Function.constructor === Function</code>结果为true。</p>
<p>证明<code>Function</code>的<code>constructor</code>是从<code>Function.prototype</code>上“继承”过来：</p>
<pre><code class="language-js">Object.getOwnPropertyNames(Function) // 没有打印出constructor
Object.getOwnPropertyNames(Function.prototype) // 有打印出constructor
</code></pre>
<h2 id="视function-prototype为实例对象"><a class="header-anchor" href="#视function-prototype为实例对象"></a>视Function.prototype为实例对象</h2>
<p>和前面一样，<strong>所有的对象都可以看成是Object()构造函数的new操作的实例化结果。</strong></p>
<p>所以，Function.prototype的原型对象是Object.prototype：</p>
<pre><code class="language-JavaScript">console.log(Function.prototype.__proto__ === Object.prototype);//true
</code></pre>
<p>刚才介绍过，Object.prototype的原型对象是null：</p>
<pre><code class="language-JavaScript">console.log(Object.prototype.__proto__ === null);//true
</code></pre>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>对于代码：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
</code></pre>
<p>其涉及到的构造函数 实例对象 原型对象 以及它们之间的关系如图所示：</p>
<p><img src="https://cloud.az22c.top/js-prototype-4.png-az22cgithub" alt="js-prototype-4"></p>
<p>【1】函数(Function也是函数)是new Function的结果，所以函数可以视作实例对象，其构造函数是Function()，原型对象是Function.prototype</p>
<p>【2】一般的对象(除了null和由指定的构造函数所产生的对象) 是new Object的结果，所以一般的对象可以视作实例对象，其构造函数是Object()，原型对象是Object.prototype</p>
<p>【3】Object.prototype的原型对象是null</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[this绑定的优先级]]></title>
      <url>https://blog.az22c.top/2017/08/07/js-this2/</url>
      <content type="html"><![CDATA[<p>上一篇文章详细介绍过 this的4种绑定规则，那如果在函数的调用位置上同时存在两种以上的绑定规则应该怎么办呢？本文将介绍this绑定的优先级：</p>
<a id="more"></a>
<h2 id="显式绑定-pk-隐式绑定"><a class="header-anchor" href="#显式绑定-pk-隐式绑定"></a>显式绑定 pk 隐式绑定</h2>
<p>显式绑定胜出</p>
<pre><code class="language-JavaScript">function foo() {
    console.log( this.a );
}
var obj1 = {
    a: 2,
    foo: foo
};
var obj2 = {
    a: 3,
    foo: foo
};
obj1.foo(); // 2
obj2.foo(); // 3
//在该语句中，显式绑定call(obj2)和隐式绑定obj1.foo同时出现，最终结果为3，说明被绑定到了obj2中
obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
</code></pre>
<h2 id="new绑定-pk-隐式绑定"><a class="header-anchor" href="#new绑定-pk-隐式绑定"></a>new绑定 pk 隐式绑定</h2>
<p>new绑定胜出</p>
<pre><code class="language-JavaScript">function foo(something) {
    this.a = something;
}
var obj1 = {foo: foo};
var obj2 = {};
// obj1隐式绑定：
obj1.foo( 2 );
console.log( obj1.a ); // 2
// obj2显式绑定：
obj1.foo.call(obj2,3);
console.log( obj2.a ); // 3
//在下列代码中，隐式绑定obj1.foo和new绑定同时出现。最终obj1.a结果是2，而bar.a结果是4，说明this被绑定在bar上
var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
</code></pre>
<h2 id="new绑定-pk-显式绑定"><a class="header-anchor" href="#new绑定-pk-显式绑定"></a>new绑定 pk 显式绑定</h2>
<p>new绑定胜出</p>
<pre><code class="language-JavaScript">function foo(something) {
    this.a = something;
}
var obj1 = {};
//先将obj1绑定到foo函数中，此时this值为obj1
var bar = foo.bind( obj1 );
bar( 2 );
console.log(obj1.a); // 2
//通过new绑定，此时this值为baz
var baz = new bar( 3 );
console.log( obj1.a ); // 2
//说明使用new绑定时，在bar函数内，无论this指向obj1有没有生效，最终this都指向新创建的对象baz
console.log( baz.a ); // 3
</code></pre>
<h2 id="结论："><a class="header-anchor" href="#结论："></a>结论：</h2>
<p>优先级排列顺序为：</p>
<p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> this </tag>
            
            <tag> new </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结合this的4种绑定规则 深入理解this指向的判定]]></title>
      <url>https://blog.az22c.top/2017/08/07/js-this/</url>
      <content type="html"><![CDATA[<p>此文适合用于进阶对this的理解，不适合用来入门。</p>
<a id="more"></a>
<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<p>根据《你不知道的JavaScript》，this的绑定规则有4种：</p>
<p>1.默认绑定</p>
<p>2.隐式绑定</p>
<p>3.显式绑定</p>
<p>4.new绑定</p>
<p>这种划分是按照JavaScript的运行机理划分的，这有助于我们判定复杂的this的指向。</p>
<blockquote>
<p>值得补充的是：</p>
<p>我们可以粗浅地理解为：进入函数的“执行上下文”会发生三件事情：1 确定this指向 2 创建活动对象并完成“变量提升” 3 确定作用域链 。</p>
<p>可见，如果想要完全理解this的指向，可以完全不用理会“作用域”的概念，它们是不同的体系。</p>
<p>“变量提升”也是不同于this的问题体系，联系在一起讲好像不会增加理解的难度，所以后文会涉及到“变量提升”。</p>
</blockquote>
<p>书中提出了“执行流”这种虚拟的概念，来比较死板地判断this的指向，判断效果还是挺靠谱的。</p>
<h2 id="默认绑定"><a class="header-anchor" href="#默认绑定"></a>默认绑定</h2>
<blockquote>
<p>非严格模式下，全局执行上下文this默认指向window；而严格模式下，全局执行上下文this默认为undefined。</p>
<p>本小节是以“非严格模式”作为前提讲解的了；严格模式同理。</p>
</blockquote>
<p>全局执行上下文中，this默认绑定全局对象；而在浏览器下，全局对象就是 window。</p>
<p>即简而言之：</p>
<p>结论1：全局执行上下文中，this默认绑定到window。</p>
<pre><code class="language-JavaScript">// demo 1-1：
console.log(this === window); // true
console.log(this.document === document); // true

this.a = 91;
console.log(window.a); // 91
</code></pre>
<p>结论2：函数独立调用时，this默认绑定到window。</p>
<pre><code class="language-JavaScript">// demo 1-2：
function foo(){
    console.log(this === window);
}
foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：foo()返回true
</code></pre>
<p>独立调用，<code>foo()</code>等价于<code>window.foo()</code></p>
<p>结论3：IIFE的本质就是 函数声明+立即的函数独立调用，所以我们把IIFE视为独立调用的情况即可：</p>
<pre><code class="language-JavaScript">// demo 1-3：
(function () {
	 console.log(this === window); // true
})();
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">// demo 1-4：
function aname() {
	 console.log(this === window); // true
}
aname(); // 声明之后要立即执行
</code></pre>
<h2 id="隐式绑定"><a class="header-anchor" href="#隐式绑定"></a>隐式绑定</h2>
<p>一般地，如果是对象的方法调用，对于这次函数的执行，this隐式绑定到该对象上：</p>
<pre><code class="language-JavaScript">// demo 2-1：
var a = 0;
var obj = {
    a : 2,
    foo:function(){
        console.log(this.a);
    }
}
obj.foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：obj.foo()返回2
</code></pre>
<p>变量提升等价于：</p>
<pre><code class="language-JavaScript">// demo 2-2：
function foo () {
    console.log(this.a);
}
var a = 0;
var obj;
obj = {
    a : 2,
    foo: foo
}
obj.foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：obj.foo()返回2
</code></pre>
<p>再对隐式绑定知识做一个巩固：</p>
<pre><code class="language-JavaScript">// demo 2-3：
function foo(){
    console.log(this.a);
};
var obj1 = {
    a:1,
    foo:foo,
    obj2:{
        a:2,
        foo:foo
    }
}

obj1.foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内；结果为1(访问到了obj1.a)
obj1.obj2.foo();// foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内；结果为2(访问到了obj1.obj2.a)
</code></pre>
<h2 id="判定this的指向"><a class="header-anchor" href="#判定this的指向"></a>// 判定this的指向</h2>
<p>我们已经对 this的4种绑定规则 的前2种进行了介绍，但是如果demo变得再复杂一点点，this的指向就比较难以判定了。</p>
<p>请在已有上文知识的基础上，思考下面的函数返回结果是如何得出的：</p>
<pre><code class="language-JavaScript">// exer 1-1 ：代码可以对比demo 2-1 的代码
var a = 0;
var obj = {
    a : 2,
    foo:function(){
            function test() {
                console.log(this.a);// 0
            }
            test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
    }
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，test才是;执行流先执行foo，再执行test
// 结果：obj.foo()返回0
</code></pre>
<p>变量提升等价于：</p>
<pre><code class="language-JavaScript">// exer 1-2 ：
var a = 0;
var obj;
function foo () {
            function test() {
                console.log(this.a);// 0
            }
            test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
}
obj = {
    a : 2,
    foo: foo
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，test才是;执行流先执行foo，再执行test
// 结果：obj.foo()返回0
</code></pre>
<p>虽然test()函数被嵌套在obj.foo()函数声明中， <strong>但test()函数是独立调用的，</strong> 因而它不是<code>对象的方法调用</code>。</p>
<p>既然是独立调用，this默认绑定到window。</p>
<hr>
<p>由demo 1-3 我们知道IIFE的本质有利于攻破含IIFE的问题，在上面的exer 1-2 中，我们可以再把test等价于一个IIFE函数：</p>
<pre><code class="language-JavaScript">// exer 1-3 ：
var a = 0;
var obj;
function foo () {
            (function () {
                console.log(this.a);// 0
            })(); // 该IIFE是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
}
obj = {
    a : 2,
    foo: foo
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，IIFE才是;执行流先执行foo，再执行IIFE
// 结果：obj.foo()返回0
</code></pre>
<h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3>
<p>我们似乎发现了 判定this的指向 的方法：</p>
<p>我们以exer 1-2 为例，进行说明：</p>
<pre><code class="language-JavaScript">// exer 1-2 ：
var a = 0;
var obj;
function foo () {
           function test() {
               console.log(this.a);// 0
           }
           test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
}
obj = {
   a : 2,
   foo: foo
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，test才是;执行流先执行foo，再执行test
// 结果：obj.foo()返回0
</code></pre>
<h4 id="一-先去找出this关键字所在的函数声明或函数表达式"><a class="header-anchor" href="#一-先去找出this关键字所在的函数声明或函数表达式"></a>一、先去找出this关键字所在的函数声明或函数表达式</h4>
<p>即，this关键字在哪个函数的声明内？！或者在哪个函数的表达式内？！ this往上一级的那个函数便是了</p>
<blockquote>
<p>我们发现要找的这个函数是test，this关键字在test的函数声明内。（而不是foo，foo只是test的上级函数）</p>
</blockquote>
<h4 id="二-找出该函数被调用时的表达式"><a class="header-anchor" href="#二-找出该函数被调用时的表达式"></a>二、找出该函数被调用时的表达式</h4>
<blockquote>
<p>例子代码中，第8行的 test() 是我们要找的调用表达式（此时test函数才被调用）</p>
</blockquote>
<h4 id="三-观察该调用表达式的形态-确定this的指向"><a class="header-anchor" href="#三-观察该调用表达式的形态-确定this的指向"></a>三、观察该调用表达式的形态，确定this的指向</h4>
<blockquote>
<p>观察 test() 这个调用表达式的形态</p>
</blockquote>
<p>如果形态像“独立调用”<code>fn()</code>，那么this指向window：</p>
<p>如，demo 1-2 和 exer 1-2 。</p>
<p>如果表达式形态可以说是IIFE，那么也可以视为函数的独立调用，this指向window：</p>
<p>如，demo 1-3 和 exer 1-3 。</p>
<p>如果形态像<code>obj.fn()</code>，那么this指向obj：</p>
<p>如，exer 2-1中的<code>obj.foo()</code>。然后另外，容易误导人的是像exer 1-2 中的<code>obj.foo()</code>这句，我们说了在exer 1-2中，foo不是我们想要的，所以应该不必理会这句，而应该去找test函数被调用的那句表达式。</p>
<p>如果形态像<code>obja.objb.fn()</code>，那么那么this指向<code>obja.objb</code>：</p>
<p>如，demo2-3 中的<code>obj1.obj2.foo()</code>，this指向<code>obj1.obj2</code></p>
<hr>
<p><strong>以上的 判定this的指向 的方法是在任何情况下通用的，</strong> 我们拿闭包来练练手，顺便讲一下闭包：</p>
<h3 id="闭包"><a class="header-anchor" href="#闭包"></a>闭包</h3>
<p>其实闭包在本文不必按特殊情况考虑，鉴于某些新手可能不熟悉闭包，特拿出来一种闭包做例子说明：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    function test(){
        console.log(this.a);
    }
    return test;
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo()(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：obj.foo()()返回0
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">function test () {
    console.log(this.a);
}
var a = 0;
test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
</code></pre>
<p>即函数的“独立调用”，那么this指向window</p>
<h4 id="补充闭包常见demo"><a class="header-anchor" href="#补充闭包常见demo"></a>补充闭包常见demo</h4>
<p>因此，这也是一个老生常谈，（类似上面的例子），由于闭包的this<strong>常常</strong>默认绑定到window对象。如果在这种情况下，需要访问外层嵌套函数的this，常见的做法是使用<code>var that = this</code>，然后在闭包中使用that替代this，使用作用域查找的方式来找到外层嵌套函数的this值 ：</p>
<pre><code class="language-javascript">var a = 0;
function foo(){
    var that = this;
    this.sth = 'hello'
    function test(){
        console.log(that.a, that.sth);
    }
    return test;
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo()();//2 hello
</code></pre>
<h2 id="隐式丢失"><a class="header-anchor" href="#隐式丢失"></a>隐式丢失</h2>
<p>隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window的现象。这是一种程序员常见的逻辑上出错的情况。</p>
<p>同样地，	<strong>以上的 判定this的指向 的方法在隐式丢失中依然适用</strong>。</p>
<p>首先，按照常见的类型，隐式丢失可以又分为：</p>
<p>1.函数别名的情况</p>
<p>2.参数传递的情况</p>
<p>3.内置函数的情况</p>
<p>4.间接引用的情况</p>
<p>5.其他情况</p>
<h3 id="函数别名的情况"><a class="header-anchor" href="#函数别名的情况"></a>函数别名的情况</h3>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系
var bar = obj.foo;
bar(); // bar和foo都是this关键字所在的函数，执行流到此，之后执行流会进入bar的函数表达式内；考虑到bar被调用时这句表达式的形态，结果为0依然可以被理解
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 0;
var bar = function foo(){
    console.log(this.a);
}
bar();//0
</code></pre>
<h3 id="参数传递的情况"><a class="header-anchor" href="#参数传递的情况"></a>参数传递的情况</h3>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
};
function bar(fn){
    fn(); // fn和foo都是this关键字所在的函数，执行流到此，之后执行流会进入fn的函数表达式内；考虑到fn被调用时这句表达式的形态，结果为0依然可以被理解
}
var obj = {
    a : 2,
    foo:foo
}
//把obj.foo当作参数传递给bar函数，之后有隐式的函数赋值fn=obj.foo。与上例类似，只是把foo函数赋给了fn，而fn与obj对象则毫无关系
bar(obj.foo);//0
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a); // 0
};
function bar(fn){
    fn(); // fn和foo都是this关键字所在的函数，执行流到此，之后执行流会进入fn的函数表达式内；考虑到fn被调用时这句表达式的形态，结果为0依然可以被理解
}
bar(foo);// 0
</code></pre>
<h3 id="内置函数的情况"><a class="header-anchor" href="#内置函数的情况"></a>内置函数的情况</h3>
<p>内置函数的情况的本质是参数传递的情况：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo,100); // obj.foo作为setTimeout的内置函数
// 结果： setTimeout(obj.foo,100)返回0
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a); // 0
};
function setTimeout(fn, 100){
	// 考虑setTimeout的原生代码的本质，等待100秒后执行：
    fn(); // fn和foo都是this关键字所在的函数，执行流到此，之后执行流会进入fn的函数表达式内；考虑到fn被调用时这句表达式的形态，结果为0依然可以被理解
}
setTimeout(foo, 100); // 0
</code></pre>
<h3 id="间接引用的情况"><a class="header-anchor" href="#间接引用的情况"></a>间接引用的情况</h3>
<p>间接引用的情况的本质是函数别名的情况：</p>
<pre><code class="language-JavaScript">var a = 2;
function foo() {
    console.log( this.a );
}
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
//将o.foo函数赋值给p.foo函数，然后立即执行，此时p.foo发生了隐式丢失
(p.foo = o.foo)(); // 2
// IIFE和p.foo和o.foo都是this关键字所在的函数，执行流到此，之后执行流会进入IIFE的函数表达式内，结果为2依然可以被理解
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 2;
function foo() {
    console.log( this.a );
}
var p = { a: 4 };
p.foo = foo;
var aname = p.foo; //第一对括号的作用
aname(); // IIFE和p.foo和o.foo都是this关键字所在的函数，执行流到此，之后执行流会进入IIFE的函数表达式内，结果为2依然可以被理解
</code></pre>
<p>而如果我们想要一个没有隐式丢失的类似demo：</p>
<pre><code class="language-JavaScript">var a = 2;
function foo() {
    console.log( this.a );
}
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
//将o.foo函数赋值给p.foo函数，之后p.foo函数再执行
p.foo = o.foo;
p.foo(); // 4
// p.foo和o.foo都是this关键字所在的函数，执行流到此，之后执行流会进入p.foo的函数表达式内，结果为4是因为隐式绑定
// 这没有隐式丢失，但结果依然可以按照我们的理解方法来理解
</code></pre>
<h3 id="其他情况"><a class="header-anchor" href="#其他情况"></a>其他情况</h3>
<p>在javascript引擎内部，obj和obj.foo储存在两个内存地址，在这里我们简称为M1和M2。只有obj.foo()这样形式的表达式调用时，是从M1调用M2，因此this指向obj。但是，下面三种情况，都是直接取出M2进行运算，然后就在全局执行上下文执行运算结果（还是M2），因此this指向全局对象</p>
<pre><code class="language-JavaScript">var a = 0;
var obj = {
    a : 2,
    foo:foo
};
function foo() {
    console.log( this.a );
};

(obj.foo = obj.foo)();//0

(false || obj.foo)();//0

(1, obj.foo)();//0
</code></pre>
<p>也可以像上面 间接引用的情况 理解为： IIFE和obj.foo都是this关键字所在的函数，执行流到此，之后执行流会进入IIFE的函数表达式内；考虑到IIFE的表达式，结果为0依然可以被理解</p>
<h2 id="显示绑定"><a class="header-anchor" href="#显示绑定"></a>显示绑定</h2>
<ul>
<li>显示绑定
<ul>
<li>通过<code>call()、apply()、bind()</code></li>
<li>es6的<code>map()、forEach()、filter()、some()、every()</code>方法：专门提供1参数来设置this。( 其原理还是基于es5这几个api )</li>
</ul>
</li>
</ul>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
}
var obj1 = {
    a:1
};
var obj2 = {
    a:2
};
foo.call(obj1);//1
foo.call(obj2);//2
</code></pre>
<p>用显式绑定就不用考虑会有隐式丢失的问题了：因为显式绑定优先于隐式绑定，如果程序员用显式绑定，在心里就已经知道隐式绑定无效了：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
}
var obj100 = {
  a : 100,
  foo: foo
}
var obj1 = {
    a:1
};
var obj2 = {
    a:2
};
obj100.foo.call(obj1);//1
obj100.foo.call(obj2);//2
obj100.foo() // 100，普通的显式绑定无法解决隐式丢失问题
</code></pre>
<h3 id="es6显示绑定api"><a class="header-anchor" href="#es6显示绑定api"></a>es6显示绑定API</h3>
<p>es6中新增了许多内置函数，具有显式绑定的功能，如数组的5个<a href="http://www.cnblogs.com/xiaohuochai/p/5682621.html#anchor10" target="_blank" rel="noopener">迭代方法</a>：<code>map()、forEach()、filter()、some()、every()</code></p>
<pre><code class="language-JavaScript">var id = 'window';
function foo(el){
    console.log(el,this.id);
}
var obj = {
    id: 'fn'
};
[1,2,3].forEach(foo);//1 &quot;window&quot; 2 &quot;window&quot; 3 &quot;window&quot;
[1,2,3].forEach(foo,obj);//1 &quot;fn&quot; 2 &quot;fn&quot; 3 &quot;fn&quot;
</code></pre>
<h2 id="new绑定"><a class="header-anchor" href="#new绑定"></a>new绑定</h2>
<p>new绑定通常指的是构造器中的this。</p>
<p>1.构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值：</p>
<pre><code class="language-JavaScript">function fn() {
  this.a = 2;
}
var test = new fn();
console.log(test); // {a:2}
</code></pre>
<p>2.如果构造函数显式地没有返回值 或者 显式地返回为基本类型时，那么这时将忽略返回值，将隐式默认值返回：</p>
<pre><code class="language-JavaScript">function fn() {
  this.a = 2;
  return;
}
var test = new fn();
console.log(test); // {a:2}
</code></pre>
<p>3.如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象：</p>
<pre><code class="language-JavaScript">function C2() {
  this.a = 26;
  return {
    a: 24
  };
}

o = new C2();
console.log(o.a); // 24
</code></pre>
<p><strong>[注意]尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，例如在表达式new o.m()中，this并不是指向o</strong>：</p>
<pre><code class="language-JavaScript">var o = {
    m: function() {
        this.a = 'test a';    
        return this;
    }
}
var obj = new o.m();
console.log(obj.constructor === o); // false
console.log(obj.constructor === o.m); // true
console.log(obj.a) // 'test a'
</code></pre>
<h2 id="严格模式的严谨修正"><a class="header-anchor" href="#严格模式的严谨修正"></a>严格模式的严谨修正</h2>
<p>在非严格模式下，独立调用的函数的this指向window；而在严格模式下，独立调用的函数的this指向undefined：</p>
<pre><code class="language-JavaScript">function fn(){
    'use strict';
    console.log(this);//undefined
}
fn();

function fn(){
    console.log(this);//window
}
fn();
</code></pre>
<p>在非严格模式下，使用函数的call()或apply()方法时，第一个参数若使用null或undefined，值会被转换为全局对象；而在严格模式下，函数的this值始终是表达式中所指定的值：</p>
<pre><code class="language-JavaScript">var color = 'red';
function displayColor(){
    console.log(this.color);
}
displayColor.call(null);//red

var color = 'red';
function displayColor(){
    'use strict';
    console.log(this.color);
}
displayColor.call(null);//TypeError: Cannot read property 'color' of null
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> IIFE </tag>
            
            <tag> this </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器事件冒泡或者捕获相关]]></title>
      <url>https://blog.az22c.top/2017/07/02/js-event4/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="事件流-事件捕获或者冒泡相关"><a class="header-anchor" href="#事件流-事件捕获或者冒泡相关"></a>事件流（事件捕获或者冒泡相关）</h2>
<p><a href="https://www.cnblogs.com/st-leslie/p/5907556.html" target="_blank" rel="noopener">建议看：博客园谢灿勇 js事件流</a></p>
<p>每次用addEventListener这个api，你需要<strong>选择绑定事件在冒泡阶段还是捕获阶段</strong>。（通常设置为false即为冒泡） 而这个api就是基于事件流的原理。</p>
<ul>
<li>事件流的过程：<strong>事件流</strong>被分为三个阶段捕获过程、<strong>目标过程</strong>、冒泡过程。event对象的属性中，表示事件流中“某元素的某个被触发的事件”是绑定在哪个阶段的属性是<code>eventPhase</code>。</li>
<li>一个完整的JS事件流是从window开始，最后回到window的一个过程（有些浏览器是到body）
<ul>
<li>也就是从window开始，依次触发<strong>绑定在</strong>捕获过程的(有绑定的)事件响应，然后是目标过程的（不分冒泡还是捕获按注册顺序），再然后是依次触发<strong>绑定在</strong>冒泡过程的直到回到window</li>
<li><strong>而目标阶段非常特别，目标阶段是按注册顺序决定的（也就是假如先绑定冒泡，则冒泡早于捕获得到响应）</strong>  <a href="https://www.cnblogs.com/alvinwei1024/p/4739344.html" target="_blank" rel="noopener">1</a> #面试题</li>
</ul>
</li>
</ul>
<h4 id="并不是所有事件都支持冒泡-局限性"><a class="header-anchor" href="#并不是所有事件都支持冒泡-局限性"></a>并不是所有事件都支持冒泡 #局限性</h4>
<p>1、最适合使用事件冒泡/事件委托技术的事件包括click、keydown、keyup、keypress、mousedown、mouseup</p>
<p>2、<strong>某些事件类型天生就不支持事件冒泡！不支持事件冒泡就更谈不上事件委托了。</strong></p>
<ul>
<li>blur: 在元素失去焦点时触发，该事件不支持冒泡</li>
<li>focus: 在元素获得焦点时触发，该事件不支持冒泡</li>
<li>mouseenter: 当鼠标移入元素时触发，该事件不支持冒泡</li>
<li>mouseleave: 当鼠标移出元素时触发，该事件不支持冒泡</li>
</ul>
<p>3、mousemove、mouseover、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的???<a href="https://juejin.im/post/58fd95bcac502e0063b197db" target="_blank" rel="noopener">https://juejin.im/post/58fd95bcac502e0063b197db</a></p>
<blockquote>
<p>mouseover的定义：当鼠标移入某元素时触发，移入和移出其子元素时也会触发。</p>
</blockquote>
<h2 id="如何应用：冒泡或者捕获事件-在事件绑定的时候"><a class="header-anchor" href="#如何应用：冒泡或者捕获事件-在事件绑定的时候"></a>如何应用：冒泡或者捕获事件  在事件绑定的时候</h2>
<blockquote>
<p>IE8及以下都不支持addEventListener，他们用attachEvent被称为IE事件处理程序；IE9及以后都支持addEventListener和attachEvent。</p>
</blockquote>
<blockquote>
<p>用addEventListener，在实战的时候，往往需要配合判断target和阻止冒泡。注意：<strong>currentTarget属性返回事件正在执行的监听函数所绑定的节点，而target属性返回事件的实际目标节点。</strong></p>
</blockquote>
<p>所以对于现代浏览器，可以同时用addEventListener绑定事件在冒泡和捕获阶段。<strong>（第三个参数通常设置为false即为冒泡）</strong></p>
<p>我们知道，如果要封装兼容IE事件处理程序attachEvent和addEventListener：因为attachEvent没有第三个参数，也就是说attachEvent只支持监听冒泡，所以为了统一，在使用addEventListener的时候第三参数传递 false。</p>
<pre><code class="language-js">function stopPropagation(e) {
  var e = e || window.event;
  if(window.event) {       //这是IE浏览器
      e.cancelBubble = true;//阻止冒泡事件
  }else if(e &amp;&amp; e.stopPropagation) {     //这是其他浏览器
      e.stopPropagation();//阻止冒泡事件
  }
}
</code></pre>
<h3 id="事件处理程序的event对象-ie兼容"><a class="header-anchor" href="#事件处理程序的event对象-ie兼容"></a>事件处理程序的Event对象 IE兼容</h3>
<p>首先作为基础，要稍微了解一下<a href="/2017/07/01/js-event3/">浏览器js的四种事件处理程序</a>。</p>
<p><a href="http://yujiangshui.com/javascript-event/#%E4%BA%8B%E4%BB%B6%E8%BF%9B%E9%98%B6%E8%AF%9D%E9%A2%98" target="_blank" rel="noopener">摘自：于江水</a></p>
<p>IE 中往回调函数中传递的事件对象与标准有一些差异，你需要使用 <code>window.event</code> 来获取事件对象。所以你通常会写出下面代码来获取事件对象：</p>
<pre><code class="language-js">event = event || window.event
</code></pre>
<p>此外还有一些事件属性有差别，比如比较常用的 <code>event.target</code> 属性，IE 中没有，而是使用 <code>event.srcElement</code> 来代替。如果你的回调函数需要处理触发事件的节点，那么需要写：</p>
<pre><code class="language-js">target = event.srcElement || event.target;
</code></pre>
<p>常见的就是这点，更细节的不再多说。在概念学习中，我们没必要为不标准的东西支付学习成本；在实际应用中，类库已经帮我们封装好这些兼容性问题。可喜的是 IE 浏览器现在也开始不断向标准进步。</p>
<p><strong>最后总结一下就是：</strong></p>
<pre><code class="language-js">// 兼容性处理
var event = e || window.event;
// 获取到目标阶段指向的元素
var target = event.target || event.srcElement;
// 获取当前触发的事件处理函数所绑定的元素
var currentTarget = event.currentTarget;
</code></pre>
<h4 id="提取冷知识："><a class="header-anchor" href="#提取冷知识："></a>提取冷知识：</h4>
<ul>
<li>为了统一多种事件处理程序（有些它不支持捕获），一般来说都是利用冒泡比较顺手。
<ul>
<li>举例：DOM Level 0即onclick等等不支持捕获：比如，onclick只支持冒泡。（PS：基本全部浏览器都支持DOM Level 0也就是onclick这些api。）</li>
</ul>
</li>
<li>绑定多个事件的效果是：onclick只能绑定一个事件，即<strong>同一个元素的</strong>后面的绑定会覆盖前面的绑定。addEventListener是先绑定先触发，<strong>老浏览器的attachEvent</strong>则相反。（IE9、10浏览器是按正序执行的，<strong>而IE8-浏览器则是按倒序执行的</strong>）</li>
</ul>
<h2 id="事件代理-你所需要知道的"><a class="header-anchor" href="#事件代理-你所需要知道的"></a>事件代理 你所需要知道的</h2>
<h3 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h3>
<ul>
<li>减少了事件的注册总量，节省内存。</li>
<li>在新增/移除DOM时，节省了的事件绑定/解绑。</li>
</ul>
<p>即，详细来说，事件代理主要有两个优点：</p>
<ol>
<li>减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个祖先节点即可。减少了绑定事件监听函数的总量。</li>
<li>动态变化的 DOM 结构，仍然可以监听。如果没有事件代理，当一个 DOM 动态创建之后，不会带有任何事件监听，因而往往需要你重新绑定事件监听函数；而使用事件代理则没有这种麻烦。</li>
</ol>
<h3 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h3>
<p>好像没有缺点，妥善的管理和合理运用能够规避问题。</p>
<h3 id="实战技巧：就近委托"><a class="header-anchor" href="#实战技巧：就近委托"></a>实战技巧：就近委托</h3>
<ul>
<li>通常需要就近委托：
<ul>
<li>如果层级过多，或者绑定在靠近根层的元素上，冒泡过程中，可能会被某层阻止掉。</li>
<li>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在ul上代理li，而不是在document上代理li。</li>
</ul>
</li>
</ul>
<h3 id="如何利用原生实现事件代理"><a class="header-anchor" href="#如何利用原生实现事件代理"></a>如何利用原生实现事件代理</h3>
<p><a href="https://juejin.im/post/58fd95bcac502e0063b197db" target="_blank" rel="noopener">如果想学代码封装实现 事件代理 可以看这篇</a></p>
<p>如果使用原生的方式实现事件代理，需要注意过滤非目标节点，可以通过 id、class 或者 tagname 等等，例如：</p>
<pre><code class="language-js">element.addEventListener('click', function(event) {
    // 判断是否是 b 节点
    if ( event.target.tagName == 'B' ) {
        // 针对 b 的一些交互操作绑定
    }
}, false);
</code></pre>
<h2 id="vue的事件冒泡和事件代理"><a class="header-anchor" href="#vue的事件冒泡和事件代理"></a>vue的事件冒泡和事件代理</h2>
<ul>
<li>vue在组件间不冒泡，在同一个组件内的事件是可以冒泡的。也就是组件内可以实现事件代理
<ul>
<li>(如果，以后能够成功实现组件间冒泡，那么就可以通过冒泡或事件代理来实现“跨组件通信”了)</li>
</ul>
</li>
<li>在vue里面，如果想阻止冒泡用的是<code>.stop</code>修饰符。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记副本 </tag>
            
            <tag> 回顾 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js四种事件处理程序]]></title>
      <url>https://blog.az22c.top/2017/07/01/js-event3/</url>
      <content type="html"><![CDATA[<p>随着W3C不断推进DOM事件模型和IE浏览器事件模型的历史变化，为了方便理解，程序员们中逐渐形成 四种事件处理程序 的概念划分。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>提示：本文章内容最后修改时间为2017年07月，部分内容可能已经过时</p>
</blockquote>
<p>在 JavaScript 中，通常分为四种事件处理程序：</p>
<ol>
<li>HTML内联事件处理程序</li>
<li>DOM0事件处理程序</li>
<li>DOM2事件处理程序</li>
<li>IE事件处理程序</li>
</ol>
<hr>
<table>
<thead>
<tr>
<th></th>
<th>HTML内联</th>
<th>DOM0级</th>
<th>DOM2级</th>
<th>IE【后于2022年报废】</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码形式</td>
<td><code>onclick=&quot;fun()&quot;</code></td>
<td><code>btn.onclick = fun(){}</code></td>
<td><code>addEventListener()</code></td>
<td><code>attachEvent()</code></td>
</tr>
<tr>
<td>触发阶段</td>
<td>冒泡阶段</td>
<td>冒泡阶段</td>
<td>冒泡/捕获阶段皆可</td>
<td>冒泡阶段</td>
</tr>
</tbody>
</table>
<h2 id="html内联事件处理程序"><a class="header-anchor" href="#html内联事件处理程序"></a>HTML内联事件处理程序</h2>
<p>在HTML的内联属性中添加事件处理。</p>
<pre><code class="language-html">&lt;button onclick=&quot;alert('Hello world!')&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<p>如上，可直接在<code>onclick = &quot;&quot;</code>里添加执行语句；也可如下，调用一个函数：</p>
<pre><code class="language-html">&lt;button onclick=&quot;showMessage()&quot;&gt;按钮&lt;/button&gt;
&lt;script&gt; function showMessage(){ alert(&quot;Hello world!&quot;); } &lt;/script&gt;
</code></pre>
<ul>
<li><strong>优势：</strong> 代码直观、方便。</li>
<li><strong>劣势：</strong> 放任其中前1种写法会导致html和javascript重度耦合，代码不易读。
<ul>
<li>而在现今，比如Vue.js，框架与使用者通过规范化代码能够削弱“代码耦合”这种缺点，越来越多的主流JavaScript框架都是推崇这种内联属性的写法。</li>
</ul>
</li>
</ul>
<h2 id="dom0级事件处理程序"><a class="header-anchor" href="#dom0级事件处理程序"></a>DOM0级事件处理程序</h2>
<pre><code class="language-JavaScript">var element = document.getElementById(&quot;myBtn&quot;); 
element.onclick = function(){
//操作
};
</code></pre>
<p>在事件的冒泡阶段触发回调。</p>
<ul>
<li><strong>优势：</strong> 具有跨浏览器的优势。</li>
<li><strong>劣势</strong>：只能绑定1个回调函数
<ul>
<li>因为直接赋值给对应 DOM object 属性，如果你在后面代码中再次为 <code>element</code> 绑定一个回调函数，会覆盖掉之前回调函数的内容。通俗来说就是很难实现多个绑定。</li>
<li>虽然也可以用一些小技巧实现<strong>多个绑定</strong>，但还是推荐下面的DOM2级事件处理程序实现<strong>多个绑定</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>1级DOM-----(为什么没有1级DOM)</p>
<p>DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型</p>
</blockquote>
<h2 id="dom2级事件处理程序"><a class="header-anchor" href="#dom2级事件处理程序"></a>DOM2级事件处理程序</h2>
<pre><code class="language-JavaScript">var btn = document.getElementById('btn');
btn.addEventListener('click', function(){ 
  alert('你点击了这里');
}, false);
</code></pre>
<p>addEventListener是<strong>标准的事件处理程序</strong>，亦称为绑定事件监听，提供三个参数可供传递。(IE9+也支持addEventListener)</p>
<p>第三个参数是一个布尔值，<code>true</code>表示在捕获阶段被处理，<code>false</code>表示在冒泡阶段被处理，考虑到浏览器的兼容问题，一般使用<code>false</code>。</p>
<p><strong>优势：</strong> 可以为一个元素添加多个事件处理程序。</p>
<h2 id="ie事件处理程序"><a class="header-anchor" href="#ie事件处理程序"></a>IE事件处理程序</h2>
<blockquote>
<p>【对于许多年前】IE 浏览器就是特立独行，它对于事件的操作与标准有一些差异。不过 IE 浏览器现在也开始慢慢努力改造，让浏览器变得更加标准。</p>
<p>【对于2022年后】IE正式宣布报废。只有极少数装着旧Windows系统的机器在用。</p>
</blockquote>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;);
btn.attachEvent(&quot;onclick&quot;, function(){ 
  alert(&quot;Clicked&quot;);
});
</code></pre>
<p>（IE事件处理程序：IE5到IE10支持，IE11就不再支持了。但是最好应用于IE5到IE8，因为IE9之后又略有变化）</p>
<p>实际上与addEventListener的使用十分相似。</p>
<p>区别在于，第二个参数传入的是<code>onclick</code>而并非<code>click</code>，且IE只支持在冒泡阶段进行程序处理，所以没有第三个参数布尔值的选择。</p>
<p>此外，如果为同一个元素添加了两个事件处理程序，addEventListener会以添加的顺序依次执行事件处理，而attachEvent则相反。</p>
<blockquote>
<p>如果要封装兼容attachEvent和addEventListener：因为attachEvent没有第三个参数，也就是说attachEvent只支持监听冒泡，所以为了与IE表现一致，在使用addEventListener的时候第三参数设置为 false。</p>
</blockquote>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<ul>
<li>一般情况下为了最大限度发挥事件处理程序的作用，使用标准事件处理程序，即addEventListener，并且把第三个参数设为<code>false</code>；</li>
<li>如果专门为了兼容IE，则使用attachEvent；</li>
<li>如果是在编写一个小demo，为了简单快捷，可以使用DOM0级处理程序或者考虑HTML内联处理程序。</li>
</ul>
<p>所谓的跨浏览器的事件处理程序代码，就是基于以上这些api来实现的。</p>
<h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2>
<h3 id="dom0移除事件绑定"><a class="header-anchor" href="#dom0移除事件绑定"></a>DOM0移除事件绑定</h3>
<p>如果想要移除element的“点击事件绑定”，将其置为null即可：</p>
<pre><code>element.onclick = null
</code></pre>
<h3 id="dom2移除事件监听"><a class="header-anchor" href="#dom2移除事件监听"></a>DOM2移除事件监听</h3>
<p>需要注意的是，<strong>绑定事件时的回调函数一般不能是匿名函数，</strong> 必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如：</p>
<pre><code class="language-javascript">var fun = function() {
    // function logic
};

element.addEventListener('click', fun, false);
element.removeEventListener('click', fun, false);
</code></pre>
<h3 id="ie移除事件监听"><a class="header-anchor" href="#ie移除事件监听"></a>IE移除事件监听</h3>
<p>detachEvent()，用法与DOM2级的removeEventListener类似</p>
<h3 id="函数作用域"><a class="header-anchor" href="#函数作用域"></a>函数作用域</h3>
<p>最直观的查看办法就是在函数回调里面加debugger，触发回调后，就能在控制台看到其作用域。</p>
<p>讨论事件处理程序的作用域的意义不大：一般意义上的作用域主要服务于“变量的访问”，而正好 事件处理程序 的“根层级函数”基本上都是靠dom、不需要依靠作用域来实现“变量的访问”。</p>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[考古：js取消默认事件行为]]></title>
      <url>https://blog.az22c.top/2017/07/01/js-pv-default/</url>
      <content type="html"><![CDATA[<p>常见的默认行为有，点击<code>a</code>标签链接后，浏览器跳转到指定页面；再比如<code>&lt;form&gt;</code>表单元素的&quot;submit&quot;事件。</p>
<a id="more"></a>
<blockquote>
<p>提示：本文章内容成篇于2017年07月，部分内容可能已经过时</p>
</blockquote>
<p>IE被废弃之前，同一个命令有不同的写法，而且为了满足兼容性导致处理方式错综复杂，所以重度依赖jquery来简化；</p>
<p>2022年IE被废弃之后，编写这个单一的命令变简洁了很多。历史前后形成鲜明对比。</p>
<hr>
<p>关于取消默认行为的属性包括cancelable、defaultPrevented、preventDefault()和returnValue。</p>
<p>而“return false”这种方式不算是属性，我们后面会介绍到。</p>
<blockquote>
<p>作为程序员，原本我们应该优先判别cancelable属性，</p>
<p>不过我们先拿preventDefault()、returnValue和“return false”这三者来讲：</p>
<p>在DOM0级事件处理程序中取消默认行为，这三者都有效；</p>
<p>在DOM2级事件处理程序中取消默认行为，使用“return false”无效;</p>
<p>在IE事件处理程序中取消默认行为，使用preventDefault()无效。</p>
</blockquote>
<h2 id="preventdefault"><a class="header-anchor" href="#preventdefault"></a>preventDefault()</h2>
<p>preventDefault()方法取消浏览器对当前事件的默认行为，无返回值。（IE8-浏览器不支持该方法）</p>
<pre><code class="language-html">&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    e.preventDefault();
}
&lt;/script&gt;
</code></pre>
<h2 id="returnvalue"><a class="header-anchor" href="#returnvalue"></a>returnValue</h2>
<p>returnValue属性可读写，默认值是true，但将其设置为false就可以取消事件的默认行为，与preventDefault()方法的作用相同。（firefox和IE9+浏览器不支持）</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    e.returnValue = false;
}
&lt;/script&gt;
</code></pre>
<h3 id="如果不用到dom0-考虑兼容："><a class="header-anchor" href="#如果不用到dom0-考虑兼容："></a>// 如果不用到DOM0，考虑兼容：</h3>
<p>在本文开头：</p>
<blockquote>
<p>我们先拿preventDefault()、returnValue和“return false”这三者来讲：</p>
<p>在DOM0级事件处理程序中取消默认行为，这三者都有效；</p>
<p>在DOM2级事件处理程序中取消默认行为，使用“return false”无效;</p>
<p>在IE事件处理程序中取消默认行为，使用preventDefault()无效。</p>
</blockquote>
<p>所以，如果<strong>不使用到DOM0</strong>，考虑兼容可以这么写：</p>
<p>(即，如果我们要用addEventListener()或者attachEvent()来绑定的话，就要用preventDefault()方法或者设置事件对象的returnValue属性。)</p>
<pre><code>var handler = function(e){
    e = e || event;
    if(e.preventDefault){
        e.preventDefault(); // 针对支持DOM标准的浏览器
    }else{
        e.returnValue = false; // 针对IE
    }
}
</code></pre>
<h2 id="return-false"><a class="header-anchor" href="#return-false"></a>return false</h2>
<p>除了以上方法外，取消默认事件还可以使用&quot;return false&quot;</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    return false;
}
&lt;/script&gt;
</code></pre>
<p>HTML5规范中有指出在mouseover等几种特殊事件情况下，return false;并不一定能终止事件。所以，在实际使用中，我们需要尽量避免通过&quot;return false&quot;的方式来取消事件的默认行为。</p>
<p><strong>若使用的是jquery，“return false ”既会阻止默认行为，也会阻止事件的冒泡。</strong> 这样使用return false往往会造成意想不到的失误。</p>
<hr>
<h2 id="cancelable"><a class="header-anchor" href="#cancelable"></a>cancelable</h2>
<p>cancelable属性返回一个布尔值，表示事件是否可以取消。</p>
<p>该属性为<strong>只读</strong>属性。返回true时，表示可以取消；返回false时，要么表示没有默认动作，要么表示不能阻止默认动作。（IE8-浏览器不支持cancelable属性）</p>
<p>这样来看，优先考虑到cancelable属性才是比较合理的逻辑顺序。</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    test.innerHTML = e.cancelable;
}
&lt;/script&gt;
</code></pre>
<h2 id="defaultprevented"><a class="header-anchor" href="#defaultprevented"></a>defaultPrevented</h2>
<p>defaultPrevented属性表示默认行为是否被阻止，返回true时表示被阻止，返回false时，表示未被阻止。（IE8-浏览器不支持）</p>
<pre><code class="language-html">&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    if(e.preventDefault){
        e.preventDefault();
    }else{
        e.returnValue = false;
    }
    test.innerHTML = e.defaultPrevented; // defaultPrevented在这里用到
}
&lt;/script&gt;
</code></pre>
<blockquote>
<p>很明显 cancelable属性 和 defaultPrevented属性，一个是说明“能不能”，而另1个表示的是状态。后者主要是方便debug的时候查询状态。</p>
</blockquote>
<hr>
<h2 id="jquery的写法："><a class="header-anchor" href="#jquery的写法："></a>JQuery的写法：</h2>
<p>JQuery的思想就是和原生的对应，并且作一定兼容：</p>
<pre><code>$(&quot;a&quot;).click(function(event){
  event.preventDefault();
});
</code></pre>
<ul>
<li>如果使用jQuery绑定的事件处理函数&quot;return false&quot;，jQuery也会阻止触发元素的默认行为。
<ul>
<li><strong>若使用的是jquery，“return false ”既会阻止默认行为，也会阻止事件的冒泡。</strong></li>
<li><a href="http://www.365mini.com/page/jquery-event-preventdefault.htm" target="_blank" rel="noopener">http://www.365mini.com/page/jquery-event-preventdefault.htm</a></li>
</ul>
</li>
<li>使用  <a href="http://www.runoob.com/jquery/event-isdefaultprevented.html" target="_blank" rel="noopener">event.isDefaultPrevented() 方法</a> 来检查指定的事件上是否调用了 preventDefault() 方法。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[let和const变量声明的特点]]></title>
      <url>https://blog.az22c.top/2017/05/08/let-n-const/</url>
      <content type="html"><![CDATA[<p>本文的结构是：前文就是一个完整的内容提炼；后文是作为拓展和详细的介绍：</p>
<a id="more"></a>
<hr>
<p>（本文写于2017年，虽然ES8都出来了，但是需要维护的用var的旧工程依然是不少啊）</p>
<p>ES6提出了两个新的声明变量的命令：<code>let</code>和<code>const</code> 。在使用层面就是：在做新的 js 项目的时候，var可以完全被它们俩替换掉。</p>
<p>用let替代var时，你需要注意到它们的不同点有三个：</p>
<p><strong>1.块级作用域：</strong></p>
<pre><code>for (var i = 0; i &lt; 10; i++) {}
console.log(i);   // 10

for (let j = 0; j &lt; 10; j++) {}
console.log(j);   // ReferenceError: j is not defined
</code></pre>
<p>在执行到 console.log(i) 的时候，“标识符解析”所想要解析到的 i 仍在其所属的函数作用域的执行上下文内。基于此，log的打印结果是：此时 i 还没有被销毁。</p>
<p>在执行到 console.log(j) 的时候，“标识符解析”所想要解析到的 j 已经在本例中各个“声明了 j 的块级作用域的执行上下文”外了。也就是此时解析不到对于变量 j 的声明。</p>
<p><strong>2.变量提升：</strong>  var会变量提升，但let不会：</p>
<pre><code>console.log(bar); // undefined
var bar = 1;

console.log(baz); // ReferenceError: baz is not defined
let baz = 1;
</code></pre>
<p><strong>3.不允许重复声明：</strong> let声明的变量 不允许在同一个作用域中被重复声明 （，幸运的是，浏览器会很清晰地报错以提醒你这条规则）：</p>
<pre><code>var count = 30;
let count = 40; //Uncaught SyntaxError: Identifier 'count' has already been declared
</code></pre>
<blockquote>
<p>对于循环体的块级作用域的情况，则是要求 js 解析器：每一次循环中创建的各个循环体块级作用域都能有属于它们自己的 循环变量 的副本。详细说明见后文。</p>
</blockquote>
<hr>
<p>const同样有以上的三条规则，即：</p>
<p>1.块级作用域</p>
<p>2.const不再能变量提升</p>
<p>3.const声明的变量是不允许被重复声明的</p>
<p>另外，const 的特点是<strong>一经声明，该变量值就不能被赋新的值</strong>。</p>
<ul>
<li>一经声明，该变量值就不能被赋新的值
<ul>
<li>const声明的变量<strong>只可以在声明时赋值</strong></li>
<li>在声明的之后，赋新的值给该变量会报错</li>
</ul>
</li>
</ul>
<blockquote>
<p>因而，在使用和操作的层面：如果要声明一个常量，通常推荐使用 const 来声明。</p>
</blockquote>
<hr>
<h2 id="以下为详细内容："><a class="header-anchor" href="#以下为详细内容："></a>以下为详细内容：</h2>
<h3 id="let"><a class="header-anchor" href="#let"></a>let</h3>
<p>let的规则被提出，就是希望帮助你捕捉可能造成bug的地方，写出更健壮的代码。除了<code>NaN</code>错误以外，每一个异常都能在当前行抛出。</p>
<h4 id="let的块级作用域"><a class="header-anchor" href="#let的块级作用域"></a>let的块级作用域</h4>
<p><code>let</code>与<code>var</code>一样，也可以用来声明变量，但let有着更精确的作用域规则：</p>
<p><strong>let声明的变量拥有块级作用域。</strong> 也就是说用<code>let</code>声明的变量的作用域只是<strong>外层块</strong>，而不是整个外层函数。</p>
<p>【注意该话题下的细节】：</p>
<ul>
<li><strong>let声明的全局变量不是全局对象的属性。</strong> 这就意味着，你<strong>不可以</strong>通过<code>window.变量名</code>的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的<strong>外层块</strong>。</li>
<li><strong>形如for (let i…)的循环在每次迭代时都为 i 创建新的绑定。</strong></li>
</ul>
<h5 id="代码示例："><a class="header-anchor" href="#代码示例："></a>代码示例：</h5>
<p>可以先看一个 “循环内变量过度共享” 的例子：</p>
<pre><code>var messages = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
for (var i = 0; i &lt; messages.length; i++) {
	setTimeout(function () {
		console.log(i);
	}, i * 500);
}
// 控制台输出三次 &quot;3&quot;，比较不符合常规的惯性思维
</code></pre>
<p>解释该例：</p>
<p>首先执行 3 次循环。当循环结束执行时，</p>
<p>在 var 声明的变量是属于其函数作用域(的执行上下文)的 的规则下，本例最外层的那个作用域(的执行上下文)，<strong>在执行完全局代码的时机</strong>保留了循环执行 3 次之后变量 i 的值，即为3。(此时 setTimeout 回调尚未被执行。)</p>
<p>然后，再到分别依次执行 setTimeout 回调的时候，3 个 setTimeout 回调函数的执行上下文，能解析到的是其父级作用域(也就是本例最外层的那个作用域)的 i，值为3。</p>
<h5 id="而如果我们在该例中使用的是let："><a class="header-anchor" href="#而如果我们在该例中使用的是let："></a>// 而如果我们在该例中使用的是let：</h5>
<pre><code>var messages = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
for (let i = 0; i &lt; messages.length; i++) {
	setTimeout(function () {
		console.log(i);
	}, i * 500);
}
// 控制台输出 &quot;A&quot; &quot;B&quot; &quot;C&quot;，符合我们常规的预期
</code></pre>
<p><code>for (let i...)</code>循环执行三次，<strong>每次循环都会产生新的块级作用域，</strong> 并且 为 每次循环里面的函数 将捕捉当时循环变量 i 的不同值作为副本(换而言之，而不是所有循环体都捕捉循环变量的同一个值)。</p>
<blockquote>
<p>因为let是块级作用域规则，</p>
<p>而每一次循环都是进入新的块级作用域，都会创建一个新的变量 i，并将其初始化为 i 的当前值，所以每一次循环中创建的各个循环体块级作用域都能有属于它们自己的 i 的副本（值分别为 0 1 2）。</p>
<p>由于这些timeout函数都需要被推入 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">任务队列</a> ，稍后再执行，所以最终为它们每一个都保留了一个因 setTimeout 所需要而产生的闭包。</p>
<ul>
<li>第一个timeout函数所对应的闭包(即本例第一次for循环产生的块级作用域)中保留了一个值为0的 i 的副本</li>
<li>第二个timeout函数所对应的闭包(即本例第二次for循环产生的块级作用域)中保留了一个值为1的 i 的副本</li>
<li>第三个timeout函数所对应的闭包(即本例第三次for循环产生的块级作用域)中保留了一个值为2的 i 的副本</li>
</ul>
</blockquote>
<p>所以在上例中，直接可以将<code>var</code>替换为<code>let</code>修复bug。</p>
<p>这种解决办法，适用于现有的三种循环方式：<code>for-of</code>、<code>for-in</code>、以及传统的用分号分隔的类C语言的循环。</p>
<h4 id="let不再变量提升"><a class="header-anchor" href="#let不再变量提升"></a>let不再变量提升</h4>
<p><strong>let声明的变量直到执行流到达该变量被声明的代码行时才会被装载，所以在到达之前使用该变量会触发错误</strong> 。举个例子：</p>
<pre><code>  function foo() {
  	console.log(&quot;当前值: &quot; + x);  // 引用错误（ReferenceError）
  	// ...
  	let x = &quot;hello&quot;;
  }
  foo()
</code></pre>
<p>不可访问的这段时间里，变量 x 一直处于作用域中，虽已声明，但是尚未装载，它位于 临时死区（Temporal Dead Zone，简称TDZ）中。</p>
<p>换句话说就是：let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，就会引发错误。因而从作用域顶部到声明变量语句之前的这个区域，被称为“临时死区”。</p>
<p>PS：但是，在let或const声明的作用域之外使用该变量就 <strong>不会报错</strong>：(也就是，(由作用域shadow的基本规则推导出：) TDZ 现象仅限于在let声明所属的作用域内)</p>
<pre><code>console.log(typeof value);
if(true){
    let value = &quot;blue&quot;;
}
</code></pre>
<h4 id="let声明的变量不允许重复声明"><a class="header-anchor" href="#let声明的变量不允许重复声明"></a>let声明的变量不允许重复声明</h4>
<p>let声明的变量 不允许在同一个作用域中被重复声明。</p>
<p>此时，重声明会抛出一个语法错误（SyntaxError）。</p>
<pre><code>var count = 30;
let count = 40; //Uncaught SyntaxError: Identifier 'count' has already been declared
</code></pre>
<p>这一条规则也可以帮助你检测琐碎的小问题。当你全局搜索<code>var</code>替换为<code>let</code>时可能会发现<code>let</code>重复声明的语法错误。</p>
<blockquote>
<p>而对于循环体的块级作用域的处理规则，参考上一个小节中的例子。</p>
</blockquote>
<h3 id="const"><a class="header-anchor" href="#const"></a>const</h3>
<blockquote>
<p>const声明的变量 一经声明，该变量值就不能被赋新的值，这是最大的特点。</p>
</blockquote>
<p><code>const</code>声明的变量与<code>let</code>声明的变量类似，它们的不同之处在于：</p>
<p>1.<code>const</code>声明的变量不可随意修改，否则会导致SyntaxError（语法错误）：</p>
<pre><code>const MY_PI = 3.14159; // 正确

MY_PI = 5000; // 语法错误（SyntaxError）
MY_PI++; // 虽然换了一种方式，但仍然会导致语法错误
</code></pre>
<p>2.<strong>用 const 声明变量的语句必须要赋值，否则也抛出语法错误。</strong> 这个一般代码编辑器都会提示的，不用担心。</p>
<pre><code>const MY_NEW_PI;  // 依然是语法错误
</code></pre>
<h4 id="注意1："><a class="header-anchor" href="#注意1："></a>// 注意1：</h4>
<p>const声明不允许修改绑定，但允许修改值。</p>
<p>即：对象属性不在const的保护范围之内：</p>
<pre><code>// 常量可以声明为对象
const MY_OBJECT = {&quot;key&quot;: &quot;value&quot;};

// 重写对象会失败
MY_OBJECT = {&quot;OTHER_KEY&quot;: &quot;value&quot;};

// 但对象属性并不在保护的范围内，下面这个声明会成功执行
MY_OBJECT.key = &quot;otherValue&quot;;

// 也可以用来声明数组
const MY_ARRAY = [];
// 可以向数组填充数据
MY_ARRAY.push('A'); // [&quot;A&quot;]
// 但是，将一个新数组赋给变量会引发错误
MY_ARRAY = ['B']
</code></pre>
<h4 id="注意2："><a class="header-anchor" href="#注意2："></a>// 注意2：</h4>
<p>因为const声明的变量不能改变，所以普通的for循环不能用const声明循环变量。</p>
<p>而由于for-in循环中每次迭代不会修改已有绑定，而是创建一个新绑定，所以在for-in循环中可以使用const：</p>
<pre><code>for(const key in obj){
       console.log(key);
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 作用域 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 任务队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript Date对象回顾]]></title>
      <url>https://blog.az22c.top/2017/05/07/js-date/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<p>Date 对象：涉及基于1970年1月1日(世界标准时间)起的毫秒数。</p>
<a id="more"></a>
<h2 id="构造函数"><a class="header-anchor" href="#构造函数"></a>构造函数</h2>
<pre><code>new Date();
// 依据系统设置的当前时间来创建一个Date对象
new Date(value);
// value 代表自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数。表达式的结果为一个字符串。
new Date(dateString);
// new Date(&quot;05 October 2011 14:48 UTC&quot;);
new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);
// 注意：month 代表月份的整数值从0（1月）到11（12月）。
</code></pre>
<p>解释：</p>
<ul>
<li>如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。</li>
<li><strong>JavaScript的Date对象为跨平台提供了统一的行为。</strong> 时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。</li>
<li>JavaScript 的Date对象提供了数个UTC时间的方法，也相应提供了当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。</li>
</ul>
<ul>
<li><strong>以一个函数的形式来调用JavaScript的Date对象（i.e., 不使用new操作符）会返回一个代表当前日期和时间的字符串。</strong></li>
</ul>
<h2 id="方法"><a class="header-anchor" href="#方法"></a>方法</h2>
<pre><code>Date.now()
// 返回自 1970-1-1 00:00:00  UTC (时间标准时间)至今所经过的毫秒数。也可以直接new Date()
Date.parse()
// 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。IE9
Date.UTC()
// 接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。
</code></pre>
<h2 id="实例方法"><a class="header-anchor" href="#实例方法"></a>实例方法</h2>
<h3 id="date-prototype-getmonth"><a class="header-anchor" href="#date-prototype-getmonth"></a>Date.prototype.getMonth()</h3>
<p>根据本地时间返回指定日期对象的月份（0-11）。（0表示一年中的第一月）</p>
<h3 id="date-prototype-gettime"><a class="header-anchor" href="#date-prototype-gettime"></a>Date.prototype.getTime()</h3>
<pre><code>new Date(1994, 1, 10)
// Thu Feb 10 1994 00:00:00 GMT+0800 (中国标准时间)
new Date(1994, 1, 10).getTime()
// 760809600000
</code></pre>
<h4 id="利用gettime-创建一个拥有相同时间值的日期对象："><a class="header-anchor" href="#利用gettime-创建一个拥有相同时间值的日期对象："></a>利用getTime()创建一个拥有相同时间值的日期对象：</h4>
<pre><code>var birthday = new Date(1994, 12, 10)
var copy = new Date()
copy.setTime(birthday.getTime())
</code></pre>
<h3 id="date-prototype-toutcstring"><a class="header-anchor" href="#date-prototype-toutcstring"></a>Date.prototype.toUTCString()</h3>
<p>而Date.prototype.toISOString()其实也同理：</p>
<pre><code>var today = new Date();
var UTCstring = today.toUTCString()
// Mon, 03 Jul 2006 21:44:38 GMT
</code></pre>
<blockquote>
<p>GMT和UTC：</p>
<p>从理论上说，GMT和UTC应该是两回事。</p>
<p>但是由于一开始设计者的失误，现在我们将错就错，在JavaScript Date对象的范畴里面，我们把GMT和UTC看做是同一回事。</p>
</blockquote>
<h3 id="date-prototype-totimestring"><a class="header-anchor" href="#date-prototype-totimestring"></a>Date.prototype.toTimeString()</h3>
<p><code>toTimeString()</code> 方法以人类易读形式返回一个日期对象时间部分的字符串，该字符串以美式英语格式化。</p>
<p>Date 对象的实例引用一个具体的时间点。 调用 toString 方法以美式英语和人类易读的形式，返回日期对象的格式化字符串。</p>
<p>而<code>toDateString()</code>也同理：</p>
<pre><code>var d = new Date(1993, 6, 28, 14, 39, 7)

console.log(d.toString());     // &quot;Wed Jul 28 1993 14:39:07 GMT+0800 (中国标准时间)&quot;
console.log(d.toTimeString()); // &quot;14:39:07 GMT+0800 (中国标准时间)&quot;

console.log(d.toString());     // &quot;Wed Jul 28 1993 14:39:07 GMT+0800 (中国标准时间)&quot;
console.log(d.toDateString()); // &quot;Wed Jul 28 1993&quot;
</code></pre>
<h2 id="将iso转utc："><a class="header-anchor" href="#将iso转utc："></a>将ISO转UTC：</h2>
<pre><code>new Date(&quot;2017-05-05T12:59:16.373Z&quot;)
// d为&quot;Fri May 05 2017 21:00:20 GMT+0800&quot;
d.toUTCString()
// &quot;Fri, 05 May 2017 13:00:20 GMT&quot;
</code></pre>
<p>如果不想自己折腾的话，就使用别人的轮子吧，<a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment</a>。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[纯vue实现checkbox父子联动]]></title>
      <url>https://blog.az22c.top/2017/05/07/vue-checkbox-table/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/vue-checkbox-table" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-checkbox-table</a></p>
<p><a href="https://alexzhong22c.github.io/vue-checkbox-table/vue-checkbox-table.html" target="_blank" rel="noopener">demo</a> (在线演示初次加载会有点慢，请稍等)</p>
<p>vue.js的出现，导致很多小插件的简单实现成为可能。</p>
<p>但是，正是由于<strong>vue的数据绑定</strong>使用起来耦合度太强，导致一些比较常规的插件的实现方式要稍微有所不同。</p>
<a id="more"></a>
<hr>
<p>这是一个带复选框(checkbox)的表格，只用纯vue不用其他框架实现<strong>checkbox父子联动</strong>：</p>
<p><img src="https://cloud.az22c.top/show-vue-checkbox-table.png-az22cgithub" alt></p>
<h2 id="效果："><a class="header-anchor" href="#效果："></a>效果：</h2>
<ul>
<li>表头的checkbox视之为一个全局(global)的checkbox，点击它可以实现“全选”和“全不选”</li>
<li>其他的checkbox视之为表中每个条目的一部分，若被勾选则代表该条目被勾选</li>
<li><strong>如果全部条目的checkbox都被勾上，表头的checkbox会被自动勾上</strong></li>
</ul>
<h2 id="实现："><a class="header-anchor" href="#实现："></a>实现：</h2>
<ul>
<li>每个条目中的checkbox用<code>:value=&quot;item['id']&quot;</code>来绑定，每当被勾选，对应的value(也就是这个id)会被放进<strong>数组checkedIds</strong></li>
<li>用一个<strong>深度 watcher</strong>，通过判断<strong>数组checkedIds</strong>的长度，实现 “如果所有条目被勾选，<strong>变量isAllChecked</strong>变为true，则全局checkbox被自动勾选”</li>
<li>全局checkbox不能用<code>:value</code>来绑定状态，要用<code>:checked</code>和一个<strong>onclick函数</strong>绑定状态，否则逻辑会混乱</li>
</ul>
<h2 id="作用原理链："><a class="header-anchor" href="#作用原理链："></a>作用原理链：</h2>
<h3 id="当我点击全局checkbox："><a class="header-anchor" href="#当我点击全局checkbox："></a>当我点击全局checkbox：</h3>
<ol>
<li>触发一个<strong>onclick函数</strong></li>
<li>改变<strong>数组checkedIds</strong>（因为<code>:value</code>的数据绑定，影响其他checkbox是否会被勾选）</li>
<li>通过一个<strong>深度watcher</strong>得出<strong>变量isAllChecked</strong>的值(因为<code>:checked</code>的数据绑定，影响全局checkbox是否被勾选)</li>
</ol>
<h3 id="当我点击某个条目中的checkbox："><a class="header-anchor" href="#当我点击某个条目中的checkbox："></a>当我点击某个条目中的checkbox：</h3>
<ol>
<li>因为<code>:value</code>的数据绑定，改变<strong>数组checkedIds</strong></li>
<li>通过一个<strong>深度watcher</strong>得出<strong>变量isAllChecked</strong>的值(因为<code>:checked</code>的数据绑定，影响全局checkbox是否被勾选)</li>
</ol>
<h2 id="最后："><a class="header-anchor" href="#最后："></a>最后：</h2>
<p>如果对<code>:value</code>和<code>:checked</code>的用法不清楚可以看看官网的checkbox是怎么写的：</p>
<p><a href="https://cn.vuejs.org/v2/guide/forms.html#checkbox" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/forms.html#checkbox</a></p>
<p>但是官网并没有像这里这样做出一个带复选框的表格。</p>
<p>重申一次，正是由于<strong>vue的数据绑定</strong>使用起来耦合度太强，全局checkbox不能用<code>:value</code>来绑定状态，要用<code>:checked</code>和一个<strong>onclick函数</strong>绑定状态，否则逻辑会混乱。</p>
<p>另，如果你想找<strong>带分页导航条的</strong>demo，可以参考我的：</p>
<p><a href="https://github.com/AlexZhong22c/vue-table-nav" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-table-nav</a></p>
<blockquote>
<p>如果各位看官喜欢的话留一个Star吧！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 复选框 </tag>
            
            <tag> 全选 </tag>
            
            <tag> 表格 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[经典vue单页路由入门全家桶]]></title>
      <url>https://blog.az22c.top/2017/04/25/vue-time-tracker/</url>
      <content type="html"><![CDATA[<p>vue-cli + vue2 + vue-router + axios + vuex2 + express + mongoose</p>
<p>一个简单的ToDoList——经典vue单页路由入门全家桶，我在大神们demo的基础上不断地改进。</p>
<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/vue-time-tracker" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-time-tracker</a></p>
<a id="more"></a>
<ul>
<li>使用vue-cli创建项目</li>
<li>.vue文件组件化的开发</li>
<li>使用vue-router实现单页路由</li>
<li>使用axios请求我们的node服务端，即express</li>
<li>使用vuex管理我们的数据流</li>
<li>express 和 MongoDB做后台和数据库，演示了前后台的数据交互，ajax请求</li>
<li>使用mongoose操作MongoDB</li>
</ul>
<p>“计划列表”界面</p>
<p><img src="https://cloud.az22c.top/time-tracker1.png-az22cgithub" alt="演示图1"></p>
<p>创建任务：</p>
<p><img src="https://cloud.az22c.top/time-tracker2.png-az22cgithub" alt="演示图2"></p>
<h2 id="运行demo"><a class="header-anchor" href="#运行demo"></a>运行demo:</h2>
<p>用<code>npm install</code>之后，总共需要打开两个命令行窗口，一个命令行运行：</p>
<pre><code>node app.js // 会在8888端口开启一个后台
</code></pre>
<p>另一个命令行运行：</p>
<pre><code>npm run dev
</code></pre>
<h3 id="历史版本的commit记录："><a class="header-anchor" href="#历史版本的commit记录："></a>历史版本的commit记录：</h3>
<table>
<thead>
<tr>
<th>commit名</th>
<th>commit时间</th>
<th>版本内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>finish-first-time</td>
<td>2017/4/25</td>
<td>vue-cli + vue2 + vue-router + vue-resource + vuex2 + express + MongoDB</td>
</tr>
<tr>
<td>use-mongoose</td>
<td>2017/4/26</td>
<td>使用mongoose，重写app.js文件，使其简单易懂</td>
</tr>
<tr>
<td>use-axios</td>
<td>2017/5/2</td>
<td>使用axios代替原来的vue-resource</td>
</tr>
</tbody>
</table>
<h2 id="懒人速查"><a class="header-anchor" href="#懒人速查"></a>懒人速查</h2>
<h3 id="main-js文件"><a class="header-anchor" href="#main-js文件"></a>main.js文件</h3>
<ul>
<li><code>main.js</code>将会作为我们应用的入口文件而<code>App.vue</code>会作为我们应用的初始化组件</li>
</ul>
<ul>
<li><code>...App</code>这句代码等价于<code>render:h =&gt; h(App)</code></li>
<li>使用axios代替原来的vue-resource做ajax请求</li>
</ul>
<h4 id="eslint-disable-no-new"><a class="header-anchor" href="#eslint-disable-no-new"></a>eslint-disable no-new</h4>
<p>我们这个项目是用vue-cli帮助配置生成的，如果在生成时你选择了启用eslint检测语法，那么eslint默认是不允许你使用new的，如果eslint不通过会报错，你的项目因此就无法让webpack用浏览器调试。</p>
<p>解决办法有很多，正如它提示的一样：eslint-disable no-new，就是去项目的根目录找到.eslintrc.js配置文件，然后在rules字段里面添加<code>&quot;no-new&quot;: 0</code>，取消对no-new规则的检查，就像是这样：</p>
<pre><code>  'rules': {
    // allow paren-less arrow functions
    'arrow-parens': 0,
    &quot;no-new&quot;: 0,
    // allow async-await
    'generator-star-spacing': 0,
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0
  }
</code></pre>
<p>此后，当我们调试或者打包项目的时候就不会因为这个new语法报错。</p>
<p>如果你想要了解各个eslint配置的含义，强烈推荐去 <a href="http://eslint.cn/" target="_blank" rel="noopener">eslint中文官网</a> 在官网用搜索栏一搜就能查到含义。</p>
<p>另外，可以看到这个demo的eslint配置主要是在引入 <em>eslint-config-standard</em> 的基础上稍稍修改的，其他的配置如果你不想浪费时间在自定义上，你可以参考我的博文：<a href="https://blog.az22c.top/2017/03/11/try-eslint/">https://blog.az22c.top/2017/03/11/try-eslint/</a></p>
<h3 id="app-vue文件"><a class="header-anchor" href="#app-vue文件"></a>App.vue文件</h3>
<ul>
<li><code>main.js</code>将会作为我们应用的入口文件而<code>App.vue</code>会作为我们应用的初始化组件</li>
<li><a href="#%60ready%60%E8%A2%AB%E5%BA%9F%E9%99%A4"><code>ready</code>已被废除</a> ，见本项目的App.vue 或 <a href="https://cn.vuejs.org/v2/guide/migration.html#ready-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></li>
</ul>
<h3 id="timeentries-vue文件"><a class="header-anchor" href="#timeentries-vue文件"></a>TimeEntries.vue文件</h3>
<ul>
<li><a href="#%60$dispatch%60%E8%A2%AB%E5%BA%9F%E9%99%A4"><code>$dispatch</code>已被废除</a> ，本demo使用的就是vuex，见本项目TimeEntries.vue文件和src/store下的各个文件夹或 <a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></li>
</ul>
<p>总结：<strong>在vue2.0中废除了使用事件的方式进行通信，所以在小项目中我们可以使用Event Bus，其余最好都使用vuex，本demo我们使用Vuex来实现数据通信</strong>。</p>
<pre><code>// this.$dispatch('deletePlan', timeEntry)，事件*通信*的写法
// $dispatch是vue1.x的写法，现已被废除，改为vuex来*通信*：
this.$store.dispatch('deletePlan', timeEntry)，用vuex*通信*
</code></pre>
<h3 id="logtime-vue文件"><a class="header-anchor" href="#logtime-vue文件"></a>LogTime.vue文件</h3>
<ul>
<li>组件可以没有“name&quot;，如果给组件一个name可以方便在调试的时候在控制台打印错误是来自哪个组件的</li>
<li>对 <a href="#axios%E5%9C%A8vue%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">axios</a> 的用法做了粗浅介绍</li>
</ul>
<h3 id="app-js文件"><a class="header-anchor" href="#app-js文件"></a>app.js文件</h3>
<blockquote>
<p>demo经过了版本更新，原本使用MongoClient，现在用mongoose改写了一次</p>
</blockquote>
<h4 id="mpromise-mongoose-s-default-promise-library-is-deprecated"><a class="header-anchor" href="#mpromise-mongoose-s-default-promise-library-is-deprecated"></a>mpromise (mongoose’s default promise library) is deprecated</h4>
<p><a href="http://blog.csdn.net/fd214333890/article/details/53486862" target="_blank" rel="noopener">http://blog.csdn.net/fd214333890/article/details/53486862</a></p>
<p>增加一句： <code>mongoose.Promise = global.Promise</code> 即可</p>
<h4 id="mongoose是怎么找collections的"><a class="header-anchor" href="#mongoose是怎么找collections的"></a>mongoose是怎么找collections的?</h4>
<p><a href="https://cnodejs.org/topic/4f71363f8a04d82a3d1e4aea" target="_blank" rel="noopener">https://cnodejs.org/topic/4f71363f8a04d82a3d1e4aea</a></p>
<pre><code>mongoose.model('User', UserSchema);
</code></pre>
<p>去命令行：</p>
<pre><code>use node_club show collections //只能看到有一个名为users的collection，而没有User的collection
</code></pre>
<p>由此我们可以推断mongoose在内部创建collection时将我们传递的collection名小写化，同时如果小写化的名称后面没有字母——s,则会在其后面添加一s,针对我们刚建的collection,则会命名为：users。</p>
<p><strong>可以通过下面两种方式更改collection的名字：</strong></p>
<pre><code>1.xxschema = new Schema({
…
}, {collection: “your collection name”});

2.mongoose.model(‘User’, UserSchema, “your collection name”);
</code></pre>
<h2 id="深入理解数据的请求"><a class="header-anchor" href="#深入理解数据的请求"></a>深入理解数据的请求</h2>
<h3 id="生命周期和数据请求的时机"><a class="header-anchor" href="#生命周期和数据请求的时机"></a>生命周期和数据请求的时机</h3>
<p>vue实例的生命周期看这一篇：<a href="http://blog.csdn.net/sexy_squirrel/article/details/60764504" target="_blank" rel="noopener">http://blog.csdn.net/sexy_squirrel/article/details/60764504</a></p>
<p>同样是向后台请求数据，App.vue是在mounted的时机，而TimeEntries是在created的时机。</p>
<p>那主要是因为我们需要先挂载好App组件，然后再请求数据。</p>
<p>而TimeEntries要等到请求完数据之后才会挂载上去，所以我们为TimeEntries做了一个loading提示，代表正在请求数据。</p>
<h3 id="导航钩子和数据请求的时机"><a class="header-anchor" href="#导航钩子和数据请求的时机"></a>导航钩子和数据请求的时机</h3>
<p>强烈推荐看这一篇：<a href="https://github.com/vuefe/vuefe.github.io/blob/1f6e110db81a0a385955ce4ec998f23e7190d2a9/src/router/advanced/data-fetching.md" target="_blank" rel="noopener">https://github.com/vuefe/vuefe.github.io/blob/1f6e110db81a0a385955ce4ec998f23e7190d2a9/src/router/advanced/data-fetching.md</a></p>
<h3 id="vuex和数据请求"><a class="header-anchor" href="#vuex和数据请求"></a>vuex和数据请求</h3>
<p>谈一谈下面这一段被注释的代码：</p>
<pre><code>    watch: {
      如果路由有变化，会再次执行该方法，进入和离开都会触发
      由于我们用了vuex--让timeEntries作为计算属性就能拿到数据，不必fetchData
      '$route': 'fetchData'
    },
</code></pre>
<ul>
<li>我们经常拿计算属性和watch做对比</li>
<li>一般vue组件从vuex的state拿到数据的方式有二：
<ul>
<li>一个是计算属性</li>
<li>一个是封装getter函数再调用getter(适用于多个组件都需要相同的state数据的情况)</li>
</ul>
</li>
<li>vuex其实相当于一个前台的小数据库</li>
<li>使用vuex的一大特点就是：有vuex帮忙管理数据，<strong>应用一开始从后台拿大量的数据也不会混乱</strong>，之后用户每次增删改查一小部分数据的时候，先ajax让后台数据库实现增删改查，成功之后直接通过vuex的actions–&gt;mutations–&gt;state来增删改查state那里的数据就行了。
<ul>
<li>因为ajax比较容易失败，所以一般都是ajax成功之后，再在回调函数中同步对应的前台state数据</li>
</ul>
</li>
<li><strong>尤其是“查”，页面切换回来或者路由切换回来的时候，需要重复再查一次此页的数据。</strong> 使用vuex后，查数据不必去用ajax访问数据库，直接从state查数据就行了</li>
</ul>
<p>结论：使用vuex后，原本这次需要调用fetchData函数去再查数据库，而现在直接用计算属性从state那里查就行了。</p>
<hr>
<blockquote>
<p>2017/5/2更新：使用axios代替原来的vue-resource：</p>
</blockquote>
<h3 id="axios在vue中如何使用"><a class="header-anchor" href="#axios在vue中如何使用"></a>axios在vue中如何使用</h3>
<p>安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能在每个需要发送请求的组件中即时引入。</p>
<p>为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，（另一种是在vuex的actions内封装一下，由于考虑到某些小伙伴不使用vuex，我们选用第一种方法）。</p>
<blockquote>
<p>对这方面好奇的同学可以参考：<a href="http://blog.csdn.net/fen747042796/article/details/70660419?locationNum=6&amp;fps=1" target="_blank" rel="noopener">http://blog.csdn.net/fen747042796/article/details/70660419?locationNum=6&amp;fps=1</a></p>
</blockquote>
<p>在 main.js 中引入 axios：</p>
<pre><code>import axios from 'axios'
Vue.prototype.$ajax = axios
// 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $ajax 命令
</code></pre>
<p><a href="http://www.cnblogs.com/wisewrong/p/6402183.html" target="_blank" rel="noopener">http://www.cnblogs.com/wisewrong/p/6402183.html</a></p>
<h4 id="回调函数的this"><a class="header-anchor" href="#回调函数的this"></a>回调函数的this</h4>
<p>当请求成功时，会执行 .then，否则执行 .catch</p>
<p>这两个回调函数都有各自独立的作用域，<strong>如果直接在里面访问 this，将会无法访问到 Vue 实例</strong>，所以我们改为用箭头函数，详见demo中LogTime.vue文件的注释说明。</p>
<p><a href="https://segmentfault.com/q/1010000005932552" target="_blank" rel="noopener">https://segmentfault.com/q/1010000005932552</a></p>
<p><a href="http://blog.csdn.net/qtwwyl/article/details/70094361?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.csdn.net/qtwwyl/article/details/70094361?utm_source=itdadao&amp;utm_medium=referral</a></p>
<h2 id="深入理解vuex"><a class="header-anchor" href="#深入理解vuex"></a>深入理解vuex</h2>
<h3 id="state的数据在内存中"><a class="header-anchor" href="#state的数据在内存中"></a>state的数据在内存中</h3>
<p>vuex的本质作用是管理组件之间复杂的状态的（如购物车逻辑等等…）,所以当F5刷新浏览器时，这些状态也会一并被清空。</p>
<p>如果想在F5之后不要丢失数据，一般都会采用cookie或者localStorage等方法存储：</p>
<p><a href="https://segmentfault.com/q/1010000007336361" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007336361</a></p>
<p><a href="https://www.zhihu.com/question/54164220/answer/138185671" target="_blank" rel="noopener">https://www.zhihu.com/question/54164220/answer/138185671</a></p>
<h3 id="既然vuex2-可以直接去store拿state-那getters还有什么用啊"><a class="header-anchor" href="#既然vuex2-可以直接去store拿state-那getters还有什么用啊"></a>既然vuex2 可以直接去store拿state, 那getters还有什么用啊?</h3>
<p>getters可以看做是store的计算属性。另外，我们最好遵循vuex的通讯流程：</p>
<h4 id="vuex单向数据流"><a class="header-anchor" href="#vuex单向数据流"></a>vuex单向数据流</h4>
<p>Vuex实际上是类<a href="https://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a>的数据管理架构。下面这张图很好的诠释了Vuex和组件之间的通讯关系。</p>
<p><img src="https://cloud.az22c.top/vuex.png-az22cgithub" alt="Vuex和组件之间的通讯关系"></p>
<p>这个图告诉我们不应该直接在vue Components去操作state中的数据，而是应该按照vue Components–&gt;actions–&gt;mutations–&gt;state这个过程来操作数据。</p>
<blockquote>
<p>组件永远都不应该直接改变 Vuex store 的状态。因为我们想要让状态的每次改变都很明确且可追踪，Vuex 状态的所有改变都必须在 store 的 mutation handler (变更句柄)中管理。</p>
</blockquote>
<h3 id="区分-actions-和-mutations"><a class="header-anchor" href="#区分-actions-和-mutations"></a>区分 actions 和 mutations</h3>
<p>更改 Vuex 的 store 中的<strong>状态</strong>的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行<strong>状态</strong>更改的地方，并且它会接受 state 作为第一个参数。</p>
<h4 id="mutation-必须是同步函数-什么意思"><a class="header-anchor" href="#mutation-必须是同步函数-什么意思"></a>mutation 必须是同步函数，什么意思?</h4>
<p>一条重要的原则就是要记住mutation 必须是<strong>同步函数</strong>，即<strong>不准在mutations中编写异步回调的操作。</strong></p>
<pre><code>mutations: {
  someMutation (state) {
    api.callAsyncMethod(() =&gt; {
      // 这句话在异步函数的回调函数中 
      state.count++
    })
  }
}
</code></pre>
<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。</p>
<p>然而，在上面的例子中 mutation 中的<strong>异步函数中的回调</strong>让这不可能完成：(当 mutation 触发的时候，回调函数还没有被调用)，devtools 不知道什么时候<strong>回调函数实际上被调用</strong> —— 实质上任何在回调函数中进行的的状态的改变都是不可追踪记录的。</p>
<h5 id="从另一个角度去理解："><a class="header-anchor" href="#从另一个角度去理解："></a>从另一个角度去理解：</h5>
<p><code>Store</code>理解为一个仓库，<code>action</code>是一次操作，<code>mutation</code>是让仓库中存储的东西产生某种变化的方式，<code>state</code>则是存储的东西当前的状态。</p>
<p>一个操作可能需要对数据产生变动，另一个操作也需要对数据产生同样的变动，那这个变动可以抽取出来，称为一个<code>mutation</code>，这样，通过<code>commit</code>触发指定<code>的mutation</code>就可以了, 不必使其与操作业务的代码混在一起，导致代码混乱、可维护性差的结果。</p>
<h5 id="作者在知乎上的解释："><a class="header-anchor" href="#作者在知乎上的解释："></a>作者在知乎上的解释：</h5>
<p>区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪记录状态的变化。</p>
<p>事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点。[在 redux 里面就好像 reducer 必须同步返回(而不能异步返回)下一个状态一样。]</p>
<p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p>
<p>如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。其实尤雨溪有个点子一直没时间做，那就是把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助。</p>
<p>作者：尤雨溪链接：<a href="https://www.zhihu.com/question/48759748/answer/112823337" target="_blank" rel="noopener">https://www.zhihu.com/question/48759748/answer/112823337</a></p>
<h3 id="mutations-需遵守-vue-的响应规则"><a class="header-anchor" href="#mutations-需遵守-vue-的响应规则"></a>Mutations 需遵守 Vue 的响应规则</h3>
<p>1. 最好提前在你的 store 中初始化好所有所需属性。</p>
<p>2. 当需要在对象上添加<strong>新属性</strong>时，你应该</p>
<ul>
<li>使用 <code>Vue.set(obj, 'newProp', 123)</code>, 或者 -</li>
<li>以新对象替换老对象。例如，利用 stage-3 的<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">对象展开运算符</a>我们可以这样写：</li>
</ul>
<pre><code>  state.obj = { ...state.obj, newProp: 123 }
</code></pre>
<p>(这个demo并没有为对象添加新属性的操作，这里只是提醒一下有这个知识点)</p>
<h2 id="vue2-新旧替换"><a class="header-anchor" href="#vue2-新旧替换"></a>vue2 新旧替换</h2>
<h3 id="ready被废除"><a class="header-anchor" href="#ready被废除"></a><code>ready</code>被废除</h3>
<p>使用新的 <code>mounted</code> 钩子函数替代。应该注意的是，使用 <code>mounted</code> 并不能保证钩子函数中的 <code>this.$el</code> 在 document 中。为此还应该引入 <code>Vue.nextTick</code>/<code>vm.$nextTick</code>。例如：</p>
<pre><code class="language-vue">mounted: function () {
  this.$nextTick(function () {
    // 使用$nextTick，代码保证 this.$el 在 document 中
  })
}
</code></pre>
<p>见本项目的App.vue 或 <a href="https://cn.vuejs.org/v2/guide/migration.html#ready-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></p>
<h3 id="dispatch被废除"><a class="header-anchor" href="#dispatch被废除"></a><code>$dispatch</code>被废除</h3>
<p>总结：<strong>在vue2.0中废除了使用事件的方式进行通信，所以在小项目中我们可以使用Event Bus，其余最好都使用vuex，本demo我们使用Vuex来实现数据通信</strong>。</p>
<pre><code>// this.$dispatch('deletePlan', timeEntry)，事件*通信*的写法
// $dispatch是vue1.x的写法，现已被废除，改为vuex来*通信*：
this.$store.dispatch('deletePlan', timeEntry)，用vuex*通信*
</code></pre>
<p><code>$dispatch</code> 和 <code>$broadcast</code> 已经被弃用。因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好。</p>
<p>对于<code>$dispatch</code> 和 <code>$broadcast</code>最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。</p>
<blockquote>
<p>这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 <a href="https://cn.vuejs.org/v2/guide/components.html#Form-Input-Components-using-Custom-Events" target="_blank" rel="noopener"><code>v-on</code>监听子组件上 $emit 的变化</a>。这可以允许你很方便的添加事件显性。</p>
<p>然而，如果是跨多层父子组件通信的话， <code>$emit</code> 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。（这会让组件之间的通信非常顺利，即使是兄弟组件。）</p>
</blockquote>
<h4 id="单独的事件中心"><a class="header-anchor" href="#单独的事件中心"></a>单独的事件中心</h4>
<p>比如，假设我们有个 todo 的应用结构如下：</p>
<pre><code>Todos
|-- NewTodoInput
|-- Todo
    |-- DeleteTodoButton
</code></pre>
<p>可以通过单独的事件中心管理组件间的通信：</p>
<pre><code>// 将在各处使用该事件中心
// 组件通过它来通信
var eventHub = new Vue()
</code></pre>
<p>然后在组件中，可以使用 <code>$emit</code>, <code>$on</code>, <code>$off</code> 分别来分发、监听、取消监听事件：</p>
<pre><code>// NewTodoInput
// ...
methods: {
  addTodo: function () {
    eventHub.$emit('add-todo', { text: this.newTodoText })
    this.newTodoText = ''
  }
}
// --------------------------------------------
// DeleteTodoButton
// ...
methods: {
  deleteTodo: function (id) {
    eventHub.$emit('delete-todo', id)
  }
}
// --------------------------------------------
// Todos
// ...
created: function () {
  eventHub.$on('add-todo', this.addTodo)
  eventHub.$on('delete-todo', this.deleteTodo)
},
// 最好在组件销毁前
// 清除事件监听
beforeDestroy: function () {
  eventHub.$off('add-todo', this.addTodo)
  eventHub.$off('delete-todo', this.deleteTodo)
},
methods: {
  addTodo: function (newTodo) {
    this.todos.push(newTodo)
  },
  deleteTodo: function (todoId) {
    this.todos = this.todos.filter(function (todo) {
      return todo.id !== todoId
    })
  }
}
</code></pre>
<p>在简单的情况下可以这样用事件中心替代 <code>$dispatch</code> 和 <code>$broadcast</code>，但是对于大多数复杂情况，更推荐使用一个专用的状态管理层如：<a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">Vuex</a> ，Vuex意味着更多简明清晰的组件间通信和更好的状态管理方案。</p>
<h5 id="vuex"><a class="header-anchor" href="#vuex"></a>vuex</h5>
<p>本demo使用的就是vuex，见本项目TimeEntries.vue文件和src/store下的各个文件夹或 <a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></p>
<h2 id="最后还有小尾巴："><a class="header-anchor" href="#最后还有小尾巴："></a>最后还有小尾巴：</h2>
<ul>
<li>后台的代码主要在app.js文件里，已经解决了跨域请求的问题，还没有解释这部分代码</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> express </tag>
            
            <tag> MongoDB </tag>
            
            <tag> vuex </tag>
            
            <tag> 异步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[按条目展示表格数据小插件]]></title>
      <url>https://blog.az22c.top/2017/04/15/vue-table-nav/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/vue-table-nav" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-table-nav</a></p>
<p><a href="https://alexzhong22c.github.io/vue-table-nav/vue-table-nav.html" target="_blank" rel="noopener">demo</a> (在线演示初次加载会有点慢，请稍等)</p>
<a id="more"></a>
<hr>
<p>vue.js的出现，导致很多小插件的简单实现成为可能。</p>
<p>这是一个关于表格数据的分页导航，按照表格中的每个条目作为单元来展示数据。</p>
<p><strong>这样的数据呈现方式可读性更强，设计更人性化。</strong></p>
<p>当然它只适用于少量表格数据的直观呈现，如果数据太多，还是用传统的表格来呈现比较合适。demo的下方我还展示了原始的表格，方便各位看官做做对比。</p>
<p><img src="https://cloud.az22c.top/show-vue-table-nav.png-az22cgithub" alt></p>
<h2 id="分页导航"><a class="header-anchor" href="#分页导航"></a>分页导航</h2>
<ul>
<li>可设置每页显示的条目数</li>
<li>用vue的 计算属性 和对象数组的slice()实现分页显示，非常简便</li>
<li>在总页数比较多的情况下仍能维持导航样式的统一</li>
</ul>
<h2 id="引用boostrap的样式"><a class="header-anchor" href="#引用boostrap的样式"></a>引用boostrap的样式</h2>
<ul>
<li>css写得比较潦草，让大家见笑</li>
<li>对于class=“pagination”，直接从bootstrap库复制了那部分的css样式</li>
</ul>
<h2 id="用dl-dt-dd标签展示键值对"><a class="header-anchor" href="#用dl-dt-dd标签展示键值对"></a>用dl dt dd标签展示键值对</h2>
<ul>
<li>阻止dt标签之后的换行</li>
<li>阻止dd标签之前的空白</li>
<li><strong>为了方便阅读，直接用中文作为键值对的键名。在实际工程中当然不能这样。</strong></li>
</ul>
<h2 id="最后："><a class="header-anchor" href="#最后："></a>最后：</h2>
<blockquote>
<p>如果各位看官喜欢的话去留一个Star吧！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 表格 </tag>
            
            <tag> 插件 </tag>
            
            <tag> 条目 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭合浮动]]></title>
      <url>https://blog.az22c.top/2017/04/01/clearfix-n-bfc/</url>
      <content type="html"><![CDATA[<p>本文介绍闭合浮动，和对比两种“利用伪元素闭合浮动”的方案。</p>
<a id="more"></a>
<blockquote>
<p>提示：本文章内容最后修改时间为2017年04月，部分内容可能已经过时</p>
<p>本文部分内容参考 <a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="noopener">那些年我们一起清除过的浮动</a> ，但是 这位作者 的这篇文章有很多地方我都不认同，取其精华去其糟粕，所以本文并没有包含那些我所不认同的内容。</p>
</blockquote>
<h2 id="区分-清除浮动-和-闭合浮动"><a class="header-anchor" href="#区分-清除浮动-和-闭合浮动"></a>区分 清除浮动 和 闭合浮动</h2>
<ul>
<li>清除浮动：对应CSS中的属性是 clear：left | right | both | none；</li>
<li>闭合浮动：解决<strong>因为子元素浮动导致父元素高度塌陷</strong>的问题</li>
</ul>
<p>两者的区别 <a href="http://www.iyunlu.com/demo/enclosing-float-and-clearing-float/index.html" target="_blank" rel="noopener">请看Demo</a></p>
<h2 id="闭合浮动的一些老方法："><a class="header-anchor" href="#闭合浮动的一些老方法："></a>闭合浮动的一些老方法：</h2>
<ul>
<li>利用局部的“最后的元素”的“清除浮动”
<ul>
<li>【1】在子元素们的最后追加一个<code>style=&quot;clear:both&quot;</code>的空标签，这个不好</li>
<li>【2】在子元素们的最后追加一个br标签，使用br标签的<code>clear=&quot;all | left | right | none&quot;</code> 属性，因为一般不建议在HTML中使用br标签，这个也不好</li>
</ul>
</li>
<li>bfc 作为布局上下文
<ul>
<li>【3】通过<strong>设置父元素</strong>overflow值设置为hidden；在IE6中还需要触发 hasLayout ，例如 zoom：1；因为最终还是有补不了的bug被大家弃用</li>
<li>【4】通过<strong>设置父元素</strong>overflow值设置为auto，同样也有bug</li>
<li>【5】父元素也设置浮动，缺点是<strong>使得与父元素相邻的元素的布局会受到影响</strong>，不可能一直浮动到body，不推荐使用</li>
<li>【6】父元素设置display:table，盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用。文章最后还会再介绍到给<strong>父元素的伪元素设置display:table</strong>。</li>
</ul>
</li>
<li>利用伪元素after作为“最后的元素”的“清除浮动”  【如下文】</li>
</ul>
<h3 id="7-使用：after伪元素"><a class="header-anchor" href="#7-使用：after伪元素"></a>7. 使用<code>：after</code>伪元素</h3>
<blockquote>
<p>需要注意的是 :after是伪元素，不是伪类（另外，某些CSS手册里面称之为“伪对象”，不太对）。</p>
</blockquote>
<p>由于IE6-7不支持:after，要同时使用 zoom:1触发IE6和IE7的 hasLayout。<strong>在后面的demo中会介绍到。</strong></p>
<ul>
<li>优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）</li>
</ul>
<h3 id="不要使用方案3和4"><a class="header-anchor" href="#不要使用方案3和4"></a>不要使用方案3和4</h3>
<p>方案3、4通过overflow闭合浮动，实际上已经创建了新的 块级格式化上下文，而它们设置的对象都是父元素，这将导致其布局和相对于浮动的行为等发生一系列的变化，闭合浮动只不过是一系列变化中的一个作用而已。所以为了闭合浮动去改变全局特性，这是不明智的，带来的风险就是一系列的bug，比如firefox 早期版本产生 focus，截断绝对定位的层等等。始终要明白，如果单单只是需要闭合浮动，overflow就不要使用，而不是某些文章所说的“慎用”。</p>
<h3 id="父级div定义height的方法-不灵活"><a class="header-anchor" href="#父级div定义height的方法-不灵活"></a>父级div定义height的方法 #不灵活</h3>
<ul>
<li>父级div定义height，这样就<strong>不必闭合浮动</strong>了</li>
<li>不推荐使用，只建议高度固定的布局时使用</li>
</ul>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>通过对比，我们不难发现，其实以上列举的方法，无非有两类：</p>
<p>其一，通过在浮动元素的末尾添加一个空的元素</p>
<p>其二，通过设置父元素 overflow 或者display：table 属性来闭合浮动，原理就是BFC，下面探讨一下：</p>
<p>其三，「利用伪元素after作为“最后的元素”的“清除浮动”」之后再讲。</p>
<h2 id="深入理解伪元素闭合浮动"><a class="header-anchor" href="#深入理解伪元素闭合浮动"></a>深入理解伪元素闭合浮动</h2>
<p>上面已经列举了7种闭合浮动的方法，通过第三节分析的原理，我们发现其实更多的：对父元素使用display：table-cell，display：inline-block等只要触发了BFC的属性值都可以闭合浮动。</p>
<p>从各个方面比较，<strong>方案7</strong>：after伪元素闭合浮动无疑是相对比较好的解决方案了。这种思路的演进历史可以参考文章：<a href="https://css-tricks.com/snippets/css/clear-fix/" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/clear-fix/</a></p>
<p>而最后，方案7里面有两个最值得一提的“具体方案”：</p>
<h3 id="具体方案1：-仅供对比参考效果-理解debug-相对地不常用"><a class="header-anchor" href="#具体方案1：-仅供对比参考效果-理解debug-相对地不常用"></a>具体方案1： #仅供对比参考效果、理解debug;相对地不常用</h3>
<p>这种也是比较多人用的写法之一，但是流行程度相对地不如另一个写法。</p>
<pre><code class="language-css">.clearfix:before,
.clearfix:after {
content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both; }

.clearfix { *zoom:1; }
</code></pre>
<p>1）通过 content:&quot;.&quot;生成内容作为伪元素的内容</p>
<p>2）display:block 使生成的元素以块级元素显示,占满剩余空间;</p>
<p>3）height:0 避免生成内容破坏原有布局的高度。</p>
<p>4）visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;</p>
<p>5）同时要使用 zoom:1触发IE6和IE7的 hasLayout</p>
<p><strong>通过分析发现，除了clear：both用来清除浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0的缘故。</strong></p>
<p><strong>更重要的是，我认为这个方法根本就没产生 BFC 。</strong></p>
<blockquote>
<p>另外，不建议将content设置为空字符串&quot;&quot;，在firefox 7里面会看到它会产生空隙</p>
</blockquote>
<h3 id="最优具体方案2：-这种最为常用"><a class="header-anchor" href="#最优具体方案2：-这种最为常用"></a>最优具体方案2： #这种最为常用</h3>
<pre><code class="language-css">.clearfix:before,
.clearfix:after {
    content: &quot; &quot;; /* 1 */
    display: table; /* 2 */
}

.clearfix:after {
    clear: both;
}

.clearfix {
    *zoom: 1;
}
</code></pre>
<p>1. 使用content: &quot; &quot; 是为了避免Opera的bug，否则它会在 被清除浮动的元素的顶部和底部 产生一个看得出的空格</p>
<p>2. 这里对伪元素使用的<code>display: table;</code>会产生一个 <a href="http://www.w3.org/TR/CSS2/tables.html#anonymous-boxes" target="_blank" rel="noopener">anonymous boxes</a> 和一个BFC，这个BFC意味着before伪类会阻止上外边距的合并，同时after伪类会闭合浮动。</p>
<blockquote>
<p>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。</p>
</blockquote>
<p>**这个具体方案的好处是：**不用隐藏用content属性产生的内容，并且代码量特别少。</p>
<h4 id="设置before伪元素的作用：间接产生bfc-以阻止上外边距合并-显得上下对称"><a class="header-anchor" href="#设置before伪元素的作用：间接产生bfc-以阻止上外边距合并-显得上下对称"></a>设置before伪元素的作用：间接产生BFC，以阻止上外边距合并，显得上下对称</h4>
<p>设定before伪元素的属性<strong>并不是用来闭合浮动的，不过它能阻止上外边距的合并，</strong> 这会带来两个好处：</p>
<ul>
<li>这种清除浮动的方式所表现出来的外貌看上去和 其他的清除浮动的方式(比如overflow:hidden)的 一致。</li>
<li>和IE6/7使用zoom:1后的外貌保持一致</li>
</ul>
<p>毕竟，<strong>使用after伪元素闭合浮动</strong>的时候，<strong>下外边距的合并</strong>已经被阻止了，为了上下看上去对称，before伪元素也应该这样。</p>
<p>主要译自： <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">A new micro clearfix hack</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 清除浮动 </tag>
            
            <tag> BFC </tag>
            
            <tag> 伪元素 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task02笔记]]></title>
      <url>https://blog.az22c.top/2017/04/01/ife-css-task02/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="noopener">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<p>这篇文章的内容基本没有用在 <a href="https://ife-css-learning.az22c.vercel.app/task02.html" target="_blank" rel="noopener">demo</a> 中，这只是一番拓展性总结。</p>
<a id="more"></a>
<h2 id="css选择器优先级"><a class="header-anchor" href="#css选择器优先级"></a>CSS选择器优先级</h2>
<p>在文章 <a href="/2017/03/31/css-selectors-specificity/">CSS选择器优先级</a> 中我整合了这部分笔记。</p>
<h2 id="list-style-xxx"><a class="header-anchor" href="#list-style-xxx"></a>list-style-xxx</h2>
<p>我们常用list-style，实则它是一个 简写属性。</p>
<h3 id="list-style-type"><a class="header-anchor" href="#list-style-type"></a>list-style-type</h3>
<p>而<code>list-style-type</code>在CSS2中的新特性需要至少IE8的支持，所以我们一般只使用它在CSS1中的内容。况且，很少人提及list-style在移动设备浏览器上的支持，所以不能乱用。</p>
<p>另外，任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “decimal-leading-zero”、“lower-greek”、“lower-latin”、“upper-latin”、“armenian”、“georgian” 或 “inherit”。</p>
<p>可以使用的有：</p>
<ul>
<li>none</li>
</ul>
<p>用于无序列表的：</p>
<ul>
<li>disc 实心圆</li>
<li>circle 空心圆</li>
<li>square 实心方块</li>
</ul>
<p>用于有序列表的：</p>
<ul>
<li>decimal 数字</li>
<li>lower-alpha、upper-alpha</li>
<li>lower-roman、upper-roman</li>
</ul>
<h3 id="list-style-position"><a class="header-anchor" href="#list-style-position"></a>list-style-position</h3>
<p>默认值是outside，和inside的区别，看一下 <a href="http://www.w3school.com.cn/tiy/t.asp?f=csse_list-style-position" target="_blank" rel="noopener">demo</a> 马上就清楚</p>
<h3 id="list-style-image"><a class="header-anchor" href="#list-style-image"></a>list-style-image</h3>
<p>使用图像来替换列表项的标记。</p>
<p>这个属性指定作为一个有序或无序列表项标志的图像。图像相对于列表项内容的放置位置通常使用 list-style-position 属性控制。</p>
<p>注释：<strong>请始终规定一个 “list-style-type” 属性以防图像不可用。</strong></p>
<pre><code>ul {
  list-style:square outside url('/i/arrow.gif');
}
</code></pre>
<h2 id="border-collapse"><a class="header-anchor" href="#border-collapse"></a>border-collapse</h2>
<p>默认值是separate，不会忽略border-spacing和empty-cells属性。</p>
<p>collapse会忽略border-spacing和empty-cells属性。</p>
<p>注释：如果没有规定 !DOCTYPE，则 border-collapse 可能产生意想不到的结果。</p>
<h2 id="text-indent"><a class="header-anchor" href="#text-indent"></a>text-indent</h2>
<p>直接参考：<a href="http://ued.ctrip.com/blog/text-indent-summing-up.html" target="_blank" rel="noopener">http://ued.ctrip.com/blog/text-indent-summing-up.html</a></p>
<p>其总结就是：</p>
<p>1.text-indent只用于div，p这样的元素上，像image、input、inline-block、inline元素绝对不用。</p>
<p>2.text-indent的值如果子元素也要用到父元素的值，用px单位，而绝不用em。</p>
<h2 id="禁止用户选择文字"><a class="header-anchor" href="#禁止用户选择文字"></a>禁止用户选择文字</h2>
<p>一般情况下用<code>user-select:none</code>，</p>
<p>IE6-9不支持该属性，但支持使用标签属性 <code>onselectstart=&quot;return false;&quot;</code> 来达到 <code>user-select:none</code> 的效果；Safari和Chrome也支持该标签属性；</p>
<p>直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 <code>unselectable=&quot;on&quot;</code> 来达到 <code>user-select:none</code> 的效果；unselectable 的另一个值是 off；</p>
<p>除Chrome和Safari外，在其它浏览器中，如果将文本设置为 <code>-ms-user-select:none;</code>，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 <code>-ms-user-select:none;</code> 的区域文本；</p>
<p><strong>所以，“禁止用户选择文字”一般是用来引导用户在界面的操作，而不能用来 控制用户的行为 或者 重度依赖这个trick。</strong></p>
<p>参考： <a href="http://www.css88.com/book/css/properties/user-interface/user-select.htm" target="_blank" rel="noopener">user-select-css88</a> 说明很完备。</p>
<pre><code class="language-html">&lt;body&gt;
前方的文字&lt;div class=&quot;test&quot; onselectstart=&quot;return false;&quot; unselectable=&quot;on&quot;&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>CSS代码：</p>
<pre><code class="language-css">.test{
  -webkit-user-select:none;
  -moz-user-select:none;
  -o-user-select:none;
  user-select:none;
  /*onselectstart和unselectable在html那里*/
}
</code></pre>
<p><strong>另外，结合JavaScript代码来实现禁止效果，效果会更好。</strong></p>
<p>例如：<a href="http://stackoverflow.com/questions/2700000/how-to-disable-text-selection-using-jquery" target="_blank" rel="noopener">http://stackoverflow.com/questions/2700000/how-to-disable-text-selection-using-jquery</a></p>
<h2 id="text-align"><a class="header-anchor" href="#text-align"></a>text-align</h2>
<p><a href="http://www.css88.com/book/css/properties/text/text-align.htm" target="_blank" rel="noopener">text-align–CSS88</a> 还介绍了单行文字怎么应用justify</p>
<h2 id="fieldset默认样式隐藏"><a class="header-anchor" href="#fieldset默认样式隐藏"></a>fieldset默认样式隐藏</h2>
<p>看到一篇文章介绍 <a href="http://canfly2010.iteye.com/blog/678584" target="_blank" rel="noopener">Extjs FieldSet组件</a> 的文章很有趣，这个组件的目的是将fieldset的边框去掉或者改变内边距。</p>
<p>学到的一个知识是：</p>
<blockquote>
<p>fieldset默认是带边框的，而legend默认一般显示在左上角。但在某些场合或许不愿意让fieldset和legend的默认样式或默认布局影响设计方案中的美观。</p>
<p>解决方法：在CSS中将fieldset的border设置为0，legend的display设置为none即可。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> list-style </tag>
            
            <tag> 文字 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS选择器优先级]]></title>
      <url>https://blog.az22c.top/2017/03/31/css-selectors-specificity/</url>
      <content type="html"><![CDATA[<p>CSS优先级计算的快速回顾，最后附上一些应用知识的实例。</p>
<a id="more"></a>
<h2 id="计算特殊性值的情况"><a class="header-anchor" href="#计算特殊性值的情况"></a>计算特殊性值的情况</h2>
<p>选择器的特殊性值 由4个位构成，基础值用 0,0,0,0 表示，为了方便描述用 A,B,C,D 分别对应代表各个位：</p>
<p>能令A位增加的：行间样式</p>
<p>能令B位增加的：ID选择器</p>
<p>能令C位增加的：类选择器、属性选择器或伪类</p>
<p>能令D位增加的：元素和伪元素</p>
<p><strong>通配选择器 *</strong> 对特殊性值没有贡献，也当做是经过加 0 计算了</p>
<hr>
<p>例如：以下规则中选择器的特殊性分别是：</p>
<pre><code>a{color: yellow;} /*特殊性值：0,0,0,1*/
div a{color: green;} /*特殊性值：0,0,0,2*/
.demo a{color: black;} /*特殊性值：0,0,1,1*/
.demo input[type=&quot;text&quot;]{color: blue;} /*特殊性值：0,0,2,1*/
.demo *[type=&quot;text&quot;]{color: grey;} /*特殊性值：0,0,2,0*/
#demo a{color: orange;} /*特殊性值：0,1,0,1*/
div#demo a{color: red;} /*特殊性值：0,1,0,2*/
</code></pre>
<p><a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="noopener">验证结果参考demo</a></p>
<h3 id="应对常见疑问："><a class="header-anchor" href="#应对常见疑问："></a>应对常见疑问：</h3>
<ul>
<li>这些所谓的“特殊性值”不会进位</li>
<li><strong>假如特殊性值相同</strong>的两条规则应用到同一个元素，只有后声明的那条规则会生效</li>
<li>由上文可得：外联样式优先级并不一定低于内联样式</li>
</ul>
<blockquote>
<p>外联样式指的是，样式放在.css文件里，然后html引用该文件</p>
<p>内联样式指的是，样式放在head标签的style标签里面</p>
<p>行内样式指的是，写在具体元素的style属性里面的样式</p>
</blockquote>
<h2 id="不计算特殊性值的情况"><a class="header-anchor" href="#不计算特殊性值的情况"></a>不计算特殊性值的情况</h2>
<ul>
<li><code>!important</code>(权重) 优先于 任何需要计算的特殊性值，可以视它为1,0,0,0,0</li>
<li><strong>通配选择器 *</strong> 定义的规则 优先于 元素<strong>继承</strong>过来的规则</li>
</ul>
<h2 id="not伪类例外"><a class="header-anchor" href="#not伪类例外"></a><code>:not</code>伪类例外</h2>
<ul>
<li><code>:not</code> 否定伪类。
<ul>
<li>本身在优先级计算中不会被看作是伪类</li>
<li>即本身对“特殊性值”没贡献</li>
<li><strong>而它括号里面的选择器对“特殊性值”是有贡献的</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
div.outer p {
  color:red;
}
div:not(.outer) p {
  color: blue;
}
&lt;/style&gt;
&lt;div class=&quot;outer&quot;&gt;
  &lt;p&gt;This is in the outer div.&lt;/p&gt;
  &lt;div class=&quot;inner&quot;&gt;
    &lt;p&gt;This text is in the inner div.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>结果：</p>
<p>“This is in the outer div.”红色；“This text is in the inner div.”蓝色。</p>
<p>解释：</p>
<p>选择器div.outer p 和选择器div:not(.outer) p的优先级是相同的。</p>
<p>:not被忽略掉了。</p>
<p>:not(.outer)中的.outer正常计数。</p>
<h2 id="知识应用实例"><a class="header-anchor" href="#知识应用实例"></a>知识应用实例</h2>
<h3 id="a的四种状态选择器"><a class="header-anchor" href="#a的四种状态选择器"></a>a的四种状态选择器</h3>
<p>我们知道a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active。</p>
<p>如果用这四个伪类对同一个元素设置同一个属性，那它们的<strong>声明顺序</strong>应该有一定要求，一般大家都遵循“爱恨原则LVHA”（LoVe HAte），为什么是这个顺序？不能是其它顺序吗？</p>
<blockquote>
<p>当鼠标滑过a链接时，满足:link和:hover两个伪类，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；同理，当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。</p>
</blockquote>
<p>因此得出LVHA这个顺序。</p>
<blockquote>
<p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</p>
</blockquote>
<p><strong>对于:hover在IE6下只有a元素支持，:active只有IE6-7不支持，:focus在IE6-7下不被支持。</strong>  <a href="https://www.quirksmode.org/css/selectors/" target="_blank" rel="noopener">查阅文档</a></p>
<h3 id="继承失效实例"><a class="header-anchor" href="#继承失效实例"></a>继承失效实例</h3>
<h4 id="代码示例："><a class="header-anchor" href="#代码示例："></a>代码示例：</h4>
<pre><code class="language-html">&lt;p&gt;Hello,&lt;span&gt;CSS&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p>CSS代码：</p>
<pre><code class="language-css">* {
    color:red;
}
p {
    color:green;
}
</code></pre>
<p>结果：<code>span</code>标签内的文本颜色是红色，而不是绿色。</p>
<h4 id="解释："><a class="header-anchor" href="#解释："></a>解释：</h4>
<p>我们常用*来做CSS reset，这常见的问题是<strong>导致继承失效</strong>：</p>
<p>继承的样式根本没有任何特殊性，而使用通配选择器<code>*</code>的声明具有0, 0, 0, 0特殊性。当二者冲突时，通配选择器胜出，导致继承失效。</p>
<p>自己写 CSS 时不要滥用 <code>*</code>，reset.css 也只是设置 margin, padding, box-sizing 等少数几个属性时才使用，这几个被重置的属性都不继承。</p>
<p>另外，不要用<code>*</code>设置font-family</p>
<h2 id="进一步理解-important"><a class="header-anchor" href="#进一步理解-important"></a>进一步理解<code>!important</code></h2>
<p>绝大多数情况下，都不要直接用<code>!important</code>。</p>
<p>因为(对于某个元素的样式)只要用1次了<code>!important</code>，绝大多数的其他的样式选择器规则都因为优先级不够而失效。那么后期再想覆盖它的样式，就需要继续增加<code>!important</code>类型样式，样式表极其难维护。</p>
<h3 id="什么时候应该使用："><a class="header-anchor" href="#什么时候应该使用："></a>什么时候应该使用：</h3>
<p>你的网站上有一个设定了全站样式的CSS文件，同时你（或是你同事）写了一些效果很差的<code>行内样式</code>（行内样式的优先级是最高的）。</p>
<p>在这种情况下，你就可以在你全局的CSS文件中写一些<code>!important</code>的样式来覆盖掉那些直接写在元素上的<code>行内样式</code>。</p>
<p>活生生的例子比如：有人在jQuery插件里写了糟糕的行内样式。</p>
<hr>
<p>参考：<a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="noopener">css优先级计算规则–王美建</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS选择器 </tag>
            
            <tag> 优先级 </tag>
            
            <tag> 权重 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H5新标签和被H5拥抱的老元素们]]></title>
      <url>https://blog.az22c.top/2017/03/28/h5-new-ele/</url>
      <content type="html"><![CDATA[<p>事实上，所有元素都能被归类为几个 元素内容模型（content model），详情请参考MDN：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories</a></p>
<p>这里不大谈内容模型，只不过按照这种思路划分我们的元素，谈谈那些比较广为接受的HTML5新元素和那些被HTML5拥抱的老元素。</p>
<a id="more"></a>
<h2 id="元数据内容"><a class="header-anchor" href="#元数据内容"></a>元数据内容</h2>
<h3 id="base元素"><a class="header-anchor" href="#base元素"></a>base元素</h3>
<p>老元素，假如你不是使用前端框架，基本上都可以用到。</p>
<p>base元素为页面上的所有的相对链接规定默认 URL 或默认目标，所以最好放在head元素里比较靠前的位置。</p>
<p><strong>在一个文档中，最多能使用一个 base 元素。base 元素必须位于 head 元素内部。</strong></p>
<p><strong>如果使用了 base 标签，则必须具备 href 属性或者 target 属性或者两个属性都具备。</strong></p>
<pre><code class="language-html">&lt;head&gt;
&lt;base href=&quot;http://www.runoob.com/images/&quot; target=&quot;_blank&quot;&gt;
&lt;/head&gt;
 
&lt;body&gt;
&lt;img src=&quot;logo.png&quot; width=&quot;24&quot; height=&quot;39&quot; alt=&quot;Stickman&quot;&gt;
&lt;a href=&quot;http://www.runoob.com&quot;&gt;runoob.com&lt;/a&gt;
&lt;/body&gt;
</code></pre>
<p>href属性：规定页面中所有相对链接的基准 URL。</p>
<p>target属性：规定页面中所有的超链接和表单在何处打开。该属性会被每个链接中的 target 属性覆盖。</p>
<h3 id="noscript元素"><a class="header-anchor" href="#noscript元素"></a>noscript元素</h3>
<p>老元素，浏览器们都支持。</p>
<p>此标签可被用于可识别 noscript 标签但无法支持js脚本的时候，通常写上它也不会有什么损失。</p>
<p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p>
<blockquote>
<p>其他“元数据内容”标签的介绍可在此先省略。</p>
</blockquote>
<h2 id="章节元素-sectioning-content"><a class="header-anchor" href="#章节元素-sectioning-content"></a>章节元素（Sectioning content）</h2>
<p>在当前的大纲中创建一个<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="noopener">分节</a>，此分节将定义 <a href="#header%E5%85%83%E7%B4%A0">header元素</a>、<a href="#footer%E5%85%83%E7%B4%A0">footer元素</a> 和“标题元素”的范围。</p>
<blockquote>
<p>属于此类的H5元素总共有：</p>
<ul>
<li><a href="#article%E5%85%83%E7%B4%A0">article元素</a></li>
<li><a href="#section%E5%85%83%E7%B4%A0">section元素</a></li>
<li><a href="#aside%E5%85%83%E7%B4%A0">aside元素</a></li>
<li><a href="#nav%E5%85%83%E7%B4%A0">nav元素</a></li>
</ul>
<p><strong>都是比较新出的元素，还好IE9及以上都作了基本支持。</strong></p>
<p>用法可参考 <a href="https://ife-css-learning.az22c.vercel.app/task02.html" target="_blank" rel="noopener">demo</a></p>
</blockquote>
<h3 id="article元素"><a class="header-anchor" href="#article元素"></a>article元素</h3>
<p>article元素 表示文档、页面、应用或网站中的<strong>独立结构</strong>，其意在成为<strong>可独立分配的或可复用的结构</strong>。</p>
<p>如在发布中，它可能是论坛帖子或新闻文章、博客文章、用户提交的评论、交互式组件，或者其他独立的内容项目。</p>
<p><strong>用时要特别注意内容的独立性：一般独立完整的内容才使用article元素，如果只是一段内容的话应该是用section元素。</strong></p>
<blockquote>
<p>使用说明：</p>
<ul>
<li>当 article元素 嵌套使用时，则该元素代表与外层元素有关的文章。
<ul>
<li>例如，代表博客评论的 article元素 可嵌套在代表博客文章的 article元素 中。</li>
</ul>
</li>
<li>article元素 的作者信息可通过 <a href="#address%E5%85%83%E7%B4%A0">address元素</a> 提供，但是不适用于嵌套的 article元素。</li>
<li>article元素 的发布日期和时间可通过 <a href="#time%E5%85%83%E7%B4%A0">time元素</a> 表示。</li>
</ul>
</blockquote>
<h3 id="section元素"><a class="header-anchor" href="#section元素"></a>section元素</h3>
<ul>
<li>用于定义文章中的章节(通常应该有标题和段落内容)。</li>
</ul>
<ul>
<li>用来定义文档中特定的内容区块，可视为一个区域分组元素。</li>
</ul>
<ul>
<li>用一句话来概括它的作用就是：给内容分段，给页面分区。</li>
</ul>
<ul>
<li>注意它与div的区别，div强调在形式上的独立性，section强调的是内容上的独立性，注意它的语义。</li>
</ul>
<blockquote>
<p>article和section对比：</p>
<p>1.语义不同：article元素是独立完整的内容，section元素页面内容分块。</p>
<p>2.相同点：本质上都是带有语义的div块元素 。</p>
<p>分别可以看做<code>&lt;div id=&quot;section&quot;&gt;</code>和<code>&lt;div id=&quot;article&quot;&gt;</code></p>
</blockquote>
<h3 id="aside元素"><a class="header-anchor" href="#aside元素"></a>aside元素</h3>
<ul>
<li>aside元素通常用来设置侧边栏。</li>
<li>用于定义article元素之外的内容，前提是这些内容与article元素内的内容相关。</li>
<li>同时也可嵌套在article元素内部使用，作为主要内容的附属信息。比如与内容有关的参考资料，名词解释等。</li>
</ul>
<h3 id="nav元素"><a class="header-anchor" href="#nav元素"></a>nav元素</h3>
<ul>
<li>用来定义目录、导航栏。</li>
<li>并非所有的超链接都放在nav元素中，<strong>通常只把一个文档中的主导航栏放在nav中。</strong></li>
</ul>
<h2 id="流式元素"><a class="header-anchor" href="#流式元素"></a>流式元素</h2>
<blockquote>
<p><strong>header元素 和 footer元素 都是比较新出的元素，还好IE9及以上都作了基本支持。</strong></p>
<p>用法可参考 <a href="https://ife-css-learning.az22c.vercel.app/task02.html" target="_blank" rel="noopener">demo</a></p>
</blockquote>
<h3 id="header元素"><a class="header-anchor" href="#header元素"></a>header元素</h3>
<p>header元素 表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</p>
<h3 id="footer元素"><a class="header-anchor" href="#footer元素"></a>footer元素</h3>
<p>footer元素 表示最近一个章节内容或者 根节点元素 的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p>
<blockquote>
<ul>
<li>footer元素 内的作者信息应包含在 <a href="#address%E5%85%83%E7%B4%A0">address元素</a> 中。</li>
<li>footer元素 不是章节内容，因此在<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="noopener">outline</a>中不能包含新的章节。</li>
</ul>
</blockquote>
<h3 id="address元素"><a class="header-anchor" href="#address元素"></a>address元素</h3>
<p>address元素 虽然是老元素，但是一直大受 WHATWG组织 青睐，也进入了HTML5行列，浏览器兼容很好，尽量使用。</p>
<p>HTML的 address元素 可以让作者为它最近的 <code>&lt;article&gt;</code> 或者 <code>&lt;body&gt;</code> 祖先元素提供联系信息。在后一种情况下，它应用于整个文档。</p>
<ul>
<li>通常用来说明作者的联系信息，例如名字、E-mail、电话、地址等。</li>
<li>address元素中的内容会以斜体显示。</li>
<li>通常， address元素 可以放在当前section的 footer元素中，如果存在的话。</li>
<li>浏览器兼容很好，尽量使用。</li>
</ul>
<hr>
<blockquote>
<p>HTML5强调多媒体在网页的嵌入：</p>
<ul>
<li>figure元素 和 figcaption元素</li>
<li>video元素</li>
</ul>
<p>在IE9及之后都可以支持基本的使用。</p>
</blockquote>
<h3 id="figure元素"><a class="header-anchor" href="#figure元素"></a>figure元素</h3>
<p>figure元素 是一个媒体组合元素，也就是对其他的媒体元素（比如：图像、图标等等）进行组合后代表一段独立的内容。</p>
<p>当它属于主体(main flow)时，它的位置独立于主体。当 figure元素 转移到附录中或者其他页面时不会影响到主体。</p>
<p>经常与 figcaption元素 配合使用，并且作为一个独立的引用单元。</p>
<h3 id="figcaption元素"><a class="header-anchor" href="#figcaption元素"></a>figcaption元素</h3>
<p>是与其相关联的图片的说明/标题，用于描述其父节点 figure元素 里的其他数据。</p>
<p><strong>这意味着 figcaption元素 是 figure元素块里的第一个或者最后一个。</strong></p>
<p>同时，该元素是可以使用，也可以不使用的。</p>
<pre><code>&lt;figure&gt;
  &lt;img src=&quot;https://developer.cdn.mozilla.net/media/img/mdn-logo-sm.png&quot; alt=&quot;An awesome picture&quot;&gt;	
  &lt;figcaption&gt;Fig1. MDN Logo&lt;/figcaption&gt;
&lt;/figure&gt;
</code></pre>
<h3 id="video元素"><a class="header-anchor" href="#video元素"></a>video元素</h3>
<p>该元素的各个属性才是研究的重点，需要大家去深入总结。</p>
<h2 id="短语元素"><a class="header-anchor" href="#短语元素"></a>短语元素</h2>
<h3 id="time元素"><a class="header-anchor" href="#time元素"></a>time元素</h3>
<p>浏览器的支持非常差，最好把它当做一个有“时间”语义的 span标签 来用。尽量不使用它的属性。</p>
<pre><code>&lt;p&gt;The concert starts at &lt;time&gt;20:00&lt;/time&gt;.&lt;/p&gt;
</code></pre>
<h3 id="mark元素"><a class="header-anchor" href="#mark元素"></a>mark元素</h3>
<p>HTML5中的全新标签，需要IE9及以上的浏览器。不过低版本浏览器用了也无妨，只不过该标签没有默认的CSS样式而已。</p>
<p>突出一段文字，这段文字通常是被外部引用/需要被搜索引擎搜索获得/用来方便读者的某种特定的审阅。</p>
<blockquote>
<ul>
<li>虽然 mark元素 本身有高亮效果，但是不要为了语法高亮而使用 mark元素，这时候应该使用 strong元素达到语法高亮。</li>
<li>mark元素 通常用于标注<strong>用来衔接上下文关系的文本</strong>，而strong元素用来标注在该大段文字中的重要语句。</li>
</ul>
</blockquote>
<h3 id="cite元素"><a class="header-anchor" href="#cite元素"></a>cite元素</h3>
<p>老元素，通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</p>
<p>按照惯例，引用的文本将以斜体显示。</p>
<p>cite标签 还有一个隐藏的功能：它可以使你或者其他人从文档中自动摘录参考书目。我们可以很容易地想象一个浏览器，它能够自动整理引用表格，并把它们作为脚注或者独立的文档来显示。</p>
<h2 id="表单相关内容"><a class="header-anchor" href="#表单相关内容"></a>表单相关内容</h2>
<blockquote>
<p>HTML5推崇新的表单控件，<strong>以及 表单相关的老元素 的更合理的使用，</strong> 这些老元素中常用的有：</p>
<ul>
<li>form元素</li>
<li>fieldset元素</li>
<li>legend元素</li>
<li>label元素</li>
</ul>
<p>用法可参考 <a href="https://ife-css-learning.az22c.vercel.app/task02.html" target="_blank" rel="noopener">demo</a></p>
</blockquote>
<h3 id="form元素"><a class="header-anchor" href="#form元素"></a>form元素</h3>
<p>和表单相关的元素都由 form元素 包着，一个form代表一个表单。</p>
<h3 id="fieldset元素"><a class="header-anchor" href="#fieldset元素"></a>fieldset元素</h3>
<p>通常用来对表单的相关元素进行分组，如果不需要分组就可以直接不用fieldset这一层。</p>
<p>HTML5 中新增了一些 fieldset元素 的新属性：disabled、form、name，而HTML 4.01 中不支持这些属性。</p>
<p><strong>目前，这些新属性被浏览器们支持得都很差。不建议fieldset使用任何属性。</strong></p>
<h3 id="legend元素"><a class="header-anchor" href="#legend元素"></a>legend元素</h3>
<p>legend元素 代表一个用于表示 它的父元素<code>&lt;fieldset&gt;</code> 的内容的标题。</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Title&lt;/legend&gt;
    &lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio&quot;&gt; &lt;label for=&quot;radio&quot;&gt;Click me&lt;/label&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h3 id="label元素"><a class="header-anchor" href="#label元素"></a>label元素</h3>
<p>label元素 表示用户界面中项目的标题。</p>
<pre><code>&lt;form&gt;
  &lt;label for=&quot;GET-name&quot;&gt;Name:&lt;/label&gt;
  &lt;input id=&quot;GET-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;
&lt;/form&gt;
</code></pre>
<h4 id="使用-label配合控件使用："><a class="header-anchor" href="#使用-label配合控件使用："></a>使用 label配合控件使用：</h4>
<p>在下面这个例子中，点击label会选中对应的input控件。靠的就是 for属性 和 id属性 产生的联系。</p>
<pre><code>&lt;label for=&quot;User&quot;&gt;Click me&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;
</code></pre>
<h3 id="progress元素"><a class="header-anchor" href="#progress元素"></a>progress元素</h3>
<p><strong>需要IE10及以上的浏览器。</strong></p>
<p>标示任务的进度：</p>
<pre><code>&lt;progress value=&quot;22&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 
</code></pre>
<h2 id="提高html代码性能的几点建议："><a class="header-anchor" href="#提高html代码性能的几点建议："></a>// 提高HTML代码性能的几点建议：</h2>
<h3 id="语义化标记"><a class="header-anchor" href="#语义化标记"></a>语义化标记</h3>
<p>语义指意义相关的事物，HTML 可从页面内容中看出语义：元素和属性的命名一定程度上表达了内容的角色和功能。HTML5 引入了新的语义元素，如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>及<code>&lt;nav&gt;</code>。</p>
<p>选择合适的元素来编写代码可保证代码的易读性：</p>
<ul>
<li>使用<code>&lt;h1&gt;</code>(<code>&lt;h2&gt;</code>,<code>&lt;h3&gt;</code>…)表示标题，<code>&lt;ul&gt;</code>或<code>&lt;ol&gt;</code>实现列表</li>
<li>注意使用<code>&lt;article&gt;</code>标签之前应添加<code>&lt;h1&gt;</code>标签；</li>
<li>选择合适的HTML5语义元素如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>,<code>&lt;nav&gt;</code>,<code>&lt;aside&gt;</code>;</li>
<li>使用<code>&lt;p&gt;</code>描述Body 文本，HTML5 语义元素可以形成内容，反之不成立。</li>
<li>使用<code>&lt;label&gt;</code>元素，输入类型，占位符及其他属性来强制验证。</li>
<li>将文本和元素混合，并作为另一元素的子元素，会导致布局错误。</li>
<li>img元素记得加alt属性。</li>
</ul>
<h4 id="i-b-em-strong元素"><a class="header-anchor" href="#i-b-em-strong元素"></a>i/b/em/strong元素</h4>
<p><code>&lt;em&gt;</code> 用于对文本内容进行强调，强调位置的不同通常会改变句子的含义。如果仅仅在语态或语气上为了突出某一个文本，那应该使用<code>&lt;i&gt;</code>。</p>
<p>但如果为了突出某一部分的重要性、严重性或紧急性，那应该使用 <code>&lt;strong&gt;</code>。根据 W3C 对 <code>&lt;b&gt;</code>元素的说明，<code>&lt;b&gt;</code>元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签。</p>
<p>相同的，在考虑使用 <code>&lt;i&gt;</code> 之前，也要想想是否用<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;dfn&gt;</code> 或 <code>&lt;mark&gt;</code> 等元素更合适。</p>
<h3 id="布局"><a class="header-anchor" href="#布局"></a>布局</h3>
<p>要提高HTML代码的性能，要遵循HTML 代码以实现功能和为目标，而不是样式。</p>
<ul>
<li>使用<code>&lt;p&gt;</code>元素修饰文本，而不是布局；默认<code>&lt;p&gt;</code>是自动提供边缘，而且其他样式也是浏览器默认提供的。</li>
<li>避免使用<code>&lt;br&gt;</code>分行，可以使用block元素或CSS显示属性来代替。</li>
<li>避免使用<code>&lt;hr&gt;</code>来添加水平线，可使用CSS的border-bottom 来代替。</li>
<li>不到关键时刻不要使用div标签。</li>
<li>尽量少用Tables来布局。</li>
<li>可以多使用Flex Box</li>
<li>使用CSS 来调整边距等。</li>
</ul>
<h2 id="被嫌弃的h5标签们："><a class="header-anchor" href="#被嫌弃的h5标签们："></a>// 被嫌弃的H5标签们：</h2>
<p><a href="http://www.w3school.com.cn/tags/tag_command.asp" target="_blank" rel="noopener">command标签</a> ：</p>
<p>目前只有IE支持。</p>
<p><a href="http://www.qianxingzhem.com/post-1882.html" target="_blank" rel="noopener">hgroup标签</a> ：</p>
<p>用来表明标题的集合，这样功能就比较鸡肋了，在最新的 HTML5.1 版中被废除了。</p>
<p><a href="http://www.w3school.com.cn/tags/tag_keygen.asp" target="_blank" rel="noopener">keygen标签</a> ：</p>
<p>IE和Safari都不支持。</p>
<p><a href="http://www.w3school.com.cn/tags/tag_meter.asp" target="_blank" rel="noopener">meter标签</a> ：</p>
<p>IE不支持。</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task01笔记]]></title>
      <url>https://blog.az22c.top/2017/03/27/ife-css-task01/</url>
      <content type="html"><![CDATA[<p>因为大家对html代码不是很重视，所以整理了一些容易忽略的问题并且对一些知识点作了梳理。</p>
<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="noopener">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<p>task01其实就是对HTML的学习，对应的代码其实就是task02的<a href="https://ife-css-learning.az22c.vercel.app/task02.html" target="_blank" rel="noopener">demo</a>的HTML部分。</p>
<a id="more"></a>
<h2 id="细节问题总结"><a class="header-anchor" href="#细节问题总结"></a>细节问题总结</h2>
<h3 id="i-b-em-strong元素"><a class="header-anchor" href="#i-b-em-strong元素"></a>i/b/em/strong元素</h3>
<p><code>&lt;em&gt;</code> 用于对文本内容进行强调，强调位置的不同通常会改变句子的含义。如果仅仅在语态或语气上为了突出某一个文本，那应该使用<code>&lt;i&gt;</code>。</p>
<p>但如果为了突出某一部分的重要性、严重性或紧急性，那应该使用 <code>&lt;strong&gt;</code>。根据 W3C 对 <code>&lt;b&gt;</code>元素的说明，<code>&lt;b&gt;</code>元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签。</p>
<p>相同的，在考虑使用 <code>&lt;i&gt;</code> 之前，也要想想是否用<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;dfn&gt;</code> 或 <code>&lt;mark&gt;</code> 等元素更合适。</p>
<h3 id="单标签要闭合吗"><a class="header-anchor" href="#单标签要闭合吗"></a>单标签要闭合吗</h3>
<p>一句话总结，xhtml严格要求空标签必须自闭合，html5又不要求自闭合但是兼容xhtml的自闭合写法。</p>
<h3 id="alt属性"><a class="header-anchor" href="#alt属性"></a>alt属性</h3>
<p>为了写优雅的代码：img元素记得加alt属性。</p>
<h3 id="表单控件"><a class="header-anchor" href="#表单控件"></a>表单控件</h3>
<ul>
<li>name对于radio很重要；name对于checkbox很重要</li>
<li>对于表单中的单选radio控件和复选checkbox控件以及下拉框select控件，可以为radio, checkbox添加checked属性以及为option添加selected属性让其默认选中</li>
</ul>
<h3 id="h5加id的观点"><a class="header-anchor" href="#h5加id的观点"></a>H5加id的观点</h3>
<p>虽然语义化标签好用，但是当它需要加id的时候还是加吧：id=“header”</p>
<hr>
<h3 id="form元素"><a class="header-anchor" href="#form元素"></a>form元素</h3>
<p>和表单相关的元素都由 form元素 包着，一个form代表一个表单。</p>
<h3 id="fieldset元素"><a class="header-anchor" href="#fieldset元素"></a>fieldset元素</h3>
<p>通常用来对表单的相关元素进行分组，如果不需要分组就可以直接不用fieldset这一层。</p>
<p>HTML5 中新增了一些 fieldset元素 的新属性：disabled、form、name，而HTML 4.01 中不支持这些属性。</p>
<p><strong>目前，这些新属性被浏览器们支持得都很差。不建议fieldset使用任何属性。</strong></p>
<h3 id="legend元素"><a class="header-anchor" href="#legend元素"></a>legend元素</h3>
<p>legend元素 代表一个用于表示 它的父元素<code>&lt;fieldset&gt;</code> 的内容的标题。</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Title&lt;/legend&gt;
    &lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio&quot;&gt; &lt;label for=&quot;radio&quot;&gt;Click me&lt;/label&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h3 id="label元素"><a class="header-anchor" href="#label元素"></a>label元素</h3>
<p>label元素 表示用户界面中项目的标题。</p>
<pre><code>&lt;form&gt;
  &lt;label for=&quot;GET-name&quot;&gt;Name:&lt;/label&gt;
  &lt;input id=&quot;GET-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;
&lt;/form&gt;
</code></pre>
<h4 id="使用-label配合控件使用："><a class="header-anchor" href="#使用-label配合控件使用："></a>使用 label配合控件使用：</h4>
<p>在下面这个例子中，点击label会选中对应的input控件。靠的就是 for属性 和 id属性 产生的联系。</p>
<pre><code>&lt;label for=&quot;User&quot;&gt;Click me&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;
</code></pre>
<hr>
<h3 id="和按钮相关的元素"><a class="header-anchor" href="#和按钮相关的元素"></a>和按钮相关的元素</h3>
<p>在一个页面上画一个按钮，有四种办法：</p>
<ul>
<li><code>&lt;input type=&quot;button&quot; /&gt;</code>这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><code>&lt;input type=&quot;submit&quot; /&gt;</code> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。</li>
<li><code>&lt;button&gt;</code>这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题（<a href>葛亮</a>）。</li>
<li>其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。</li>
</ul>
<p>type=&quot;button&quot;和type=&quot;submit&quot;各写一个，绑个alert或者dom操作。可以发现：button如果没别的，就会一动不动；submit如果没别的，就会刷新页面（应该是一闪然后保持原页面）；sb绑了dom，就是js的效果一闪，然后保持原页面。可以写js事件来绑定button，js是客户端的。但submit的实质作用是提交给服务端的，不是写个js阻止就能完事。</p>
<h3 id="dl-dt-dd元素"><a class="header-anchor" href="#dl-dt-dd元素"></a>dl dt dd元素</h3>
<p>严格来说定义列表只用来<strong>标记字典或术语表</strong>这样的结构，也有一说是它也可以用来标记对话。在实践中，如果有一系列的“标题 + 详情”这样的结构，使用定义列表也勉强说得过去。但实际上是有更好的标记方式，比如 hx + div/p 本身就表达了标题与详情的对应关系；如果一定要强调这一系列数据的并列关系，可以在外围使用 ul 或 ol。</p>
<p><a href="http://know.webhek.com/html5/html-dl-dt-dd.html" target="_blank" rel="noopener">http://know.webhek.com/html5/html-dl-dt-dd.html</a></p>
<p><a href="http://www.cnblogs.com/duhuo/p/5656511.html" target="_blank" rel="noopener">http://www.cnblogs.com/duhuo/p/5656511.html</a></p>
<h2 id="h5新标签和被h5拥抱的老元素们"><a class="header-anchor" href="#h5新标签和被h5拥抱的老元素们"></a>H5新标签和被H5拥抱的老元素们</h2>
<ul>
<li>在HTML5之后，哪些新标签可以放心使用、哪些老标签需要继续使用？</li>
<li>这个demo用到的标签的详细介绍？</li>
</ul>
<p>这些话题的主要内容都写到了我的博客里： <a href="/2017/03/28/h5-new-ele/">H5新标签和被H5拥抱的老元素们</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
            <tag> IFE </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IIFE回顾]]></title>
      <url>https://blog.az22c.top/2017/03/10/iife-intro/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="定义"><a class="header-anchor" href="#定义"></a>定义</h2>
<p>IIFE: 意为立即调用的函数表达式，也就是说，<strong>声明函数的同时立即调用这个函数。</strong></p>
<h3 id="对比"><a class="header-anchor" href="#对比"></a>对比</h3>
<p>如果不采用IIFE：</p>
<pre><code>function foo(){
  var a = 10;
  console.log(a);
}

foo();
</code></pre>
<p>函数声明和执行是可以分离的。</p>
<hr>
<p>如果采用IIFE：</p>
<pre><code>(function foo(){
  var a = 10;
  console.log(a);
})();
</code></pre>
<p>JS编译器不再认为这是一个函数声明，而是一个IIFE，即需要立刻执行声明的函数。</p>
<p>两者达到的目的是相同的，都是声明了一个函数foo并且随后调用函数foo。</p>
<h2 id="为什么需要iife"><a class="header-anchor" href="#为什么需要iife"></a>为什么需要IIFE</h2>
<ul>
<li>立即执行一个函数</li>
<li>需要用函数实现作用域隔离</li>
</ul>
<p>在这两种情景下，使用IIFE就比较方便。</p>
<p>如果只是为了立即执行一个函数，显然IIFE所带来的好处有限。实际上，IIFE的出现是为了弥补JS在scope方面的缺陷：JS只有全局作用域（global scope）、函数作用域（function scope），从ES6开始才有块级作用域（block scope）。对比现在流行的其他面向对象的语言可以看出，JS在访问控制这方面是多么的脆弱！那么如何实现作用域的隔离呢？在JS中，只有function，只有function，**只有function才能实现作用域隔离，**因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。</p>
<p>在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，当然声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：这通常的目的是为了隔离作用域了！<strong>既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。</strong></p>
<h2 id="iife的函数名和参数"><a class="header-anchor" href="#iife的函数名和参数"></a>IIFE的函数名和参数</h2>
<pre><code>var a = 2;
(function IIFE(global){
    var a = 3;
    console.log(a); // 3
    console.log(global.a); // 2
})(window);

console.log(a); // 2
</code></pre>
<h2 id="iife构造单例模式"><a class="header-anchor" href="#iife构造单例模式"></a>IIFE构造单例模式</h2>
<p>JS的模块就是函数，最常见的模块定义如下：</p>
<pre><code>function myModule(){
  var someThing = &quot;123&quot;;
  var otherThing = &quot;456&quot;;

  function doSomeThing(){
    console.log(someThing);
  }

  function doOtherThing(){
    console.log(otherThing);
  }

  return {
    doSomeThing:doSomeThing,
    doOtherThing:doOtherThing
  }
}

var foo = myModule();
foo.doSomeThing();
foo.doOtherThing();

var foo1 = myModule();
foo1.doSomeThing();
</code></pre>
<p>如果需要一个单例模式的模块，那么可以利用IIFE：</p>
<pre><code>var myModule = (function module(){
  var someThing = &quot;123&quot;;
  var otherThing = &quot;456&quot;;

  function doSomeThing(){
    console.log(someThing);
  }

  function doOtherThing(){
    console.log(otherThing);
  }

  return {
    doSomeThing:doSomeThing,
    doOtherThing:doOtherThing
  }
})();

myModule.doSomeThing();
myModule.doOtherThing();
</code></pre>
<p>参考：<a href="http://dz.sdut.edu.cn/blog/subaochen/2016/02/%E8%AF%B4%E4%B8%80%E8%AF%B4js%E7%9A%84iife/" target="_blank" rel="noopener">IIFE–subaochen</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> IIFE </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[和margin有关的知识]]></title>
      <url>https://blog.az22c.top/2017/03/04/about-margin/</url>
      <content type="html"><![CDATA[<p>总结一下和margin有关的基本知识，属于必须了解的范畴。</p>
<a id="more"></a>
<h2 id="基本知识"><a class="header-anchor" href="#基本知识"></a>基本知识</h2>
<h3 id="外边距的单位"><a class="header-anchor" href="#外边距的单位"></a>外边距的单位</h3>
<ul>
<li>为文本元素设置外边距时通常需要混合使用不同的单位</li>
<li>左右边距使用像素，使文本始终和包含元素边界保持固定间距</li>
<li>上下外边距以em为单位，让段间距随字号变化而响应增大或缩小</li>
</ul>
<h3 id="如果没有设置width属性"><a class="header-anchor" href="#如果没有设置width属性"></a>如果没有设置width属性</h3>
<ul>
<li>如果不设置块级元素的width属性，那么这个属性的默认值是auto,结果会让元素的宽度扩展到与父元素同宽。</li>
</ul>
<ul>
<li>没有宽度(没有设置width)的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边框和外边框，会导致内容宽度减少，减少量等于水平边框、内边框和外边框的和。</li>
</ul>
<h3 id="margin可以写1到4个值"><a class="header-anchor" href="#margin可以写1到4个值"></a>margin可以写1到4个值</h3>
<p>在实际应用中，个人不推荐使用三个值的margin，一是容易记错，二是不容易日后修改，一开始如果写成margin:10px 20px 30px;日后需求改动为上10px，右30px，下30px，左20px，你不得不还是得把这个margin拆开为margin:10px 30px 30px 20px;费力且不讨好，不如一开始就老老实实的写成margin:10px 20px 30px 20px;来的实在，不要为了现在节省俩个字节而让日后再次开发的成本上升。</p>
<h2 id="垂直外边距合并问题"><a class="header-anchor" href="#垂直外边距合并问题"></a>垂直外边距合并问题</h2>
<p>简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。你可以查看 <a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="noopener">W3Shool CSS外边距合并</a> 了解这个基本知识。</p>
<p>实际工作中，垂直外边距合并问题常见于<strong>第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距</strong>，而且只在标准浏览器下 (FirfFox、Chrome、Opera、Sarfi)产生问题，IE下反而表现良好。例子可以查看下面代码(IE下表现“正常”，标准浏览器下查看出现“bug”)：</p>
<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
	&lt;head&gt;
        &lt;title&gt;垂直外边距合并&lt;/title&gt;
        &lt;style&gt;
        .top{width:160px; height:50px; background:#ccf;}
        .middle{width:160px; background:#cfc;}
        .middle .firstChild{margin-top:20px;}
        &lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
        &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;middle&quot;&gt;
        &lt;div class=&quot;firstChild&quot;&gt;我其实只是想和我的父元素隔开点距离。&lt;/div&gt;
        &lt;div class=&quot;secondChild&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果按照CSS规范，IE的“良好表现”其实是一个错误的表现，因为IE的hasLayout渲染导致了这个“表现良好”的外观。而其他标准浏览器则会表现出“有问题”的外观。好了，如果你读过了上面W3Shcool的CSS外边距合并的文章后，就很容易讨论这个问题了。这个问题发生的原因是根据规范，一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>
<p>再说了白点就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己 “领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级，假传圣旨，把自己的margin当领导的margin执行。 对于垂直外边距合并的解决方案上面已经解释了，<strong>为父元素例子中的middle元素增加一个border-top或者padding-top即可解决这个问题。</strong></p>
<blockquote>
<p>一般说来这个问题解释到这里，大多数文章就不会再深入下去了，但作为一名实战开发者，最求的是知其然知其所以然，原本使用margin-top就是为了与父元素隔开距离，而按照你这么一个解法，其实是一种“修复”，为了“弥补修复”这个父子垂直外边距合并这个CSS规范“Bug”，而强制在父元素上使用border-top和padding-top，不舒服，也不容易记住，下次再发生这样的情况还是会忘记这条准则，而且在页面设计稿里如果不需要 border-top加个上边框，这么一加反而画蛇添足，为以后修改留下隐患。</p>
<p>为什么一定要用border-top,padding-top去为了这么一个所谓的标准规范而多写这么一行代码呢？答案你可以参考另外一篇文章<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="noopener">用Margin还是用Padding</a>里找到答案。</p>
</blockquote>
<h2 id="用margin还是用padding"><a class="header-anchor" href="#用margin还是用padding"></a>用Margin还是用Padding</h2>
<h3 id="何时应当使用margin："><a class="header-anchor" href="#何时应当使用margin："></a>何时应当使用margin：</h3>
<p>需要在border外侧添加空白时。</p>
<p>空白处不需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，需要相互抵消时。如15px + 20px的margin，将得到20px的空白。</p>
<h3 id="何时应当时用padding："><a class="header-anchor" href="#何时应当时用padding："></a>何时应当时用padding：</h3>
<p>需要在border内测添加空白时。</p>
<p>空白处需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px + 20px的padding，将得到35px的空白。</p>
<p>个人认为：margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p>
<p>这里我截取了部分另外一篇文章的内容，详细内容请见<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="noopener">用Margin还是用Padding</a></p>
<hr>
<h2 id="margin在块元素-内联元素中的区别"><a class="header-anchor" href="#margin在块元素-内联元素中的区别"></a>margin在块元素、内联元素中的区别</h2>
<p>HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。</p>
<p>另外有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。</p>
<p>margin在块级元素下，他的性能可以完全体现，上下左右任你设定。且记住块级元素的margin的参照基准是前一个元素即相对于自身之前的元素有margin距离。如果元素是第一个元素，则就是相对于父元素的margin距离（但第一个元素相对于父元素margin-top而父元素又没有设定 padding-top/border-top的话要需要印证上面的垂直外边距合并的知识）</p>
<p>margin也能用于内联元素，这是规范所允许的，但是margin-top和margin-bottom对内联元素（对行）的高度没有影响，并且由于边界效果(margin效果)是透明的，他也没有任何的视觉影响。</p>
<p>这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距，那么你只能使用这三个属性：line- height，fong-size，vertical-align。</p>
<blockquote>
<p>请记住，这个影响内联元素高度的是line-height而不是height，因为内联元素是一行行的，定一个height的话，那这到底是整段inline元素的高呢？还是inline元素一行的高呢？这都说不准，所以统一都给每行定一个高，只能是line-height了。</p>
</blockquote>
<p>margin-top/margin-bottom对内联元素没有多大实际效果，不过margin-left/margin-right还是能够对内联元素产生影响的。应用margin:10px 20px 30px 40px;，左边这个css如果写在inline元素上，他的效果大致是，上下无效果，左边离他相邻元素或者文本距离为40px，右边离他相邻元素或者文本距离为20px。你可以自行尝试一番。</p>
<p>最后在内联元素中还有上文我们提到的非可置换inline元素（non-replaced element），这些个元素img|input|select|textarea|button|label虽然是内联元素，但margin依旧可以影响到他的上下左右！</p>
<p>总结下来margin 属性可以应用于几乎所有的元素，除了表格显示类型（不包括 table-caption, table and inline-table）的元素，而且垂直外边距对非置换内联元素（non-replaced inline element）不起作用。</p>
<hr>
<h2 id="常见的浏览器下margin出现的bug"><a class="header-anchor" href="#常见的浏览器下margin出现的bug"></a>常见的浏览器下margin出现的bug</h2>
<p>林林总总写了那么多，最后总结一些浏览器中常见的margin Bug吧，以后遇到margin下的布局问题可以查看这里找到解决的方案，如果你还发现其他关于浏览器下margin的Bug你可以发表留言，核对采纳后我会及时添加进去，感谢你的分享：</p>
<p>IE6中双边距Bug：</p>
<p>发生场合：当给父元素内第一个浮动元素设置margin-left（元素float:left）或margin-right（元素float:right）时margin加倍。</p>
<p>解决方法：是给浮动元素加上display:inline;CSS属性；或者用padding-left代替margin-left。</p>
<p>原理分析：块级对象默认的display属性值是block，当设置了浮动的同时，还设置了它的外边距就会出现这种情况。也许你会问：“为什么之后的对象和第一个对象之间就不存在双倍边距的Bug”？因为浮动都有其相对应的对象，只有相对于其父对象的浮动对象才会出现这样的问题。第一个对象是相对父对象的，而之后对象是相对第一个对象的，所以之后对象在设置后不会出现问题。为什么display:inline可以解决这个双边距bug，首先是 inline元素或inline-block元素是不存在双边距问题的。然后，float:left等浮动属性可以让inline元素 haslayout，会让inline元素表现得跟inline-block元素的特性一样，支持高宽，垂直margin和padding等，所以div class的所有样式可以用在这个display inline的元素上。</p>
<p>IE6中浮动元素3px间隔Bug：</p>
<p>发生场合：发生在一个元素浮动，然后一个不浮动的元素自然上浮与之靠近会出现的3px的bug。</p>
<p>解决方法：右边元素也一起浮动；或者为右边元素添加IE6 Hack _margin-left:-3px;从而消除3px间距。</p>
<p>原理分析：IE6浏览器缺陷Bug。</p>
<p>IE6/7负margin隐藏Bug：</p>
<p>发生场合：当给一个有hasLayout的父元素内的非hasLayout元素设置负marin时，超出父元素部分不可见。</p>
<p>解决方法：去掉父元素的hasLayout；或者赋hasLayout给子元素,并添加position:relative;</p>
<p>原理分析：iE6/7独有的hasLayout产生问题。</p>
<p>IE6/7下ul/ol标记消失bug：</p>
<p>发生场合：当ul/ol触发了haslayout并且是在ul/ol上写margin-left，前面默认的ul/ol标记会消失。</p>
<p>解决方法：给li设置margin-left，而不是给ul/ol设置margin-left。</p>
<p>原理分析：IE6/7浏览器Bug</p>
<p>IE6/7下margin与absolute元素重叠bug：</p>
<p>发生场合：双栏自适应布局中，左侧元素absolute绝对定位，右侧的margin撑开距离定位。在IE6/7下左侧应用了absolute属性的块级元素与右边的自适应的文字内容重叠。</p>
<p>解决方法：把左侧块级元素更改为内联元素，比如把div更换为span。</p>
<p>原理分析：这是由于IE6/IE7浏览器将inline水平标签元素和block水平的标签元素没有加以区分一视同仁渲染了。属于IE6/7浏览器渲染Bug。</p>
<p>IE6/7/8下auto margin居中bug：</p>
<p>发生场合：给block元素设置margin auto无法居中</p>
<p>解决方法：出现这种bug的原因通常是没有Doctype，然后触发了ie的quirks mode，加上Doctype声明就可以了。</p>
<p>在《打败IE的葵花宝典》里给出的方法是给block元素添加一个width能够解决，但根据本人亲测，加 with此种方法是无效的，如果没有Doctype即使给元素添加width也无法让block元素居中。
原理分析：缺少Doctype声明。</p>
<p>IE8下input[button | submit] 设置margin:auto无法居中</p>
<p>发生场合：ie8下，如果给像button这样的标签（如button input[type=“button”] input[type=“submit”]）设置{ display: block; margin:0 auto; }如果不设置宽度的话无法居中。</p>
<p>解决方法：可以给为input加上宽度</p>
<p>原理分析：IE8浏览器Bug。</p>
<p>IE8百分比padding垂直margin bug：</p>
<p>发生场合：当父元素设置了百分比的padding，子元素有垂直的margin的时候，就好像父元素被设置了margin一样。</p>
<p>解决方法：给父元素加一个overflow:hidden/auto。</p>
<p>原理分析：IE8浏览器Bug</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> margin </tag>
            
            <tag> bug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[桌面端和移动端图标的引入]]></title>
      <url>https://blog.az22c.top/2017/02/27/icon-usage/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://bitsofco.de/all-about-favicons-and-touch-icons/" target="_blank" rel="noopener">All About Favicons-bitsofcode</a> ：</p>
</blockquote>
<p>这星期我决定找到一些合适的方式来使用网站的favicon（另外还包括移动端的touch icon）。我想总结一下我自己的观点并且通过简明的语言来表述清楚：</p>
<a id="more"></a>
<h2 id="一些基础的知识"><a class="header-anchor" href="#一些基础的知识"></a>一些基础的知识</h2>
<p>favicon 是浏览器展示web网页时用到的一种图片。最典型的就是16x16像素大小，不过现在通常需要更多更大的尺寸以供不同的用途使用：</p>
<ul>
<li>地址栏</li>
<li>链接栏</li>
<li>书签</li>
<li>标签</li>
<li>桌面图标</li>
</ul>
<p>如果没有指明favicon的位置，所有主流的浏览器（甚至包括IE5时代的浏览器）都会默认去网站根目录找一个叫&quot;favicon.ico&quot;的文件。从技术层面来讲，这意味着我们不需要用作任何声明就能在网站中使用图标。</p>
<p>然而，这种情况下图标的格式需要受到限制。另外还不支持带透明的图标，这并不是一个最优的办法。因为现在我们能使用更多格式的图标：<a href="http://caniuse.com/#feat=link-icon-png" target="_blank" rel="noopener">png</a>, gif, jpeg，在某些情况下还有<a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="noopener">svg</a> 。</p>
<h2 id="favicon声明和link标签"><a class="header-anchor" href="#favicon声明和link标签"></a>favicon声明和link标签</h2>
<p>你可以用link标签设置你喜欢的图标：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;&quot; type=&quot;&quot; sizes=&quot;&quot; href=&quot;&quot;&gt;  
</code></pre>
<h3 id="rel属性"><a class="header-anchor" href="#rel属性"></a>rel属性</h3>
<p>用于声明链接目标和html文档的关系。通常用来引入css样式表。如果是图标，比较官方的写法应该是：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;icon&quot;&gt;
</code></pre>
<p>曾经你可能见过这种写法：</p>
<pre><code class="language-JavaScript"> &lt;link rel=&quot;shortcut icon&quot;&gt;
</code></pre>
<p>这是因为某些老浏览器（IE8或者更早）需要这么写，否则浏览器会忽略这整个link标签。因此，即便<code>rel=&quot;shortcut icon&quot;</code>不在HTML5标准里面，它依然在现代浏览器中有效。然而后面我们会讲到，在实际中你可能只需要使用<code>&lt;link rel=&quot;icon&quot;&gt;</code> 这一种写法即可。</p>
<h3 id="type属性"><a class="header-anchor" href="#type属性"></a>type属性</h3>
<p>用来	指定链接目标的<a href="http://www.iana.org/assignments/media-types/media-types.xhtml#image" target="_blank" rel="noopener">MIME type format</a>。比如，指定一个图标文件是<code>image/x-icon</code> 类型还一个png文件 <code>image/png</code>。</p>
<p>根据W3C，指定type类型仅仅只是一个建议。但除此之外，IE9和IE10需要指定type属性。在这些版本的浏览器里面，虽然不必指定<code>rel=&quot;shortcut icon&quot;</code>，作为替代，它们需要指定媒体文件的type为 <code>image/x-icon</code> 。</p>
<p>幸运的是，IE11和其他现代浏览器不需要指定媒体文件的type。</p>
<h3 id="sizes属性"><a class="header-anchor" href="#sizes属性"></a>sizes属性</h3>
<p>用于声明特定被链接的文件的大小，不同大小用于不同用途。你能为每种用途提供各自最优的文件。这对使用png图片的情景尤为重要，因为png是不能拓展的。这是一张很好的<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="noopener">备忘单</a>,它会告诉你应该使用的文件的大小和用途。</p>
<h3 id="href属性"><a class="header-anchor" href="#href属性"></a>href属性</h3>
<p>不必多说，这是用来指定图标的位置和地址的。</p>
<h2 id="做个小结"><a class="header-anchor" href="#做个小结"></a>做个小结</h2>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Link “rel”/ “type”</th>
<th>Accepted Formats</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE 8 and below</td>
<td>link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 9, IE 10</td>
<td>link rel=”icon” type=”image/x-icon” or link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 11</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Chrome</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Firefox</td>
<td>link rel=”icon”</td>
<td>ico, png, gif, <a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="noopener">svg*</a></td>
</tr>
<tr>
<td>Safari</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Opera</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
</tbody>
</table>
<p>看上去，最好的方案应该是声明两个版本，用现代浏览器的方法引用png，IE8的方法引用ico文件。</p>
<p>然而，如果ico和png同时被引用，现代浏览器会不论标签顺序的先后，只选择ico。这意味着，如果我们要兼容老浏览器，现代浏览器可能会被提供一个错误的图片文件的格式。</p>
<h3 id="当只引入ico时"><a class="header-anchor" href="#当只引入ico时"></a>当只引入ico时</h3>
<pre><code class="language-html">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
</code></pre>
<h3 id="当需要引入ico和png"><a class="header-anchor" href="#当需要引入ico和png"></a>当需要引入ico和png</h3>
<p>最佳的方案应该是<strong>只声明引入png，让老浏览器使用默认的方式引入ico</strong>，这样最稳妥。(但实际上，把ico文件放在根目录时，某些现代浏览器可能并不会引入它)</p>
<pre><code class="language-JavaScript">&lt;!-- For IE 10 and below --&gt;  
&lt;!--  No link, just place a file called favicon.ico in the root directory --&gt;

&lt;!-- For IE 11, Chrome, Firefox, Safari, Opera --&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-16.png&quot; sizes=&quot;16x16&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-32.png&quot; sizes=&quot;32x32&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-48.png&quot; sizes=&quot;48x48&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-62.png&quot; sizes=&quot;62x62&quot; type=&quot;image/png&quot;&gt;  
</code></pre>
<h2 id="移动设备的touch-icon"><a class="header-anchor" href="#移动设备的touch-icon"></a>移动设备的touch Icon</h2>
<p>一些移动设备允许用户自定义浏览器主页书签。像原生app图标一样，在这种情景下，我们应该提供专门的图标。</p>
<p>怎么指定这个图标由浏览器/移动设备决定：</p>
<table>
<thead>
<tr>
<th>Device / Browser</th>
<th>Link “rel”</th>
<th>Sizes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apple / Safari</td>
<td>link rel=”apple-touch-icon” or link rel=”apple-touch-icon-precomposed”</td>
<td>76x76 - iPad 2 and iPad mini ;120x120 - iPhone 4s, 5, 6 ;152x152 - iPad (retina) ;180x180 - iPhone 6 Plus</td>
</tr>
<tr>
<td>Apple / Opera Coast</td>
<td>link rel=”icon” (<a href="https://dev.opera.com/articles/opera-coast/" target="_blank" rel="noopener">Will also accept Safari and Windows formats</a>)</td>
<td>228x228</td>
</tr>
<tr>
<td>Android / Chrome</td>
<td>link rel=”icon” (<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="noopener">Will, for a limited time, also accept Safari format</a>)</td>
<td>192x192</td>
</tr>
</tbody>
</table>
<p>对于Windows，这些图标应该用meta标签指定。</p>
<p>For Windows 8 / IE 10 -</p>
<pre><code class="language-html">&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;pinned-tile.png&quot;&gt;  
&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#009900&quot;&gt;  
</code></pre>
<p>For Windows 8.1 / IE 11 -</p>
<pre><code class="language-html">&lt;!-- In &lt;head&gt; --&gt;  
&lt;meta name=&quot;msapplication-config&quot; content=&quot;ieconfig.xml&quot; /&gt;

&lt;!--  In ieconfig.xml --&gt;  
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;browserconfig&gt;  
  &lt;msapplication&gt;
    &lt;tile&gt;
      &lt;square70x70logo src=&quot;images/smalltile.png&quot;/&gt;
      &lt;square150x150logo src=&quot;images/mediumtile.png&quot;/&gt;
      &lt;wide310x150logo src=&quot;images/widetile.png&quot;/&gt;
      &lt;square310x310logo src=&quot;images/largetile.png&quot;/&gt;
      &lt;TileColor&gt;#009900&lt;/TileColor&gt;
    &lt;/tile&gt;
  &lt;/msapplication&gt;
&lt;/browserconfig&gt;  
</code></pre>
<p>就是这样，用到 favicon的地方还挺多的。如果是一个很基础的网站，我可能只会使用ico图标	。期待 SVG favicon 时代的到来。</p>
<p>另可参考：<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="noopener">https://github.com/audreyr/favicon-cheat-sheet</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图标 </tag>
            
            <tag> meta标签 </tag>
            
            <tag> link标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发事件入门概述]]></title>
      <url>https://blog.az22c.top/2017/02/25/webapp-events-intro/</url>
      <content type="html"><![CDATA[<p>本文修改自 <a href="http://www.infoq.com/cn/articles/touch-pointer-event" target="_blank" rel="noopener">PPK的《移动Web手册》</a></p>
<a id="more"></a>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<p>触摸事件为苹果发明，它将触摸和鼠标两种行为区分开，而微软的指针事件则将它们合并，此标准更具前瞻性，现已被W3C采纳为正式标准。</p>
<p>早在2007年，苹果公司就发布了第一款真正支持触摸屏的浏览器。这款浏览器会监控用户的触摸操作，并派发相应的事件。</p>
<p>除了指针事件的发明者微软外，其他多数浏览器厂商复制谷歌或Mozilla的实现。这两套事件是本章讨论的主题。</p>
<p>乍一看，在指针事件上，IE又是那么“与众不同”，但事实并不如你所想。</p>
<p>微软在这方面提出了一个有趣的哲学观点，我们将在后面详细讨论。在撰写本书时，谷歌和Mozilla正在考虑着手实现指针事件。W3C也正在从触摸事件过渡到指针事件。</p>
<p>在大多数方面，触摸事件和指针事件是普通的JavaScript事件。当触摸动作发生时，触摸事件和指针事件被触发。你可以为它们指定事件处理函数，它们的事件对象也提供了有用的触摸相关的信息。触控事件和传统的鼠标、键盘事件之间有一些技术上的差异。 此外，出于兼容性的考虑，触屏设备必须触发鼠标事件，因为很多网站仍然依赖于它们。但是，在没有鼠标的设备上触发鼠标事件会发生什么事情呢？本章专门讨论这些问题。</p>
<p>本章的其余部分在本质上更具有哲学性。随着iPhone的推出，苹果引入了一种新的交互模式：触摸。 现在，触摸、传统鼠标、键盘三种交互模式并存。Web开发人员需要确保网站适应这三种交互模式。乍一看，触摸事件和鼠标事件差不多。那它们之间有什么区别呢？我们真的需要为触摸交互模式再设计一套事件吗？</p>
<h2 id="触摸事件"><a class="header-anchor" href="#触摸事件"></a>触摸事件</h2>
<ol>
<li>touchstart，在用户的手指触摸屏幕的瞬间触发。</li>
<li>touchmove，在用户移动手指的过程中连续触发。</li>
<li>touchend，用户的手指离开屏幕的瞬间触发。</li>
<li>touchcancel ，（不太被使用），其含义取决于浏览器。后面将会讨论。</li>
</ol>
<p>pointerdown、pointermove和pointerup事件在同一时刻触发</p>
<p>这些事件得到了大多数触屏浏览器的支持，但IE浏览器是一个例外。还有一些很古老的和不完善的浏览器也不支持，比如塞班Anna的默认浏览器。代理浏览器也不支持，因为这些事件不适用于代理浏览模式。其中的原因我们将会在“浏览器”一章讨论。</p>
<h3 id="touchcancel"><a class="header-anchor" href="#touchcancel"></a>touchcancel</h3>
<p>不同浏览器对<code>touchcancel</code>的实现有所不同。</p>
<p>幸运的是，我还没有发现必须使用touchcancel的情景。貌似其他脚本和库也几乎没有使用
touchcancel。有些代码为了安全起见，把它等同于touchend。综上所述，本章将忽略touchcancel事件。如果在某些情况下浏览器
没有触发touchend事件，导致一些奇怪的问题，你可以将touchend的处理函数绑定到touchcancel上。</p>
<h2 id="指针事件"><a class="header-anchor" href="#指针事件"></a>指针事件</h2>
<p><strong>指针事件合并了触摸和鼠标操作，它的必要性在于有一些超极本、平板电脑（Surface系列）同时支持触摸和鼠标操作，并且需要在两者间进行无缝的切换。</strong></p>
<ul>
<li>pointerdown</li>
<li>pointermove</li>
<li>pointerup</li>
<li>pointerover</li>
<li>pointerout</li>
</ul>
<h2 id="键盘事件"><a class="header-anchor" href="#键盘事件"></a>键盘事件</h2>
<p>因为容易理解，不解释。</p>
<h2 id="其他事件"><a class="header-anchor" href="#其他事件"></a>// 其他事件</h2>
<h3 id="触摸：touchenter和touchleave"><a class="header-anchor" href="#触摸：touchenter和touchleave"></a>触摸：touchenter和touchleave</h3>
<p>触摸事件规范中曾经包含<code>touchenter</code>和<code>touchleave</code>事件，这两个事件在用户手指移入
或移出某个元素时触发。但是这两个事件从来没有被实现。微软有这两个事件的替代事件，但是只有IE浏览器支持。某些情况下可以知道用户手指滑入、滑出某个
元素是非常有用的，所以我希望这两个事件可以重返规范。现在暂时不应该用它们。</p>
<h3 id="缩放事件-不在规范"><a class="header-anchor" href="#缩放事件-不在规范"></a>缩放事件(不在规范)</h3>
<p>能响应用户缩放还是很有用的：比如你可以在用户缩放后改变界面，或者只是收集缩放数据以得知页面字号是不是过小。但既然不在规范内，就不应该使用。</p>
<h3 id="手势事件："><a class="header-anchor" href="#手势事件："></a>手势事件：</h3>
<p>两个或多个触摸事件同时发生。放大放小图片时等等场景会用到。仅Safari和IE支持，不建议使用。</p>
<p>手势事件存在两个问题：一来，其他浏览器不支持。二来，它们根本没什么用处。理论上，通过这套事件检
测用户的手势听起来很不错，但实际上，你需要分析触摸坐标、移动速度甚至加速度才能搞清楚用户真正的意图。所以我们不需要手势事件，因为普通的触摸事件已
经提供了同样的信息。所以本章不再讨论手势事件。</p>
<h2 id="实例"><a class="header-anchor" href="#实例"></a>实例</h2>
<p>通过实例对比触摸、指针事件与鼠标键盘事件。</p>
<ul>
<li>下拉菜单。对于用mouseover的下拉菜单，触摸事件几乎不可用。</li>
<li>拖拽。触摸和鼠标差不多，键盘难操作。</li>
<li>滚动层。鼠标难操作。</li>
</ul>
<h3 id="下拉菜单"><a class="header-anchor" href="#下拉菜单"></a>下拉菜单</h3>
<p>跨设备环境的最好解决方案是使用点击事件。点击展开菜单，而不是鼠标悬停时展开。点击另一菜单项则会收起当前菜单。我们在本章后面会看到，点击事件很安全。并且基于点击的下拉菜单可以适用于鼠标和触摸交互。</p>
<p>尽管如此，移动浏览器仍然需要与现实抗争：网上仍然有成千上万基于鼠标悬停的下拉菜单。幸运的是，下拉菜单是一个特殊的用例。苹果公司在设计触摸事件的时候已经考虑到了并且其他浏览器照搬了他们的实现。这点我们在本章后面会遇到。</p>
<p>与下拉菜单完全不同的一个实例是拖动和拖放。用户在鼠标按下时选中一个元素，然后移动，最后松开鼠标将元素放在某个地方。最后脚本会计算放置点是否有效并根据计算结果做出处理。</p>
<h3 id="拖放"><a class="header-anchor" href="#拖放"></a>拖放</h3>
<p>将这个实现移植到基于触摸的交互非常简单：将mousedown替换为touchstart，mousemove替换为touchmove，mouseup替换为touchend就可以了。唯一的问题是如何确定事件的坐标。后面我们会讲到。</p>
<p>这里的问题是键盘的可访问性。如何让用户通过键盘移动可拖动元素？你可以将一个区域的元素设置成可以 通过键盘聚焦，一旦某个元素得到焦点，就开始监听方向键。这在技术上并不困难，但是用户体验很差。这个问题基本上无法解决：拖放操作本身就是为鼠标和触摸 交互设计的，无法在键盘上得到好的体验。</p>
<h3 id="滚动层"><a class="header-anchor" href="#滚动层"></a>滚动层</h3>
<p>在2011年时，我需要一个可以在所有设备上工作的水平滚动元素。那时候设备还没有原生支持，仍需要脚本，所以我写过一个。现在设备已经原生支持，那段脚本不再需要了。这点我们在CSS章节已经看到。不过这段脚本仍然是一个很有用的实例，所以我们假设仍然需要那段脚本。</p>
<p><img src="https://cloud.az22c.top/roll-layer.png-az22cgithub" alt="img"></p>
<p>写这段脚本不是什么难事：在ontouchstart事件中计算滚动元素的当前位置，并初始化其他事 件处理函数；在ontouchmove事件中将元素移动相应像素的距离；在ontouchend中，运行一个函数来计算合理的减速，一旦被移动的元素停止 移动，这个函数结束。很简单吧，我花了大概两个小时。</p>
<p>非触摸设备怎么办呢？为了让滚动层可以工作，我需要将触摸交互翻译成鼠标、键盘交互。键盘很简单，只需监听keydown事件，当用户按下左/右键时滚动元素。这点可能不是那么容易发现，但是现在这个脚本算是正式支持键盘操作了。</p>
<p>鼠标设备怎么办？从技术上来讲，增加对mousedown、mousemove和mouseup事件的处理并不难，但是交互非常奇怪：用户必须一直按下鼠标按键才能滚动元素。这种交互和拖放一样，但是对于滚动层来说并不是那么直观。</p>
<p>我可以用老式的滚动条箭头：当鼠标移动到箭头上时脚本开始工作。但是视觉上看，增加箭头有些零乱。除此之外，当用户触摸或者使用键盘时还得隐藏箭头。我没有找到一种安全正确的方法（我们在后面会再次遇到这个问题），最终我并没有支持鼠标交互。</p>
<h2 id="事件和交互模式"><a class="header-anchor" href="#事件和交互模式"></a>事件和交互模式</h2>
<ul>
<li>鼠标事件。1996年Netscape引入</li>
<li>键盘事件。后来引入。</li>
<li>触摸交互。2007年左右开始出现。</li>
</ul>
<p>Web开发者必须确保他们的网站可以在三种交互模式下正常工作。做到这点有时候很简单，有时候却很困难，不过都是必要的。不仅是为你现在的网站增加这些支持，你应该开始思考为UI元素增加对各种操作模式的支持。</p>
<p>在未来，我们可能会有更多的交互模式，比如Xbox
Kinect，它将身体动作转换成屏幕动作。这样你可以用你的手来控制屏幕上的指针。从技术角度来讲，控制指针意味着将使用鼠标事件，但是从用户的角度看这是一种新的操作模式。毕竟感觉上完全不同。</p>
<p>汽车、冰箱、可穿戴以及新兴的设备都可能为用户和Web开发人员带来新的交互模式，比如doorclose（关门）事件。</p>
<p>思考交互模式和JavaScript事件带来三个问题：</p>
<ol>
<li>是不是每个交互模式都需要自己的事件？</li>
<li>已有的交互模式的事件在新设备上不再有意义时，是否需要继续支持？</li>
<li>如何判断设备支持哪种交互模式或用户正在使用哪种模式？</li>
</ol>
<p>目前来看，前两个问题的答案是肯定的，第三个问题的答案比较复杂。但是，在将来，第一个问题的答案可能是否定的。再看看Kinect的例子：我们是发明全新的硬件事件，还是使用指针和鼠标事件呢？从技术上来讲，无论用户怎么移动，指针还是指针。</p>
<h3 id="等价事件"><a class="header-anchor" href="#等价事件"></a>等价事件</h3>
<p>目前每种交互模式都有自己的一套事件，但这并不意味着它们是完全无关且不同的。事实上，某些事件是等价的。下面的表格给出了这方面的情况。</p>
<p><img src="https://cloud.az22c.top/compare-3-events1.png-az22cgithub" alt="img"></p>
<p>很显然，触摸动作序列：touchstart-touchmove-touchend和鼠标序 列：mousedown-mousemove-mouseup以及键盘序列：keydown-keypress-keyup很相似，这并不是巧合，因为这 三种交互模式都可以描述为start-move-stop。（所以我们不需要完全不同的事件，对不对？）</p>
<p>但是，有时候两个操作模式很像，但第三个却不。比如在下拉菜单的例子里，鼠标和键盘很像，而触摸不同。在拖放实例中，鼠标和触摸几乎一致，但键盘非常不同。在滚动层的例子里，这三种操作模式完全不同。（所以我们还是需要不同的事件，对吧？）</p>
<p>最后是mouseover和mouseout的问题。focus和blur是它们的键盘模式的等价事件，但是触摸模式没有这样的等价事件。就像我们在“CSS”一章看到的，在触摸屏设备中不存在“悬停”。</p>
<h3 id="触摸事件的不同之处"><a class="header-anchor" href="#触摸事件的不同之处"></a>触摸事件的不同之处</h3>
<p>可以看出，等价事件确实存在，这取决于上下文。但是触摸、按键和鼠标事件并不完全相同。显然，由于键盘是这三种交互模式中最与众不同的，所以Web开发人员倾向于将注意力集中在鼠标与触摸上。让我们先来讨论这二者的差异吧。</p>
<p>当鼠标指针移入某个元素，或者用户按下某个鼠标按键时，系统可以立即判断出应该触发哪个事件。而对于 触摸操作来说就不同了，**触摸操作可以引出不同的动作：在你的手指触碰屏幕的瞬间，系统还无法判断出你的意图。**你只是想轻触（Tap）某个元素？还是想滚动 某个可滚动元素？亦或是想缩放？还是想双触（Double-Tap）？浏览器必须等待一定时间间隔才能做出判断。这个时间间隔并不是非常短，而是一个可察 觉的间隔。这点在后面还会讲到。</p>
<p>**多个触摸动作可以同时发生。**这一点对鼠标动作来说是不可能的：一台计算机只能有一个鼠标（指针）。通 常来说，多点触摸不会带来麻烦：大多数网站只支持单点触摸。单点触摸很容易用鼠标来模拟。即便是网页中有两个滑动条，它们之间也不会互相干扰。因为就算用 户同时滑动它们，你也可以认为它们之间是相互独立的。二者都可以很好地通过触摸和鼠标进行操作。</p>
<p>当网站允许并需要多点触摸时，情况就不同了。如果脚本将同时发生的多点触摸翻译成手势、旋转或者缩放动作，鼠标就无法模拟了。多点触摸带来的问题需要具体问题具体分析。但是你必须意识到这一点。</p>
<p>鼠标指针总是指着某一个像素，而手指触摸会覆盖很多像素点。通常，系统会从这些像素点计算出一个中心点作为触摸事件的坐标。并且在touchstart和touchend之间给手指移动留有余地。但是后面会讲到有些浏览器并没有这么做。</p>
<p>**触摸事件是不连续的，而鼠标事件是连续的。**当你将鼠标指针从元素A移动到元素B时，鼠标指针会不可避 免地掠过AB之间的元素。鼠标移动是连续的还意味着你可以通过脚本进行监控。触摸操作就不同了，你可以放开元素A，抬起手直接去碰元素B。这正是我们在下 拉菜单实例里试图支持触摸事件时遇到的问题。下拉菜单设计之初就需要连续的事件，因为它是为鼠标环境而设计的。</p>
<p>**触摸事件比鼠标事件携带了更多的信息。**比如，触摸屏可以探测到用户手指的温度，触摸区域的半径，触摸的压力值。现在虽然没有给出这些数据，不过将来很有可能给出。因为在IE的指针事件中，已经预留了一些对应的属性。</p>
<p>不管怎样，鼠标和触摸虽然相似但又不完全相同。</p>
<h3 id="指针事件-v2"><a class="header-anchor" href="#指针事件-v2"></a>指针事件</h3>
<blockquote>
<p>事实上因为兼容性问题，**直到现在指针事件仍是不可用的，**最好还是用苹果的触摸事件。</p>
</blockquote>
<p>我们发现，通常情况下鼠标事件和触摸事件非常相似，但是二者还是有一些本质区别的。有了这个认识，我们就可以更好地理解微软的指针事件，以及为什么会提出指针事件。</p>
<p>微软认为没有必要分出鼠标、触摸两种事件。不管是鼠标指针、手指（触摸）还是触控笔（也叫定位笔），统称为指针，只要通过这些指针改变了些什么，就触发指针事件。所以，下面是微软版本的等价事件：</p>
<p><img src="https://cloud.az22c.top/compare-3-events2.png-az22cgithub" alt="img"></p>
<p>现在我们有了两种事件分类方式：鼠标、触摸分离的苹果版本；鼠标、触摸整合的微软版本。到目前为止， 只有IE支持微软的版本。其他浏览器都支持苹果版本。又如我们在前面看到的，Mozilla和Google正在考虑实现指针事件 （PointerEvent）。所以未来情况可能还会发生变化。</p>
<p>Google 之所以对指针事件感兴趣，是因为它的Chromebook Pixel笔记本和微软的Surface平板电脑一样，都有触摸屏和带触摸板的键盘。二者都支持鼠标和触摸操作。如果这两种事件能统一成一种，网站对它们的支持就会变得简单很多。</p>
<p>微软的Surface是一个触屏平板电脑，你还可以外接一个带触摸板的键盘。在访问网站时你可以在鼠标和触摸之间切换。这种情况需要通过指针事件来处理。</p>
<p>我个人认为微软的方案是个好主意。随着时间的推移，越来越多的设备会同时支持鼠标和触摸操作。所以指 针事件是超前意识。同时指针事件可以方便地扩展以支持其他操作，而不局限于触控笔，还包括Wacom绘图板之类的设备。在将来，可以方便地囊括体感电视遥 控器、Kinect动作。这两种操作都可以操控指针、激活元素，比如激活链接。（不过，关冰箱门事件不在这个范围内。）所以，指针事件比相互分离的鼠标和 触摸事件有更好的前景。</p>
<p>我们来试试在刚才上面三个实例中实现指针事件。</p>
<ol>
<li>拖放操作完美匹配：无论用户是用鼠标还是触摸，亦或是触控笔选中了一个元素，拖动它然后放下它。指针事件都可以在不增加代码的情况下支持Kinect、电视遥控和其他类似指针的操作。</li>
<li>滚动层可以在指针事件下正常工作。在触摸交互模式下，滚动层完美工作。当使用触控笔时，用户在滚动层按下、滚动，最后释放。这个操作也讲得 通。鼠标操作和触控笔相似，但是按下笔选取滚动层这个操作有些奇怪。这也是为什么我觉得对滚动层的操作很难移植到鼠标操作。不过，无论我们使用分离的鼠 标、触摸事件还是使用指针事件，这个问题仍然存在。所以指针事件不会带来额外的问题。</li>
<li>下拉菜单是三个实例中最复杂的一个。pointerover和pointerout看似恰是为下拉菜单设计的。但是仔细一看，完全不是。<strong>下拉菜单无法很好地在触摸交互下工作，就算换成指针事件也一样。最好的处理方法还是用点击（click）事件。</strong></li>
</ol>
<p>上面的实例说明，当某种交互不是专门针对某个操作模式设计的时候，指针事件就能很好地工作。在后面我 们会讨论，如果你愿意，你还是可以<strong>通过指针事件对象的pointerType属性来判断是鼠标还是触摸操作。</strong>（指针事件的初衷是统一鼠标、触摸事件，显然 这个属性与初衷相悖，不过这也是实践所需。）</p>
<h3 id="mouseover和-pointerover"><a class="header-anchor" href="#mouseover和-pointerover"></a>mouseover和 pointerover</h3>
<p>pointerover融合了mouseover事件和我们虚构的“touchover”事件：在鼠 标指针或用户手指滑入某个元素时触发。pointerout则是在用户手指或鼠标指针离开某个元素时触发。这就是我们在CSS章节讨论的:hover问 题，只不过是在JavaScript上下文中。</p>
<p>我们再一次遇到了连续事件和非连续事件的本质区别。当使用鼠标从A移动到B时，用户必须经过A、B之 间的元素，别无选择。但是触摸操作就可以先触摸A，再直接触摸B，中间不会碰到其他任何元素。除非是在拖放元素，手指不能离开屏幕。此时 pointerover就很有用了：可以在pointerover时判断当前滑入的对象是不是一个合法的放置区域。</p>
<p>除了这种情景，pointerover与mouseover还是有本质区别的。尤其是在鼠标移入某个 区域后显示额外信息这类精细的操作中，鼠标移入（mouseover）根本无法正常工作。因为此时用户的触摸操作不太可能从某个地方移入期望的区域。更可 能的情况是，用户直接触摸相应的元素，而没有任何移入（pointerover）操作。当然，额外的信息也就无法展现出来了。</p>
<p>解决办法是，只处理mouseover和mouseout事件。因为这两个事件在触摸操作时都会被触发。仅在触摸点移入和移出时不会触发，这一点我们在后面会详细解释。虽然有了这个解决方案，但是由于悬停操作在触摸环境下实在是太另类了，所以这个方案并不完美。</p>
<h3 id="输入模式的渐进增强"><a class="header-anchor" href="#输入模式的渐进增强"></a>输入模式的渐进增强</h3>
<p>渐进增强就像响应式设计教导我们的，要支持各种屏幕尺寸的设备，我们必须想办法来支持多种输入模式（这里的输入模式指鼠标、触摸、键盘等输入模式）。我们暂且称之为输入模式的渐进增强。不过“输入模式的渐进增强”的概念并没有“响应式设计”那么一目了然。</p>
<p>“响应式设计”的基本思想是以同一个设计适应多种屏幕尺寸。而“输入模式的渐进增强”在很多情况下需要我们为不同输入模式分别编写不同的脚本。比如前面讲到的滚动层实例就需要我们为鼠标、键盘和触摸写三个不同的脚本。</p>
<p>除此之外，在用户与网站交互的过程中，屏幕尺寸通常是不会改变的。而输入模式却可以频繁改变。以微软的Surface平板为例：在浏览同一页面时，用户可以在鼠标和触摸操作之间随意切换。而你的脚本必须支持这种复杂的操作。</p>
<p>通常情况下，相比智能手机来说，这种支持对平板电脑来说更重要。因为手机上的输入模式相对少一些。尽管如此，也不要一厢情愿地假设在浏览页面时用户只使用一种输入模式。虽然这种假设可以让Web开发者的工作变得轻松一些，但是并不能改变这骨感的现实。</p>
<p>我们可以从响应式设计中借鉴一些思想应用到“输入模式的渐进增强”中。在“响应式设计”中有一个好的 思想：**从限制最多的情况着手，<strong>比如最小的屏幕。类似的，D-pad可以算是最局限的输入模式了。它由四个方向键和一个OK键组成。好消息是，D-pad的 按键完全和普通键盘兼容：触发相同的事件、使用相同的键码。所以我们不需要区分D-pad和普通键盘。坏消息是，尽管如此，它们还是很有局限性。更坏的消息是，在这方面我也没有什么指导意见可以分享。因为“输入模式的渐进增强”这个概念太新了，以至于我们</strong>还没有找到普适的应对策略。**而且连一些可以帮助大家 的好点子都很少。你可以把这视为一个问题，也可以视为一个挑战。谁知道呢，没准你就是那个教会这个世界如何实现“输入模式的渐进增强”的人。</p>
<h3 id="判断当前的交互模式"><a class="header-anchor" href="#判断当前的交互模式"></a>判断当前的交互模式</h3>
<p>“输入模式的渐进增强”可能需要你去检测用户的当前交互模式。尽管很困难，但这在技术上可以实现。然而，我们真正的问题是，它究竟能提供哪些有用的信息呢？</p>
<p>让我们再次以微软Surface的用户为例。你可以检测到用户正在使用鼠标。但这是否意味着他们将在 整个会话中一直使用鼠标呢?不尽其然。事实上，他们很有可能、或者至少是偶尔地会使用键盘或是触摸屏，又或者干脆把键盘和鼠标触控板折叠起来，只使用触摸 屏。假如发生了以上任一情况，那么你的互动模式检测的价值何在呢？</p>
<p>你唯一可以确定的合理判断是，当用户以某种模式开始某个动作时，他们不会在中途切换模式。因此，如果 你检测到用户正移动鼠标进行拖放，那么他们不太可能在拖曳过程中切换到触摸操作。但是，一旦拖放完成，用户就可能选择切换到触摸、或继续使用鼠标、亦或使 用键盘，来进行下一步操作。</p>
<p>**你必须确保所有交互在任何交互模式下均可实现，**这一点至关重要。鼠标、触摸甚至键盘都应该可以执行拖放操作。一旦做到了这一点，那么用户正在使用何种交	互模式都将无关紧要。</p>
<p>让我们假设，你有很好的理由去寻找当前的交互模式。也许你想收集一些数据来研究用户的模式使用偏好。那么我们来看一下几种可能性。</p>
<ul>
<li>指针事件最简单明了：它具备pointerType属性，其值可以是mouse、touch或pen。找到当前值即可知道用户的操作。另一 个简单的情况：当有任何按键事件触发时，用户一定会使用键盘。但这与未来的交互无关——用户仍然可能随时转换到键盘或是触摸。但无论如何，这还是提供了一 些有用的信息。</li>
<li>与之类似的，当一个触摸事件触发时，你可以肯定你的用户在当下一定正在使用触摸交互模式。同理，这并不影响未来的交互，但至少提供了一些信息。</li>
<li>对于鼠标事件要格外小心：当用户触摸屏幕时，鼠标事件也会触发，因此检测交互模式并不适用于鼠标事件。检测鼠标使用的方法就是排除其他交互模式。如果用户没有使用触摸或键盘，那么他有可能正在使用鼠标。</li>
</ul>
<p>目前有很多方法可以检测到一个触摸交互模式是否可用。其中有一种由Modernizr普及，但可惜并不十分可靠的方法是：</p>
<pre><code class="language-javascript">var hasTouch = !!('ontouchstart' in window);
</code></pre>
<p>“如果window对象有ontouchstart属性，说明浏览器支持触摸事件，我们就可以放心地 使用。”这可能正是你所想的。前半句的结论是“虽然正确”，但是，支持触摸事件的浏览器并不一定运行在具有触摸屏的设备上。比如，黑莓6的浏览器支持触摸 事件，但它却运行在一个非触摸设备上。老版本的Chrome浏览器也有类似的问题。并且，依赖ontouchstart的方法让IE变得无能为力。</p>
<p>唯一安全的检测浏览器支持触摸事件、运行在触摸设备上并且用户正在使用触摸交互的方法就是看是否确实有触摸或指针事件被触发。</p>
<pre><code class="language-javascript">    var hasTouch = false;
    document.ontouchstart = function () { 
        hasTouch = true;
    }
    document.onpointerdown = function (e) { 
        if (e.pointerType === 'touch') {
            hasTouch = true;
        }
    }
</code></pre>
<p><strong>最好的办法是依次检测各种交互模式：首先从指针事件开始。pointerType属性可以提供有用的信息。然后检测触摸事件。后面我们会看到触摸操作还会触发鼠标事件，所以只有当触摸事件没有触发时，才考虑鼠标事件。最后轮到键盘。</strong></p>
<pre><code class="language-javascript">    var interactionMode;
    document.onpointerdown = function (e) { 
        interactionMode = e.pointerType;
    }
    document.ontouchstart = function () {
        if (!interactionMode) {
            interactionMode = 'touch';
        }
    }
    document.onmousedown = function () {
        if (!interactionMode) {
            interactionMode = 'mouse';
        }
    }
    document.onkeydown = function () { 
        if (!interactionMode) {
            interactionMode = 'keyboard';
        }
    }
</code></pre>
<p>登录界面或类似的地方是运行上面代码的理想场景。在这个场景中，用户必须与网站交互。当用户登录时， 用类似上面的代码检测用户正在使用哪种交互方式。要注意，这也只能说明用户在登录时使用的交互模式，并不是整个交互过程都会使用这个模式。虽然信息有限， 但这段代码还是有一定预测功能的。</p>
<p>尽管上面的方法无法预测用户接下来会使用哪种交互模式，但是目前最好的处理不同交互模式的方法还是<strong>为鼠标、键盘和触摸编写不同的代码。</strong></p>
<h2 id="补充"><a class="header-anchor" href="#补充"></a>补充</h2>
<h3 id="触摸事件的级联"><a class="header-anchor" href="#触摸事件的级联"></a>触摸事件的级联</h3>
<p>移动浏览器同时支持触摸事件和鼠标事件，会导致一个触摸动作触发多个事件。</p>
<ul>
<li>触摸（Tap）：touchstart/pointerdown、touchend/pointerup、mouseover、mousemove、mousedown、mouseup、click、:hover样式（需要注意的是为了兼容mouseover，抬起手指并不会触发mouseout，再次触摸才会）</li>
<li>滑动（Swipe）：touchstart、touchmove、touchend、scroll</li>
<li>缩放（Pinch）：touchstart、touchmove、touchend、scroll，可能还有resize</li>
<li>双触（double-tap）：touchstart、两次touchend、scroll，可能还有resize</li>
<li>按住（touchhold）：touchstart、touchend，有些浏览器还有contextmenu</li>
</ul>
<h3 id="剖析click"><a class="header-anchor" href="#剖析click"></a>剖析click</h3>
<p>300毫秒问题，无解。（Chrome支持但苹果不可能支持）</p>
]]></content>
      
        <categories>
            
            <category> 移动端Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 触摸事件 </tag>
            
            <tag> 指针事件 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发入门概述]]></title>
      <url>https://blog.az22c.top/2017/02/24/webapp-intro/</url>
      <content type="html"><![CDATA[<p><strong>PPK的《移动Web手册》</strong> 是对移动Web现状（2014年夏）的一个系统检阅，市场上有不少公司将赌注放在HTML5上，因此对于HTML5在移动Web上的应用多有炒作，但实际上如何呢？看完本书能让你有个清醒的认识。</p>
<p>移动浏览器虽然大都实现了桌面浏览器的功能，但实际上移动设备上的情况更加复杂，而且由于Android系统的碎片化直接导致浏览器的碎片化，它们对于一些和桌面不同情况的处理，以及一些最新特性的支持都是不尽相同的。</p>
<p><strong>所以HTML5在移动Web上的兼容性目前是很差的，</strong> 还有像触摸事件向指针事件标准化的过渡，估计最少需要5-10年才能达到一个比较理想的状态。</p>
<a id="more"></a>
<h2 id="浏览器相关"><a class="header-anchor" href="#浏览器相关"></a>浏览器相关</h2>
<h3 id="浏览器的类型"><a class="header-anchor" href="#浏览器的类型"></a>浏览器的类型</h3>
<ul>
<li>内置浏览器</li>
<li>可下载浏览器</li>
<li>代理浏览器</li>
<li>webview</li>
</ul>
<p>大多数内置浏览器都被紧密集成到底层的操作系统中，也就是说，无法单独升级浏览器。因此，为了得到新的Safary版本，你必须升级IOS。内置浏览器都有不同的内核比如：安卓是webkit、winphone是ie、ios是safari，大致上就是这样。</p>
<p>可下载浏览器，顾名思义用户可下载安装的浏览器，见的多的就是firefox、chrome了、360等。</p>
<p>代理浏览器是指服务端进行对页面的渲染，再把结果发送给客户端进行显示，比较少见。代理浏览器与完备浏览器（full browser）相对，代表为opera mini、UC mini。</p>
<p>WebView是留给原生应用的一个操作系统浏览接口。苹果不允许在IOS设备上安装其他渲染引擎。（其他平台是可以的）因此，其他浏览器要想在IOS上安装就必须用苹果的WebView。IOS上的Chrome就是这样的，同样的还有Opera Coast。大体上，WebView是独立的程序，用了内置浏览器很多底层的组件（比如渲染引擎），但是在其他方面可能会有所不同。<strong>如果希望你的页面能在WebView里跑起来的话，你最好在WebView上测试一下。</strong></p>
<p>补充：</p>
<blockquote>
<p>代理浏览器的原理：当用户请求页面，它不会发送一个普通HTTP请求而是通过加密链接发送特殊请求到一个特殊的代理服务器。代理服务器来抓取用户希望访问的内容，渲染页面，然后压缩渲染的页面成为某种图片，类似于PDF，然后代理服务器将这个文件发到客户端。</p>
<ul>
<li>好处：给用户节省流量。</li>
<li>弊端：页面内的javascript不能正常工作。</li>
</ul>
<p>随着现在wifi的普及等原因，代理浏览器用得很少。</p>
</blockquote>
<hr>
<h3 id="手机上的webkit"><a class="header-anchor" href="#手机上的webkit"></a>手机上的WebKit</h3>
<p>先列出不使用WebKit的浏览器：</p>
<blockquote>
<p>1. IE Mobile(即将替换为edge)，使用Trident
2. Opera Mini使用Presto，但是最终会换成Blink
3. Chrome浏览器用Blink
4. Firefox Mobile和Firefox OS使用Gecko
5. UC Mini、Nokia Xpress还有Jolla的Sailfish OS上的内置浏览器也用的是Gecko</p>
</blockquote>
<p>任何没在上面提到的浏览器都用WebKit。乍一看，这么多浏览器都用WebKit的事实对于Web开发者似乎是一个强大的支持，不幸的是，一个浏览器用Webkit并不意味着它跟其他任何基于Webkit的浏览器一样。实际上，**它们有很大的不同，依赖于操作系统、键盘、鼠标还有触屏交互。平台所有者必须提供所有这些功能。**手机上的Webkit名存实亡。</p>
<p>很多浏览器用着差不多一样的渲染引擎但是在细节上却大不相同。你最好在所有不同的基于WebKit的浏览器上测试你的网站。</p>
<hr>
<h3 id="测试android浏览器"><a class="header-anchor" href="#测试android浏览器"></a>测试Android浏览器</h3>
<p>对于Android设备的浏览器，有三个必须测试的浏览器：</p>
<blockquote>
<p>1. 安卓WebKit4，富含不同的设备和不同版本的安卓系统。一个专门的设备实验室需要大概6到8个这样的来自不同厂商的设备。一个小型实验室必须拥有2到3个：三星、HTC和一个其他厂商的设备
2. Google Chrome。如果你的设备上没有，下载一个。
3. 三星Chrome（三星字Galaxy S4发布以来，三星开始使用他自己开发的基于Chromium的一款浏览器作为内置浏览器，因此出现三星Chrome）。你讲需要购买一个2013年获以后发布的三星高端手机——类似Galaxy S4或更新的设备</p>
</blockquote>
<h2 id="视口相关"><a class="header-anchor" href="#视口相关"></a>视口相关</h2>
<h3 id="css像素和设备像素"><a class="header-anchor" href="#css像素和设备像素"></a>css像素和设备像素</h3>
<p>设备像素：设备屏幕的物理像素。</p>
<p>CSS像素：为Web开发者创造的，在CSS和JS中使用的一个抽象层。CSS像素和设备像素的比例取决于屏幕是否高DPI和用户缩放的比例。</p>
<blockquote>
<p>css像素是专门为我们Web开发者创造的一个抽象层。当在使用css和javascript的时候，你并不在意一个css像素跨越了多少个设备像素。你开心地将这个依赖于屏幕特性和用户缩放程度的复杂计算交给了浏览器。</p>
<p>用户放大得越大，一个css像素覆盖的设备像素越多。</p>
</blockquote>
<hr>
<h3 id="布局视口"><a class="header-anchor" href="#布局视口"></a>布局视口</h3>
<p>CSS布局会根据它来计算，并被它约束。在手机上，为了容纳为桌面浏览器设计的网站，**默认的布局视口宽度远大于屏幕的宽度。**为了让用户看到网站全貌，它会缩小网站。</p>
<pre><code class="language-html">&lt;!-- width属性设置布局视口的宽度为特定的值 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
</code></pre>
<p>但在另一篇文章里面，并不推荐设置width属性。</p>
<h3 id="视觉视口"><a class="header-anchor" href="#视觉视口"></a>视觉视口</h3>
<p>它是用户正在看到的网站的区域。这个视口与设备屏幕一样宽。</p>
<p>用户可以缩放来操作视觉视口，同时不会影响布局视口，布局视口仍保持在原来的宽度。视觉视口与设备屏幕一样宽，并且它的CSS像素的数量会随着用户缩放而改变。</p>
<h3 id="理想视口"><a class="header-anchor" href="#理想视口"></a>理想视口</h3>
<p>对于特定设备上的特定浏览器的布局视口的一个理想尺寸，在这个尺寸下，用户刚进入页面时不再需要缩放，拥有最理想的浏览和阅读的宽度。</p>
<hr>
<h3 id="缩放"><a class="header-anchor" href="#缩放"></a>缩放</h3>
<p>桌面浏览器的缩放仅改变内容尺寸，不改变布局视口；移动端缩放则整体改变。</p>
<p><strong>不要禁止缩放！</strong> 禁止缩放是邪恶的，并且浏览器可以关闭禁止缩放功能。</p>
<p>禁止缩放的代码为：</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
</code></pre>
<h3 id="分辨率"><a class="header-anchor" href="#分辨率"></a>分辨率</h3>
<p>物理分辨率：设备每英寸内点数（DPI）</p>
<p>设备像素比：设备像素个数和理想视口的比（DPR）</p>
<p>dppx和dpi：每一个像素的点数。JS中的<code>window.devicePixelRatio</code>和媒体查询的<code>device-pixel-ratio</code>的单位。IE不支持，因此要使用dpi单位：</p>
<pre><code class="language-javascript">if(window.devicePixelRatio) {
    // DPR大于等于2时执行
}

@media all and((-webkit-min-device-pixel-ratio:2), (min-resolution:192dpi)) {
    // DPR大于等于2时生效
}
</code></pre>
<p>1dppx = 96dpi：一英寸对应CSS中96个像素。</p>
<h3 id="meta视口标签："><a class="header-anchor" href="#meta视口标签："></a>meta视口标签：</h3>
<p>meta视口标签存在的主要目的是让布局视口的尺寸和理想视口的尺寸匹配。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot;&gt;
</code></pre>
<p>其中可用的name为：</p>
<ul>
<li>width：device-width适用于大多数情况。</li>
<li>initial-scale：一般设为1，为了兼容应同时设置width=device-width。</li>
<li>minimum-scale</li>
<li>maximum-scale</li>
<li>user-scalable</li>
</ul>
<h3 id="媒体查询"><a class="header-anchor" href="#媒体查询"></a>媒体查询</h3>
<p>媒体类型：目前只有print被正确实现。一般使用all。</p>
<blockquote>
<p>Web开发者希望区分能力弱和能力强的浏览器，而弱浏览器为了避免探测开始伪装自己。</p>
<p>过去的浏览器最多可处理WAP和HTML的子集XHTML-MP，它们大都遵循标准并实现handheld，Web开发者为这些类型提供简单的样式。而新的现代移动浏览器出现后，它们支持全部样式、JS，因此宁愿不实现handheld而获得和桌面浏览器一样的待遇。</p>
</blockquote>
<h3 id="javascript"><a class="header-anchor" href="#javascript"></a>JavaScript</h3>
<p>媒体查询与JavaScript属性相对应。</p>
<ul>
<li>物理屏幕分辨率：screen.width/height（有兼容问题不建议使用）</li>
<li>布局视口：document.documentElement.clientWidth</li>
<li>视觉视口：window.innerWidth</li>
<li>理想视口：screen.width/height（有兼容问题不建议使用）</li>
<li>设备像素比：window.devicePixelRatio</li>
<li>屏幕方向：window.orientation</li>
</ul>
<p><code>document.documentElement.clientWidth/Height</code>返回的是布局视口的尺寸，被普遍支持。</p>
<p><code>window.innerWidth/Height</code>返回视觉视口的尺寸。接近被普遍支持。</p>
<p><code>screen.width/height</code>返回理想视口的尺寸。有很严重的浏览器兼容性问题，	不建议使用。</p>
<h2 id="css相关"><a class="header-anchor" href="#css相关"></a>CSS相关</h2>
<p>移动浏览器与桌面浏览器对CSS支持的差异：</p>
<ul>
<li>桌面用例在移动端不存在。如hover。</li>
<li>视口不统一。如单位vw和vh。</li>
<li>对独立可滚动层的需求在移动设备上更难实现。如background-attachment。</li>
<li>硬件限制。在老设备上transition和animation可能无法使用。</li>
</ul>
<p>以下属性都<strong>不建议</strong>在移动Web上使用:</p>
<h3 id="position-fixed"><a class="header-anchor" href="#position-fixed"></a>position:fixed</h3>
<p>此属性标准没有支持缩放。</p>
<h3 id="overflow-auto"><a class="header-anchor" href="#overflow-auto"></a>overflow:auto</h3>
<p>多个可滚动层体验不好，并且移动上默认不显示滚动条会漏掉内容。</p>
<p><code>-webkit-overflow-scrolling:auto</code>：平滑滚动。</p>
<h3 id="background-attachment"><a class="header-anchor" href="#background-attachment"></a>background-attachment</h3>
<p>三个可选值scroll、fixed、local。会创建过多的可滚动层，影响性能。</p>
<h3 id="尺寸单位vw和vh"><a class="header-anchor" href="#尺寸单位vw和vh"></a>尺寸单位vw和vh</h3>
<p>非常冷门的单位，本来也没什么人用，这里就不多说了。</p>
<h3 id="active和-hover"><a class="header-anchor" href="#active和-hover"></a>:active和:hover</h3>
<p><code>:hover</code>在桌面浏览器用的过多，因此移动设备必须支持，但实际上在用户触摸元素时触发，引起事件级联。</p>
<p><code>:active</code>相对支持的不好，可以和<code>:focus</code>同时使用，后者支持的较好。</p>
<h3 id="transition和animation"><a class="header-anchor" href="#transition和animation"></a>transition和animation</h3>
<p>实际上浏览器支持的很好，但这两个属性会用到GPU，而移动设备GPU很糟糕，至少是早期的很糟糕。</p>
<h3 id="css过度和动画"><a class="header-anchor" href="#css过度和动画"></a>css过度和动画</h3>
<p>只要你使用了过度和动画，就在你能找到的最老、最差的设备上进行测试。它们的问题不在浏览器，而在<strong>设备</strong>，浏览器对两者的支持都很好。但是为了达到非常平滑的效果，浏览器必须借助设备GPU的计算能力。在高端智能手机上不成问题，但对于早期和廉价的手机来说，它们可能根本没有响应的硬件和系统API。这就导致最终的动画效果很生硬。</p>
<h2 id="触摸和指针事件"><a class="header-anchor" href="#触摸和指针事件"></a>触摸和指针事件</h2>
<p>触摸事件为苹果发明，它将触摸和鼠标两种行为区分开，而微软的指针事件则将它们合并，此标准更具前瞻性，现已被W3C采纳为正式标准。</p>
<p>内容详见另一篇文章：</p>
<h2 id="克服过时的惯性思维"><a class="header-anchor" href="#克服过时的惯性思维"></a>克服过时的惯性思维</h2>
<ul>
<li>浏览器探测。事实上无论是浏览器探测还是特性探测在移动浏览器上都可能表现不佳。</li>
</ul>
<blockquote>
<p>浏览器只会返回它支持某项特性，但不会告诉你支持程度有多差。</p>
</blockquote>
<ul>
<li>Javascript脚本库。**在编写小功能时不要依赖脚本库而是应该用原生JS实现。 **</li>
</ul>
<h2 id="移动web的未来"><a class="header-anchor" href="#移动web的未来"></a>移动Web的未来</h2>
<h3 id="html5-vs-原生应用"><a class="header-anchor" href="#html5-vs-原生应用"></a>HTML5 vs 原生应用</h3>
<blockquote>
<p>全面追赶原生应用并不是Web技术的关键所在。我感觉我们应该聚焦在Web擅长的方面，并将它们做得更好。或者找出我们能够做好的方面，将它们做得超越原生应用。</p>
</blockquote>
<h3 id="模拟原生应用"><a class="header-anchor" href="#模拟原生应用"></a>模拟原生应用</h3>
<ul>
<li>网络连通性和AppCache。离线存储对移动Web应用非常有意义，但是AppCache简直是个垃圾。新的Service Worker试图取代它。</li>
<li>安装到主屏幕。被支持的并不好。</li>
<li>设备API。第一支持不完善，标准总是落后于现实；第二有安全问题，需要授权，而像安卓的用户授权是行不通的。</li>
</ul>
<blockquote>
<p>当你安装一个安卓应用时，系统会让你授权该应用可以具备哪些权限。这个设计的失败不仅在于我们需要更精细的权限控制，而且还在于它出现的时机不对：当用户安装某个应用时，用户只想尽快的用上它，他们会同意任何事情。</p>
</blockquote>
<h3 id="模拟web"><a class="header-anchor" href="#模拟web"></a>模拟Web</h3>
<p>Applink，直达应用的深层页面。（注：Android M和iOS 9都有类似的更新支持这项特性）</p>
<h3 id="分享应用"><a class="header-anchor" href="#分享应用"></a>分享应用</h3>
<p>PPK的脑洞：Web应用由于其良好的兼容性，应该让它可以通过蓝牙、NFC等在不同设备之间共享。</p>
]]></content>
      
        <categories>
            
            <category> 移动端Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yelee主题改bug总结]]></title>
      <url>https://blog.az22c.top/2017/02/22/my-hexo-theme/</url>
      <content type="html"><![CDATA[<p>从找一个喜欢的hexo主题到修改好bug发布到博客上面，整个过程花了我不少时间，下面是对这个改bug过程中发现的小问题做的总结。</p>
<p>此文无图。</p>
<a id="more"></a>
<p>一开始我是在知乎上面找好看的主题，找了很长一段时间才找到一个我比较喜欢的主题，并且挑选了一个已经被大神们优化得不错的主题来借鉴借鉴。</p>
<p>我的hexo主题其实就是直接Fork了<a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="noopener">ngudream</a>的主题，只不过该大神日常比较忙碌，我自己琢磨了一下代码，把一些报错的小bug给修复了，暂时还没有为这个主题添加什么特殊的功能。（原因是这个主题在各位大神的努力下，功能已经非常齐全炫酷了。）</p>
<p>直接参考ngudream的这篇文章就可以了，在此在此表示一万个感谢：</p>
<p><a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="noopener">http://ngudream.com/2017/01/24/n-hexo-blog/</a></p>
<p>在这个过程中我发现了一些小问题：</p>
<h2 id="左右搜索栏"><a class="header-anchor" href="#左右搜索栏"></a>左右搜索栏</h2>
<p>一定要先根据这个来安装插件：</p>
<p><a href="http://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Yilia主题添加本地站内搜索-高明飞</a></p>
<h3 id="找不到content-json"><a class="header-anchor" href="#找不到content-json"></a>找不到content.json</h3>
<ul>
<li>这是因为左下角搜索栏找不到content.json</li>
</ul>
<ul>
<li>将<code>yelee\source</code>文件夹下的search文件夹剪切到 根目录的source文件夹里面</li>
<li>生成一次页面</li>
<li>再把刚刚的search文件夹剪切回<code>yelee\source</code>文件夹下即可</li>
</ul>
<h3 id="cb-search-json-404-not-found"><a class="header-anchor" href="#cb-search-json-404-not-found"></a>cb-search.json 404 (Not Found)</h3>
<ul>
<li>是因为没有安装右下角搜索栏插件</li>
</ul>
<ul>
<li>如果安装插件之后语法报错，就把别人项目的文件代码复制过来就行了，省得去检查语法</li>
</ul>
<h3 id="百度分享因为混合内容报错"><a class="header-anchor" href="#百度分享因为混合内容报错"></a>百度分享因为混合内容报错</h3>
<p>如果因为混合内容报错（即https网站引用了http的资源），你可以将百度分享的地址改为：<code>https://github.com/hrwhisper/baiduShare</code>；本来我想把static文件夹放在外面一点的，但是有bug，我现在只是做到不报错而已，具体的百度分享内容都没弄</p>
<h3 id="百度站长要重新配置"><a class="header-anchor" href="#百度站长要重新配置"></a>百度站长要重新配置</h3>
<ul>
<li>查阅相关资料，依照资料放baidu_verify_QshFoK3ZRz.html在yelee的source文件夹下通过站长验证，放googleeff62ed1566e185e.html也是同理。</li>
</ul>
<p>百度sitemap要另外安装：</p>
<pre><code>npm install hexo-generator-baidu-sitemap --save 
</code></pre>
<ul>
<li>如果想要给谷歌提交网站，只需要在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Search Console</a>验证网站，并提交站点地图就可以了。谷歌真的好简单啊！谷歌的<code>sitemap.xml</code>不需要写到配置文件中，自动生效。
<ul>
<li>有个问题是，Github禁止百度爬虫，所以提交的sitemap迟早会显示失败，成功几率非常小</li>
</ul>
</li>
</ul>
<h2 id="温馨提示"><a class="header-anchor" href="#温馨提示"></a>温馨提示</h2>
<ul>
<li>多说也是会因为混合内容而报错，但是我只能改良，不能彻底解决这个问题
<ul>
<li>将多说的<code>embed.js</code>本地化，	将这个文件的地址改动到<code>duoshuo.ejs</code>和<code>click2show.ejs</code>和layout的<code>after-footer.ejs</code>文件里面，但是依然报错</li>
<li>见到http就给它加s</li>
</ul>
</li>
<li>在Markdown文章头部的标注信息的冒号后面要加一个空格，这是语法要求</li>
</ul>
<ul>
<li>在hexo s调试下，百度站长push报错属于正常现象</li>
<li>在hexo s调试下，文章导航的特效会失灵，属于正常现象</li>
</ul>
<ul>
<li>发现大神每篇文章文件的名字都是英文，Markdown里面的标题才是中英随意的，不然isPost()函数会出错
<ul>
<li>用cmd创文件名的时候英文全小写，空格用-表示，为了风格统一</li>
</ul>
</li>
<li>插件这种东西最好不要复制，所以<strong>在重新搭建博客的时候</strong>我没有直接复制node_modules文件夹，这也容易令人忽略了大神自己在这个文件夹下改良的index.js和search.ejs文件</li>
</ul>
<h2 id="请不要fork我的主题"><a class="header-anchor" href="#请不要fork我的主题"></a>请不要Fork我的主题</h2>
<p>去Fork大神ngudream的主题就可以了，因为我的个人改动比较私人化，所以Fork之后别人可能会看不懂。另外我的主题作了几个不好的改动：</p>
<ul>
<li>为了避免报错，一开始我把一些if语句的判断条件直接改为false，原本它们的判断条件是xxx.on的</li>
</ul>
<ul>
<li>还有一个feed属性没研究，应该是订阅博客的功能，好像也被我粗暴地关了</li>
<li>报错<code>Cannot GET /plugins/css/special.css</code>，我直接把“字往下掉”动画关掉</li>
<li>然后就是折腾在显示主页时标签栏出现的undefined，一开始我不知道那个把三项文字的标签转为二项的js文件，所以一直研究ejs代码都没弄好。后来我直接给主页加一个英文名字blog就算了。总算不出现undefined</li>
<li>乱关乱开了一下博文最下方的分享栏，不知道会不会出问题，这个模块应该是百度分享</li>
<li>点击微信之后，那个左右滑动的栏目我暂时改不了代码，本来我想去掉qq的，但是只好把qq的二维码弄上
<ul>
<li>还有就是去掉qq之后，点击微信，上面那个圆形地方就没有图案显示</li>
</ul>
</li>
<li>发现search-result-list模块的文字被顶到后面
<ul>
<li>把.col-3的CSS的marginbottom改为4px就行了</li>
</ul>
</li>
</ul>
<h3 id="我没有完善的内容"><a class="header-anchor" href="#我没有完善的内容"></a>我没有完善的内容</h3>
<ul>
<li>代码压缩没搞</li>
<li>公益404没搞</li>
<li>右下角搜索栏搞了，但是利用的不是打分排名</li>
<li>谷歌分析到现在也不会，所以先不用，应该和百度站长是差不多的，没心思搞</li>
<li>好像就只有360浏览器看不到emoji表情，所以即便安装了插件，文章尽量不要用emoji</li>
</ul>
<h2 id="整个过程的心得"><a class="header-anchor" href="#整个过程的心得"></a>整个过程的心得</h2>
<ul>
<li>在这过程中学会了用HTML-beautify来美化sublime中的html代码排版</li>
<li>对ejs的代码写法有所了解</li>
<li>明白了代码中的partial是干嘛的：复用模板</li>
<li>第一次发现一些私人的代码改动都是写在<code>after-footer.ejs</code>里面</li>
<li>发现dos的报错信息还是有点用的</li>
<li>令我困惑的是填yml文件中的url项，后来发现用来填绑定的域名，域名要自己出钱买</li>
<li>一开始遇到<code>Cannot read property 'on' of undefined</code>不会调，后来发现是yml文件填得不好，可能是不符合语法，导致错误。再比如yml文件中代码没有在适当的地方空空格。</li>
<li>如果在网上打开js文件发现中文变乱码，在谷歌浏览器打开查看就可以了，这是最不消耗脑力的办法</li>
<li>另外，推荐一款布局非常合理的hexo主题： <a href="https://github.com/shenliyang/hexo-theme-snippet" target="_blank" rel="noopener">snippet</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> yelee </tag>
            
            <tag> theme </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ToDo小应用完工总结]]></title>
      <url>https://blog.az22c.top/2017/02/17/todo-app/</url>
      <content type="html"><![CDATA[<p>完成了百度IFE2015的 <a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003" target="_blank" rel="noopener">task3</a> ，实现了一个 ToDo 的单页应用，功能颇为强大。</p>
<p>使用 localStorage 存储数据，JSON 模拟数据表，实现了分类和待办状态的改变，具有良好的交互体验。</p>
<p>旧项目地址：<a href="https://github.com/AlexZhong22c/ToDoApp-IFE2015" target="_blank" rel="noopener">https://github.com/AlexZhong22c/ToDoApp-IFE2015</a></p>
<p>新增了 <a href="https://to-do-web-app.az22c.vercel.app/" target="_blank" rel="noopener">升级版</a> 修复了一些bug，并且适配移动端：<a href="https://github.com/AlexZhong22c/ToDo-WebApp" target="_blank" rel="noopener">https://github.com/AlexZhong22c/ToDo-WebApp</a></p>
<a id="more"></a>
<h2 id="知识收获"><a class="header-anchor" href="#知识收获"></a>知识收获</h2>
<h3 id="自适应高度布局"><a class="header-anchor" href="#自适应高度布局"></a>自适应高度布局</h3>
<p>分为上中下三栏，中间的一栏自适应浏览器高度。这是参考了横向的三栏布局来写的。</p>
<ul>
<li>中间一栏要在外面包一层div，如果外面本来就有一层div这种布局就非常合适。上栏和下栏用绝对定位即可。</li>
<li>外面的这层div使用大面积的padding</li>
</ul>
<h3 id="在javascript-中创建html元素-用createelement-还是innerhtml好一点？"><a class="header-anchor" href="#在javascript-中创建html元素-用createelement-还是innerhtml好一点？"></a>在JavaScript 中创建HTML元素，用createElement()还是innerHTML好一点？</h3>
<ul>
<li>最叼的好像是 使用<a href="https://github.com/xwcoder/template" target="_blank" rel="noopener">模板技术</a>，其实我的静态博客用的就是这种。</li>
<li>在用js代码的循环创建元素的时候就顺便一个个绑定好事件这是一种比较简单的思路，这样就不用给每个元素增加id或者class了。这时候用createElement来创建元素就比较方便绑定事件，而如果用innerHTML来创建元素的话肯定不能在形成元素的循环里面给元素绑定事件了，这样太硬编码了。</li>
</ul>
<blockquote>
<p>《高性能JavaScript》：</p>
<ul>
<li>如果在对性能有苛刻要求更新一大段的HTML，innerHTML在大多数浏览器中执行更快。在旧版本浏览器中innerHTML方法更快，在基于Webkit内核却相反。</li>
<li>对于大多数日常操作而言，差异不大，根据代码可读性、可维护性、团队习惯、代码风格来决定采用哪种方法。</li>
<li>某答主说：**他一般大段就使用innerHTML了，而用dom创建单个元素或少量元素。 **</li>
<li>或者DOM结构嵌套的级数比较多的就用innerHTML</li>
<li>如果要使用createElement()，强烈推荐一下createDocumentFragment()
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">documentFragment</a> 被所有主流浏览器支持，甚至是IE 6。所以，没有理由不用。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="html属性用双引号-使用小写英文"><a class="header-anchor" href="#html属性用双引号-使用小写英文"></a>html属性用双引号、使用小写英文</h3>
<ul>
<li><strong>HTML4标准里没有单引号的对应实体，</strong> 所以单引号里写单引号很麻烦。后来XML规范才加入了’ 并由XHTML 1.0引入HTML。不过考虑到兼容性，前端几乎从来不写。
<ul>
<li>刚才在单引号里面写单引号只能用实体不能用反斜杠转移字符，根据HTML标准，反斜杠是不行的。</li>
</ul>
</li>
<li><strong>而JS中字符串用单引号，其实可能是HTML属性用双引号的结果。</strong></li>
<li>另外，一般大家惯用的做法是 HTML 用双引号，JS 用单引号的原因是，这样在 JS 中拼 HTML 片段不用转义：
<ul>
<li><code>elem.innerHTML = '&lt;div class=&quot;post&quot;&gt;&lt;/div&gt;';</code></li>
<li>当然你要反过来也可以，但不是主流做法。</li>
</ul>
</li>
<li>HTML属性不仅仅只有URL，另外引号出现在URL也是合法的。</li>
<li>根据W3Cschool的说法，<strong>要求属性和属性值使用小写，属性值应该始终被包括在引号内。</strong>
<ul>
<li>用innerHTML来创建taskid=1和cateid=0这种属性好像没有用啊，因为浏览器自动解析成：taskid=&quot;1&quot;和cateid=“0”</li>
</ul>
</li>
</ul>
<h3 id="ul里面能放除了li的其他标签吗？"><a class="header-anchor" href="#ul里面能放除了li的其他标签吗？"></a>ul里面能放除了li的其他标签吗？</h3>
<p>不能，<code>&lt;ul&gt;</code>里面只能放<code>&lt;li&gt;</code>。但是<code>&lt;li&gt;</code>里面可以放<code>&lt;hx&gt;</code>,<code>&lt;p&gt;</code>等标签。</p>
<p>ul里面放其他标签，不光不符合语义，在IE7- 里面也会有问题：</p>
<p>如果<code>&lt;other&gt;</code>标签前面有<code>&lt;li&gt;</code>标签，浏览器会认为<code>&lt;other&gt;</code>为<code>&lt;li&gt;</code>的子节点。</p>
<h3 id="box-shadow"><a class="header-anchor" href="#box-shadow"></a>box-shadow</h3>
<p>是CSS3里面的属性。只要shadow不占太多px的地方，用一下还是非常好的</p>
<h3 id="jquery"><a class="header-anchor" href="#jquery"></a>JQuery</h3>
<ul>
<li>JQuery的<code>not()</code>方法非常好用，<code>each()</code>也非常好</li>
</ul>
<ul>
<li>在绑定事件 函数中的 JQuery选择器 在函数触发后才会去选择对象</li>
<li>像这个App中分类列表的单击交互，如果想要只有被单击选择的HTML元素有 高亮，那么在绑定单击事件来响应单击选择的时候，记得先清除所有同类HTML元素的 高亮</li>
</ul>
<h4 id="jquery中-this-和-this-有区别："><a class="header-anchor" href="#jquery中-this-和-this-有区别："></a>JQuery中 this 和 $(“this”)有区别：</h4>
<p><a href="http://www.jb51.net/article/57376.htm" target="_blank" rel="noopener">JQuery中 this 和 $(“this”)有区别</a></p>
<p>如果你要使用html元素本身的属性或方法就需要使用this,如果你要使用jQuery包装后的方法或属性就要$(this),一般则有如下的关系.</p>
<pre><code>$(this)[0] == this;
</code></pre>
<p>上文的代码是要使用this的地方是要调用表单form的有reset方法,而这一方法jQuery没有包装支持,所以才有this.reset(),也可以使用$(this)[0].reset();</p>
<hr>
<p>关于什么时候使用二者?可以看如下例子:</p>
<pre><code>$('a').click(function(){
        this.innerHTML==$(this).html()=='jQuery';//三者是一样的.
        this.getAttribute('href')==this.href==$(this).attr('href')//三者是一样的;
        this.getAttribute('target')==this.target==$(this).attr('target')//三者是一样的;
        this.getAttribute('data-id')==$(this).attr('data-id')//二者是一样的;
    });
</code></pre>
<h3 id="caller的经典用法"><a class="header-anchor" href="#caller的经典用法"></a>caller的经典用法</h3>
<p>注：<strong>该特性是非标准的，请尽量不要在生产环境中使用它！</strong></p>
<p><img src="https://cloud.az22c.top/caller%E7%9A%84%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95.png-az22cgithub" alt></p>
<h2 id="精益求精"><a class="header-anchor" href="#精益求精"></a>精益求精</h2>
<h3 id="html-css"><a class="header-anchor" href="#html-css"></a>HTML+CSS</h3>
<ul>
<li><a href="http://blog.bingo929.com/CSS-coding-semantic-naming.html" target="_blank" rel="noopener">CSS命名惯例语义化</a></li>
<li>把需要的li全都设成了<code>cursor:pointer</code></li>
<li>虽然DOM结构是由js代码渲染的，在HTML留下一些<strong>template</strong>方便参考和编写代码</li>
<li>将颜色抽象成单独的class，方便更换颜色：</li>
</ul>
<pre><code>.white-bg {background: #FFFFCC;}
.black-bg {background: #3F3A39;}
.green-bg {background: #CFE8CC;}
.blue-bg {background: #5D6684;}
.grey-bg {background: #E9E9E9;}
.lt-blue-bg {background: #DADADA;}
</code></pre>
<p>我认为，只有占<strong>大块区域</strong>的元素才用色彩的class来设置<strong>背景颜色</strong>。因为如果要上色的元素很多的话，或者元素会短时间内存在再消失的话，一个一个加class就很麻烦。</p>
<h3 id="javascript"><a class="header-anchor" href="#javascript"></a>JavaScript</h3>
<ul>
<li>优化了 JavaScript 函数的命名，使得风格统一，语义明确。
<ul>
<li>这个App里面，用来控制视图层的函数最好用refresh来命名，用update命名的函数用于更新数据库的信息</li>
</ul>
</li>
</ul>
<ul>
<li>一般留下数组index为0的位置来存放一些默认的数组元素。比如存储“分类”的数组就将“默认分类”设为是它的0号元素。</li>
<li>深刻感受到使用主键等等概念管理数据库的简便</li>
<li>如果是 JavaScript 对象字面量，键值对的 键 最好不要用&quot;“包着，转成JSON的时候 键 会自动被”&quot;包上</li>
<li><strong>util.js</strong>是基于前面的小任务写的，它的功能很薄弱。例如<code>$(#modal-foot button)</code>返回来的只是一个元素对象，不合理，所以为了省事我直接用JQuery库就好了。</li>
</ul>
<h3 id="改进代码"><a class="header-anchor" href="#改进代码"></a>改进代码</h3>
<pre><code>function queryCateById(id) {
    var allCates = queryAllCates();
    var result = null;
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            result = allCates[i];
            break;
        }
    }
    return result;
}
</code></pre>
<p>简化为：</p>
<pre><code>function queryCateById(id) {
    var allCates = queryAllCates();
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            return allCates[i];
        }
    }
}
</code></pre>
<h3 id="容易犯的错误"><a class="header-anchor" href="#容易犯的错误"></a>容易犯的错误</h3>
<ul>
<li>JQuery中使用id选择器返回的也是<strong>元素数组</strong>。</li>
</ul>
<pre><code>console.log($(&quot;#modal-foot&quot;))// 元素数组
console.log($(&quot;#modal-foot&quot;)[0])// 这才是想要的元素
</code></pre>
<ul>
<li>HTML会自动忽略空格，要空格请用<code>&amp;nbsp;</code></li>
</ul>
<hr>
<p>在JQuery中，$(selector)[0]中的[0]会将JQuery对象转化为JavaScript对象。所以onclick有两种写法：</p>
<pre><code>$(&quot;#modal-foot button.cancel&quot;)[0].onclick = function() {
	// ```
}; 
///////分割线
$(&quot;#modal-foot button.cancel&quot;).click(function() {
	$(&quot;.cover&quot;).hide();
}); 
// $(selector).click(function() {});
</code></pre>
<p>另外还有一个例子可以看一下：</p>
<pre><code>$(&quot;.cover&quot;).show();
$(&quot;.cover&quot;).css(&quot;display&quot;,&quot;block&quot;);
$(&quot;.cover&quot;)[0].style.display = &quot;block&quot;;
</code></pre>
<h3 id="优化命名"><a class="header-anchor" href="#优化命名"></a>优化命名</h3>
<p><strong>函数名</strong>中包含&quot;all&quot;还是挺有用的，但是<strong>函数中的变量名</strong>包含&quot;all&quot;就没什么作用，如果是数组用&quot;arr&quot;命名就可以了。</p>
<p>比如：</p>
<pre><code>// 函数名中包含all，比较容易与其他类似的函数区分
function queryAllCates() {
    return JSON.parse(localStorage.cate);
}
</code></pre>
<p>再比如：</p>
<pre><code>function queryCateById(id) {
    var allCates = JSON.parse(localStorage.cate);
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            return allCates[i];
        }
    }
}
// 函数内变量名带all好像也没什么用。allCates还不如直接叫cates或者叫catesArr
</code></pre>
<p>但是：</p>
<p>如果用addNewTask作为函数名，肯定不够用addTask作为函数名好。</p>
<h2 id="发现的bug-找时间再fix"><a class="header-anchor" href="#发现的bug-找时间再fix"></a>发现的bug，找时间再fix</h2>
<ol>
<li>火狐浏览器不实现<code>&lt;input type=&quot;date&quot;&gt;</code></li>
</ol>
<h2 id="最后："><a class="header-anchor" href="#最后："></a>最后：</h2>
<blockquote>
<p><a href="https://github.com/AlexZhong22c/color-design-22c" target="_blank" rel="noopener">color design</a>：<a href="https://github.com/AlexZhong22c/color-design-22c" target="_blank" rel="noopener">https://github.com/AlexZhong22c/color-design-22c</a></p>
<p>如果各位看官喜欢的话留一个Star吧！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 项目总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> App </tag>
            
            <tag> caller </tag>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[相等操作符回顾]]></title>
      <url>https://blog.az22c.top/2017/02/11/equality-operators/</url>
      <content type="html"><![CDATA[<p>最早的ECMAscript中的相等和不相等操作符会在执行比较之前，先将对象转换成相似的类型(即，强制转型)。</p>
<p>后来有人对这种转换的合理性提出质疑。</p>
<p>最后，ECMAcript的解决方案是提供两组操作符：</p>
<ul>
<li>相等和不相等——先转换再比较</li>
<li>全等和不全等——仅比较而不转换</li>
</ul>
<a id="more"></a>
<h2 id="相等-和不相等"><a class="header-anchor" href="#相等-和不相等"></a>相等(==)和不相等(!=)</h2>
<p>&quot;==“和”!=“是互补对立的：如果两个操作数用”==“比较时返回 true，则这两个操作数用”!=“比较时就会返回 false ; 另外，用”==“返回 false 时，用”!=&quot;则返回true，这点很容易理解。</p>
<p>这两个操作符都会强制转型，<strong>在比较相等性之前</strong>会作以下工作：</p>
<ul>
<li>布尔值转换为数值，详见后面的补充。</li>
<li>字符串和数值比较时，将字符串转换成数值</li>
<li>对象和<strong>不是对象的操作数</strong>比较时，调用对象的<code>valueOf()</code>方法，用得到的基本类型值按照前面的规则进行比较。</li>
</ul>
<p>==和!=<strong>在进行比较之时</strong>遵循以下规则：</p>
<ul>
<li>null 和 undefined 是相等的。null == undefined
<ul>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
</ul>
</li>
<li>NaN和任何操作数不等，NaN 不等于NaN。
<ul>
<li>如果有一个操作数是 NaN，则&quot;==“返回 false ，而”!=&quot;返回 true 。</li>
<li>重要提示：即便两个操作数都是NaN，&quot;==&quot;也返回false，因为按照规则，NaN 不等于NaN。</li>
</ul>
</li>
<li>如果两个操作数都是对象，则比较它们是不是指向同一个对象。</li>
</ul>
<p>补充：</p>
<p>1. 相等运算符隐藏的强制转型，会带来一些违反直觉的结果：</p>
<pre><code> '' == 0            // true
' \t\r\n ' == 0     // true

false == 'false'    // false，这个超坑爹
false == '0'        // true
</code></pre>
<p>2.</p>
<pre><code>true == 1 返回true
false == 0 返回true
true == 2 返回true
</code></pre>
<p>还有另外一个概念叫<strong>Boolean 表达式</strong>，容易和以上概念混淆。在需要用到 Boolean 表达式的情景(比如if等语句中的条件判断)，非 Boolean 表达式也可以被转换为 Boolean 值，但是要遵循下列规则：</p>
<ul>
<li>所有的对象都被当作 true。</li>
<li>当且仅当字符串为空时，该字符串被当作 false。</li>
<li><strong>null</strong> 和 <strong>undefined</strong> 被当作 false。</li>
<li>当且仅当数字为零时，该数字被当作 false。</li>
</ul>
<h2 id="全等-和不全等"><a class="header-anchor" href="#全等-和不全等"></a>全等(===)和不全等(!==)</h2>
<p>和**相等(==)和不相等(!=)**类似，只不过在比较之前没有强制转型的过程，两个操作数直接比较。</p>
<h2 id="尽量使用全等和不全等"><a class="header-anchor" href="#尽量使用全等和不全等"></a>尽量使用全等和不全等</h2>
<p>举个简单的例子，团队协作中你肯定需要读别人的代码。而当你看到“==”时，要判断清楚作者的代码意图是确实需要转型，还是无所谓要不要转型只是随手写了，还是不应该转型但是写错了……所花费的脑力和时间比明确的“===”（加上可能需要的明确转型）要多得多。要记得团队中的每个人（包括原作者自己）都需要付出这理解和维护成本。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作符回顾]]></title>
      <url>https://blog.az22c.top/2017/02/11/js-operators/</url>
      <content type="html"><![CDATA[<p>ECMAScript 操作符的与众不同之处在于，它们能适用于很多种基本数据类型的值，例如字符串、数字值、布尔值、甚至对象。</p>
<p>不过，在应用于对象时，响应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p>
<a id="more"></a>
<h2 id="一元操作符"><a class="header-anchor" href="#一元操作符"></a>一元操作符</h2>
<p>自增和自减直接借鉴了C语言</p>
<p>自增、自减、加、减这些一元操作符可以用于转换数据类型。</p>
<h2 id="位操作符"><a class="header-anchor" href="#位操作符"></a>位操作符</h2>
<p>这是借鉴了一些底层的语言，在特殊情况下才会用到，一般情况下已经很少用了</p>
<h2 id="布尔操作符"><a class="header-anchor" href="#布尔操作符"></a>布尔操作符</h2>
<h3 id="逻辑非"><a class="header-anchor" href="#逻辑非"></a>逻辑非</h3>
<p>返回的是布尔值</p>
<h3 id="逻辑与和逻辑或"><a class="header-anchor" href="#逻辑与和逻辑或"></a>逻辑与和逻辑或</h3>
<p>如果操作数不只有布尔值：</p>
<h4 id="none"><a class="header-anchor" href="#none"></a>&amp;&amp;</h4>
<p>如果第一个操作数是 Boolean 类型，而且值为 false ，那么直接返回 false。
如果第一个操作数是 Boolean 类型，而且值为 true，另外一个操作数是 object 类型，那么将返回这个对象。
如果两个操作数都是 object 类型，那么，返回第二个对象。
如果任何一个操作数是 null，那么，返回 null。
如果任何一个操作数是 NaN，那么返回 NaN。
如果任何一个操作数是 undefinded，那么返回 undefined。</p>
<h4 id="none-v2"><a class="header-anchor" href="#none-v2"></a>||</h4>
<p>如果第一个操作数是 boolean 类型，而且值为 true， 那么，直接返回 true。
如果第一个操作数是 Boolean 类型，而且值为 false ，第二个操作数为 object，那么返回 object 对象。
如果两个操作数都是 object 类型，那么返回第一个对象。
如果两个操作数都是 null，那么，返回 null。
如果两个操作数都是 NaN，那么返回 NaN。
如果两个操作数都是 undefined，那么，返回 undefined。</p>
<h4 id="不用搞得这么复杂-推荐大家看这部分的说明"><a class="header-anchor" href="#不用搞得这么复杂-推荐大家看这部分的说明"></a>不用搞得这么复杂 推荐大家看这部分的说明</h4>
<p>a &amp;&amp; b : 将a, b转换为Boolean类型, 再执行逻辑与, true返回b, false返回a
a || b : 将a, b转换为Boolean类型, 再执行逻辑或, true返回a, false返回b
转换规则:
对象为true
非零数字为true
非空字符串为true
其他为false</p>
<hr>
<p>我们可以利用 逻辑或 这一行为来避免为变量赋值 null 或 undefined 值：</p>
<pre><code>var myObject = preferredObject || backupObject;
</code></pre>
<p>变量 preferredObject 的值优先赋给 myObject ，变量 backupObject 的值作为后备。</p>
<h2 id="乘性操作符"><a class="header-anchor" href="#乘性操作符"></a>乘性操作符</h2>
<p>Infinity 和 -Infinity 表示无穷大和负无穷大</p>
<h3 id="乘法"><a class="header-anchor" href="#乘法"></a>乘法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity * 0 ==&gt; NaN</li>
</ul>
<h3 id="除法"><a class="header-anchor" href="#除法"></a>除法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity / Infinity ==&gt; NaN</li>
<li>0 / 0 ==&gt; NaN</li>
</ul>
<h3 id="求模"><a class="header-anchor" href="#求模"></a>求模</h3>
<p>a % b：</p>
<p>如果a有限大，而b无限大，结果为a</p>
<p>如果a为0， 结果为0</p>
<p>其他特殊情况一般为NaN</p>
<h2 id="加性操作符"><a class="header-anchor" href="#加性操作符"></a>加性操作符</h2>
<h3 id="加法"><a class="header-anchor" href="#加法"></a>加法</h3>
<ul>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后拼接字符串
<ul>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的toString() 方法</li>
<li>对于undefined 和 null ，调用String()函数取得字符串&quot;undefined&quot;和&quot;null&quot;</li>
</ul>
</li>
</ul>
<h3 id="减法"><a class="header-anchor" href="#减法"></a>减法</h3>
<p>略</p>
<h2 id="关系操作符"><a class="header-anchor" href="#关系操作符"></a>关系操作符</h2>
<ul>
<li>如果两个操作符都是字符串，则比较两个字符串对应的字符编码值
<ul>
<li>大写字母的字符编码 全部小于 小写字母的字符编码</li>
</ul>
</li>
</ul>
<h2 id="相等操作符"><a class="header-anchor" href="#相等操作符"></a>相等操作符</h2>
<p>见另外一篇文章 <a href="/2017/02/11/equality-operators/">相等操作符</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[font-face--CSS3]]></title>
      <url>https://blog.az22c.top/2017/01/25/font-face/</url>
      <content type="html"><![CDATA[<p><code>@font-face</code>是一个css命令，用来导入服务器端字体，将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。因此本地浏览器浏览网页时，不需要设置字体，就可以自动看到@font-face设置的任何字体。</p>
<p>如果你看到一些英文网站或blog看到一些很漂亮的自定义Web字体，比如说首页的Logo，Tags以及页面中的手写英文体，这些都是**@font-face**实现的。</p>
<a id="more"></a>
<h2 id="font-face在css中使用"><a class="header-anchor" href="#font-face在css中使用"></a>@font-face在css中使用</h2>
<pre><code>@font-face {
　　font-family: &lt;YourWebFontName&gt;;
　　src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;
　　[font-weight: &lt;weight&gt;];
　　[font-style: &lt;style&gt;];
}
</code></pre>
<p>取值说明：</p>
<ol>
<li>YourWebFontName:你自定义的字体名称，最好是使用你下载的默认字体名（下载回来的叫什么字体，这里就填什么字体名），他将被引用到你的Web元素中的font-family。如“font-family:“YourWebFontName”;”</li>
<li>source:此值指的是自定义的字体的存放路径，可以是相对路径也可以是绝路径；</li>
<li>format：此值指的是自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</li>
<li>weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</li>
</ol>
<h2 id="兼容浏览器"><a class="header-anchor" href="#兼容浏览器"></a>兼容浏览器</h2>
<p>说到浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，这样大家有必要了解一下，各种版本的浏览器支持什么样的字体：</p>
<blockquote>
<p><strong>一、TureTpe(.ttf)格式：</strong></p>
<p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p>
<p><strong>二、OpenType(.otf)格式：</strong></p>
<p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，所以也提供了更多的功能,支持这种字体的浏览器有【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】；</p>
<p><strong>三、Web Open Font Format(.woff)格式：</strong></p>
<p><strong>.woff字体是Web字体中最佳格式</strong>，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p>
<p><strong>四、Embedded Open Type(.eot)格式：</strong></p>
<p>.eot字体是<strong>IE专用字体</strong>，可以从TrueType创建此格式字体,支持这种字体的浏览器有【IE4+】；</p>
<p><strong>五、SVG(.svg)格式：</strong></p>
<p>.svg字体是基于SVG字体渲染的一种格式,支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p>
</blockquote>
<p><strong>这就意味着在@font-face中我们至少需要.woff,.eot两种格式字体</strong>，<strong>甚至还需要.svg等字体达到更多种浏览版本的支持。</strong></p>
<hr>
<p>为了使@font-face达到更多的浏览器支持，<a href="http://paulirish.com/" target="_blank" rel="noopener">Paul Irish</a>写了一个独特的@font-face语法叫<a href="http://paulirish.com/2009/bulletproof-font-face-implementation-syntax/" target="_blank" rel="noopener">Bulletproof @font-face</a>:</p>
<pre><code>  @font-face {
	font-family: 'YourWebFontName';
	src: url('YourWebFontName.eot?#iefix') format('eot');/*IE*/
	src:url('YourWebFontName.woff') format('woff'), url('YourWebFontName.ttf') format('truetype');/*non-IE*/
   }
</code></pre>
<p>但为了让各多的浏览器支持，你也可以写成：</p>
<pre><code>  @font-face {
	font-family: 'YourWebFontName';
	src: url('YourWebFontName.eot'); /* IE9 Compat Modes */
	src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
             url('YourWebFontName.woff') format('woff'), /* Modern Browsers */
             url('YourWebFontName.ttf')  format('truetype'), /* Safari, Android, iOS */
             url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */
   }
</code></pre>
<p>直接改改<code>YourWebFontName</code>就行了。</p>
<p>然后就在CSS 里面引用给对应的元素：</p>
<pre><code>p {
	font-family: 'YourWebFontName'
}
</code></pre>
<hr>
<h2 id="获取特殊字体"><a class="header-anchor" href="#获取特殊字体"></a>获取特殊字体</h2>
<p>我平时都是到Google Web Fonts和Dafont.com寻找自己需要的字体，当然网上也还有别的下载字体的地方,如：<a href="http://webfonts.fonts.com/" target="_blank" rel="noopener">Webfonts</a>,<a href="http://typekit.com/" target="_blank" rel="noopener">Typekit</a>,<a href="http://kernest.com/" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.google.com/webfonts" target="_blank" rel="noopener">Google Web Fonts</a>,<a href="http://kernest.com/licenses" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont</a>,<a href="http://nicewebtype.com/fonts/" target="_blank" rel="noopener">Niec Web Type</a>,不然你点<a href="http://www.google.com/search?q=webfonts" target="_blank" rel="noopener">这里</a>将有更多的免费字体。前面几个链接是帮助你获取一些优美的怪异的特殊字体!</p>
<h3 id="获取-font-face所需字体格式："><a class="header-anchor" href="#获取-font-face所需字体格式："></a>获取@font-face所需字体格式：</h3>
<p>特殊字体已经在你的电脑中了，现在我们需要想办法获得@font-face所需的.eot,.woff,.ttf,.svg字体格式。要获取这些字体格式，我们同样是需要第三方工具或者软件来实现，下面我给大家推荐一款我常用的一个工具<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">fontsquirrel</a>, 链接：<a href="http://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="noopener">http://www.fontsquirrel.com/tools/webfont-generator</a></p>
<p>使用这个在线字体格式生成工具，我们只需要上传我们下载回来的一种字体格式，就能生成其它的.eot,.woff,.ttf,.svg字体格式，很方便地说！这款工具的具体使用方法，可参考原文：</p>
<p><a href="http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2084875.html" target="_blank" rel="noopener">http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2084875.html</a> ，本文也是转载该站 的内容 ，在此表示 感谢 ！</p>
<p>或者这个在线字体格式转换地址：<a href="https://cloudconvert.com/" target="_blank" rel="noopener">https://cloudconvert.com/</a> 也是可以的，有其它比较实用方便的网址，欢迎留言提供，方便大家。</p>
<hr>
<p>推荐给body写：</p>
<pre><code>font-family: -apple-system-font,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Open Sans&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;WenQuanYi Micro Hei&quot;,sans-serif;
</code></pre>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> font-face </tag>
            
            <tag> 字体 </tag>
            
            <tag> 特殊 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js函数基础回顾]]></title>
      <url>https://blog.az22c.top/2017/01/13/js-function/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="创建函数对象的三种方法"><a class="header-anchor" href="#创建函数对象的三种方法"></a>创建函数对象的三种方法</h2>
<h3 id="函数声明"><a class="header-anchor" href="#函数声明"></a>函数声明</h3>
<p>就是对函数进行普通的声明</p>
<pre><code>function add(a, b) {
    return a + b;
}
</code></pre>
<h3 id="函数表达式"><a class="header-anchor" href="#函数表达式"></a>函数表达式</h3>
<ul>
<li>将函数赋值给变量</li>
</ul>
<pre><code>// function variable
var add = function(a, b) {
    // body...
};
</code></pre>
<ul>
<li>立即执行函数，把匿名函数用括号括起来，再直接调用。</li>
</ul>
<pre><code>// IEF(Immediately Executed Function)
(function() {
    // body...
})();
</code></pre>
<ul>
<li>函数对象作为返回值</li>
</ul>
<pre><code>return function() {
    // body...
};
</code></pre>
<ul>
<li>命名式函数表达式</li>
</ul>
<pre><code>//NFE(Named Function Expression)
var add = function foo(a, b) {
    // body...
};
</code></pre>
<p>这里大家肯定会好奇，这个函数怎么调用？到底用哪个名字呢？</p>
<p>做一个测试：</p>
<pre><code>var func = function nfe() {};
console.log(func === nfe);
// 在 IE6~8，得到 false
// 在 IE9+ 及现代浏览器中 Uncaught ReferenceError: nfe is not defined
</code></pre>
<p>那么命名函数表达式有什么使用场景呢？</p>
<ul>
<li>一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。</li>
<li>或者在递归时，使用名字调用自己。</li>
</ul>
<p>但是这两种用法都不常见。</p>
<h3 id="function-构造器"><a class="header-anchor" href="#function-构造器"></a>Function 构造器</h3>
<p>除了函数声明、函数表达式。还有一种创建函数对象的方式，是使用函数构造器。</p>
<pre><code>var func = new Function('a','b','console.log(a+b);');
func(1,2);//3

var func2 = Function('a','b','console.log(a+b);');
func2(1,2);//3
</code></pre>
<p>Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。</p>
<p>还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。</p>
<h3 id="三种方法的对比"><a class="header-anchor" href="#三种方法的对比"></a>// 三种方法的对比:</h3>
<p><img src="https://cloud.az22c.top/%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png-az22cgithub" alt></p>
<h2 id="变量-函数的声明前置"><a class="header-anchor" href="#变量-函数的声明前置"></a>变量 &amp; 函数的声明前置</h2>
<p>举两个例子</p>
<p>例1，函数声明：</p>
<pre><code>var num = add(1,2); // 调用
console.log(num);

function add(a, b) { // 声明
    return a + b;
}
</code></pre>
<p>例2，函数表达式：</p>
<pre><code>var num = add(1, 2);
console.log(num);

var add = function(a, b) {
    return a + b;
};
</code></pre>
<p>例1中得到的结果是 3，而例2中是 <code>Uncaught TypeError: add is not a function</code>。</p>
<p>因为函数和变量在声明的时候，会被前置到当前作用域的顶端。例1将函数声明<code>function add(a, b)</code>前置到作用域前端，例2将声明<code>var add</code>前置到其作用域的前端了，但并没有赋值。<strong>赋值的过程是在函数执行到相应位置的时候才进行的。</strong></p>
<h2 id="调用方式"><a class="header-anchor" href="#调用方式"></a>调用方式</h2>
<ul>
<li>直接调用</li>
</ul>
<pre><code>foo();
</code></pre>
<ul>
<li>对象方法</li>
</ul>
<pre><code>o.method();
</code></pre>
<ul>
<li>构造器</li>
</ul>
<pre><code>new Foo();
</code></pre>
<ul>
<li>函数方法call/apply/bind</li>
</ul>
<pre><code>func.call(o);
</code></pre>
<h2 id="函数属性"><a class="header-anchor" href="#函数属性"></a>函数属性</h2>
<h3 id="arguments属性"><a class="header-anchor" href="#arguments属性"></a>arguments属性</h3>
<p>函数的arguments属性使函数可以处理可变数量的参数。 <code>arguments</code> 对象的 <code>length</code> 属性包含了 传递给函数的参数(即所谓的实参) 的数目。</p>
<p><code>arguments</code> 对象还可以当做是一个数组来用： <code>arguments</code> 对象中包含的各个参数的访问方式与数组元素的访问方式相同：</p>
<pre><code>function ArgTest(arg1, arg2){
   var s = &quot;&quot;;
   s += &quot;The individual arguments are: &quot;
   for (n = 0; n &lt; arguments.length; n++){
      s += ArgTest.arguments[n];
      s += &quot; &quot;;
   }
   return(s);
}
console.log(ArgTest(1, 2, &quot;hello&quot;));
// Output: The individual arguments are: 1 2 hello
</code></pre>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">严格模式对arguments有一些要求</a></p>
</blockquote>
<h3 id="caller属性"><a class="header-anchor" href="#caller属性"></a>caller属性</h3>
<blockquote>
<p>functionName.caller</p>
</blockquote>
<p><em>functionName</em> 是任何正在执行的函数的名称。</p>
<p><code>caller</code> 属性只有当函数正在执行时（实质上就是被调用）才被定义。</p>
<p>假设有这么一个函数foo，它是在全局作用域内被调用的，则<code>foo.caller</code>为<code>null</code>；相反，如果这个函数foo是在另外一个函数作用域内被调用的,则<code>foo.caller</code>指向调用它的那个函数。</p>
<p>可见，其返回结果为函数或者是<code>null</code>。</p>
<p>而如果在字符串上下文中使用 <code>caller</code> 属性，则其结果和 <em>functionName</em>.<code>toString</code> 相同。</p>
<p>下面的示例阐释了 <code>caller</code> 属性的用法：</p>
<pre><code class="language-JavaScript">function CallLevel() {
   if (CallLevel.caller == null)
      return(&quot;CallLevel was called from the top level.&quot;);
   else
      return(&quot;CallLevel was called by another function.&quot;);
}

console.log(CallLevel());
// Output: CallLevel was called from the top level.
</code></pre>
<p>caller也可以用于<code>arguments</code>，常用形式<code>arguments.callee.caller</code>替代了被废弃的<code>arguments.caller</code>。</p>
<p><strong>备注：</strong></p>
<p>caller属性，实质上就是去查找并返回调用者（当前函数）的一个特殊属性<code>_caller_</code> ，返回的是<strong>调用当前函数的函数</strong>的活动对象，因而可以用来重现出整个调用栈。在调试的时候可以它用来帮助找bug；它是不安全的，它不被列入浏览器标准之内，不要在生产环境中使用。</p>
<h3 id="apply属性-方法"><a class="header-anchor" href="#apply属性-方法"></a>apply属性(方法)</h3>
<blockquote>
<p>调用函数，并用指定一个对象替换函数的 <code>this</code> 值，同时用指定数组替换函数的参数。</p>
<p>apply([thisObj[,argArray]])</p>
<p><code>thisObj</code>：可选。要用作 this 对象的对象。即调用这个函数的对象。</p>
<p><code>argArray</code>：可选。要额外传递到函数的一组参数。</p>
</blockquote>
<h3 id="call属性-方法"><a class="header-anchor" href="#call属性-方法"></a>call属性(方法)</h3>
<p><strong>apply 后面的参数需为数组；而call 为扁平化传参</strong></p>
<pre><code class="language-JavaScript">function foo(x, y) {
    console.log(x, y, this);
}

foo.call(100, 1, 2); //1 2 Number {[[PrimitiveValue]]: 100}
foo.apply(true, [3, 4]); //3 4 Boolean {[[PrimitiveValue]]: true}
foo.apply(null); //undefined undefined Window
foo.apply(undefined); //undefined undefined Window
</code></pre>
<p>可见，传入 null/undefined 时，实际为 Window 对象
在严格模式下：上述代码最后两行分别输出 null， undefined</p>
<h3 id="bind属性-方法"><a class="header-anchor" href="#bind属性-方法"></a>bind属性(方法)</h3>
<p>bind和call/apply的区别是：bind返回的是<code>函数</code>，可供稍后继续调用；而call和apply直接就是改变this之后立即调用，返回值是对应的调用结果。</p>
<blockquote>
<p>fun.bind(thisArg[, arg1[, arg2[, …]]])</p>
</blockquote>
<p>下面的代码演示如何使用 <code>bind</code> 方法：</p>
<pre><code class="language-JavaScript">// 定义原始函数：
var checkNumericRange = function (value) {
    if (typeof value !== 'number')
        return false;
    else
        return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;
}

var range = { minimum: 10, maximum: 20 };

var boundCheckNumericRange = checkNumericRange.bind(range);

console.log(boundCheckNumericRange (12));	// true
</code></pre>
<p>上例中结果正常，美中不足的是<code>checkNumericRange</code>只是在特定情境下使用，没必要暴露在全局环境中，所以我们想去把它放在某个对象内部。</p>
<p>在下面的示例中，thisArg对象 与 包含原始函数<code>checkNumericRange</code>的对象不同：</p>
<pre><code class="language-JavaScript">var originalObject = {
    minimum: 50,
    maximum: 100,
    checkNumericRange: function (value) {
        if (typeof value !== 'number')
            return false;
        else
            return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;
    }
}

console.log(originalObject.checkNumericRange(10)); // Output: false，对象调用自身方法
// ------------------分割线----------------------------
var range = { minimum: 10, maximum: 20 };

var boundObjectWithRange = originalObject.checkNumericRange.bind(range);

console.log(boundObjectWithRange(10)); // Output: true
</code></pre>
<p>显然后者更加灵活一点。用<code>bind</code>改变this的指向，一个对象可以使用另外一个对象里面的方法，这是一种常见用法。</p>
<hr>
<p>再来一个例子，说明一下 <a href="/2017/08/07/js-this/">结合this的4种绑定规则 深入理解this指向的判定</a> 和 <strong>函数的调用者（点运算符之前的对象或者window全局）</strong> 的区别：</p>
<pre><code>this.x = 9;
var module = {
    x: 81,
    getX: function() {
        return console.log(this.x);
    }
};

module.getX(); //81
// 函数的调用者为module，函数的this指向module

var getX = module.getX;
getX(); //9
// var getX = module.getX; 将这个方法赋值给一个全局变量，这时 this 指向了 window
// 函数的调用者为window，函数的this指向window

var boundGetX = getX.bind(module);
boundGetX(); //81
// 应用bind,函数的调用者为window，函数的this指向module
</code></pre>
<p>一般情况下，谁调用函数，函数的this就指向谁。</p>
<p><code>bind</code> 主要用于改变函数中的 <code>this</code></p>
<ul>
<li><code>module.getX();</code>直接通过对象调用自己的方法，结果是 81</li>
<li><code>var getX = module.getX;</code> 将这个方法赋值给一个全局变量，这时 this 指向了 window，所以结果为 9</li>
<li><code>var boundGetX = getX.bind(module);</code> 使用 bind 绑定了自己的对象，这样 this 仍然指向 module 对象，所以结果为 81</li>
</ul>
<hr>
<p>以下代码演示如何使用 arg1[,arg2[,argN]]] 参数：</p>
<pre><code>var displayArgs = function (val1, val2, val3, val4) {
    console.log(val1 + &quot; &quot; + val2 + &quot; &quot; + val3 + &quot; &quot; + val4);
}

var emptyObject = {};

var displayArgs2 = displayArgs.bind(emptyObject, 12, &quot;a&quot;);
// &quot;b&quot;和&quot;c&quot;被传给形参val3和val4
displayArgs2(&quot;b&quot;, &quot;c&quot;);
// Output: 12 a b c 
</code></pre>
<p>在上例中，一开始绑定函数将 <code>bind</code> 方法中指定的参数用作第一个参数和第二个参数。再调用绑定函数时，指定的任何参数将用作第三个、第四个参数（依此类推）。</p>
<h4 id="bind-与-currying"><a class="header-anchor" href="#bind-与-currying"></a>bind 与 currying</h4>
<p>bind 可以使函数柯里化，那么什么是柯里化？</p>
<blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回 <strong>接受</strong>余下的参数且<strong>返回</strong>结果的新函数 的技术。</p>
</blockquote>
<pre><code>function add(a, b, c) {
    return a + b + c;
}

var func = add.bind(undefined, 100); // 接受一个单一参数
func(1, 2); //103

var func2 = func.bind(undefined, 200);// 接受一个单一参数

func2(10); //310
</code></pre>
<p>add 函数拥有 3 个参数。我们想先传入一个参数，再去传其他参数。</p>
<p><code>var func = add.bind(undefined, 100);</code>add 函数对象调用 bind 方法，由于不需要将 this 指向原来的 add 函数对象，所以第一个参数写为 undefined 或 null。第二个参数 100 传给了 add 函数中的形参 a，并赋值给一个新的函数对象 func。</p>
<p>这时，<code>func(1, 2)</code> 即相当于传入后两个参数，所以结果为 103。</p>
<p>同理，基于 func 可以创造一个函数 func2。它只用传最后一个参数。</p>
<p>再见一个柯里化对函数参数拆分的例子：</p>
<pre><code class="language-JavaScript">function getConfig(colors,size,otherOptions){
    console.log(colors,size,otherOptions);
}
var defaultConfig = getConfig.bind(null,'#c00','1024*768');
defaultConfig('123');//'#c00 1024*768 123'
defaultConfig('456');//'#c00 1024*768 456'
</code></pre>
<h4 id="bind-与-new一起用时"><a class="header-anchor" href="#bind-与-new一起用时"></a>bind 与 new一起用时</h4>
<pre><code>function foo() {
    this.b = 100;
    return this.a;
}
console.log(foo()); //undefined
var func = foo.bind({
    a: 1
});
console.log(func()); //1

console.log(new func()); //foo {b: 100} ，bind与new一起用时。
</code></pre>
<p>如果执行普通的某个函数，其返回值可以是任意类型。</p>
<p>而对于使用了 <code>new func()</code> 这种方式创建对象，其返回值<strong>应</strong>为一个对象。</p>
<p>原函数 foo 的返回值不是对象，所以会直接忽视这个 return 方法。而是变为 <code>return this;</code>。并且 this 会被初始化为一个空对象，这个空对象的原型指向 foo.prototype。所以后面的 bind 是不起作用的。</p>
<p>这里面这个 this 对象包含一个属性 <code>b = 100</code>。所以返回的是对象 <code>{b: 100}</code>。</p>
<p>MDN有提到，bind不要和构造函数一起用，各浏览器可能结果不一样。MDN建议不要这样用。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 函数属性 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
