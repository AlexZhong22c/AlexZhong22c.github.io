<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[面试题：改造代码，使之隔秒输出0 - 9]]></title>
      <url>https://alexzhong22c.github.io/2020/04/02/settimeout-0-to-9/</url>
      <content type="html"><![CDATA[<p>通过一道面试题，文末总结一下js【变量快照】和【缓存变量值】的手法。原题考察的是对js作用域和对setTimeout api的理解，在本文主要给出5种解法。</p>
<a id="more"></a>
<hr>
<p><strong>题目的提出：</strong> “改造下面的代码，使之隔秒输出0 - 9，写出你能想到的所有解法：”</p>
<pre><code class="language-js">// 题目代码：
for (var i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i);
    // debugger;
  }, i * 1000)
}
</code></pre>
<p>考察的是对作用域和对setTimeout api的理解。</p>
<p><strong>首先不急着答题，若想更好地理解，我们思考一下代码未改动前打印结果和原理。</strong></p>
<h4 id="首先解释原代码的打印结果：-没有形成闭包"><a class="header-anchor" href="#首先解释原代码的打印结果：-没有形成闭包"></a>// 首先解释原代码的打印结果：【没有形成闭包】</h4>
<p>打印全都是10。<strong>没有形成闭包。</strong></p>
<p>因为计数变量 i 它还是属于全局作用域：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  // 故意不写代码，让打印测试结果更加清楚
}
console.log(window.i) // 10
console.log(i) // 10，明显没有闭包，i是全局变量啊，因为是全局变量所以驻留在内存中
setTimeout(() =&gt; {
  console.log(i) // 10
}, 2000)
</code></pre>
<p>证明：setTimeout引用计数变量i，也没有产生闭包（计数变量还是没有达到闭包的要有“外层函数”的条件）：</p>
<pre><code class="language-js">for(var i = 0; i &lt; 10; i++) {
  setTimeout(function() {
      console.log(i);
      debugger; // 在这里断点，查看是否有闭包
  }, i * 1000);
}
</code></pre>
<p><strong>回到本文的正题，这个面试题的解法有哪些呢？</strong></p>
<h2 id="方法一：let-const块级作用域-于for循环"><a class="header-anchor" href="#方法一：let-const块级作用域-于for循环"></a>方法一：let / const块级作用域 于for循环</h2>
<p>原理：利用 <code>let</code> 变量的特性 — 在每一次 <code>for</code> 循环的过程中，<code>let</code> 声明的变量会在当前的块级作用域里面（<code>for</code> 循环的 body 体，也即两个花括号之间的内容区域）创建一个词法环境（Lexical Environment），该环境里面包括了当前 <code>for</code> 循环过程中的 <code>i</code>，（也就是类似函数作用域的效果）<a href="https://javascript.info/closure#for-while" target="_blank" rel="noopener">具体链接</a></p>
<p>另外，记得曾在知乎上看到，方应杭也是这么说的。PS：chrome控制台断点debug能看到block作用域。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i);
  }, i * 1000)
}
// 等价于：
for (var i = 0; i &lt; 10; i++) {
  let _i = i;// 所以即便在本次循环中篡改_i也不会影响到i
  setTimeout(() =&gt; {
    console.log(_i);
    // console.log(++_i);
  }, i * 1000)
}
</code></pre>
<p>写法2：let tmp局部变量，需要是块级作用域。一定要let，而var tmp是不行的。</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  let tmp = i;
  setTimeout(() =&gt; {
    console.log(tmp);
  }, i * 1000)
}
</code></pre>
<h2 id="方法二：-外层函数-传入自由变量-settimeout构建闭包"><a class="header-anchor" href="#方法二：-外层函数-传入自由变量-settimeout构建闭包"></a>方法二：“外层函数”传入自由变量+setTimeout构建闭包</h2>
<p>原理： <strong>这里主要是setTimeout帮助构建闭包。</strong> 函数局部作用域在这里也是构建闭包的条件之一。另外，不会因为单纯有IIFE就会有闭包。</p>
<pre><code class="language-js">// 这个还真的是闭包，不信在chrome debug断点一下：应该是setTimeout回调函数引用了自执行函数的自由变量，导致该自由变量没被回收。
// 不信的话，可以去掉setTimeout，闭包就没了。
for (var i = 0; i &lt; 10; i++) {
  (i =&gt; {
    setTimeout(() =&gt; {
      console.log(i);
    }, i * 1000)
  })(i)
}
</code></pre>
<p>另外一种方式：（后面会补充说到，如果setTimeout的第一个参数是js语句，该语句会被同步执行）</p>
<pre><code class="language-js">for(var i = 0; i &lt; 10; i++) {
  setTimeout(
    (function(i) {
      return function() {
          console.log(i)
      }
    })(i)
  , i * 1000)
}
// 这样也是同理的：！！！！！！！！！！！
for (var i = 0; i &lt; 10; i++) {
  const cbGenerator = (i) =&gt; {
    return function() {
      console.log(i)
    }
  }
  setTimeout(cbGenerator(i), i * 1000);
}
</code></pre>
<h4 id="证明：不会因为单纯有iife就会有闭包"><a class="header-anchor" href="#证明：不会因为单纯有iife就会有闭包"></a>证明：不会因为单纯有IIFE就会有闭包。</h4>
<p><strong>IIFE 其实并不属于闭包的范畴：</strong> 参考链接如下：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/41228824/difference-between-closures-and-iifes-in-javascript" target="_blank" rel="noopener">difference-between-closures-and-iifes-in-javascript</a></li>
<li><a href="https://bit.ly/2NXNT56" target="_blank" rel="noopener">IIFE 是闭包?</a></li>
</ul>
<p><strong>记住，记住，这样是连打印结果都不符合题目要求的：</strong></p>
<pre><code class="language-js">// 没用：连打印结果都不符合题目要求
for (var i = 0; i &lt; 10; i++) {
  setTimeout(function () {
    (i =&gt; {
      console.log(i);
    })(i)
  }, i * 1000)
}
</code></pre>
<p>另外，比如这个，因为没有setTimeout，<strong>不符题目要求</strong>。另外，也因为没有setTimeout，即便有<strong>函数按值传递</strong>的变量快照的效果，也没有形成闭包：</p>
<pre><code class="language-js">// 没有形成闭包：
// 这也对照证明了setTimeout是有帮助构建闭包的作用的！！！！！！！！！
for(var i= 0; i &lt; 5; i++){
  console.log('add timeout: ', i);
  (function(index){
      console.log('imitate timeouting: ', index);
      debugger;
  })(i)
}
// 而如果基于此，给log再套多一层自执行，就又有闭包了，你懂的。
</code></pre>
<h2 id="方法三：try-catch特殊的作用域机制：-即利用其它方式构建出局部作用域"><a class="header-anchor" href="#方法三：try-catch特殊的作用域机制：-即利用其它方式构建出局部作用域"></a>方法三：try catch特殊的作用域机制： 即利用其它方式构建出<strong>局部作用域</strong></h2>
<p>对于js，一般来说只有全局作用域和函数作用域。而这个catch大括号包裹的部分，作用域链的表现类似于函数作用域。非常特别。</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  try {
    throw new Error(i);
  } catch ({
    message: i // 为了重命名解构出i变量
  }) {
    setTimeout(() =&gt; {
      console.log(i);
    }, i * 1000)
  }
}
</code></pre>
<h2 id="方法4：bind返回新函数：利用的是柯里化的缓存效果-没有闭包产生"><a class="header-anchor" href="#方法4：bind返回新函数：利用的是柯里化的缓存效果-没有闭包产生"></a>方法4：bind返回新函数：利用的是柯里化的缓存效果，没有闭包产生</h2>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(console.log.bind(Object.create(null), i), i * 1000)
  // also or: 
  // setTimeout(console.log.bind(console, i), i * 1000)
}
</code></pre>
<p>或者：(配合函数按值传递)</p>
<pre><code class="language-js">for (var i = 1; i &lt;= 5; i++) {
  setTimeout(function timer(i) {
    console.log(i);
  }.bind(null, i), i * 1000);
}
</code></pre>
<h4 id="来个demo模拟简化后的代码-反映：的确是柯里化缓存的功劳："><a class="header-anchor" href="#来个demo模拟简化后的代码-反映：的确是柯里化缓存的功劳："></a>来个demo模拟简化后的代码，反映：的确是柯里化缓存的功劳：</h4>
<pre><code class="language-js">function hey(a,b,c) {
  console.log(this)
  console.log(a,b,c)
  debugger;
}

const foo = hey.bind({}, 1)
foo() // 1 undefined undefined
</code></pre>
<h2 id="方法五：利用-settimeout-函数的第三个参数-ie9之前不兼容该api"><a class="header-anchor" href="#方法五：利用-settimeout-函数的第三个参数-ie9之前不兼容该api"></a>方法五：利用 <code>setTimeout</code> 函数的第三个参数【IE9之前不兼容该api】</h2>
<p>复习一下setTimeout api的语法：<code>setTimeout(function, milliseconds, param1, param2, ...)</code></p>
<p>第三个参数，会作为回调函数的第一个参数传入。第四第五个参数位同理，以此类推。</p>
<p>神奇的是，它的规律是：缓存这些参数，等到回调触发的时候使用。</p>
<p>代码1：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(i =&gt; {
    console.log(i);
  }, i * 1000, i)
}
</code></pre>
<p>代码2：</p>
<pre><code class="language-js">// 注意这段代码的setTimeout的第一个参数并不是完整js语句，不是同步执行的：
for (var i = 0; i &lt; 10; i++) {
  setTimeout(console.log, i * 1000, i)
}
</code></pre>
<h2 id="拓展知识一：语句作为settimeout第一个参数位-无法隔秒打印-不符合本题要求"><a class="header-anchor" href="#拓展知识一：语句作为settimeout第一个参数位-无法隔秒打印-不符合本题要求"></a>// 拓展知识一：语句作为setTimeout第一个参数位 #无法隔秒打印。不符合本题要求</h2>
<p>如果想要更好地理解setTimeout api，那么你需要看看这个章节。</p>
<p><a href="https://segmentfault.com/q/1010000009490850" target="_blank" rel="noopener">链接：提问的确是这个提问，但是没有人回答得好</a></p>
<p><del>原理：很多其它的方案只是把 <code>console.log(i)</code> 放到一个函数里面，因为 <code>setTimeout</code> 函数的第一个参数只接受函数以及字符串，如果是 <strong><code>js</code> 语句</strong>的话，<code>js</code> 引擎应该会自动在该语句外面包裹一层函数</del></p>
<p>setTimeout毕竟不是js规范里面的api，其实是属于浏览器或者node环境的范畴。所以我也没找到对应的文档的说明。经过测试，大体上就是：如果第一个参数位是js语句，就会同步执行。</p>
<p><strong>无法隔秒打印：</strong> 虽然能打印0 ~ 9，但是因为是第一个参数如果是语句就同步执行的。第二个参数的延迟时间就发挥不了作用了。因为都是同步执行完，就谈不上闭包了。</p>
<pre><code class="language-js">// 注意，这个就没法做到每隔一秒打印了，都是同步执行完的。
// 这样chrome控制台没有显示任何闭包：因为，i引用到的是计数变量，也就是这里的全局变量。
for (var i = 0; i &lt; 10; i++) {
  setTimeout(console.log(i), i * 1000)
}
// or:
for (var i = 0; i &lt; 10; i++) {
  setTimeout((() =&gt; {
    console.log(i);
  })(), i * 1000)
}
</code></pre>
<p>同理：区别只不过是i作为函数的局部变量，（即便用了setTimeout，）因为没有异步执行，没有产生闭包。</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; { // 同步代码复制了一份局部变量
    console.log(i);
  })(i), i * 1000)
}
// 换种写法：call/apply 按值传参：
for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; {
    console.log(i);
  }).call(Object.create(null), i), i * 1000)
}
// 换种写法同理：
for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; {
    console.log(i);
  }).apply(Object.create(null), [i]), i * 1000)
}
// 换种写法同理：apply类数组
for (var i = 0; i &lt; 10; i++) {
  setTimeout((i =&gt; {
    console.log(i);
  }).apply(Object.create(null), { length: 1, '0': i }), i * 1000)
}
</code></pre>
<h2 id="总结并拓展：另一种实现-非引用数据类型的-变量快照的方式"><a class="header-anchor" href="#总结并拓展：另一种实现-非引用数据类型的-变量快照的方式"></a>总结并拓展：另一种实现(非引用数据类型的)变量快照的方式</h2>
<p>我们可以总结一下上述所有【变量快照】或者【缓存变量值】的手法：（手法和每一个解题回答一一对应）</p>
<ul>
<li><code>let</code> / <code>const</code>+<code>for</code>循环：增加块级作用域 【变量快照】</li>
<li>加中间函数，闭包维持之：增加并维持函数作用域 【变量快照】</li>
<li>try catch作用域：特殊的作用域机制 【变量快照】</li>
<li>柯里化/bind使用 【缓存变量值】</li>
<li>setTimeout第3个参数 【缓存变量值】</li>
</ul>
<p>说白了以上就是：要么增设并维持<strong>作用域</strong>，因此实现【变量快照】，要么就是【缓存变量值】。</p>
<p>而另外一种实现【变量快照】的方式是：<strong>借助能解析执行字符串的api，把变量值编进代码里面：</strong>（记得吗，eval作用域又是一种特殊的<strong>作用域</strong>）</p>
<p>代码 1：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(eval('console.log(i)'), i * 1000)
}
</code></pre>
<p>代码 2，同样的效果：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(new Function('i', 'console.log(i)')(i), i * 1000)
}
// or:
for (var i = 0; i &lt; 10; i++) {
  setTimeout(new Function('console.log(i)')(), i * 1000)
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 笔记副本 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解文字高度和行高的设置]]></title>
      <url>https://alexzhong22c.github.io/2019/02/06/height-calculate/</url>
      <content type="html"><![CDATA[<p>font-size设置的是什么?line-height设置的是什么?各种行高是怎么计算出来的?你真的知道吗?</p>
<a id="more"></a>
<h2 id="从font-size讲起-说文字高度："><a class="header-anchor" href="#从font-size讲起-说文字高度："></a>从font-size讲起，说文字高度：</h2>
<p>当你按住鼠标左键选中一段文字的时候，这段文字背后会有一个颜色变化的区域，这个区域可以近似的视为是这段文字的<code>content-area（内容区域）</code>。</p>
<p>又或者当我们给一行文字设置background的时候，文字背景所占的区域可以近似的视为是这段文字的<code>content-area（内容区域）</code>。</p>
<p>我们通常用content-area的高度代表<code>文字高度</code> ，这是字体设计领域的一个概念。</p>
<p>你先别质疑这种思想！我们知道有些文字的样子喜欢往上突出，有些文字喜欢往下突，再者，行与行文字之间需要一定的空间，所以content-area在上下两个区域预留出空白的区域是很正常的，如图：</p>
<p><img src="https://cloud.az22c.top/font-line.jpg-az22cgithub" alt="font-line"></p>
<p>先说结论：</p>
<p><strong>font-size 相同时，font-family 不同，得到的<code>文字高度</code>也不同</strong>：</p>
<p><img src="https://cloud.az22c.top/diff-font.jpg-az22cgithub" alt="diff-fon"></p>
<p>上图表明，同样是font-size为100px，三款不同字体在浏览器画面上的高度是不同的。</p>
<p>我们再来分析一下，在font-size设置为100px时，Catamaran字体的那164px是怎么构成的：</p>
<p><img src="https://cloud.az22c.top/catamaran-font.jpg-az22cgithub" alt="catamaran-font"></p>
<p>我们假设画面由相对单位构成方便缩放拉伸，再假设现在1px对应画面上的10个相对单位。（这点你可以不用理会）</p>
<p>那么我们所能设置的<code>font-size: 100px</code>其实设置的是上图左方1000个单位(em-square)这部分的高度而已； <strong>我们可以把em-square区域视为content-area的主体区域。</strong></p>
<blockquote>
<p>(em-square这个概念的产生是有历史原因的，但是这点我们不用理会。)</p>
<p>em-square之内，图中&quot;B&quot;上方预留的小区域，大概是考虑到有些字母模仿手写体会有起笔效果，需要一定的位置；&quot;a&quot;下方预留的区域是为了写类似g这样的字母的时候，下方需要一定的区域。</p>
<p>em-square之外，上方和下方都预留了一定空白区域，这样可以防止行与行间文字挤在一起。</p>
<p>事实上对于所有font-family而言，规则都是这样的，对于中文字体而言也是如此。</p>
</blockquote>
<p>我们可以得到第二个结论：</p>
<p><strong>font-size不能直接控制文字的高度(content-area的高度)，它控制的是文字主体部分的高度(em-square的高度)。</strong> 而content-area和em-square之间的比例，完全是由字体设计师决定，作为程序员是无法统一的。</p>
<p>所以再经过调查， <strong>没有属性能<code>直接</code>控制文字的高度，我们只能这样通过font-size<code>间接</code> 控制文字的高度。</strong></p>
<h2 id="计算一个p元素的内容高度"><a class="header-anchor" href="#计算一个p元素的内容高度"></a>计算一个p元素的<code>内容高度</code></h2>
<p>(我们既然说是<code>内容高度</code>，就直接把margin、border厚度、padding排除在外了。)</p>
<p>当 p 元素出现在屏幕上时，它可能包含了多行的内容，其内容高度由<code>每一行的高度</code>堆叠而成。这点很好理解。</p>
<h3 id="line-box的默认高度"><a class="header-anchor" href="#line-box的默认高度"></a>line-box的默认高度</h3>
<p>每一行可视为一个line-box。通常来讲，line-box的默认高度是由这一行的内容撑大的，这一行里面的元素谁的高度最大，line-box的高度就等于它，由它撑大：</p>
<p><img src="https://cloud.az22c.top/line-boxes.jpg-az22cgithub" alt="line-boxes"></p>
<pre><code class="language-HTML">&lt;p&gt;
    Good design will be better.
    &lt;span class=&quot;a&quot;&gt;Ba&lt;/span&gt;
    &lt;span class=&quot;b&quot;&gt;Ba&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;Ba&lt;/span&gt;
    We get to make a consequence.
&lt;/p&gt;
</code></pre>
<p>如图，我们给class=“a”、class=“b”、class=&quot;c&quot;设置了不同的font-family或者font-size，导致这些文字的高度各不相同。每一个line-box代表每一行的区域。一个line-box的默认高度由这行内的最大高度决定。</p>
<blockquote>
<p>补充：还记得吗?对于文字而言，文字高度就是它的content-area的高度。</p>
</blockquote>
<h2 id="line-height的作用"><a class="header-anchor" href="#line-height的作用"></a>line-height的作用</h2>
<p><strong>当我们没有设置line-height的时候，一个line-box的默认高度由这行内的最大高度决定。</strong></p>
<p>所以通常情况下，line-box的高度 &gt;= content-area的高度 &gt; em-square的高度</p>
<hr>
<p><strong>当我们设置了line-height的时候，line-box的高度就是由line-height所设定的。</strong>  因此此时我们可以把line-box的高度设置得比content-area甚至em-square小，导致文字看上去挤在一起。</p>
<blockquote>
<p>一行内的内容，除了文字外；通常就是<code>行内块级元素</code>了，通常可以分为三类：</p>
<ul>
<li>img元素、input元素、svg元素等</li>
<li><code>display:inline-block</code>、<code>display:inline-table</code>、<code>display:inline-flex</code> 的元素</li>
<li>处于某种特殊格式化上下文的内联元素：例如 flexbox 元素中的子元素都处于 <a href="http://link.zhihu.com/?target=https%3A//www.w3.org/TR/css-flexbox-1/%23flex-items" target="_blank" rel="noopener">flex formatting context（弹性格式化上下文）</a>中，这些子元素的 display 值都是「blockified」</li>
</ul>
<p>这些<code>行内块级元素</code>，其所占的高度通常由height，margin，border，padding盒子模型的高度来决定。</p>
<p>如果你将其 height 设置为 auto 的话，那么其高度的取值就是 line-height，其 content-area 的取值也是 line-height。</p>
</blockquote>
<h2 id="line-height是怎么计算的"><a class="header-anchor" href="#line-height是怎么计算的"></a>line-height是怎么计算的</h2>
<p>官方对<code>line-height</code>的定义是：</p>
<blockquote>
<p>两行文字基线(baseline)之间的距离。</p>
</blockquote>
<h3 id="额外谈谈-基线"><a class="header-anchor" href="#额外谈谈-基线"></a>额外谈谈&quot;基线&quot;</h3>
<p>为什么是基线呢？</p>
<p>line-height可不可以定义为是两行文字的“中线”之间的距离呢？</p>
<p>可不可以定义为是两行文字的“底线”之间的距离呢？</p>
<p>张鑫旭认为都是都可以的。</p>
<p>那么为什么选基线作为定义的依据？</p>
<p>因为， <strong>基线乃其他线定义之根本也。</strong></p>
<p>了解“基线”大有好处。</p>
<p>回到刚才那幅图：</p>
<p><img src="https://cloud.az22c.top/font-line.jpg-az22cgithub" alt="font-line"></p>
<p>这么多线，都是字体设计师为了比对位置用的。这几条线，可以视为是字体设计的度衡。任何一款字体都会给出以上各种线的位置参数，<strong>所有线的位置参数都是相对于基线的位置而确定的</strong> 。我们把某款字体放到 <a href="http://link.zhihu.com/?target=https%3A//fontforge.github.io/en-US/" target="_blank" rel="noopener">FontForge</a> 中，分析它的字体度量：</p>
<p><img src="https://cloud.az22c.top/font-forge.jpg-az22cgithub" alt="font-forge"></p>
<blockquote>
<p>首先说明的是HHead Ascent是针对macOS的计算值，Win Ascent是针对Windows系统的计算值，这点可以不用理会。</p>
</blockquote>
<p>设计一款字体的时候从基线开始定位。</p>
<p>我们看到，Em Size设置为1000，就是<code>基线到基线以上1000个单位的那片区域</code>都是em-square的区域。</p>
<p>Ascent设置为770，就是Ascender线距离基线770个单位。</p>
<p>Descent设置为230，就是Descender线距离基线230个单位。</p>
<p>Capital Height是680，也是相对于基线的。是大写字母顶部位置的线距离基线多少。</p>
<p>X Height是485，也是相对于基线而言的。是小写字母顶部位置的线距离基线多少。</p>
<p><code>Ascender线到Descender线之间的高度</code> 加上Line Gap就是content-area的总高度。（笔者注：这点可能有误）</p>
<hr>
<p>所以说，我们选基线来定义line-height：line-height是两行文字基线(baseline)之间的距离。</p>
<p>但是这个定义说了等于没说，因为它不能告诉我们怎么设置line-height啊！</p>
<p>还是我们早之前做的定义比较棒！！<strong>当我们设置了line-height的时候，line-box的高度就是由line-height所设定的。</strong></p>
<h3 id="line-height的计算-画重点"><a class="header-anchor" href="#line-height的计算-画重点"></a>line-height的计算（画重点！）</h3>
<p>line-height的计算要<strong>根据这行文字的font-size多少</strong> ，即是根据em-square的高度计算。本文说的&quot;计算&quot;就是这个意思。</p>
<p>w3c说，line-height可以设置的值有5种：</p>
<ul>
<li>normal</li>
<li>数字</li>
<li>多少px(都写死了，不必计算)</li>
<li>百分数(多少%)</li>
<li>inherit(对于该元素而言，不必计算)</li>
</ul>
<h4 id="line-height-normal的时候"><a class="header-anchor" href="#line-height-normal的时候"></a>line-height:normal的时候</h4>
<p>我们来看看 Arial 字体，它的 em-square 是 2048，ascender 是 1854，descender 是 434，line gap 是 67。那么当 font-size: 100px 时：</p>
<p>line-height:normal为 100/2048*(67+1854+434) 约为 115px</p>
<h4 id="line-height设为数字-百分数的时候"><a class="header-anchor" href="#line-height设为数字-百分数的时候"></a>line-height设为数字/百分数的时候</h4>
<p>line-height设为数字/百分数的时候，line-height就是拿 数字/百分数  去乘以em-square的高度。</p>
<p>所以如果设置line-height:1或者line-height:100%肯定是有问题的啊——本来em-square基本上就比content-area要小，你还让line-height是em-square的高度的一倍？！行与行之间的文字绝对是要挤在一起了：</p>
<p><img src="https://cloud.az22c.top/set-line-height-1.jpg-az22cgithub" alt="set-line-height-1"></p>
<p>那怎么设置呢？反正line-height最终的计算结果超过content-area就应该比较符合常理了。</p>
<p>张鑫旭大神鼓励大家用数字来设置line-height。</p>
<ul>
<li>如果是博客类型的网站，line-height设置为1.5到1.6，行与行之间比较宽，适合舒适地阅读。</li>
<li>如果是研发正规的产品，推荐大家使用<code>20px匹配法</code> ，方便计算。</li>
</ul>
<h4 id="20px匹配法"><a class="header-anchor" href="#20px匹配法"></a>20px匹配法</h4>
<p>为什么呢？</p>
<p>首先我们一般来说会设置font-size在14px到16px之间，然后content-area的高度也不会比这个高太多的吧。所以我们想着让line-height设置为20px应该够用了。而且20px方便计算。像这样：</p>
<pre><code class="language-CSS">body { font-size: 14px; line-height:??? }
</code></pre>
<p>只要把???结果计算出来就行啦！</p>
<p>20除以14等于1.42857后面还有小数位。</p>
<p>如果你写line-height:1.42857，虽然它乘以14非常接近20，但是没有超过20，chrome会把它设置为19px。</p>
<p>所以我们一般设line-height为1.4286，稍微大那么一点点，chrome把它们乘起来，然后再约等于，就是20px了。</p>
<p>结果写法就像这样：</p>
<pre><code class="language-CSS">body { font-size: 14px; line-height: 1.4286; }
</code></pre>
<p>或者是这样：</p>
<pre><code class="language-CSS">body { font-size: 14px/1.4286 'microsoft yahei'; }
</code></pre>
<h4 id="补充：line-height-1-5和line-height-150-的区别？"><a class="header-anchor" href="#补充：line-height-1-5和line-height-150-的区别？"></a>补充：line-height: 1.5和line-height: 150%的区别？</h4>
<p>这是一个在网上被人讲烂了的知识点了，line-height设置为数字和百分数时之间的区别：</p>
<ul>
<li><code>line-height:1.5</code>： 所以可继承元素根据font-size重新计算行高</li>
<li><code>line-height:150%</code>： 当前元素根据font-size计算行高，继承给下面的元素</li>
<li><code>line-height: 1.5em</code> ：当前元素根据font-size计算行高，继承给下面的元素(与百分比效果相同)</li>
</ul>
<p>例如：</p>
<pre><code class="language-HTML">&lt;style&gt;
.parent { font-size: 30px; }
.child { font-size: 60px; }
.p1 { line-height: 1.5; }
.p2 { line-height: 150%; }
&lt;/style&gt;
&lt;body&gt;
&lt;div&gt;
&lt;p class=&quot;parent p1&quot;&gt;文字&lt;span class=&quot;child&quot;&gt;算出子级line-height为90px&lt;/span&gt;文字&lt;/p&gt;&lt;hr&gt;
&lt;p class=&quot;parent p2&quot;&gt;文字&lt;span class=&quot;child&quot;&gt;算出子级line-height为15px&lt;/span&gt;文字&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>可见，对于百分比这种，如果父子元素设置的font-size差别比较大，或者line-height设置不合理，会计算出不太理想的行高。</p>
<p>所以在CSS reset body元素的时候，<strong>业界普遍使用数字</strong>来设置line-height，具体怎么设置我们刚刚在上文也讲好了。</p>
<h2 id="后记："><a class="header-anchor" href="#后记："></a>后记：</h2>
<h3 id="全文总结"><a class="header-anchor" href="#全文总结"></a>全文总结</h3>
<ul>
<li>首先<code>文字高度</code>和font-size只有间接的关系</li>
<li>然后，line-height的计算是根据font-size的</li>
<li>当我们没有设置line-height的时候，一个line-box的默认高度由这行内的最大高度决定。</li>
<li>当我们设置了line-height的时候，line-box的高度就是由line-height所设定的。</li>
</ul>
<h3 id="预告：文字在一行中的位置的计算"><a class="header-anchor" href="#预告：文字在一行中的位置的计算"></a>预告：文字在一行中的位置的计算?</h3>
<p>有没有发现？根据我们上面的理论，如果想要确定一段文字在一行(line-box模型)中的位置太难了！是不是垂直居中？文字位置偏上还是偏下？要经过一系列计算才能得出结论。</p>
<p>进而，我们联想到，平时我们想让行内元素垂直居中的办法：设置<code>vertical-align:middle</code>，<strong>这种居中方法是错的吗？</strong></p>
<p>嗯，是错的，这只能使得行内元素近似垂直居中。</p>
<p>如果想要行内的文字或者图片完美居中，就要研究清楚line-height和vertical:middle的原理了。</p>
<p>你可以系统地看一看张鑫旭在慕课网上的视频教程。如果急着想看结论，直接翻到他每个视频的最后一章就可以了。</p>
<p>或者你可以直接翻看我下一篇文章 <a href="https://alexzhong22c.github.io/2018/02/05/vertical-align-middle/">深入理解vertical-align:middle</a> 的结论。</p>
<h2 id="参考："><a class="header-anchor" href="#参考："></a>参考：</h2>
<p><a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="noopener">css-font-metrics-line-height-and-vertical-align</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25808995?group_id=825729887779307520" target="_blank" rel="noopener">译文，部分内容有误</a></p>
<p><a href="https://www.imooc.com/video/7920" target="_blank" rel="noopener">CSS深入理解之line-height</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> 居中 </tag>
            
            <tag> line-height </tag>
            
            <tag> font-size </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vertical-align:middle近似居中和完美居中]]></title>
      <url>https://alexzhong22c.github.io/2019/02/05/vertical-align-middle/</url>
      <content type="html"><![CDATA[<p>很多人想要垂直居中的时候，第一时间就想到了<code>vertical-align:middle</code>，用完之后，疑惑它怎么会无效呢?</p>
<p>——原来<code>vertical-align</code> 是有适用范围的限制的。</p>
<p>因为水平垂直居中直接就包括了垂直居中，本文直接给出水平垂直居中的例子，并说明其中垂直居中的原理。</p>
<a id="more"></a>
<blockquote>
<p>首先说明<code>vertical-align</code>只能应用于两个情景：</p>
<ul>
<li>应用于inline/inline-block元素</li>
<li>应用于table-cell元素（其实就是td元素）</li>
</ul>
<p>而用<code>vertical-align: middle;</code>的效果是：</p>
<ul>
<li>应用于inline/inline-block元素：元素的中心线和父元素基线上方1/2 x-height处对齐</li>
<li>应用于table-cell元素：单元格填充盒子 相对于 外面的表格行 居中对齐。</li>
</ul>
</blockquote>
<p>本文就不讲table-cell的例子了，因为它实质上是很简明直观的。</p>
<p>然后我们分类以例子来说明：</p>
<h2 id="大小不固定的图片-水平垂直居中"><a class="header-anchor" href="#大小不固定的图片-水平垂直居中"></a>大小不固定的图片–水平垂直居中</h2>
<h3 id="近似居中"><a class="header-anchor" href="#近似居中"></a>近似居中</h3>
<p>先给容器设置line-height维持一定的高度，然后设置图片vertical-align:middle</p>
<pre><code class="language-HTML">&lt;style&gt;
.box {
  line-height: 300px;
  text-align: center;
}
.box &gt; img {
  vertical-align: middle;
}
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;example/logo.jpg?imageMogr2/thumbnail/x100&quot; alt=&quot;图片src要设置!!&quot;/&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>而实际上这仍不是完美的垂直居中。因为我们知道，通过设置<code>vertical-align: middle;</code>，图片的中线的位置被确定为<code>从行内基线往上1/2 x-height 的位置</code> 。</p>
<blockquote>
<p>(备注：在英文字体设计中，通常以小写字母&quot;x&quot;的高度作为其他小写字母高度的设计的基础。因此x-height被用于表示一款字体中的小写字母&quot;x&quot;的高度。)</p>
<p>(备注：文字处于的位置高度和line-height之间关系的计算非常麻烦，详见我另一篇文章<a href="https://alexzhong22c.github.io/2018/02/06/height-calculate/">深入理解文字高度和行高的设置</a>。只需记住绝大多数情况下是：文字&quot;x&quot;的中心高度(即基线往上1/2 x-height处) 比line-height的中线高度要低。有些人称这种现象为&quot;字符下沉&quot;)</p>
</blockquote>
<p><img src="https://cloud.az22c.top/x-height.png-az22cgithub" alt="二分之一 x-height"></p>
<p>也就是说，假如现在给img后面添加一个&quot;x&quot;作为文字，图片所处的高度不会变，图片的中线位置就穿过文字&quot;x&quot;的中心，这时，图片的中线的位置实际上是比容器行内的中线位置要低的。<strong>所以，此乃近似垂直居中。</strong></p>
<p>另外，这种垂直居中方法还要IE8及以上才能兼容。</p>
<p><strong>备注：</strong></p>
<p>如果在IE7里面使用这个方法的时候，HTML结构要调整一下，例如：</p>
<pre><code class="language-HTML">&lt;div class=&quot;box&quot;&gt;
  &lt;img alt=&quot;图片src要设置!!&quot;/&gt;&lt;!-- 这里要换行或空格 --&gt;
&lt;/div&gt;
</code></pre>
<p>可以看做是在图片后面创建一个空白的文本节点。</p>
<hr>
<p>如果我们进而想要完美居中，可以有两种办法：</p>
<ul>
<li>font-size设为0</li>
<li>添加辅助元素</li>
</ul>
<h3 id="完美居中-font-size设为0"><a class="header-anchor" href="#完美居中-font-size设为0"></a>完美居中–font-size设为0</h3>
<p>完美居中：在&quot;近似居中&quot;的基础上，我们给<code>.box</code>加多一个<code>font-size:0</code> 即可。</p>
<pre><code class="language-CSS">.box {
  line-height: 300px;
  text-align: center;
  
  font-size: 0;
}
.box &gt; img {
  vertical-align: middle;
}
</code></pre>
<p>如果读过<a href="https://alexzhong22c.github.io/2018/02/06/height-calculate/">深入理解文字高度和行高的设置</a> 这篇文章的原理分析，我们会发现，如果设置字号为0，基线、x-height线等等线都合为一体（因为它们之间的距离为0嘛）。所以1/2 x-height 的位置也变成在行内最中间的那里，图片就完美居中了。</p>
<h3 id="完美居中-添加辅助元素"><a class="header-anchor" href="#完美居中-添加辅助元素"></a>完美居中–添加辅助元素</h3>
<p>完美居中：在&quot;近似居中&quot;的基础上，添加一个辅助元素使得其变成完美居中：</p>
<p>首先HTML结构中插入一个 i 元素；</p>
<p>然后CSS步骤有三：</p>
<ol>
<li>辅助元素inline-block化</li>
<li>辅助元素宽度为0，高度为100%</li>
<li>vertical-align:middle</li>
</ol>
<pre><code class="language-HTML">&lt;style&gt;
  .box {
    line-height: 300px;
    text-align: center;
  }
  .box &gt; img {
    vertical-align: middle;
  }
  i {
    display: inline-block;
    height: 100%;
    vertical-align: middle;
  }
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;example/logo.jpg?imageMogr2/thumbnail/x100&quot; alt=&quot;图片src要设置!!&quot;/&gt;
    &lt;i&gt;&lt;/i&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p><strong>备注：</strong> 这个辅助元素也可以是伪元素，替代 i 元素即可：</p>
<pre><code class="language-CSS">.box:before {
    content:'';
    width: 0%;

    display:inline-block;
    vertical-align:middle;
    height:100%;
}
</code></pre>
<h2 id="多行文字-水平垂直居中"><a class="header-anchor" href="#多行文字-水平垂直居中"></a>多行文字–水平垂直居中</h2>
<h3 id="近似居中-v2"><a class="header-anchor" href="#近似居中-v2"></a>近似居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.box {
  line-height: 300px;
  text-align: center;
}
.box &gt; .text {
  display: inline-block;
  vertical-align: middle;
  
  line-height: normal;
  text-align: left;
  max-width: 100%;
}
&lt;/style&gt;
&lt;body&gt;
&lt;p class=&quot;box&quot;&gt;
&lt;span class=&quot;text&quot;&gt;一行文字&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;&lt;!-- 兼容IE7,这里要换行或空格 --&gt;
&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p><strong>我们把多行文字的display属性转变为inline-block，就能对它像对上文的img元素做一样的水平垂直居中操作。</strong></p>
<p>总的来说近似居中的步骤有二：</p>
<ol>
<li>把多行文字的display水平设置得和图片的一样，即inline-block；</li>
<li>一般来说，需要重置外部继承的text-align和line-height属性。</li>
</ol>
<p>这种方法同样还要IE8及以上才能兼容。</p>
<hr>
<p>如果我们进而想要完美居中，原理同上文的图片，可以有两种办法：</p>
<ul>
<li>父元素font-size设为0</li>
<li>添加辅助元素</li>
</ul>
<h3 id="完美居中-font-size设为0-bad"><a class="header-anchor" href="#完美居中-font-size设为0-bad"></a>完美居中–font-size设为0(bad)</h3>
<p>给父元素设置font-size为0后，由于是文本，会继承父元素的font-size为0，所以又要再重置这多行文字的font-size回正常。特别麻烦，所以对于文字来说，不推荐这种方法。</p>
<h3 id="完美居中-添加辅助元素-good"><a class="header-anchor" href="#完美居中-添加辅助元素-good"></a>完美居中–添加辅助元素(good)</h3>
<p>原理已经在上文解释过了：</p>
<pre><code class="language-HTML">&lt;style&gt;
.box {
  line-height: 300px;
  text-align: center;
}
.box &gt; .text {
  display: inline-block;
  vertical-align: middle;
  
  line-height: normal;
  text-align: left;
  max-width: 100%;
}
i {
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}
&lt;/style&gt;
&lt;body&gt;
&lt;p class=&quot;box&quot;&gt;
&lt;span class=&quot;text&quot;&gt;一行文字&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;
&lt;i&gt;&lt;/i&gt;
&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<h2 id="后记："><a class="header-anchor" href="#后记："></a>后记：</h2>
<p>关于line-height的一些补充：</p>
<p>首先<code>文字高度</code>和font-size只有间接的关系，详见 <a href="https://alexzhong22c.github.io/2018/02/06/height-calculate/#%E4%BB%8Efont-size%E8%AE%B2%E8%B5%B7-%E8%AF%B4%E6%96%87%E5%AD%97%E9%AB%98%E5%BA%A6%EF%BC%9A">深入理解文字高度和行高的设置</a> 中第一章的内容。</p>
<p>然后，line-height的计算是根据font-size的，详见 <a href="https://alexzhong22c.github.io/2018/02/06/height-calculate/#line-height%E7%9A%84%E8%AE%A1%E7%AE%97-%E7%94%BB%E9%87%8D%E7%82%B9">深入理解文字高度和行高的设置</a> 。</p>
<p>然后，对于一个inline或者inline-block元素：</p>
<p>设置vertical-align为百分比的时候，是根据父元素的line-height来计算的。（补充，这个设置值也是为数不多的可以设置为负数的属性设置。）</p>
<p>设置vertical-align为其他值的时候，很多都和父元素的line-height有关系。</p>
<p>而如果你把上面的这些demo对于line-height的设置改为对于height的，vertical-align就无法发挥效果。（因为如果你只设置了height，line-height还是处于默认的状态，而vertical-align参考的还是line-height）</p>
<p><strong>实际上，vertical-align和line-height有关系，和height没有关系。</strong></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> vertical-align </tag>
            
            <tag> 居中 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[总结：使单一对象水平/垂直居中]]></title>
      <url>https://alexzhong22c.github.io/2019/02/05/centralize-one-ele/</url>
      <content type="html"><![CDATA[<p>明白单一对象的水平/垂直居中的写法和原理，有助于我们构造更加复杂的居中布局。</p>
<p>我们按照居中的“里面的内容”来分类，展开全文：</p>
<a id="more"></a>
<h2 id="里面的内容-为单行行内元素的时候-以单行文字为例"><a class="header-anchor" href="#里面的内容-为单行行内元素的时候-以单行文字为例"></a>“里面的内容”为单行行内元素的时候(以单行文字为例)</h2>
<p>由于设置<code>text-align:center</code>之后，行内的元素就会水平居中，比较简单。所以这里侧重讲垂直居中。</p>
<h3 id="a法：令line-height和height相等-垂直居中"><a class="header-anchor" href="#a法：令line-height和height相等-垂直居中"></a>A法：令line-height和height相等–垂直居中</h3>
<pre><code class="language-CSS">.parent {
  height: 300px;
  line-height: 300px;
}
</code></pre>
<p>事实上，不需要对于height属性的设置也是可以的。</p>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<p>只能居中一行文字：如果不想在页面缩放的时候让文字跑出元素的范围外，建议在后面加上<code>overflow: hidden</code> 。</p>
<h3 id="b法：使用display-table-cell和vertical-align-middle-垂直居中"><a class="header-anchor" href="#b法：使用display-table-cell和vertical-align-middle-垂直居中"></a>B法：使用display:table-cell和vertical-align:middle–垂直居中</h3>
<pre><code class="language-html">&lt;style&gt;
.parent {
  width: 300px;
  height: 250px;
  background: green;

  display: table-cell;
  vertical-align: middle;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;parent&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h4>
<ul>
<li>height和line-height可以自由定义，这方便内容从单行文字发展为多行文字</li>
<li>在浏览器缩放的时候表现优异</li>
</ul>
<h4 id="缺点：-v2"><a class="header-anchor" href="#缺点：-v2"></a>缺点：</h4>
<ul>
<li>设置.parent为<code>float:left</code>或者<code>positon:absolute</code>或者<code>position:fixed</code> 时居中会失效。如需兼顾他们，此时需要外面套多一层元素。（因为<code>vertical-align</code>只适用于inline/inline-block元素或者table-cell元素，详见 <a href="https://alexzhong22c.github.io/2018/02/05/vertical-align-middle/">深入理解vertical-align:middle</a>）</li>
<li>IE7及以下都不支持</li>
</ul>
<h4 id="备注："><a class="header-anchor" href="#备注："></a>备注：</h4>
<ul>
<li>特点是在IE8及以上浏览器的时候，<code>.grandparent</code> 的高度其实是可以自动适应的。</li>
<li>兼容更老的IE的写法：
<ul>
<li>HTML结构需要多套两层div：<code>.grandparent</code>和<code>.child</code></li>
<li>宽度、高度和背景等属性需要转移到<code>.grandparent</code> 这一级</li>
<li>文字内容需要转移到<code>.child</code> 这一级</li>
</ul>
</li>
</ul>
<pre><code class="language-HTML">&lt;style&gt;
.grandparent {
  width: 300px;
  /*自动高度：*/
  /*height: 250px;*/
  background: green;

  display: table;
  *position:relative;
  overflow:hidden;
}
.parent {
  display: table-cell;
  vertical-align: middle;

  *position:absolute;
  *top:50%;
}
.child {
  *position:relative;
  *top:-50%;
}
.someone {
  height: 400px;
  background: yellow;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;grandparent&quot;&gt;
  &lt;div class=&quot;someone&quot;&gt;用来增大高度用来增大高度用来增大高度，可以被删掉&lt;/div&gt;
  &lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h3 id="c法：使用display-inline-block和vertical-align-middle-垂直居中"><a class="header-anchor" href="#c法：使用display-inline-block和vertical-align-middle-垂直居中"></a>C法：使用display: inline-block和vertical-align:middle–垂直居中</h3>
<p>这里只给出近似垂直居中的例子，如果想设置为完美垂直居中的位置或者了解更多，详见<a href="https://alexzhong22c.github.io/2018/02/05/vertical-align-middle/">深入理解vertical-align:middle</a> ：</p>
<pre><code class="language-HTML">&lt;style&gt;
.parent {
  line-height: 300px;
  text-align: center;
  background: green;
}
.text {
  display: inline-block;
  vertical-align: middle;
  
  line-height: normal;
  text-align: left;
  max-width: 100%;
}
&lt;/style&gt;
&lt;body&gt;
&lt;p class=&quot;parent&quot;&gt;
&lt;span class=&quot;text&quot;&gt;一行文字&lt;br&gt;一行文字&lt;br&gt;一行文字&lt;/span&gt;&lt;!-- 兼容IE7,这里要换行或空格 --&gt;
&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<h3 id="d法：flex布局-垂直居中"><a class="header-anchor" href="#d法：flex布局-垂直居中"></a>D法：flex布局–垂直居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.parent {
  width: 300px;
  height: 250px;
  background: green;

  display: -webkit-flex;
  display: -ms-flex;/* IE 10 */
  display: flex;
  align-items: center;
}
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;parent&quot;&gt;这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="优点：-v2"><a class="header-anchor" href="#优点：-v2"></a>优点：</h4>
<ul>
<li><code>.parent</code>元素不用定高</li>
<li>代码简单</li>
</ul>
<h4 id="缺点：-v3"><a class="header-anchor" href="#缺点：-v3"></a>缺点：</h4>
<ul>
<li>IE要10才支持</li>
<li>其实文字是可以自动换行的，这样就是多行文字了，但是需要IE11</li>
</ul>
<h4 id="备注：-v2"><a class="header-anchor" href="#备注：-v2"></a>备注：</h4>
<ul>
<li>兼容IE10的写法为：<code>display: -ms-flex;</code>； 而且要求<code>-ms-flex-preferred-size</code>（即第三个参数）带单位，所以必须写成<code>0px</code>或<code>0%</code>或<code>auto</code>。</li>
<li>如果要兼容旧浏览器就惨了，这货换了好多次名字：</li>
</ul>
<pre><code>display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */
display: -moz-box; /* Firefox 17- */
display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */
display: -moz-flex; /* Firefox 18+ */
display: -ms-flexbox; /* IE 10 */
display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */
</code></pre>
<h2 id="里面的内容-为多行行内元素的时候-以多行文字为例"><a class="header-anchor" href="#里面的内容-为多行行内元素的时候-以多行文字为例"></a>“里面的内容”为多行行内元素的时候(以多行文字为例)</h2>
<p><strong>参考上文B法</strong></p>
<p><strong>参考上文C法</strong></p>
<p><strong>参考上文D法</strong></p>
<h2 id="里面的内容-为大小不固定的图片的时候"><a class="header-anchor" href="#里面的内容-为大小不固定的图片的时候"></a>“里面的内容”为大小不固定的图片的时候</h2>
<p><strong>参考上文B法</strong></p>
<p><strong>参考上文C法</strong></p>
<p><strong>参考上文D法</strong></p>
<h2 id="里面的内容-为定宽高的块级元素的时候"><a class="header-anchor" href="#里面的内容-为定宽高的块级元素的时候"></a>“里面的内容”为定宽高的块级元素的时候</h2>
<h3 id="定宽-margin-auto-水平居中"><a class="header-anchor" href="#定宽-margin-auto-水平居中"></a>定宽+margin auto–水平居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.child {
    width: 300px;
    background: green;

    margin: 0 auto;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="备注：-v3"><a class="header-anchor" href="#备注：-v3"></a>备注：</h4>
<p>首先，元素定宽是必须的。然后，大家都知道，只要margin-left和margin-right都为auto就行了。</p>
<h4 id="优点：-v3"><a class="header-anchor" href="#优点：-v3"></a>优点：</h4>
<p>IE7及以上都是可以的</p>
<h3 id="定宽高-绝对定位-负margin-水平垂直居中"><a class="header-anchor" href="#定宽高-绝对定位-负margin-水平垂直居中"></a>定宽高+绝对定位+负margin–水平垂直居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.child {
    width: 300px;
    height: 250px;
    background: green;

    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -150px;
    margin-top: -125px;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="优点：-v4"><a class="header-anchor" href="#优点：-v4"></a>优点：</h4>
<ul>
<li>兼容性好</li>
</ul>
<h4 id="缺点：-v4"><a class="header-anchor" href="#缺点：-v4"></a>缺点：</h4>
<ul>
<li>要定宽高</li>
</ul>
<h4 id="备注：-v4"><a class="header-anchor" href="#备注：-v4"></a>备注：</h4>
<p>将<code>position: absolute;</code>改成<code>position: fixed;</code>也是可以的，相信大家都懂什么意思。但是在老版本IE下会不支持fixed，在网上抄一下怎么兼容就行了。</p>
<h2 id="里面的内容-为不定宽高的块级元素的时候"><a class="header-anchor" href="#里面的内容-为不定宽高的块级元素的时候"></a>“里面的内容”为不定宽高的块级元素的时候</h2>
<h3 id="绝对定位-margin-auto-水平垂直居中"><a class="header-anchor" href="#绝对定位-margin-auto-水平垂直居中"></a>绝对定位+margin:auto–水平垂直居中</h3>
<pre><code class="language-HTML">&lt;style&gt;
.child {
  /*宽高可以不写：*/
  width: 300px;
  height: 250px;
  background: green;

  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;

  margin: auto;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="优点：-v5"><a class="header-anchor" href="#优点：-v5"></a>优点：</h4>
<p>符合人的直觉思维习惯</p>
<h4 id="缺点：-v5"><a class="header-anchor" href="#缺点：-v5"></a>缺点：</h4>
<p>需要IE8及以上</p>
<h4 id="备注：-v5"><a class="header-anchor" href="#备注：-v5"></a>备注：</h4>
<ul>
<li>定位改成用fixed也是可以的</li>
<li>其原理参考：</li>
</ul>
<p><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" target="_blank" rel="noopener">margin-auto-absolute-绝对定位-水平垂直居中-张鑫旭</a></p>
<p><a href="https://www.zhihu.com/question/21644198" target="_blank" rel="noopener">为什么margin:auto可以让块级元素水平居中</a></p>
<h3 id="绝对定位-translate-水平垂直居中"><a class="header-anchor" href="#绝对定位-translate-水平垂直居中"></a>绝对定位+translate–水平垂直居中</h3>
<pre><code class="language-CSS">&lt;style&gt;
.parent {
    width: 300px;
    height: 300px;
    background: green;

    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;parent&quot;&gt;
&lt;div class=&quot;child&quot;&gt;这是文字这是文字这是文字这是文字这是文字这是文字这是文字这是文字&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="优点"><a class="header-anchor" href="#优点"></a>优点:</h4>
<p>父子元素的width和height都可以自己定</p>
<h4 id="缺点：-v6"><a class="header-anchor" href="#缺点：-v6"></a>缺点：</h4>
<p>IE8及以下不兼容</p>
<h4 id="备注：-v6"><a class="header-anchor" href="#备注：-v6"></a>备注：</h4>
<ul>
<li>绝对定位也可以改写为相对定位：</li>
</ul>
<pre><code class="language-CSS">.parent {
  	/*子元素相对定位，父元素定高*/
    width: 300px;
    height: 250px;
    background: green;
}
.child {
    position: relative;
    top: 50%;
    transform: translateY(-50%);
}
</code></pre>
<ul>
<li>transform的兼容性写法：</li>
</ul>
<pre><code class="language-CSS">transform:translateY(-50%);
-ms-transform:translateY(-50%); 	/* IE 9 */
-moz-transform:translateY(-50%); 	/* Firefox */
-webkit-transform:translateY(-50%); /* Safari 和 Chrome */
-o-transform:translateY(-50%); 	/* Opera */
</code></pre>
<p>对于<code>transform</code>而言：</p>
<p>Internet Explorer 10、Firefox、Opera 支持 transform 属性。</p>
<p>Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。</p>
<p>Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。</p>
<p>Opera 只支持 2D 转换。</p>
<h3 id="flex布局-水平垂直居中"><a class="header-anchor" href="#flex布局-水平垂直居中"></a>flex布局–水平垂直居中</h3>
<p>flex布局在这里有点大才小用了。关键在于了解flex布局的特点。因为写法较多，参考网上的。</p>
<h3 id="转换成行内块级元素"><a class="header-anchor" href="#转换成行内块级元素"></a>转换成行内块级元素</h3>
<p>此次我们居中的目标是一个<code>块级元素的</code>块块，而非之前的<code>行内元素</code>。</p>
<p>我们需要加上<code>display: inline-block;</code>使它变成行内块级元素，然后就可以参考行内元素的居中来弄了。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> vertical-align </tag>
            
            <tag> 居中 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[到底什么是函数式编程 精简总结]]></title>
      <url>https://alexzhong22c.github.io/2018/02/05/js-functional-intro/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<p>到底什么是函数式编程？我将分别用一段话来总结其 特点 和 作用。</p>
<a id="more"></a>
<p><strong>特点：</strong></p>
<ul>
<li>没有副作用（函数的纯度）
<ul>
<li>柯里化是延伸出来的</li>
<li>延伸问题是副作用的管理</li>
</ul>
</li>
<li>范畴论和函子
<ul>
<li>函数是一等公民，高阶函数等概念</li>
<li>函数的组合</li>
</ul>
</li>
<li>声明式代码</li>
<li>不可变量和不可变对象</li>
</ul>
<p><strong>作用：</strong></p>
<p>函数式编程，和面向对象编程一样都是用来 <strong>降低系统复杂度的</strong> ，在js里面，可以说是作为一种设计思路和其他的互相补充。</p>
<blockquote>
<p>就这样，完成了全文，有点空荡荡的。后面还补充一个简单的问题，来帮助思考的：</p>
</blockquote>
<h2 id="问题：基于函子思想改写-实现一个可reject的map"><a class="header-anchor" href="#问题：基于函子思想改写-实现一个可reject的map"></a>问题：基于函子思想改写，实现一个可reject的map</h2>
<pre><code class="language-js">// 要实现的调用效果：
const result = new MMM(1)
  .map((item, reject) =&gt; {
    return item + 2;
  })
  .map((item, reject) =&gt; {
    // reject(); // 注释开关我，重新运行
    return item + 3;
  })
  .map((item, reject) =&gt; {
    return item + 4;
  })
  .join();
console.log(result) // 期望10
</code></pre>
<p>如果在任一个map中调用了reject，后续的map就全被跳过不必执行，同时链式调用的结果直接fallback到一个“候补值”。（为了简便，这个fallback值定义在js文件的作用域中，也就是后文源码的<code>VIEW_INVALID</code>这个值）</p>
<h4 id="对比promise的调用代码："><a class="header-anchor" href="#对比promise的调用代码："></a>对比promise的调用代码：</h4>
<p>显然这段代码结构有点像Promise的语法，但比promise简漏的是：</p>
<ol>
<li>它不能处理异步</li>
<li>它一样可以reject，但是还没有catch的机制</li>
<li>没有办法引入函数外的副作用</li>
<li>没有Monad自动拆箱的机制</li>
</ol>
<p>而从这种代码改写，直到进化到promise需要怎么改写代码呢？是很有意思的问题，这里暂时就不讨论了。</p>
<h4 id="利用原型对象-代码实现："><a class="header-anchor" href="#利用原型对象-代码实现："></a>利用原型对象 代码实现：</h4>
<p>回到正题，一开始的实现代码是这样，<strong>还是停留在利用js原型链上的属性的范畴</strong> ：</p>
<pre><code class="language-js">const VIEW_INVALID = 'VIEW_INVALID';
const MMM = function(value, isInvalid) {
  this.isInvalid = isInvalid || false;
  this.value = value;
}
// MMM.prototype.of = function(value) {
//   return new MMM(value);
// }
MMM.prototype.map = function(func) {
  if (!this.isInvalid) {
    const result = func(this.value, () =&gt; {
      this.isInvalid = true;
      this.value = VIEW_INVALID;
    });
    this.value = !this.isInvalid ? result : this.value;
    return new MMM(this.value, this.isInvalid);
  } else if (this.isInvalid) {
    return new MMM(this.value, this.isInvalid);
  }
}
MMM.prototype.join = function() {
  return this.value;
}
</code></pre>
<h4 id="函子化改写的实现："><a class="header-anchor" href="#函子化改写的实现："></a>函子化改写的实现：</h4>
<p>经研究，按照either函子的思想，源码可改写为：</p>
<pre><code class="language-js">const VIEW_INVALID = 'VIEW_INVALID';
// const MMM = function(value, isInvalid) { /**/ } // 代码没变，同上回
// MMM.prototype.of = function (/**/) { /**/ } // 代码没变，同上回
MMM.prototype.mapEither = function(func, fForInvalid) {
  fForInvalid = fForInvalid || function(x) {return x};
  func = func || function(x) {return x};
  const todoFN = !this.isInvalid ? func : fForInvalid;
  return new MMM(todoFN(this.value), this.isInvalid);
}
MMM.prototype.map = function(func) {
  const result = func(this.value, () =&gt; {
    this.isInvalid = true;
    this.value = VIEW_INVALID;
  });
  return this.mapEither(() =&gt; {
    return this.mapEither(() =&gt; result).join()
  })
}
</code></pre>
<p>代码还可以怎么改写？这种改写之后带来什么优势？其实是比较开放性的问题。</p>
<p>之后如果对函数式编程有更深入的理解，我再把这个坑填上吧。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 笔记副本 </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web前端性能优化概述]]></title>
      <url>https://alexzhong22c.github.io/2018/02/04/performance-optimized-summary/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。如果想做一个系统性的归纳总结、以便查询，可以参考以下概述。</p>
<a id="more"></a>
<h2 id="性能优化的指导思想："><a class="header-anchor" href="#性能优化的指导思想："></a>性能优化的指导思想：</h2>
<ul>
<li>先从辅助工具入手，先从性能瓶颈入手
<ul>
<li>现在的辅助工具强大到会提示你如何进行优化，你可以参考着来一项一项做就行了</li>
<li>很多性能优化的手段是相互矛盾的，所以要抓住瓶颈和重点，舍弃掉收效不明显的手段</li>
<li>性能优化是一项庞大的工作量，出于对工期的考虑，建议抓住瓶颈和重点</li>
</ul>
</li>
<li>不要过早优化
<ul>
<li>很多性能优化的手段是相互矛盾的，在编写新功能阶段过早优化可能会造成返工和工作时间的浪费</li>
<li>返工的过程又可能引入bug</li>
</ul>
</li>
<li>不要为了优化而优化：在迭代中，等到测试人员或者用户对性能不满意，才去优化
<ul>
<li>如果你的网站性能，优化到能令用户满意，就不用追求极致的性能</li>
<li>性能优化难有终点和尽头，尤其是多人协作项目，如果追求极致优化通常会引入隐性的问题和bug</li>
</ul>
</li>
</ul>
<h2 id="性能优化概述"><a class="header-anchor" href="#性能优化概述"></a>性能优化概述</h2>
<p>刚刚提到“先从辅助工具入手，先从性能瓶颈入手”，这才是工作中性能优化的思路。</p>
<p>而如果是面试找思路回答这个问题，或者想做一个系统性的归纳总结、以便查询，可以参考以下概述：</p>
<p>(下面列表的5个根节点其实就是5个大的方向)</p>
<ul>
<li>资源预加载
<ul>
<li>w3c Resource Hints：dns预解析、TCP预连接、页面预渲染。有一些标签属性已经可以很好的做到这些，如 dns-prefetch &amp; preconnect &amp; prefetch &amp; prerender(慎用) &amp; preload。</li>
<li>其他preload的方案或者xxx-loadable库</li>
</ul>
</li>
<li>减小传输文件体积
<ul>
<li>gzip(后文有介绍)</li>
<li>webpack打包策略 BundleAnalyzerPlugin 或者执行vue ui来分析
<ul>
<li>抽离公共模块</li>
</ul>
</li>
<li>按需引入模块
<ul>
<li>利用webpack按需引入</li>
</ul>
</li>
<li>取代Cookies + Cookie free (减小http包体积)</li>
<li>js、css打包压缩</li>
<li>减少字体体积</li>
<li>压缩html</li>
<li>图片格式和压缩
<ul>
<li>图片压缩</li>
<li>雪碧图(更新起来麻烦，以前才流行)：减少http请求次数。webpack-spritesmith</li>
<li>图片格式选择
<ul>
<li>色彩丰富的小图用png（支持透明）</li>
<li>大图(背景图、轮播图)要用jpg：体积小，不支持透明</li>
<li>webp 但兼容性不是那么好，需要调研一下
<ul>
<li>微信基本用的是webp</li>
</ul>
</li>
<li>svg：矢量图体积小，因为是标签需额外的计算：比如icon-font</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>减少文件传输数量和次数
<ul>
<li>利用文件打包来控制个数和大小和按使用频率分包，这就和webpack有关了</li>
<li>http缓存，合理设置客户端缓存时间、利用好强缓存协商缓存</li>
<li>数据缓存
<ul>
<li>(cookie localstroage， sessionStroage等本地存储)</li>
<li>如果高并发的话改用redis存图片</li>
</ul>
</li>
<li>页面懒加载和图片懒加载</li>
<li>避免空的src和href</li>
<li>http keep-alive</li>
</ul>
</li>
<li>减少途经的服务器数量和路径长度
<ul>
<li>cdn
<ul>
<li>cdn域名分片规避浏览器对一个域名的并发数限制</li>
</ul>
</li>
</ul>
</li>
<li>少执行代码 和 缩短代码执行时间
<ul>
<li>--------- 【 浏览器层面： 】 ---------</li>
<li>处理阻塞css、js，异步加载组件或css、js</li>
<li>减少DOM显示数
<ul>
<li>(一个长度10000的商品列表，怎么显示)(移动设备内存存储数据过多dom也会崩掉)</li>
<li>虚拟列表
<ul>
<li>(其实就保留三屏的列表，自制组件库scoll组件也面临这个性能问题)</li>
<li>vue-virtual-scroller和react-virtualized等等</li>
</ul>
</li>
<li>无限滚动懒加载列表</li>
</ul>
</li>
<li>减少dom操作的次数</li>
<li>减少重排重绘  (和避免强制重排强制重绘)</li>
<li>慎重选择高性能消耗的css样式</li>
<li>web workers分担执行任务</li>
<li>--------- 【 代码逻辑层面： 】 ---------</li>
<li>骨架屏：vue-skeleton-webpack-plugin</li>
<li>防抖节流</li>
<li>算法优化
<ul>
<li>排序的优化</li>
<li>动态规划等等</li>
</ul>
</li>
<li>基于框架运行机制的优化：vue react：组件重新渲染机制等等</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 笔记副本 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git暂存区知识梳理]]></title>
      <url>https://alexzhong22c.github.io/2017/10/12/git-stage/</url>
      <content type="html"><![CDATA[<p>暂存区是git的一个重要概念，经过了一段时间的项目实践，总结一下个人对暂存区的一些理解。</p>
<p>当我们开始对git的一些知识进行梳理的时候，可以盗用以下这张图：</p>
<a id="more"></a>
<p><img src="https://cloud.az22c.top/add-commit-push.png-az22cgithub" alt="add-commit-push.png"></p>
<ul>
<li>working directory为本地的<strong>工作区</strong></li>
<li>stage area为<strong>暂存区</strong>，亦称作stage或者index</li>
<li>local branch代指某个<strong>本地分支</strong></li>
<li>remote branch代指某个<strong>远程分支</strong></li>
</ul>
<p>正常情况下，本地分支 和 远程分支 存在着对应关系，比如，我们用本地的一个 master分支 对应远程的 master分支。</p>
<p>git的作用围绕着 <code>“分支”</code> 这么一个对象来展开的。</p>
<p>很明显这张图只考虑单分支（一对对应分支）的情形，这也是我们在工作中常见的情形。如果明白了单分支的玩法，多分支的玩法也是同理可得的。</p>
<hr>
<p>使用 git 的最简单的一个流程就是：</p>
<pre><code>git add .              ::::将 对本地工作区中所有的内容变动 保存到暂存区
git commit -m &quot;描述&quot;   ::::将 暂存区的内容 提交到本地分支
git push               ::::将 本地分支的变化 同步到远程分支
</code></pre>
<h2 id="暂存区的作用-优化commit"><a class="header-anchor" href="#暂存区的作用-优化commit"></a><strong>暂存区</strong>的作用 – 优化commit</h2>
<p>git的规则是<strong>原子性提交</strong> 。原子，是化学世界不可再分的最小单位。</p>
<p>原子性提交 的意思是，由 多个文件的内容变动信息 组成一次提交(commit)后，每一个commit被视为一个不可再分的整体。</p>
<p>要么<strong>在同一个commit里的 多个文件的内容变动</strong> 全部成功提交到本地分支，要么全部失败。</p>
<p>原子性提交带来的好处是，我们能很简便地把分支还原到某个阶段或者时间节点。就像玩游戏，将游戏进度还原到某个存档的时间点上。</p>
<p>在存档形成的时候，各种各样的信息组成一个存档记录。一个存档记录在形成后，是不能再被细分的。</p>
<p>一个commit，相当于是游戏里的一个存档。</p>
<hr>
<p>暂存区的存在，使得一个commit比一个游戏存档更加牛逼：在形成的时候，游戏存档会把该时间节点上的所有信息（人物等级、背包里面的物品、游戏任务进度等等）全部记录下来；然而在git中，有了<strong>暂存区</strong>，我们可以自己<code>挑选</code>记录哪些信息形成一个commit。</p>
<p>比如，我在本地<strong>工作区</strong>修改了a.txt、b.txt、c.txt三个文件的内容，但是我只想记录提交a.txt、c.txt两个文件的变动，那么我们只需要把a.txt和c.txt两个文件的变动保存到<strong>暂存区</strong>，然后将暂存区的内容形成一个commit就可以了。</p>
<h3 id="git-add的作用-选取变动保存到暂存区"><a class="header-anchor" href="#git-add的作用-选取变动保存到暂存区"></a>git add的作用 – 选取变动保存到暂存区</h3>
<p>由上文可知，我们能挑选自己想记录提交的内容，git add就是 用来选择记录的 一个指令。刚才的操作的指令是：</p>
<pre><code>git add a.txt c.txt
</code></pre>
<p>就能把把a.txt和c.txt两个文件的变动保存到<strong>暂存区</strong>了。继而进行其他后续操作。</p>
<p>而一般情况下，就像游戏存档一样，我们会去选择保存所有的文件变动，而<code>git add .</code> 代表的就是这个意思。</p>
<p><img src="https://cloud.az22c.top/github-desktop.png-az22cgithub" alt="github-desktop"></p>
<p>用过GitHub Desktop的童鞋会发现它们是同样的道理的，只不过一个是git指令的形式，一个是图形化界面的形式，流程是一样的：</p>
<ul>
<li>挑选自己想记录提交的内容，形成一个commit</li>
<li>将一个commit作为一个整体，添加到分支上</li>
</ul>
<p><strong>在过程其中的区别就是：git指令没有操作界面，所以需要用到暂存区这么一个概念；而图形化界面只需直观地在界面上勾选文件的变动项就可以了。</strong></p>
<p>所以在GitHub Desktop上根本不存在<strong>暂存区</strong>的概念，直接在界面上勾选，就能起到同样的作用。</p>
<h2 id="暂存区的延伸作用-文件快照-便于回退"><a class="header-anchor" href="#暂存区的延伸作用-文件快照-便于回退"></a><strong>暂存区</strong>的延伸作用 – 文件快照，便于回退</h2>
<p>暂存区的作用，解释了它被发明是为了解决什么样的痛点。</p>
<p>接着，人们发现，这种理念还能够发挥出其他额外的作用，这种作用就是<code>文件快照</code>。</p>
<h3 id="git-checkout"><a class="header-anchor" href="#git-checkout"></a>git checkout</h3>
<p>比如，我对hello.js做了修改之后，<code>git add hello.js</code> ，把它的改动保存到暂存区作为一个快照。之后我们再继续对hello.js做修改，但是发现改得不满意，想回退到它上一次保存到暂存区时的状态。</p>
<p>这时候使用指令<code>git checkout hello.js</code>就可以实现回退到上一次快照了。</p>
<p>但是这个玩法就比较鸡肋了，因为我们在代码编辑器连续按 <code>ctrl + z</code> 也能实现撤销改动的嘛。</p>
<h3 id="git-diff"><a class="header-anchor" href="#git-diff"></a>git diff</h3>
<p>通常代码编辑器所做不到的功能是git diff：</p>
<p>git diff 显示当前<strong>工作区</strong>的文件和<strong>暂存区</strong>文件的差异</p>
<p>git diff --staged 显示<strong>暂存区</strong>和HEAD的文件的差异</p>
<p>git diff HEAD 显示工作区和HEAD的文件的差异</p>
<p>补充说明：</p>
<ul>
<li>HEAD 指向的是分支上最新提交的版本</li>
<li>英文stage area即为<strong>暂存区</strong>，亦称作stage或者index</li>
<li><code>git diff --cached</code>和<code>git diff --staged</code>的作用是一样的：前者是老版本git的写法，后者是新版本的写法。为了兼容老版本git，<code>git diff --cached</code>依然可以被git识别的。</li>
</ul>
<h3 id="git-reset"><a class="header-anchor" href="#git-reset"></a>git reset</h3>
<p>git reset其实是一个用于回退HEAD的指令。但是取决于它<code>--hard</code>、<code>--mixed</code>、<code>--soft</code>三个程度参数的不同，也有可以顺带地影响到<strong>暂存区</strong>。</p>
<p>例如，在用<code>git add hello.js</code> 将文件变动保存到<strong>暂存区</strong>后，之后我又想从<strong>暂存区</strong>删掉这项“保存”记录，我就可以使用git reset，而它同时不会撤销<strong>工作区</strong>中的文件改动：</p>
<pre><code>git reset hello.js
</code></pre>
<p>补充：git reset默认参数是<code>--mixed</code>，即上式等价为：<code>git reset hello.js --mixed</code> 。</p>
<ul>
<li>设置为<code>--hard</code>时会影响到HEAD、暂存区、工作区</li>
<li>设置为<code>--mixed</code>时只会影响到HEAD、暂存区</li>
<li>设置为<code>--soft</code>时只会影响到HEAD</li>
</ul>
<p>可以看到git reset和git checkout同样用于<code>回退</code>，但是它们作用是不同的。由于git reset主要针对的是HEAD，本文不展开讨论了，详情可参考其他资料。</p>
<h2 id="总结对比github-desktop："><a class="header-anchor" href="#总结对比github-desktop："></a>总结对比Github Desktop：</h2>
<p>git的<strong>暂存区</strong>的主要作用是优化commit；在Github Desktop界面上勾选记录，也能起到同样的作用。</p>
<p>而git的<strong>暂存区</strong>的延伸作用 – 文件快照：</p>
<ul>
<li>git checkout</li>
<li>git diff的部分指令</li>
<li>git reset</li>
<li>其他等等</li>
</ul>
<p>它们这些功能是GitHub Desktop所无法匹敌的。</p>
<blockquote>
<p>在后续的git主题的博文中，我们会继续总结如何使用git做一些比较实用和常见的操作，比如：</p>
<ul>
<li>如何撤销一个commit？</li>
<li>已经push到远程了，怎么撤销一个commit？</li>
<li>git merge的原理？管理多分支需要什么样的基础知识？</li>
<li>如何从一个分支抽取部分文件提交到另一个分支？</li>
<li>git submodule是什么，在项目中有什么实际的应用？</li>
</ul>
<p>敬请期待。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> git </tag>
            
            <tag> 基础 </tag>
            
            <tag> 指令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三栏式布局--IFE2017-CSS-task03笔记]]></title>
      <url>https://alexzhong22c.github.io/2017/09/17/ife-css-task03/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="noopener">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<a id="more"></a>
<blockquote>
<p>task03任务要求：</p>
<ul>
<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>
<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。</li>
</ul>
<p>这个任务中，懒于去上网找图片素材，直接引用了别人复仇者联盟的图片素材。</p>
</blockquote>
<p>我们先总览本文内各种实现的思路：</p>
<ol>
<li>按照普通顺序编写HTML系
<ol>
<li>运用margin</li>
<li>用BFC</li>
</ol>
</li>
<li>先加载main栏的HTML系 <strong>（重点）</strong>
<ol>
<li>双飞翼布局</li>
<li>圣杯布局</li>
</ol>
</li>
</ol>
<h2 id="按普通顺序编写html系"><a class="header-anchor" href="#按普通顺序编写html系"></a>按普通顺序编写HTML系</h2>
<p>一般来说我们 <strong>按照普通顺序编写HTML</strong> ：此时先写子栏的代码，再写main栏的代码。</p>
<p>此时，如果想要形成三栏的布局，思路可再细分为二：</p>
<h3 id="要么运用margin形成三栏的布局"><a class="header-anchor" href="#要么运用margin形成三栏的布局"></a>要么运用margin形成三栏的布局</h3>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/1%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-%E7%94%A8margin%E5%88%86%E5%BC%80.html">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/1%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-%E7%94%A8margin%E5%88%86%E5%BC%80.html" target="_blank" rel="noopener">源码</a></p>
<h3 id="要么用bfc形成三栏的布局"><a class="header-anchor" href="#要么用bfc形成三栏的布局"></a>要么用BFC形成三栏的布局</h3>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/2%E4%BD%BF%E7%94%A8BFC%E6%96%B9%E6%B3%95.html">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E6%8C%89%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%86%99/2%E4%BD%BF%E7%94%A8BFC%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">源码</a></p>
<blockquote>
<p>注：这两个demo中的<code>clearfix</code>类是用来闭合浮动的。以满足“父元素的高度始终为子元素中最高的高度”这个要求。</p>
<p>下文的各种方法也是需要闭合浮动的，为了方便演示我省略不写。</p>
</blockquote>
<h2 id="先加载main栏的html系"><a class="header-anchor" href="#先加载main栏的html系"></a>先加载main栏的HTML系</h2>
<p>我们希望页面中间的main栏的内容最先被浏览器加载呈现，这样页面就更加主次合理，所以前端圈里面出现了这么种思路。</p>
<p><strong>原理：</strong></p>
<ul>
<li>定义main-content宽度为100%（如果在IE6里不定义100%，会有点小问题，亲们自己可以一试）</li>
<li>main 左浮动，宽度为100%</li>
<li>sub 左浮动，宽度190，左外边距为-100%（此处是关键：浮动情况下，负的外边距会导致DIV上移，而使用-100%可以确使它移动到最左侧。)</li>
<li>extra 左浮动，宽度230，左外边距为-230px（道理同上，注意的是，负的左外边距值一定要大于或等于该DIV的宽度，才能靠到上一行去）</li>
</ul>
<p>当只使用负左外边距的方法时，能够实现<strong>先加载main栏</strong>，但是main栏的内容会被挡住：</p>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/1main%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E6%8C%A1%E4%BD%8F.html">demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/1main%E7%9A%84%E5%86%85%E5%AE%B9%E8%A2%AB%E6%8C%A1%E4%BD%8F.html" target="_blank" rel="noopener">源码</a></p>
<blockquote>
<p>因此，解决 main栏的内容被挡住 的思路可再细分为二：</p>
<p>1.<strong>双飞翼布局</strong></p>
<p>2. <strong>圣杯布局</strong></p>
<p>而在本文的最后，会介绍其他的方式来实现 三栏等高的 先加载main栏的 三栏式布局。</p>
</blockquote>
<h3 id="双飞翼布局"><a class="header-anchor" href="#双飞翼布局"></a>双飞翼布局</h3>
<p>淘宝的双飞翼布局：在原来的基础上多套了一层div，并且增设margin。<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-1%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html">2-1淘宝双飞翼布局demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-1%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener">源码</a></p>
<h4 id="好处："><a class="header-anchor" href="#好处："></a>好处：</h4>
<ul>
<li>可以实现主要的内容先加载的优化</li>
<li>兼容目前所有的主流浏览器，包括IE6在内</li>
</ul>
<h4 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h4>
<ul>
<li>位置不灵活，同时css对位置的控制很强</li>
</ul>
<h3 id="圣杯布局"><a class="header-anchor" href="#圣杯布局"></a>圣杯布局</h3>
<p>圣杯布局的特点是它使用了padding和相对定位，当然它也使用了负左外边距。<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html">2-2圣杯布局demo</a> –  <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener">源码</a></p>
<h4 id="好处：-v2"><a class="header-anchor" href="#好处：-v2"></a>好处：</h4>
<ul>
<li>可以实现主要的内容先加载的优化</li>
<li>位置比较灵活：毕竟它是用 相对定位 实现的</li>
<li>main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。</li>
<li>任何一栏都可以是最高栏，不会出问题。</li>
<li>只需要针对ie6来hack：<code>zoom:1</code> ，兼容目前所有的主流浏览器，包括IE5.5</li>
</ul>
<h4 id="缺点：-v2"><a class="header-anchor" href="#缺点：-v2"></a>缺点：</h4>
<ul>
<li>当浏览器宽度过窄时，子栏可能会消失，extra栏的内容可能会跑到主栏里面。</li>
</ul>
<p><a href="https://alexzhong22c.github.io/IFE-CSS-learning/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2-X%E8%AF%81%E6%98%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%86%85%E9%83%A8%E7%81%B5%E6%B4%BB.html">证明圣杯布局内部灵活的demo</a> – <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/task03%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/%E5%85%88%E5%8A%A0%E8%BD%BDmain%E6%A0%8F/2-2-X%E8%AF%81%E6%98%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%86%85%E9%83%A8%E7%81%B5%E6%B4%BB.html" target="_blank" rel="noopener">证明圣杯布局内部灵活的源码</a></p>
<h2 id="实现三栏等高的其他方法"><a class="header-anchor" href="#实现三栏等高的其他方法"></a>// 实现三栏等高的其他方法</h2>
<h3 id="用左右border作为两栏背景色-background-clip"><a class="header-anchor" href="#用左右border作为两栏背景色-background-clip"></a>用左右border作为两栏背景色+background-clip</h3>
<p>.main元素的左右border区域作为两侧栏所在区域背景，实现伪等高效果；设置.main的padding实现栏间间隔。</p>
<p>可设置main的background色，然后用<code>background-clip: content-box;</code>控制背景范围。</p>
<pre><code>.main {
    box-sizing: border-box;
    width: 100%;
    border-left: 190px solid #faa;/*作为左栏背景色*/
    border-right: 230px solid #aaf;/*作为右栏背景色*/
    padding: 0 10px;
    height: 400px; /*某一高度*/

	/*main栏背景：*/
    background: #afa;
    background-clip: content-box;
}
</code></pre>
<p>两侧栏元素再通过负margin调整到.main元素的border区域上。</p>
<p>缺点: 兼容性不好，用到了CSS3的属性，应该至少要ie9</p>
<h3 id="绝对定位"><a class="header-anchor" href="#绝对定位"></a>绝对定位</h3>
<p>设置子元素的top:0;bottom:0;使得所有子元素的高度都和父元素的高度相同，实现等高效果</p>
<h3 id="flex布局"><a class="header-anchor" href="#flex布局"></a>flex布局</h3>
<p>flex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果</p>
<p>缺点: 兼容性不好</p>
<hr>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25070186?refer=learncoding" target="_blank" rel="noopener">详解 CSS 七种三栏布局技巧</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 圣杯布局 </tag>
            
            <tag> 双飞翼布局 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[border-radius属性]]></title>
      <url>https://alexzhong22c.github.io/2017/09/07/css-border1/</url>
      <content type="html"><![CDATA[<p>border-radius，作为CSS3中经常被用及的属性，我们用一篇文章做一下总结。</p>
<a id="more"></a>
<p>先给出一个div作为演示用：</p>
<pre><code class="language-html">&lt;style&gt;
    .basic {
      /*基本样式：*/
      width: 200px;
      height: 200px;
      border: 1px solid black;
    }
&lt;/style&gt;
&lt;div id=&quot;test&quot; class=&quot;basic&quot;&gt;test&lt;/div&gt;
</code></pre>
<p>圆角边框border-radius可以为边框设置圆角(IE8-不支持)。</p>
<p>按照左上、右上、右下、左下的顺序可以设置四个角：</p>
<pre><code class="language-html">#test {
border-radius: 23px 55px 31px 15px;
}
</code></pre>
<h2 id="值的省略"><a class="header-anchor" href="#值的省略"></a>值的省略</h2>
<p>1.如果省略左下值，左下角就和右上角样式相同：</p>
<pre><code>#test {
border-radius: 23px 55px 31px;
}
</code></pre>
<p>2.如果再省略右下值，右下角就和左上角样式相同：</p>
<pre><code>#test {
border-radius: 23px 55px;
}
</code></pre>
<p>3.如果再省略到剩下一个值，那就四个角样式一样。</p>
<h2 id="值的拆分"><a class="header-anchor" href="#值的拆分"></a>值的拆分</h2>
<pre><code>#test {
border-radius: 23px 55px 31px 15px;
}
</code></pre>
<p>等价于 <strong>圆角单角</strong> 的写法：</p>
<pre><code>#test {
border-top-left-radius: 23px;
border-top-right-radius: 55px;
border-bottom-right-radius: 31px;
border-bottom-left-radius: 15px;
}
</code></pre>
<hr>
<p>所谓的&quot;圆角&quot;其实是这样获得的：</p>
<p><img src="https://cloud.az22c.top/border-radius-sh.png-az22cgithub" alt="border-radius"></p>
<p>将一个圆内切于一个直角，再把圆外的部分去掉。我们设置的就是圆的半径。</p>
<p>又或者可以：</p>
<p>将一个椭圆内切于一个直角，再把椭圆外的部分去掉。我们设置的是椭圆的 水平半径 和 垂直半径。</p>
<p>因此，每个角都可以用 <code>/</code> 符号拆分成设置 水平半径 和 垂直半径 两项：</p>
<pre><code>#test {
border-radius: 11px 22px 33px 44px / 55px 66px 77px 88px;
}
</code></pre>
<p>等价于：</p>
<pre><code>#test {
border-top-left-radius: 11px 55px;
border-top-right-radius: 22px 66px;
border-bottom-right-radius: 33px 77px;
border-bottom-left-radius: 44px 88px;
}
</code></pre>
<h2 id="内径和外径"><a class="header-anchor" href="#内径和外径"></a>内径和外径</h2>
<p>border-radius内径 = 外径 - 对应的边框宽度。</p>
<p>外径为50px，内径为40px：</p>
<pre><code>#test2 {
  border: 10px solid black;
  border-radius: 50px;
}
</code></pre>
<p>当border-radius半径值小于等于边框宽度时，元素没有内径效果：</p>
<p>外径为50px，没有内径，里面的角都是直角：</p>
<pre><code>#test2 {
  border: 50px solid black;
  border-radius: 50px;
}
</code></pre>
<h2 id="特殊图形"><a class="header-anchor" href="#特殊图形"></a>特殊图形</h2>
<h3 id="圆形"><a class="header-anchor" href="#圆形"></a>圆形</h3>
<p>元素的宽高相同，且圆角半径为宽高的一半：</p>
<pre><code>div {
    width: 100px;
    height: 100px;
    border-radius: 50%;
}
</code></pre>
<h3 id="椭圆：思路和-正圆-一样-仅仅使得宽高不同"><a class="header-anchor" href="#椭圆：思路和-正圆-一样-仅仅使得宽高不同"></a>椭圆：思路和 正圆 一样，仅仅使得宽高不同</h3>
<pre><code>div {
    width: 120px;
    height: 80px;
    border-radius: 50%;
}
</code></pre>
<h3 id="半圆"><a class="header-anchor" href="#半圆"></a>半圆</h3>
<pre><code>div {
    width: 100px;
    height: 50px;
    border-radius: 50px 50px 0 0;
}
</code></pre>
<h3 id="直角-扇形"><a class="header-anchor" href="#直角-扇形"></a>（直角）扇形</h3>
<pre><code>div {
    width: 50px;
    height: 50px;
    border-radius: 50px 0 0 0;
}
</code></pre>
<h2 id="补充说明："><a class="header-anchor" href="#补充说明："></a>// 补充说明：</h2>
<pre><code>div {
    width: 120px;
    height: 80px;
    border-radius: 120px;
}
</code></pre>
<ul>
<li>border-radius可以用具体的px值，也可以用百分比表示，但不能是负数。
<ul>
<li>如果取值为百分比，水平方向圆角百分比相对于宽度，垂直方向圆角百分比相对于高度</li>
</ul>
</li>
<li>如果需要用border-radius重置使得没有圆角：使用none无效，需要取值0</li>
<li>border-radius对<code>&lt;img&gt;</code>没有任何效果</li>
</ul>
<h2 id="圆角相关话题"><a class="header-anchor" href="#圆角相关话题"></a>// 圆角相关话题</h2>
<h3 id="圆角进化论"><a class="header-anchor" href="#圆角进化论"></a>圆角进化论</h3>
<p><a href="https://github.com/AlexZhong22c/CSS-border-radius" target="_blank" rel="noopener">https://github.com/AlexZhong22c/CSS-border-radius</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> radius </tag>
            
            <tag> 边框 </tag>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象属性的操作]]></title>
      <url>https://alexzhong22c.github.io/2017/09/03/js-obj-prop1/</url>
      <content type="html"><![CDATA[<p>类似于“增删改查”的基本操作，属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<a id="more"></a>
<h2 id="属性查询"><a class="header-anchor" href="#属性查询"></a>属性查询</h2>
<p>属性查询一般有两种方法，包括点运算符和方括号运算符：</p>
<pre><code class="language-javascript">var o = {
  p: 'Hello World'
};
o.p // &quot;Hello World&quot;
o['p'] // &quot;Hello World&quot;
</code></pre>
<h3 id="点运算"><a class="header-anchor" href="#点运算"></a>点运算</h3>
<p>点运算符是很多面向对象语句的通用写法，由于其比较简单，所以较方括号运算符相比，更常用。</p>
<p>当通过点运算符访问对象的属性时，属性名用一个标识符来表示，标识符必须要符合变量命名规则。</p>
<p>标识符必须直接出现在javascript程序中，它们不是数据类型，因此程序无法修改它们。</p>
<pre><code class="language-javascript">var o = {
    a:1,
    1:2
};
console.log(o.a);//1
//由于变量不可以以数字开头，所以o.1报错
console.log(o.1);//Uncaught SyntaxError: missing ) after argument list
</code></pre>
<h3 id="方括号运算"><a class="header-anchor" href="#方括号运算"></a>方括号运算</h3>
<p>当通过方括号运算符来访问对象的属性时，<strong>属性名最终通过字符串来表示</strong>。字符串是javascript的数据类型，在程序运行中可以修改和创建它们。</p>
<p><strong>使用方括号运算符有两个优点。</strong></p>
<p>【一】可以通过变量来访问属性</p>
<pre><code>var a = 1;
var o = {
    1: 10
}
o[a];//10
</code></pre>
<p>【二】属性名称可以为  javascript无效标识符（即，不符合<strong>变量命名规则</strong>）</p>
<pre><code>var myObject = {
    123:'zero',
    class:'foo'
};
console.log(myObject['123'],myObject['class']);//'zero' 'foo'
console.log(myObject.123);//报错
</code></pre>
<h4 id="判断调用string-隐式转换"><a class="header-anchor" href="#判断调用string-隐式转换"></a>判断调用String()隐式转换</h4>
<p>【1】方括号中的值若是 字符串类型（外面有引号），就会正常按字符串访问对象的属性；</p>
<p>【2】方括号中的值若是 非字符串类型（外面没有引号），就会先判断是否符合<strong>变量命名规则</strong>，</p>
<p>【2-1】如果不符合，就会底层调用String()隐式转换成字符串再交由方括号运算；</p>
<p>【2-2】如果符合，就是变量了，被当作<strong>通过变量来访问属性</strong>的情况（这个时候，如果对应变量没有定义，当然就会报错）。</p>
<h5 id="看demo我们就很容易理解："><a class="header-anchor" href="#看demo我们就很容易理解："></a>看demo我们就很容易理解：</h5>
<pre><code class="language-javascript">var myObject = {
    123:'this is 123',
    clasz:'this is clasz'
};
console.log(myObject[&quot;123&quot;]) // 正常访问'this is 123'
console.log(myObject[&quot;clasz&quot;]) // 正常访问'this is clasz'
console.log(myObject[123]) // 123隐式转换成字符串&quot;123&quot;，访问得到'this is 123'
console.log(myObject[clasz]) // clasz符合变量命名规则，被当作变量：Error: clasz is not defined
</code></pre>
<h5 id="再细看-2-2-："><a class="header-anchor" href="#再细看-2-2-："></a>再细看【2-2】：</h5>
<pre><code class="language-javascript">var myObject = {
    123:'this is 123',
    clasz:'this is clasz',
    extra: 'this is 补充'
};
console.log(myObject[clasz]) // clasz符合变量命名规则，被当作变量：Error: clasz is not defined
</code></pre>
<p>对比：</p>
<pre><code class="language-javascript">var myObject = {
    123:'this is 123',
    clasz:'this is clasz',
    extra: 'this is 补充'
};
var clasz = &quot;extra&quot;
console.log(myObject[&quot;clasz&quot;]) // 访问得到'this is 补充'
</code></pre>
<p>现在我们就能理解为什么【2】要这么设置了。</p>
<h4 id="可计算属性名"><a class="header-anchor" href="#可计算属性名"></a>可计算属性名</h4>
<p>在方括号运算符内部可以使用表达式：</p>
<pre><code>var a = 1;
var person = {
    3: 'abc'
};
person[a + 2];//'abc'
</code></pre>
<p>但如果要在对象字面量内部对属性名使用表达式，则需要使用ES6的可计算属性名：</p>
<pre><code>var a = 1;
//Uncaught SyntaxError: Unexpected token +
var person = {
    a + 3: 'abc'
};
</code></pre>
<p>ES6增加了可计算属性名，可以在文字中使用[]包裹一个表达式来当作属性名：</p>
<pre><code>var a = 1;
var person = {
    [a + 3]: 'abc'
};
person[4];//'abc'
</code></pre>
<h3 id="属性查询错误"><a class="header-anchor" href="#属性查询错误"></a>属性查询错误</h3>
<p>【1】查询一个不存在的属性不会报错，而是返回undefined：</p>
<pre><code>var person = {};
console.log(person.a);//undefined
</code></pre>
<p>【2】如果对象不存在，试图查询这个不存在的对象的属性会报错：</p>
<pre><code>console.log(person.a);//Uncaught ReferenceError: person is not defined
</code></pre>
<p>可以利用这一点，来检查一个全局变量是否被声明：</p>
<pre><code>// 检查a变量是否被声明
if (a) {...} // 报错

//-----------------------------------------//

//所有全局变量都是window对象的属性。window.a的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错
if (window.a) {...} // 不报错
</code></pre>
<h2 id="属性设置"><a class="header-anchor" href="#属性设置"></a>属性设置</h2>
<p>属性设置又称为属性赋值，与属性查询相同，具有点运算符和方括号运算符这两种方法。</p>
<p>在给对象设置属性之前，一般要先检测对象是否存在：</p>
<pre><code>var len = undefined;
if(book){
    if(book.subtitle){
        len = book.subtitle.length;
    }
}
</code></pre>
<p>上面代码可以简化为：</p>
<pre><code>var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;
</code></pre>
<h3 id="属性设置错误"><a class="header-anchor" href="#属性设置错误"></a>属性设置错误</h3>
<p>null和undefined不是对象，给它们设置属性会报错：</p>
<pre><code>null.a = 1;//Uncaught TypeError: Cannot set property 'a' of null
undefined.a = 1;//Uncaught TypeError: Cannot set property 'a' of undefined
</code></pre>
<p>由于string、number和boolean有对应的 包装对象 ，所以给它们设置属性不会报错：</p>
<pre><code>'abc'.a = 1;//1
(1).a = 1;//1
true.a = 1;//1
</code></pre>
<h2 id="属性删除"><a class="header-anchor" href="#属性删除"></a>属性删除</h2>
<p>使用delete运算符可以删除对象属性(包括数组元素)：</p>
<pre><code>var o = {
    a : 1
};
console.log(o.a);//1
console.log('a' in o);//true
console.log(delete o.a);//true
console.log(o.a);//undefined
console.log('a' in o);//false
</code></pre>
<p><strong>而如果给对象属性置null或undefined，其实并没有删除该属性：</strong></p>
<pre><code>var o = {
    a : 1
};
o.a = undefined;
console.log(o.a);//undefined
console.log('a' in o);//true
console.log(delete o.a);//true
console.log(o.a);//undefined
console.log('a' in o);//false
</code></pre>
<p>使用delete删除<strong>数组元素</strong>时，不会改变数组长度：</p>
<pre><code>var a = [1,2,3];
delete a[2];
2 in a;//false
a.length;//3
</code></pre>
<p>delete运算符只能删除自有属性，不能删除继承属性(要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象)</p>
<pre><code>var o  = {
    a:1
}
var obj = Object.create(o);
obj.a = 2;

console.log(obj.a);//2
console.log(delete obj.a);//true
console.log(obj.a);//1
console.log(delete obj.a);//true
console.log(obj.a);//1
</code></pre>
<h3 id="返回值"><a class="header-anchor" href="#返回值"></a>返回值</h3>
<p>delete操作符的返回值是个布尔值true或false</p>
<p>【1】当使用delete操作符删除对象属性或数组元素删除成功时，返回true</p>
<pre><code>var o = {a:1};
var arr = [1];
console.log(delete o.a);//true
console.log(delete arr[0]);//true
</code></pre>
<p>【2】当使用delete操作符删除 不存在的属性 或 非左值 时，返回true</p>
<pre><code>var o = {};
console.log(delete o.a);//true
console.log(delete 1);//true
console.log(delete {});//true
</code></pre>
<p>【3】当使用delete操作符删除<strong>变量</strong>时，返回false，严格模式下会抛出ReferenceError错误</p>
<pre><code>var a = 1;
console.log(delete a);//false
console.log(a);//1

'use strict';
var a = 1;
//Uncaught SyntaxError: Delete of an unqualified identifier in strict mode
console.log(delete a);
</code></pre>
<p>【4】当使用delete操作符删除不可配置的属性时，返回false，严格模式下会抛出TypeError错误</p>
<pre><code>var obj = {};
Object.defineProperty(obj,'a',{configurable:false});
console.log(delete obj.a);//false

'use strict';
var obj = {};
Object.defineProperty(obj,'a',{configurable:false});
//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;
console.log(delete obj.a);
</code></pre>
<h2 id="属性继承"><a class="header-anchor" href="#属性继承"></a>属性继承</h2>
<p>每一个javascript对象都和另一个对象相关联。“另一个对象”就是我们熟知的原型，每一个对象都从原型继承属性。</p>
<p>对象本身具有的属性叫自有属性(own property)，从原型对象继承而来的属性叫继承属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
//继承自原型对象o的属性a
console.log(obj.a);//1
//自有属性b
console.log(obj.b);//2
</code></pre>
<h3 id="hasownproperty"><a class="header-anchor" href="#hasownproperty"></a>hasOwnProperty()</h3>
<p>通过hasOwnProperty()方法可以确定该属性是自有属性还是继承属性</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log(obj.hasOwnProperty('a'));//false
console.log(obj.hasOwnProperty('b'));//true
</code></pre>
<h3 id="in"><a class="header-anchor" href="#in"></a>in</h3>
<p>in操作符可以判断属性在不在该对象上，但无法区别自有还是继承属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log('a' in obj);//true
console.log('b' in obj);//true
console.log('b' in o);//false
</code></pre>
<h3 id="for-in"><a class="header-anchor" href="#for-in"></a>for-in</h3>
<p>通过for-in循环可以遍历出该对象中所有可枚举属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
for(var i in obj){
    console.log(obj[i]);//2 1
}
</code></pre>
<h3 id="object-keys"><a class="header-anchor" href="#object-keys"></a>Object.keys()</h3>
<p>Object.keys()方法返回所有可枚举的自有属性：</p>
<pre><code>var o = {a:1};
var obj = Object.create(o,{
    c:{value:3,configurable: false}
});
obj.b = 2;
console.log(Object.keys(obj));//['b']
</code></pre>
<h3 id="object-getownpropertynames"><a class="header-anchor" href="#object-getownpropertynames"></a>Object.getOwnPropertyNames()</h3>
<p>与Object.keys()方法不同，Object.getOwnPropertyNames()方法返回所有自有属性(包括不可枚举的属性)</p>
<pre><code>var o = {a:1};
var obj = Object.create(o,{
    c:{value:3,configurable: false}
});
obj.b = 2;
console.log(Object.getOwnPropertyNames(obj));//['c','b']
</code></pre>
<hr>
<h2 id="相关话题："><a class="header-anchor" href="#相关话题："></a>// 相关话题：</h2>
<p>【1】对象属性的操作： “内容即本文。”</p>
<p>属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<p>【2】对象属性描述符： <a href="https://alexzhong22c.github.io/2017/09/02/js-obj-prop2/">链接</a></p>
<p>属性描述符用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<p>【3】对象状态： <a href="https://alexzhong22c.github.io/2017/09/01/js-obj-prop3/">链接</a></p>
<p>属性描述符只能用来控制对象中一个属性的状态，而如果要控制整个对象的状态，就要用到6种对象状态。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 对象属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象属性描述符]]></title>
      <url>https://alexzhong22c.github.io/2017/09/02/js-obj-prop2/</url>
      <content type="html"><![CDATA[<p>对于操作系统中的文件，我们可以驾轻就熟将其设置为只读、隐藏、系统文件或普通文件。</p>
<p>于对象来说，属性描述符提供类似的功能，用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<a id="more"></a>
<p><strong>描述符类型：</strong></p>
<p>对象属性描述符的类型分为两类：<strong>数据属性</strong>和<strong>访问器属性</strong> 。</p>
<h2 id="数据属性"><a class="header-anchor" href="#数据属性"></a>数据属性</h2>
<p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值。</p>
<p>数据属性有4个特性：</p>
<p>【1】Configurable(可配置性)</p>
<p>【2】Enumerable(可枚举性)</p>
<p>【3】Writable(可写性)</p>
<p>【4】Value(属性值)</p>
<p>属性值 包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined</p>
<h2 id="访问器属性"><a class="header-anchor" href="#访问器属性"></a>访问器属性</h2>
<p>对象属性是名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter。而这种属性类型叫访问器属性：</p>
<p>【1】Configurable(可配置性)</p>
<p>【2】Enumerable(可枚举性)</p>
<p>【3】getter</p>
<p>【4】setter</p>
<p><strong>和数据属性不同，访问器属性不具有可写性(Writable)。</strong></p>
<p><strong>如果属性同时具有getter和setter方法，那么它是一个读/写属性；如果它只有getter方法，那么它是一个只读属性；如果它只有setter方法，那么它是一个只写属性。读取只写属性总是返回undefined</strong></p>
<hr>
<h2 id="描述符方法"><a class="header-anchor" href="#描述符方法"></a>描述符方法</h2>
<p>前面介绍了属性描述符，要想设置它们，就需要用到描述符方法。描述符方法总共有以下4个：</p>
<blockquote>
<p>【1】Object.getOwnPropertyDescriptor()</p>
<p>【2】Object.defineProperty()</p>
<p>【3】Object.defineProperties()</p>
<p>【4】Object.create()</p>
</blockquote>
<h3 id="object-getownpropertydescriptor"><a class="header-anchor" href="#object-getownpropertydescriptor"></a>Object.getOwnPropertyDescriptor()</h3>
<p>Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回：</p>
<pre><code>var obj = {a:1};
//Object {value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
//undefined
console.log(Object.getOwnPropertyDescriptor(obj,'b'));
</code></pre>
<p>查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1</p>
<p>查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined</p>
<h3 id="object-defineproperty"><a class="header-anchor" href="#object-defineproperty"></a>Object.defineProperty()</h3>
<p>Object.defineProperty(o,name,desc)方法用于创建或配置对象的一个属性的描述符，返回配置后的对象。</p>
<p><strong>使用该方法创建或配置对象属性的描述符时，如果不针对该属性进行描述符的配置，则该项描述符默认为false：</strong></p>
<pre><code>var obj = {};
//{a:1}
console.log(Object.defineProperty(obj,'a',{
        value:1,
        writable: true
    }));

//由于没有配置enumerable和configurable，所以它们的值为false
//{value: 1, writable: true, enumerable: false, configurable: false}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
</code></pre>
<h3 id="object-defineproperties"><a class="header-anchor" href="#object-defineproperties"></a>Object.defineProperties()</h3>
<p>Object.defineProperty(o,descriptors)方法用于创建或配置对象的多个属性的描述符，返回配置后的对象：</p>
<pre><code>var obj = {
    a:1
};
//{a: 1, b: 2}
console.log(Object.defineProperties(obj,{
        a:{writable:false},
        b:{value:2}
    }));

//{value: 1, writable: false, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
//{value: 2, writable: false, enumerable: false, configurable: false}
console.log(Object.getOwnPropertyDescriptor(obj,'b'));
</code></pre>
<h3 id="object-create"><a class="header-anchor" href="#object-create"></a>Object.create()</h3>
<p>Object.create(proto,descriptors)方法使用指定的原型和属性<strong>来创建一个对象</strong>：</p>
<pre><code>var o = Object.create(Object.prototype,{
    a:{writable: false,value:1,enumerable:true}
});
//{value: 1, writable: false, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(obj,'a'));
</code></pre>
<h2 id="描述符-详细说明"><a class="header-anchor" href="#描述符-详细说明"></a>描述符–详细说明</h2>
<p>前面分别介绍了数据属性和访问器属性的描述符，但没有详细说明其含义及使用，接下来逐一进行说明：</p>
<h3 id="可写性-writable"><a class="header-anchor" href="#可写性-writable"></a>可写性(writable)</h3>
<p>可写性决定是否可以修改属性的值，默认值为true；设置writable:false后，赋值语句会静默失效：</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    writable:false
});
console.log(o.a);//1
//由于设置了writable为false，所以o.a=2这个语句会静默失效
o.a = 2;
console.log(o.a);//1
Object.defineProperty(o,'a',{
    writable:true
});
//由于writable设置为true，所以o.a可以被修改为2
o.a = 2;
console.log(o.a);//2
</code></pre>
<p><strong>设置writable:false后，能通过Object.defineProperty()方法改变属性value的值，这过程不会影响到writable的值，因为这也意味着再重置writable的属性值为false：</strong></p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    writable:false
});
console.log(o.a);//1
Object.defineProperty(o,'a',{
    value:2
});
console.log(o.a);//2,writable依然是false
</code></pre>
<blockquote>
<p>在<strong>严格模式</strong>下通过赋值语句为writable为false的属性赋值，会提示类型错误TypeError：</p>
<pre><code class="language-javascript">'use strict';
var o = {a:1};
Object.defineProperty(o,'a',{
    writable:false
});
//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'
o.a = 2;
</code></pre>
</blockquote>
<h3 id="可配置性-configurable"><a class="header-anchor" href="#可配置性-configurable"></a>可配置性(Configurable)</h3>
<p>可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true</p>
<p>【1】设置Configurable:false后，无法使用delete删除属性</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false
});
delete o.a;//false
console.log(o.a);//1
</code></pre>
<p><strong>使用var命令声明变量时，变量的configurable为false：</strong></p>
<pre><code>var a = 1;
//{value: 1, writable: true, enumerable: true, configurable: false}
Object.getOwnPropertyDescriptor(this,'a');
</code></pre>
<blockquote>
<p>在严格模式下删除为configurable为false的属性，会提示类型错误TypeError</p>
<pre><code class="language-javascript">'use strict';
var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false
});
//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;
delete o.a;
</code></pre>
</blockquote>
<p>【2】一般地，设置Configurable:false后，将无法再使用defineProperty()方法来修改属性描述符</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false
});
//Uncaught TypeError: Cannot redefine property: a
Object.defineProperty(o,'a',{
    configurable:true
});
</code></pre>
<p>有一个例外，设置Configurable:false后，只允许writable的状态从true变为false</p>
<pre><code>var o = {a:1};
Object.defineProperty(o,'a',{
    configurable:false,
    writable:true
});
o.a = 2;
console.log(o.a);//2
Object.defineProperty(o,'a',{
    writable:false
});
//由于writable:false生效，对象a的o属性无法修改值，所以o.a=3的赋值语句静默失败
o.a = 3;
console.log(o.a);//2
</code></pre>
<h3 id="可枚举性-enumerable"><a class="header-anchor" href="#可枚举性-enumerable"></a>可枚举性(Enumerable)</h3>
<p>可枚举性决定属性是否出现在对象的属性枚举中，具体来说就是，for-in循环、Object.keys方法、JSON.stringify方法是否会取到该属性。</p>
<p>用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的</p>
<pre><code>//由于enumerable被设置为false，在for-in循环中a属性无法被枚举出来
var o = {a:1};
Object.defineProperty(o,'a',{enumerable:false});
for(var i in o){
    console.log(o[i]);//undefined
}
</code></pre>
<h4 id="propertyisenumerable"><a class="header-anchor" href="#propertyisenumerable"></a>propertyIsEnumerable()</h4>
<p>propertyIsEnumerable()方法用于判断对象的属性是否可枚举</p>
<pre><code>var o = {a:1};
console.log(o.propertyIsEnumerable('a'));//true
Object.defineProperty(o,'a',{enumerable:false});
console.log(o.propertyIsEnumerable('a'));//false
</code></pre>
<h3 id="get和set"><a class="header-anchor" href="#get和set"></a>get和set</h3>
<p>get是一个隐藏函数，在获取属性值时调用。set也是一个隐藏函数，在设置属性值时调用，它们的默认值都是undefined。</p>
<p><strong>Object.definedProperty()中的get和set对应于对象字面量中get和set方法。</strong></p>
<p><strong>getter和setter取代了数据属性中的value和writable属性。</strong></p>
<p>【1】一般地，set和get方法是成对出现的：</p>
<pre><code>var o ={
    get a(){
        return this._a;
    },
    set a(val){
        this._a = val*2;
    }
}
o.a = 1;
console.log(o.a);//2
</code></pre>
<p>Object.definedProperty()中的get和set对应于对象字面量中get和set方法：</p>
<pre><code>Object.defineProperty(o,'a',{
    get: function(){
        return this._a;
    },
    set :function(val){
        this._a = val*2;
    }
})
o.a = 1;
console.log(o.a);//2
</code></pre>
<hr>
<p>【2】给只设置get方法，没有设置set方法的对象赋值会静默失败（在严格模式下会报错），所以为了规范起见最好同时设置getter和setter：</p>
<pre><code>var o = {
    get a(){
        return 2;
    }
}    
console.log(o.a);//2
//由于没有设置set方法，所以o.a=3的赋值语句会静默失败
o.a = 3;
console.log(o.a);//2
</code></pre>
<p>同样地：</p>
<pre><code>Object.defineProperty(o,'a',{
    get: function(){
        return 2;
    }
})
console.log(o.a);//2
//由于没有设置set方法，所以o.a=3的赋值语句会静默失败
o.a = 3;
console.log(o.a);//2
</code></pre>
<blockquote>
<p>在严格模式下，给没有设置set方法的访问器属性赋值会报错：</p>
<pre><code class="language-javascript">'use strict';
var o = {
    get a(){
        return 2;
    }
}    
console.log(o.a);//2
//由于没有设置set方法，所以o.a=3的赋值语句会报错
//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a getter
o.a = 3;
</code></pre>
<p>并且在Object.definedProperty()中也是同理。</p>
</blockquote>
<hr>
<p>【3】只设置set方法，而不设置get方法，则对象属性值为undefined：</p>
<pre><code>var o = {
    set a(val){
        return 2;
    }
}    
o.a = 1;
console.log(o.a);//undefined
</code></pre>
<p>同样地：</p>
<pre><code>Object.defineProperty(o,'a',{
    set: function(){
        return 2;
    }
})
o.a = 1;
console.log(o.a);//undefined
</code></pre>
<hr>
<h2 id="相关话题："><a class="header-anchor" href="#相关话题："></a>// 相关话题：</h2>
<p>【1】对象属性的操作： <a href="https://alexzhong22c.github.io/2017/09/03/js-obj-prop1/">链接</a></p>
<p>属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<p>【2】对象属性描述符： “内容即本文。”</p>
<p>属性描述符用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<p>【3】对象状态： <a href="https://alexzhong22c.github.io/2017/09/01/js-obj-prop3/">链接</a></p>
<p>属性描述符只能用来控制对象中一个属性的状态，而如果要控制整个对象的状态，就要用到6种对象状态。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 对象属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象属性之对象状态]]></title>
      <url>https://alexzhong22c.github.io/2017/09/01/js-obj-prop3/</url>
      <content type="html"><![CDATA[<p>我们知道，属性描述符只能用来控制对象中一个属性的状态。而如果要控制对象的状态，就要用到下面的6种方法：</p>
<a id="more"></a>
<blockquote>
<p>【1】Object.preventExtensions()(禁止扩展)；【2】Object.isExtensible()(测试扩展)。</p>
<p>【3】Object.seal()(对象封印)；【4】Object.isSealed()(测试封印)。</p>
<p>【5】Object.freeze()(对象冻结)；【6】Object.isFrozen()(检测冻结)。</p>
</blockquote>
<h2 id="object-preventextensions-禁止扩展"><a class="header-anchor" href="#object-preventextensions-禁止扩展"></a>Object.preventExtensions()(禁止扩展)</h2>
<p>Object.preventExtensions()方法使一个对象<strong>无法再添加新的属性</strong> ，并返回当前对象</p>
<h2 id="object-isextensible-测试扩展"><a class="header-anchor" href="#object-isextensible-测试扩展"></a>Object.isExtensible()(测试扩展)</h2>
<p>Object.isExtensible()方法用来检测该对象是否可以扩展</p>
<pre><code>var o = {a:1};
console.log(Object.isExtensible(o));//true
o.b = 2;
console.log(o);//{a: 1, b: 2}
console.log(Object.preventExtensions(o));//{a: 1, b: 2}
//由于对象o禁止扩展，所以该赋值语句静默失败
o.c = 3;
console.log(Object.isExtensible(o));//false
console.log(o);//{a: 1, b: 2}
</code></pre>
<blockquote>
<p>在严格模式下，给禁止扩展的对象添加属性会报TypeError错误：</p>
<pre><code class="language-javascript">'use strict';
var o = {a:1};
console.log(Object.preventExtensions(o));//{a:1}
//Uncaught TypeError: Can't add property c, object is not extensible
o.c = 3;
</code></pre>
</blockquote>
<p>Object.preventExtensions()方法并不改变对象中属性的描述符状态：</p>
<pre><code>var o = {a:1};
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
Object.preventExtensions(o);
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
</code></pre>
<hr>
<h2 id="object-seal-对象封印"><a class="header-anchor" href="#object-seal-对象封印"></a>Object.seal()(对象封印)</h2>
<p>对象封印又叫对象密封，使一个对象<strong>不可扩展并且所有属性不可配置</strong> ，并返回当前对象</p>
<h2 id="object-issealed-测试封印"><a class="header-anchor" href="#object-issealed-测试封印"></a>Object.isSealed()(测试封印)</h2>
<p>Object.isSealed()方法用来检测该方法是否被封印</p>
<pre><code>var o = {a:1,b:2};
console.log(Object.isSealed(o));//false
console.log(Object.seal(o));//{a:1,b:2}
console.log(Object.isSealed(o));//true
console.log(delete o.b);//false
o.c = 3;
console.log(o);//{a:1,b:2}
</code></pre>
<blockquote>
<p>在严格模式下，删除旧属性或添加新属性都会报错</p>
<pre><code>'use strict';
var o = {a:1,b:2};
console.log(Object.seal(o));//{a:1,b:2}
//Uncaught TypeError: Cannot delete property 'b' of #&lt;Object&gt;
delete o.b;
</code></pre>
</blockquote>
<p>这个方法实际上会在现有对象上调用Object.preventExtensions()方法，并把所有现有属性的configurable描述符置为false</p>
<pre><code>var o = {a:1,b:2};
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
console.log(Object.seal(o));//{a:1,b:2}
//{value: 1, writable: true, enumerable: true, configurable: false}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
</code></pre>
<hr>
<h2 id="object-freeze-对象冻结"><a class="header-anchor" href="#object-freeze-对象冻结"></a>Object.freeze()(对象冻结)</h2>
<p>Object.freeze()方法使一个对象<strong>不可扩展，不可配置，也不可改写，变成一个仅可以枚举的只读常量</strong> ，并返回当前对象</p>
<h2 id="object-isfrozen-检测冻结"><a class="header-anchor" href="#object-isfrozen-检测冻结"></a>Object.isFrozen()(检测冻结)</h2>
<p>Object.isFrozen()方法用来检测一个对象是否被冻结</p>
<pre><code>var o = {a:1,b:2};
console.log(Object.isFrozen(o));//false
console.log(Object.freeze(o));//{a:1,b:2}
console.log(Object.isFrozen(o));//true
o.a = 3;
console.log(o);//{a:1,b:2}
</code></pre>
<blockquote>
<p>在严格模式下，删除旧属性、添加新属性、更改现有属性都会报错</p>
<pre><code>'use strict';
var o = {a:1,b:2};
console.log(Object.freeze(o));//{a:1,b:2}
//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'
o.a = 3;
</code></pre>
</blockquote>
<p>这个方法实际上会在现有对象上调用Object.seal()方法，并把所有现有属性的writable描述符置为false</p>
<pre><code>var o = {a:1};
//{value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
console.log(Object.freeze(o));//{a:1}
//{value: 1, writable: false, enumerable: true, configurable: false}
console.log(Object.getOwnPropertyDescriptor(o,'a'));
</code></pre>
<hr>
<h2 id="相关话题："><a class="header-anchor" href="#相关话题："></a>// 相关话题：</h2>
<p>【1】对象属性的操作： <a href="https://alexzhong22c.github.io/2017/09/03/js-obj-prop1/">链接</a></p>
<p>属性操作可分为属性查询、属性设置、属性删除，还包括属性继承。</p>
<p>【2】对象属性描述符： <a href="https://alexzhong22c.github.io/2017/09/02/js-obj-prop2/">链接</a></p>
<p>属性描述符用来描述对象的值、是否可配置、是否可修改以及是否可枚举。</p>
<p>【3】对象状态： “内容即本文。”</p>
<p>属性描述符只能用来控制对象中一个属性的状态，而如果要控制整个对象的状态，就要用到6种对象状态。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 对象属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实现继承的3种方式]]></title>
      <url>https://alexzhong22c.github.io/2017/08/12/js-inherit/</url>
      <content type="html"><![CDATA[<p>对关于继承的内容做一番整理。</p>
<a id="more"></a>
<h2 id="原型链"><a class="header-anchor" href="#原型链"></a>原型链</h2>
<p>javascript使用原型链作为实现继承的主要方法，实现的本质是重写原型对象，代之以一个新类型的实例：</p>
<pre><code class="language-javascript">function Super(){ // 注释【1】
    this.value = true;
}
Super.prototype.getValue = function(){
    return this.value;
};
function Sub(){}
//Sub继承了Super：
Sub.prototype = new Super();
Sub.prototype.constructor = Sub;

var instance = new Sub();
console.log(instance.getValue());//true
</code></pre>
<p>【1】原型链最主要的问题在于包含引用类型值的原型属性会被所有实例共享，而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。</p>
<p>在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了：</p>
<pre><code class="language-javascript">function Super(){
    this.colors = ['red','blue','green'];
}
function Sub(){};
//Sub继承了Super
Sub.prototype = new Super();
var instance1 = new Sub();
instance1.colors.push('black');
console.log(instance1.colors);//'red,blue,green,black'
var instance2 = new Sub();
console.log(instance2.colors);//'red,blue,green,black'
</code></pre>
<h3 id="原型式继承"><a class="header-anchor" href="#原型式继承"></a>原型式继承</h3>
<p>原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型Sub。</p>
<p><del>从本质上讲，相当于object()对传入其中的对象执行了一次浅复制</del> 父子对象2者从表现上看好像是浅拷贝，但是属性位于哪个对象上，这点明显和浅拷贝不同：</p>
<pre><code class="language-javascript">function object(o){
    function F(){};
    F.prototype = o;
    return new F();
}

var superObj = { // 基于已有的对象创建新对象
    colors: ['red','blue','green']
};
var subObj1 = object(superObj);
subObj1.colors.push(&quot;black&quot;);

var subObj2 = object(superObj);
subObj2.colors.push(&quot;white&quot;);

console.log(superObj.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
console.log(subObj1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
</code></pre>
<p>实际上，Object.create()方法规范化了原型式继承：(Object.create的实现即刚才自定义的object方法)</p>
<pre><code class="language-javascript">var superObj = {
    colors: ['red','blue','green']
};
var subObj1 = Object.create(superObj);
subObj1.colors.push(&quot;black&quot;);

var subObj2 = object(superObj);
subObj2.colors.push(&quot;white&quot;);

console.log(superObj.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
console.log(subObj1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
</code></pre>
<p>[注意]原型式继承只是将原型链继承的一些程序性步骤包裹在函数里而已。原型链继承 所存在的问题它都有。</p>
<h2 id="寄生式继承"><a class="header-anchor" href="#寄生式继承"></a>寄生式继承</h2>
<p>寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象：</p>
<pre><code class="language-javascript">function parasite(original){
    var clone = Object.create(original);//通过调用函数创建一个新对象
    clone.sayHi = function(){ //以某种方式来增强这个对象
        console.log(&quot;hi&quot;);
    };
    return clone;//返回这个对象
}
var superObj = {
    colors: ['red','blue','green']
};
var subObj1 = parasite(superObj);
subObj1.colors.push('black');
var subObj2 = parasite(superObj);
subObj2.colors.push('white');

console.log(superObj.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
console.log(subObj1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;, &quot;white&quot;]
</code></pre>
<p>[注意]寄生式继承实际上只是原型式继承的再包装，与原型式继承有着同样的问题，且由于不能做到函数复用而降低了效率</p>
<h2 id="借用构造函数"><a class="header-anchor" href="#借用构造函数"></a>借用构造函数</h2>
<p>借用构造函数(constructor stealing)的技术(有时候也叫做伪类继承或经典继承)。基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法在新创建的对象上执行构造函数：</p>
<pre><code class="language-javascript">function Super(){
    this.colors = ['red','blue','green'];
}
function Sub(){
    //继承了Super
    Super.call(this);
}
var instance1 = new Sub();
instance1.colors.push('black');
console.log(instance1.colors);// ['red','blue','green','black']
var instance2 = new Sub();
console.log(instance2.colors);// ['red','blue','green']
</code></pre>
<p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数：</p>
<pre><code class="language-javascript">function Super(name){
    this.name = name;
}
function Sub(){
    //继承了Super，同时还传递了参数
    Super.call(this,&quot;bai&quot;);
    //实例属性
    this.age = 29;
}
var instance = new Sub();
console.log(instance.name);//&quot;bai&quot;
console.log(instance.age);//29 
</code></pre>
<p>但是，如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。</p>
<h2 id="组合继承"><a class="header-anchor" href="#组合继承"></a>组合继承</h2>
<p>组合继承(combination inheritance)有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</p>
<p>其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性：</p>
<pre><code class="language-javascript">function Super(name){
    this.name = name;
    this.colors = ['red','blue','green'];
}
Super.prototype.sayName = function(){
    console.log(this.name);
};
function Sub(name,age){
    //继承属性
    Super.call(this,name);// 子类型构造函数内部，调用了一次父类型的构造函数
    this.age = age;
}
//继承方法
Sub.prototype = new Super(); // 创建子类型原型，调用了一次父类型的构造函数
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
    console.log(this.age);
}
var instance1 = new Sub(&quot;bai&quot;,29);
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//&quot;bai&quot;
instance1.sayAge();//29

var instance2 = new Sub(&quot;hu&quot;,27);
console.log(instance2.colors);//['red','blue','green']
instance2.sayName();//&quot;hu&quot;
instance2.sayAge();//27
</code></pre>
<p>组合继承有它自己的问题。那就是无论什么情况下，都会调用两次父类型构造函数：<strong>一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</strong></p>
<p>子类型最终会包含父类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性：</p>
<pre><code class="language-javascript">function Super(name){
    this.name = name;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
Super.prototype.sayName = function(){
    return this.name;
};
function Sub(name,age){
     // 第二次调用Super()，Sub.prototype又得到了name和colors两个属性，并对上次得到的属性值进行了覆盖
    Super.call(this,name);
    this.age = age;
}
//第一次调用Super()，Sub.prototype得到了name和colors两个属性
Sub.prototype = new Super(); 
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
    return this.age;
};  
var instance1 = new Sub(&quot;bai&quot;,29);// 第二次调用Super()
</code></pre>
<h2 id="寄生组合式继承"><a class="header-anchor" href="#寄生组合式继承"></a>寄生组合式继承</h2>
<p>寄生组合式继承与组合继承相似，都是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。只不过把原型继承的形式变成了寄生式继承。</p>
<p>使用寄生组合式继承可以<strong>不必为了指定子类型的原型而调用父类型的构造函数，从而寄生式继承只继承了父类型的原型属性，而父类型的实例属性是通过借用构造函数的方式来得到的：</strong></p>
<pre><code class="language-javascript">function parasite(original){
    var clone = Object.create(original);//通过调用函数创建一个新对象
    return clone;//返回这个对象
}

function Super(name){
    this.name = name;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
Super.prototype.sayName = function(){
    return this.name;
};
function Sub(name,age){
    Super.call(this,name);
    this.age = age;
}
Sub.prototype = parasite(Super.prototype);
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
    return this.age;
}
var instance1 = new Sub(&quot;bai&quot;,29);
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//&quot;bai&quot;
instance1.sayAge();//29

var instance2 = new Sub(&quot;hu&quot;,27);
console.log(instance2.colors);//['red','blue','green']
instance2.sayName();//&quot;hu&quot;
instance2.sayAge();//27
</code></pre>
<p>精简一点，则如下所示：</p>
<pre><code class="language-javascript">function Super(name){
  	// 父类型的实例属性：
    this.name = name; 
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
Super.prototype.sayName = function(){// 父类型的原型属性
    return this.name;
};


function Sub(name,age){
    Super.call(this,name); // 得到父类型的实例属性
    this.age = age;
}
if(!Object.create){
　　Object.create = function(proto){
　　　　function F(){};
　　　　F.prototype = proto;
　　　　return new F;
　　}
}
Sub.prototype = Object.create(Super.prototype);// 只继承了父类型的原型属性
Sub.prototype.constructor = Sub;

var instance1 = new Sub(&quot;bai&quot;,29);// 得到父类型的实例属性
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//&quot;bai&quot;

var instance2 = new Sub(&quot;hu&quot;,27);
console.log(instance2.colors);//['red','blue','green']
instance2.sayName();//&quot;hu&quot;
</code></pre>
<h2 id="最后"><a class="header-anchor" href="#最后"></a>最后</h2>
<p>每种模式都有自己的优点，而多个模式结合在一起就可能造成一些属性的重置，这是最需要注意的地方。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[new创建对象的过程发生了什么]]></title>
      <url>https://alexzhong22c.github.io/2017/08/12/js-new-happen/</url>
      <content type="html"><![CDATA[<p>用面向对象语言们通用的观点来看：new 是用来实例化一个类，从而在内存中分配一个实例对象。</p>
<a id="more"></a>
<p>我们通过一个例子来讨论<strong>new的过程中发生了什么</strong> ：</p>
<pre><code class="language-javascript">function Person(name) {
    this.name = name;
}
Person.hairColor = &quot;black&quot;;
Person.prototype.say = function() {
    console.log(&quot;My name is &quot; + this.name);
};
var john = new Person(&quot;John&quot;);

console.log(
	john.name, // &quot;John&quot;,
  	john.hairColor, // undefined
  	john.height // undefined
);
john.say(); // &quot;My name is John&quot;

console.log(
	Person.name, // &quot;Person&quot;
  	Person.hairColor // &quot;black&quot;
);
Person.say(); // Person.say is not a function
</code></pre>
<h2 id="重点解析"><a class="header-anchor" href="#重点解析"></a>重点解析</h2>
<p>第8行代码是关键：</p>
<pre><code class="language-javascript">var john = new Person(&quot;John&quot;);
</code></pre>
<p>Person本身是一个普通函数，但当通过new来创建对象时，Person就是构造函数了。</p>
<p>JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：</p>
<pre><code class="language-javascript">new Person(&quot;John&quot;) = {
  var obj = {};
	obj.__proto__ = Person.prototype;
	// 此时便建立了obj对象的原型链：
	// obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null

	var result = Person.call(obj,&quot;John&quot;); // 相当于obj.Person(&quot;John&quot;)

	// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：
	return typeof result === 'object' ? result || obj : obj;
}
</code></pre>
<p>可以看到，这里的obj经返回后会被赋给john变量：</p>
<p>obj.name是在<code>Person.call(obj,&quot;John&quot;)</code>这句话执行之后就有了“John”这个值；</p>
<p>等到obj经返回被赋给john之后，john.name就是“John”了。</p>
<p>画出最终<code>var john = new Person(&quot;John&quot;);</code>这一句代码涉及到的对象和它们间的关系：</p>
<p><img src="https://cloud.az22c.top/js-new-process-1.png-az22cgithub" alt="js-new-process-1"></p>
<blockquote>
<p>如果看不懂图，可以先看我以往文章的介绍： <a href="https://alexzhong22c.github.io/2017/08/08/js-proto/">理解prototype、proto和constructor等关系</a></p>
</blockquote>
<h2 id="控制台结果解析"><a class="header-anchor" href="#控制台结果解析"></a>控制台结果解析</h2>
<p>分析完了 john 的产生过程，我们再分析一下控制台输出结果：</p>
<p>这个例子的代码全部执行完，最终涉及到的对象和它们间的关系如图：</p>
<p><img src="https://cloud.az22c.top/js-new-process-2.png-az22cgithub" alt="js-new-process-2"></p>
<ul>
<li><a href="http://john.name" target="_blank" rel="noopener">john.name</a>： 临时变量obj有name，obj经返回被赋给john，john的一些属性由此而来。</li>
<li>john.hairColor：john实例对象 先查找自身的 hairColor，<strong>没有找到便会沿着原型链查找</strong>，在上述例子中，我们仅在 Person 对象上定义了 hairColor，并没有在其原型链上定义，因此找不到。</li>
<li>john.height：john实例对象 先查找自身的 height，<strong>没有找到便会沿着原型链查找</strong>，原型链上也没有，因此找不到。</li>
<li>john.say：john会先查找自身的 say 方法，没有找到便会沿着原型链查找，在上述例子中，我们在 Person.prototype上定义了say，因此在原型链上找到了say 方法。</li>
</ul>
<p>另外，在 say 方法中还访问<code>this.name</code>，这里的 this 指的是其调用者。如果john调用say，john就是调用者，因此输出john.name的值。</p>
<hr>
<p>对于Person来说，它本身也是一个对象，因此它在访问属性和方法时也遵守上述查找规则，所以：</p>
<ul>
<li><code>Person.name</code> —&gt; Person   <strong>// 这是特殊情况</strong></li>
<li>Person.hairColor —&gt; “black”</li>
<li>Person.say() —&gt; Person.say is not a function</li>
</ul>
<p>需要注意的是，Person 先查找自身的 name，找到了 name，<strong>但这个 name 并不是我们定义的 name，而是函数对象内置的属性</strong>，一般情况下，函数对象在产生时会内置 name 属性并将函数名作为赋值（仅函数对象）。</p>
<p>另外，Person 在自身没有找到 say() 方法，也会沿着其原型链查找：</p>
<p>Person 的原型链： <strong>Person-&gt;Function.prototype-&gt;Object.prototype-&gt;null</strong> ，这原型链在 <a href="https://alexzhong22c.github.io/2017/08/08/js-proto/">往期文章</a> 里面我有介绍到。</p>
<p>由于 Person 的原型链上也没有定义 say 方法，因此返回异常提示。</p>
<h2 id="总结new的过程中发生了什么"><a class="header-anchor" href="#总结new的过程中发生了什么"></a>总结new的过程中发生了什么</h2>
<p>[1] 导致john继承了Person.prototype：</p>
<p>令john的<code>__proto__属性</code>指向Person.prototype，确立了这条原型链， 导致 john 能通过原型链继承Person.prototype 中的部分属性，可以简单地视john和Person.prototype是继承关系。</p>
<p>[2] john是 Person构造函数 的实例：</p>
<pre><code class="language-javascript">// instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上：
john instanceof Person; //true
</code></pre>
<p>这个过程中Person构造函数被调用并发挥了作用。其结果是，经过new创建实例对象后，实例对象可以拥有自己的属性和方法。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型对象 实战使用]]></title>
      <url>https://alexzhong22c.github.io/2017/08/09/js-prototype-practice/</url>
      <content type="html"><![CDATA[<p>一般地，javascript使用构造函数和原型对象来进行面向对象编程，它们的表现与其他面向对象编程语言中的“类”相似而又不同。</p>
<p>在 <a href="https://alexzhong22c.github.io/2017/08/08/js-proto/">上一篇文章</a> 已经做过对 构造函数 和 原型对象 的简单介绍。在这篇文章主要介绍使用实战，你可不要小看“实战”，坑点还是挺多的。</p>
<a id="more"></a>
<h2 id="原型对象-属性的查找"><a class="header-anchor" href="#原型对象-属性的查找"></a>原型对象 属性的查找</h2>
<p>对象属性查找，经常会查找到原型对象上：</p>
<p>当读取一个对象的属性时，javascript引擎首先在该对象的自有属性中查找属性名字。如果找到则返回。如果自有属性不包含该名字，则javascript会沿着<code>__proto__</code>从原型对象上找。如果找到则返回。如果一直往上都找不到，则返回undefined</p>
<pre><code class="language-JavaScript">var o = {};
console.log(o.toString());//'[object Object]'

o.toString = function(){
    return 'o';
}
console.log(o.toString());//'o'

delete o.toString;
console.log(o.toString());//'[objet Object]'
</code></pre>
<h3 id="in"><a class="header-anchor" href="#in"></a>in</h3>
<p>in操作符可以判断属性在不在该对象上，但无法区别自有还是继承属性：</p>
<pre><code class="language-JavaScript">function Test(){};
var obj = new Test;
Test.prototype.a = 1;
obj.b = 2;
console.log('a' in obj);//true
console.log('b' in obj);//true
console.log('b' in Test.prototype);//false
</code></pre>
<h3 id="hasownproperty"><a class="header-anchor" href="#hasownproperty"></a>hasOwnProperty()</h3>
<p>通过hasOwnProperty()方法可以确定该属性是自有属性还是继承属性：</p>
<pre><code class="language-JavaScript">var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log(obj.hasOwnProperty('a'));//false
console.log(obj.hasOwnProperty('b'));//true
</code></pre>
<p>于是可以将hasOwnProperty方法和in运算符结合起来使用，用来鉴别原型属性</p>
<pre><code class="language-JavaScript">function hasPrototypeProperty(object,name){
    return name in object &amp;&amp; !object.hasOwnProperty(name);
}
</code></pre>
<h2 id="原型对象-属性的添加"><a class="header-anchor" href="#原型对象-属性的添加"></a>原型对象 属性的添加</h2>
<h3 id="点运算添加属性"><a class="header-anchor" href="#点运算添加属性"></a>点运算添加属性</h3>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
Person.prototype.sayName = function(){
    console.log(this.name);
}
var person1 = new Person('bai');
var person2 = new Person('hu');

person1.sayName();//'bai'
</code></pre>
<h3 id="用对象字面形式添加属性-警惕constructor属性的丢失"><a class="header-anchor" href="#用对象字面形式添加属性-警惕constructor属性的丢失"></a>用对象字面形式添加属性 #警惕constructor属性的丢失</h3>
<p>虽然可以在原型对象上一一添加属性，但是直接用一个对象字面形式替换原型对象更简洁：</p>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
//对象字面形式：
Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString : function(){
        return '[person ' + this.name + ']'
    }
};

var person1 = new Person('bai');

console.log(person1 instanceof Person);//true
console.log(person1.constructor === Person);//false，解释见下一个demo：
console.log(person1.constructor === Object);//true
</code></pre>
<p>当一个实例对象被创建时，该原型对象的constructor属性自动创建，并指向该函数。当使用对象字面形式改写原型对象Person.prototype时，需要在改写原型对象时手动重置其constructor属性：</p>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
Person.prototype = {
    constructor: Person, // 只加了这一行代码
    sayName: function(){
        console.log(this.name);
    },
    toString : function(){
        return '[person ' + this.name + ']'
    }
};

var person1 = new Person('bai');

console.log(person1 instanceof Person);//true
console.log(person1.constructor === Person);//true
console.log(person1.constructor === Object);//false
</code></pre>
<h4 id="defineproperty-设置constructor不可遍历"><a class="header-anchor" href="#defineproperty-设置constructor不可遍历"></a>defineProperty，设置constructor不可遍历</h4>
<p>由于默认情况下，原生的constructor属性是不可枚举的，更妥善的解决方法是使用Object.defineProperty()方法，改变其属性描述符中的枚举性enumerable：</p>
<pre><code class="language-JavaScript">function Person(name){
    this.name = name;
}
Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString : function(){
        return '[person ' + this.name + ']'
    }
};
Object.defineProperty(Person.prototype,'constructor',{
    enumerable: false,
    value: Person
});
var person1 = new Person('bai');
console.log(person1 instanceof Person);//true
console.log(person1.constructor === Person);//true
console.log(person1.constructor === Object);//false
</code></pre>
<h2 id="构造函数-原型对象和实例对象之间的-关系-和-其指向判断"><a class="header-anchor" href="#构造函数-原型对象和实例对象之间的-关系-和-其指向判断"></a>构造函数、原型对象和实例对象之间的 关系 和 其指向判断</h2>
<blockquote>
<p>如果没有了解基础知识，可参考我的上一篇文章： <a href="https://alexzhong22c.github.io/2017/08/08/js-proto/">理解prototype、proto和constructor等关系</a></p>
</blockquote>
<p>构造函数、原型对象和实例对象之间的关系是<strong>实例对象和构造函数之间没有直接联系。</strong></p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
</code></pre>
<p>以上代码的原型对象是Foo.prototype，实例对象是f1，构造函数是Foo</p>
<p>原型对象和实例对象的关系：</p>
<pre><code class="language-JavaScript">console.log(Foo.prototype === f1.__proto__);//true
</code></pre>
<p>原型对象和构造函数的关系 ：</p>
<pre><code class="language-JavaScript">console.log(Foo.prototype.constructor === Foo);//true
</code></pre>
<p>而实例对象和构造函数则没有直接关系，间接关系是实例对象可以继承原型对象的constructor属性：</p>
<pre><code class="language-JavaScript">console.log(f1.constructor === Foo);//true
</code></pre>
<hr>
<p>如果非要扯实例对象和构造函数的关系，那只能是下面这句代码，实例对象是构造函数的new操作的结果：</p>
<pre><code class="language-JavaScript">var f1 = new Foo();
</code></pre>
<p><strong>这句代码执行以后，</strong> 如果重置原型对象，则会打破它们三者间的关系：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype === f1.__proto__);//true
console.log(Foo.prototype.constructor === Foo);//true

Foo.prototype = {}; // 此时重置原型对象
console.log(Foo.prototype === f1.__proto__);//false
console.log(Foo.prototype.constructor === Foo);//false
</code></pre>
<p>所以，对于 <strong>改写<code>Foo.prototype</code></strong> 这种操作，代码顺序很重要。它所遵循的规律还是脱离不了操作js对象的基本规律。</p>
<p>一是谨慎重置原型对象，二是要警惕constructor属性的丢失。（恰巧constructor是原型对象的唯一自有属性，所以2个问题是可以同时预防的）</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解prototype、__proto__和constructor等关系]]></title>
      <url>https://alexzhong22c.github.io/2017/08/08/js-proto/</url>
      <content type="html"><![CDATA[<p>理解对象和函数的prototype、__proto__和constructor等关系：</p>
<a id="more"></a>
<p>在JavaScript中，函数也是对象。</p>
<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<p>先给出 构造函数 实例对象 原型对象 三者的关系：</p>
<pre><code class="language-JavaScript">//  概述demo：
function Foo() {};
var f1 = new Foo;
</code></pre>
<p><img src="https://cloud.az22c.top/js-prototype-1.png-az22cgithub" alt="js-prototype-1"></p>
<p>如图，</p>
<p><strong>[1]构造函数有一个prototype属性，指向实例对象的原型对象。</strong></p>
<p><strong>[2]原型对象有一个constructor属性，指向该原型对象对应的构造函数。</strong></p>
<p><strong>[3]由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数。</strong></p>
<p><strong>[4]实例对象有一个__proto__属性，指向该实例对象对应的原型对象。</strong></p>
<blockquote>
<p>由于constructor属性是可以继承而来。如果是继承的，我们在图中用虚线来表示。后面所有图同理。</p>
</blockquote>
<h3 id="构造函数"><a class="header-anchor" href="#构造函数"></a>构造函数</h3>
<p>用来初始化新创建的对象的函数是构造函数。在上面例子中，Foo()函数是构造函数。</p>
<h3 id="实例对象"><a class="header-anchor" href="#实例对象"></a>实例对象</h3>
<p>可以用一个构造函数，构造多个实例对象。在上面例子中，f1是一个Foo的实例对象。再如：</p>
<pre><code class="language-JavaScript">// 补充demo：
function Foo(){};
var f1 = new Foo;
var f2 = new Foo;
console.log(f1 === f2);//false
</code></pre>
<h3 id="原型对象及prototype"><a class="header-anchor" href="#原型对象及prototype"></a>原型对象及prototype</h3>
<p><strong>[1]构造函数有一个prototype属性，指向实例对象的原型对象。</strong> 构造函数Foo()的原型对象是Foo.prototype。</p>
<p>通过同一个构造函数实例化的多个对象具有相同的原型对象。经常使用原型对象来实现继承：</p>
<pre><code class="language-JavaScript">function Foo(){};
Foo.prototype.a = 1;
var f1 = new Foo;
var f2 = new Foo;

console.log(Foo.prototype.a);//1
console.log(f1.a);//1
console.log(f2.a);//1
</code></pre>
<h3 id="constructor"><a class="header-anchor" href="#constructor"></a>constructor</h3>
<p><strong>[2]原型对象有一个constructor属性，指向该原型对象对应的构造函数。</strong></p>
<pre><code class="language-JavaScript">function Foo(){};
console.log(Foo.prototype.constructor === Foo);//true
</code></pre>
<p><strong>[3]由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数。</strong></p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(f1.constructor === Foo);//true
</code></pre>
<h3 id="proto"><a class="header-anchor" href="#proto"></a><strong>proto</strong></h3>
<p><strong>[4]实例对象有一个__proto__属性，指向该实例对象对应的原型对象。</strong> 实例对象f1通过<code>__proto__属性</code>也指向原型对象Foo.prototype。</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true
</code></pre>
<h2 id="视foo-prototype为实例对象"><a class="header-anchor" href="#视foo-prototype为实例对象"></a>视Foo.prototype为实例对象</h2>
<p>Foo.prototype是f1的原型对象，同时它也可以是实例对象。实际上，任何对象都可以看做是通过Object()构造函数的new操作实例化的对象。</p>
<p><strong>所以，Foo.prototype作为实例对象时，它的构造函数是Object()，原型对象是Object.prototype。</strong></p>
<p><img src="https://cloud.az22c.top/js-prototype-2.png-az22cgithub" alt="js-prototype-2"></p>
<p>相应地，构造函数Object()的prototype属性指向原型对象Object.prototype；</p>
<p>Object.prototype的constructor属性指向构造函数Object()</p>
<p>实例对象Foo.prototype本身具有constructor属性，所以它会覆盖继承自原型对象Object.prototype的constructor属性：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype.constructor === Foo);//true
console.log(Object.prototype.constructor === Object);//true
console.log(Foo.prototype.hasOwnProperty('constructor'));//true
</code></pre>
<p>实例对象Foo.prototype的__proto__属性同样指向原型对象Object.prototype：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype.__proto__ === Object.prototype);//true
</code></pre>
<h2 id="视object-prototype为实例对象"><a class="header-anchor" href="#视object-prototype为实例对象"></a>视Object.prototype为实例对象</h2>
<p>如果Object.prototype作为实例对象的话，其原型对象是什么？结果是null。</p>
<p><img src="https://cloud.az22c.top/js-prototype-3.png-az22cgithub" alt="js-prototype-3"></p>
<pre><code class="language-JavaScript">console.log(Object.prototype.__proto__ === null);//true
</code></pre>
<h2 id="函数foo和函数object也可以被视为实例对象"><a class="header-anchor" href="#函数foo和函数object也可以被视为实例对象"></a>函数Foo和函数Object也可以被视为实例对象</h2>
<p>前面已经介绍过，函数也是对象，只不过是具有特殊功能的对象而已。任何函数都可以看做是通过Function()构造函数的new操作实例化的结果</p>
<p>如果把函数Foo当成实例对象的话，其构造函数是Function()，其原型对象是Function.prototype；类似地，函数Object的构造函数也是Function()，其原型对象是Function.prototype</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Foo.__proto__ === Function.prototype);//true
console.log(Object.__proto__ === Function.prototype);//true
</code></pre>
<p>原型对象Function.prototype的constructor属性指向构造函数Function()；实例对象Object和Foo本身没有constructor属性，需要继承原型对象Function.prototype的constructor属性：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
console.log(Function.prototype.constructor === Function);//true
console.log(Foo.constructor === Function);//true
console.log(Foo.hasOwnProperty('constructor'));//false
console.log(Object.constructor === Function);//true
console.log(Object.hasOwnProperty('constructor'));//false
</code></pre>
<blockquote>
<p>“构造函数Foo的constructor”和“构造函数Object的constructor”都是继承而来的，所以都在图中用虚线来表示。</p>
</blockquote>
<p><img src="https://cloud.az22c.top/js-prototype-4.png-az22cgithub" alt="js-prototype-4"></p>
<h2 id="视function为实例对象"><a class="header-anchor" href="#视function为实例对象"></a>视Function为实例对象</h2>
<p><strong>所有的函数都可以看成是构造函数Function()的new操作的实例化对象。</strong> 那么，Function可以看成是调用其自身的new操作的实例化的结果</p>
<p>所以，如果Function作为实例对象，其构造函数是Function，其原型对象是Function.prototype</p>
<pre><code class="language-js">console.log(Function.__proto__ === Function.prototype);//true
console.log(Function.prototype.constructor === Function);//true
console.log(Function.prototype === Function.prototype);//true
</code></pre>
<h2 id="视function-prototype为实例对象"><a class="header-anchor" href="#视function-prototype为实例对象"></a>视Function.prototype为实例对象</h2>
<p>和前面一样，<strong>所有的对象都可以看成是Object()构造函数的new操作的实例化结果。</strong></p>
<p>所以，Function.prototype的原型对象是Object.prototype：</p>
<pre><code class="language-JavaScript">console.log(Function.prototype.__proto__ === Object.prototype);//true
</code></pre>
<p>刚才介绍过，Object.prototype的原型对象是null：</p>
<pre><code class="language-JavaScript">console.log(Object.prototype.__proto__ === null);//true
</code></pre>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>对于代码：</p>
<pre><code class="language-JavaScript">function Foo(){};
var f1 = new Foo;
</code></pre>
<p>其涉及到的构造函数 实例对象 原型对象 以及它们之间的关系如图所示：</p>
<p><img src="https://cloud.az22c.top/js-prototype-4.png-az22cgithub" alt="js-prototype-4"></p>
<p>【1】函数(Function也是函数)是new Function的结果，所以函数可以作为实例对象，其构造函数是Function()，原型对象是Function.prototype</p>
<p>【2】对象(函数也是对象)是new Object的结果，所以对象可以作为实例对象，其构造函数是Object()，原型对象是Object.prototype</p>
<p>【3】Object.prototype的原型对象是null</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型系统 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[this绑定的优先级]]></title>
      <url>https://alexzhong22c.github.io/2017/08/07/js-this2/</url>
      <content type="html"><![CDATA[<p>上一篇文章详细介绍过 this的4种绑定规则，那如果在函数的调用位置上同时存在两种以上的绑定规则应该怎么办呢？本文将介绍this绑定的优先级：</p>
<a id="more"></a>
<h2 id="显式绑定-pk-隐式绑定"><a class="header-anchor" href="#显式绑定-pk-隐式绑定"></a>显式绑定 pk 隐式绑定</h2>
<p>显式绑定胜出</p>
<pre><code class="language-JavaScript">function foo() {
    console.log( this.a );
}
var obj1 = {
    a: 2,
    foo: foo
};
var obj2 = {
    a: 3,
    foo: foo
};
obj1.foo(); // 2
obj2.foo(); // 3
//在该语句中，显式绑定call(obj2)和隐式绑定obj1.foo同时出现，最终结果为3，说明被绑定到了obj2中
obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
</code></pre>
<h2 id="new绑定-pk-隐式绑定"><a class="header-anchor" href="#new绑定-pk-隐式绑定"></a>new绑定 pk 隐式绑定</h2>
<p>new绑定胜出</p>
<pre><code class="language-JavaScript">function foo(something) {
    this.a = something;
}
var obj1 = {foo: foo};
var obj2 = {};
// obj1隐式绑定：
obj1.foo( 2 );
console.log( obj1.a ); // 2
// obj2显式绑定：
obj1.foo.call(obj2,3);
console.log( obj2.a ); // 3
//在下列代码中，隐式绑定obj1.foo和new绑定同时出现。最终obj1.a结果是2，而bar.a结果是4，说明this被绑定在bar上
var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
</code></pre>
<h2 id="new绑定-pk-显式绑定"><a class="header-anchor" href="#new绑定-pk-显式绑定"></a>new绑定 pk 显式绑定</h2>
<p>new绑定胜出</p>
<pre><code class="language-JavaScript">function foo(something) {
    this.a = something;
}
var obj1 = {};
//先将obj1绑定到foo函数中，此时this值为obj1
var bar = foo.bind( obj1 );
bar( 2 );
console.log(obj1.a); // 2
//通过new绑定，此时this值为baz
var baz = new bar( 3 );
console.log( obj1.a ); // 2
//说明使用new绑定时，在bar函数内，无论this指向obj1有没有生效，最终this都指向新创建的对象baz
console.log( baz.a ); // 3
</code></pre>
<h2 id="结论："><a class="header-anchor" href="#结论："></a>结论：</h2>
<p>优先级排列顺序为：</p>
<p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> this </tag>
            
            <tag> new </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结合this的4种绑定规则 深入理解this指向的判定]]></title>
      <url>https://alexzhong22c.github.io/2017/08/07/js-this/</url>
      <content type="html"><![CDATA[<p>此文适合用于进阶对this的理解，不适合用来入门。</p>
<a id="more"></a>
<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<p>根据《你不知道的JavaScript》，this的绑定规则有4种：</p>
<p>1.默认绑定</p>
<p>2.隐式绑定</p>
<p>3.显式绑定</p>
<p>4.new绑定</p>
<p>这种划分是按照JavaScript的运行机理划分的，这有助于我们判定复杂的this的指向。</p>
<blockquote>
<p>值得补充的是：</p>
<p>我们可以粗浅地理解为：进入函数的“执行上下文”会发生三件事情：1 确定this指向 2 创建活动对象并完成“变量提升” 3 确定作用域链 。</p>
<p>可见，如果想要完全理解this的指向，可以完全不用理会“作用域”的概念，它们是不同的体系。</p>
<p>“变量提升”也是不同于this的问题体系，联系在一起讲好像不会增加理解的难度，所以后文会涉及到“变量提升”。</p>
</blockquote>
<p>书中提出了“执行流”这种虚拟的概念，来比较死板地判断this的指向，判断效果还是挺不错的。</p>
<h2 id="默认绑定"><a class="header-anchor" href="#默认绑定"></a>默认绑定</h2>
<blockquote>
<p>非严格模式下，全局执行上下文this默认指向window；而严格模式下，全局执行上下文this默认为undefined。</p>
<p>本小节是以“非严格模式”作为前提讲解的了；严格模式同理。</p>
</blockquote>
<p>全局执行上下文中，this默认绑定全局对象；而在浏览器下，全局对象就是 window。</p>
<p>即简而言之：</p>
<p>结论1：全局执行上下文中，this默认绑定到window。</p>
<pre><code class="language-JavaScript">// demo 1-1：
console.log(this === window); // true
console.log(this.document === document); // true

this.a = 91;
console.log(window.a); // 91
</code></pre>
<p>结论2：函数独立调用时，this默认绑定到window。</p>
<pre><code class="language-JavaScript">// demo 1-2：
function foo(){
    console.log(this === window);
}
foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：foo()返回true
</code></pre>
<p>独立调用，<code>foo()</code>等价于<code>window.foo()</code></p>
<p>结论3：IIFE的本质就是 函数声明+立即的函数独立调用，所以我们把IIFE视为独立调用的情况即可：</p>
<pre><code class="language-JavaScript">// demo 1-3：
(function () {
	 console.log(this === window); // true
})();
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">// demo 1-4：
function aname() {
	 console.log(this === window); // true
}
aname(); // 声明之后要立即执行
</code></pre>
<h2 id="隐式绑定"><a class="header-anchor" href="#隐式绑定"></a>隐式绑定</h2>
<p>一般地，如果是对象的方法调用，对于这次函数的执行，this隐式绑定到该对象上：</p>
<pre><code class="language-JavaScript">// demo 2-1：
var a = 0;
var obj = {
    a : 2,
    foo:function(){
        console.log(this.a);
    }
}
obj.foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：obj.foo()返回2
</code></pre>
<p>变量提升等价于：</p>
<pre><code class="language-JavaScript">// demo 2-2：
function foo () {
    console.log(this.a);
}
var a = 0;
var obj;
obj = {
    a : 2,
    foo: foo
}
obj.foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：obj.foo()返回2
</code></pre>
<p>再对隐式绑定知识做一个巩固：</p>
<pre><code class="language-JavaScript">// demo 2-3：
function foo(){
    console.log(this.a);
};
var obj1 = {
    a:1,
    foo:foo,
    obj2:{
        a:2,
        foo:foo
    }
}

obj1.foo(); // foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内；结果为1(访问到了obj1.a)
obj1.obj2.foo();// foo是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内；结果为2(访问到了obj1.obj2.a)
</code></pre>
<h2 id="判定this的指向"><a class="header-anchor" href="#判定this的指向"></a>// 判定this的指向</h2>
<p>我们已经对 this的4种绑定规则 的前2种进行了介绍，但是如果demo变得再复杂一点点，this的指向就比较难以判定了。</p>
<p>请在已有上文知识的基础上，思考下面的函数返回结果是如何得出的：</p>
<pre><code class="language-JavaScript">// exer 1-1 ：代码可以对比demo 2-1 的代码
var a = 0;
var obj = {
    a : 2,
    foo:function(){
            function test() {
                console.log(this.a);// 0
            }
            test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
    }
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，test才是;执行流先执行foo，再执行test
// 结果：obj.foo()返回0
</code></pre>
<p>变量提升等价于：</p>
<pre><code class="language-JavaScript">// exer 1-2 ：
var a = 0;
var obj;
function foo () {
            function test() {
                console.log(this.a);// 0
            }
            test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
}
obj = {
    a : 2,
    foo: foo
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，test才是;执行流先执行foo，再执行test
// 结果：obj.foo()返回0
</code></pre>
<p>虽然test()函数被嵌套在obj.foo()函数声明中， <strong>但test()函数是独立调用的，</strong> 因而它不是<code>对象的方法调用</code>。</p>
<p>既然是独立调用，this默认绑定到window。</p>
<hr>
<p>由demo 1-3 我们知道IIFE的本质有利于攻破含IIFE的问题，在上面的exer 1-2 中，我们可以再把test等价于一个IIFE函数：</p>
<pre><code class="language-JavaScript">// exer 1-3 ：
var a = 0;
var obj;
function foo () {
            (function () {
                console.log(this.a);// 0
            })(); // 该IIFE是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
}
obj = {
    a : 2,
    foo: foo
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，IIFE才是;执行流先执行foo，再执行IIFE
// 结果：obj.foo()返回0
</code></pre>
<h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3>
<p>我们似乎发现了 判定this的指向 的方法：</p>
<p>我们以exer 1-2 为例，进行说明：</p>
<pre><code class="language-JavaScript">// exer 1-2 ：
var a = 0;
var obj;
function foo () {
           function test() {
               console.log(this.a);// 0
           }
           test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
}
obj = {
   a : 2,
   foo: foo
}
obj.foo(); // 实际上，foo还不是this关键字所在的函数，test才是;执行流先执行foo，再执行test
// 结果：obj.foo()返回0
</code></pre>
<h4 id="一-先去找出this关键字所在的函数声明或函数表达式"><a class="header-anchor" href="#一-先去找出this关键字所在的函数声明或函数表达式"></a>一、先去找出this关键字所在的函数声明或函数表达式</h4>
<p>即，this关键字在哪个函数的声明内?!或者在哪个函数的表达式内?! this往上一级的那个函数便是了</p>
<blockquote>
<p>我们发现要找的这个函数是test，this关键字在test的函数声明内。（而不是foo，foo只是test的上级函数）</p>
</blockquote>
<h4 id="二-找出该函数被调用时的表达式"><a class="header-anchor" href="#二-找出该函数被调用时的表达式"></a>二、找出该函数被调用时的表达式</h4>
<blockquote>
<p>例子代码中，第8行的 test() 是我们要找的调用表达式（此时test函数才被调用）</p>
</blockquote>
<h4 id="三-观察该调用表达式的形态-确定this的指向"><a class="header-anchor" href="#三-观察该调用表达式的形态-确定this的指向"></a>三、观察该调用表达式的形态，确定this的指向</h4>
<blockquote>
<p>观察 test() 这个调用表达式的形态</p>
</blockquote>
<p>如果形态像“独立调用”<code>fn()</code>，那么this指向window：</p>
<p>如，demo 1-2 和 exer 1-2 。</p>
<p>如果表达式形态可以说是IIFE，那么也可以视为函数的独立调用，this指向window：</p>
<p>如，demo 1-3 和 exer 1-3 。</p>
<p>如果形态像<code>obj.fn()</code>，那么this指向obj：</p>
<p>如，exer 2-1中的<code>obj.foo()</code>。然后另外，容易误导人的是像exer 1-2 中的<code>obj.foo()</code>这句，我们说了在exer 1-2中，foo不是我们想要的，所以应该不必理会这句，而应该去找test函数被调用的那句表达式。</p>
<p>如果形态像<code>obja.objb.fn()</code>，那么那么this指向objb：</p>
<p>如，demo2-3 中的<code>obj1.obj2.foo()</code>，this指向obj2</p>
<hr>
<p><strong>以上的 判定this的指向 的方法是在任何情况下通用的，</strong> 我们拿闭包来练练手，顺便讲一下闭包：</p>
<h3 id="闭包"><a class="header-anchor" href="#闭包"></a>闭包</h3>
<p>其实闭包在本文不必按特殊情况考虑，鉴于某些新手可能不熟悉闭包，特拿出来一种闭包做例子说明：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    function test(){
        console.log(this.a);
    }
    return test;
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo()(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
// 结果：obj.foo()()返回0
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">function test () {
    console.log(this.a);
}
var a = 0;
test(); // test是this关键字所在的函数，执行流到此，之后执行流会进入该函数的声明内
</code></pre>
<p>即函数的“独立调用”，那么this指向window</p>
<h4 id="补充闭包常见demo"><a class="header-anchor" href="#补充闭包常见demo"></a>补充闭包常见demo</h4>
<p>因此，这也是一个老生常谈，（类似上面的例子），由于闭包的this<strong>常常</strong>默认绑定到window对象。如果在这种情况下，需要访问外层嵌套函数的this，常见的做法是使用<code>var that = this</code>，然后在闭包中使用that替代this，使用作用域查找的方式来找到外层嵌套函数的this值 ：</p>
<pre><code class="language-javascript">var a = 0;
function foo(){
    var that = this;
    this.sth = 'hello'
    function test(){
        console.log(that.a, that.sth);
    }
    return test;
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo()();//2 hello
</code></pre>
<h2 id="隐式丢失"><a class="header-anchor" href="#隐式丢失"></a>隐式丢失</h2>
<p>隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window的现象。这是一种程序员常见的逻辑上出错的情况。</p>
<p>同样地，	<strong>以上的 判定this的指向 的方法在隐式丢失中依然适用</strong>。</p>
<p>首先，按照常见的类型，隐式丢失可以又分为：</p>
<p>1.函数别名的情况</p>
<p>2.参数传递的情况</p>
<p>3.内置函数的情况</p>
<p>4.间接引用的情况</p>
<p>5.其他情况</p>
<h3 id="函数别名的情况"><a class="header-anchor" href="#函数别名的情况"></a>函数别名的情况</h3>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系
var bar = obj.foo;
bar(); // bar和foo都是this关键字所在的函数，执行流到此，之后执行流会进入bar的函数表达式内；考虑到bar被调用时这句表达式的形态，结果为0依然可以被理解
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 0;
var bar = function foo(){
    console.log(this.a);
}
bar();//0
</code></pre>
<h3 id="参数传递的情况"><a class="header-anchor" href="#参数传递的情况"></a>参数传递的情况</h3>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
};
function bar(fn){
    fn(); // fn和foo都是this关键字所在的函数，执行流到此，之后执行流会进入fn的函数表达式内；考虑到fn被调用时这句表达式的形态，结果为0依然可以被理解
}
var obj = {
    a : 2,
    foo:foo
}
//把obj.foo当作参数传递给bar函数，之后有隐式的函数赋值fn=obj.foo。与上例类似，只是把foo函数赋给了fn，而fn与obj对象则毫无关系
bar(obj.foo);//0
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a); // 0
};
function bar(fn){
    fn(); // fn和foo都是this关键字所在的函数，执行流到此，之后执行流会进入fn的函数表达式内；考虑到fn被调用时这句表达式的形态，结果为0依然可以被理解
}
bar(foo);// 0
</code></pre>
<h3 id="内置函数的情况"><a class="header-anchor" href="#内置函数的情况"></a>内置函数的情况</h3>
<p>内置函数的情况的本质是参数传递的情况：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo,100); // obj.foo作为setTimeout的内置函数
// 结果： setTimeout(obj.foo,100)返回0
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a); // 0
};
function setTimeout(fn, 100){
	// 考虑setTimeout的原生代码的本质，等待100秒后执行：
    fn(); // fn和foo都是this关键字所在的函数，执行流到此，之后执行流会进入fn的函数表达式内；考虑到fn被调用时这句表达式的形态，结果为0依然可以被理解
}
setTimeout(foo, 100); // 0
</code></pre>
<h3 id="间接引用的情况"><a class="header-anchor" href="#间接引用的情况"></a>间接引用的情况</h3>
<p>间接引用的情况的本质是函数别名的情况：</p>
<pre><code class="language-JavaScript">var a = 2;
function foo() {
    console.log( this.a );
}
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
//将o.foo函数赋值给p.foo函数，然后立即执行，此时p.foo发生了隐式丢失
(p.foo = o.foo)(); // 2
// IIFE和p.foo和o.foo都是this关键字所在的函数，执行流到此，之后执行流会进入IIFE的函数表达式内，结果为2依然可以被理解
</code></pre>
<p>等价于：</p>
<pre><code class="language-JavaScript">var a = 2;
function foo() {
    console.log( this.a );
}
var p = { a: 4 };
p.foo = foo;
var aname = p.foo; //第一对括号的作用
aname(); // IIFE和p.foo和o.foo都是this关键字所在的函数，执行流到此，之后执行流会进入IIFE的函数表达式内，结果为2依然可以被理解
</code></pre>
<p>而如果我们想要一个没有隐式丢失的类似demo：</p>
<pre><code class="language-JavaScript">var a = 2;
function foo() {
    console.log( this.a );
}
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
//将o.foo函数赋值给p.foo函数，之后p.foo函数再执行
p.foo = o.foo;
p.foo(); // 4
// p.foo和o.foo都是this关键字所在的函数，执行流到此，之后执行流会进入p.foo的函数表达式内，结果为4是因为隐式绑定
// 这没有隐式丢失，但结果依然可以按照我们的理解方法来理解
</code></pre>
<h3 id="其他情况"><a class="header-anchor" href="#其他情况"></a>其他情况</h3>
<p>在javascript引擎内部，obj和obj.foo储存在两个内存地址，在这里我们简称为M1和M2。只有obj.foo()这样形式的表达式调用时，是从M1调用M2，因此this指向obj。但是，下面三种情况，都是直接取出M2进行运算，然后就在全局执行上下文执行运算结果（还是M2），因此this指向全局对象</p>
<pre><code class="language-JavaScript">var a = 0;
var obj = {
    a : 2,
    foo:foo
};
function foo() {
    console.log( this.a );
};

(obj.foo = obj.foo)();//0

(false || obj.foo)();//0

(1, obj.foo)();//0
</code></pre>
<p>也可以像上面 间接引用的情况 理解为： IIFE和obj.foo都是this关键字所在的函数，执行流到此，之后执行流会进入IIFE的函数表达式内；考虑到IIFE的表达式，结果为0依然可以被理解</p>
<h2 id="显示绑定"><a class="header-anchor" href="#显示绑定"></a>显示绑定</h2>
<p>通过<code>call()、apply()、bind()</code>或者es6的<code>map()、forEach()、filter()、some()、every()</code>方法把对象绑定到this上，叫做显式绑定；而对于被调用的函数来说，叫做间接调用</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
}
var obj1 = {
    a:1
};
var obj2 = {
    a:2
};
foo.call(obj1);//1
foo.call(obj2);//2
</code></pre>
<p>用显式绑定就不用考虑会有隐式丢失的问题了：因为显式绑定优先于隐式绑定，如果程序员用显式绑定，在心里就已经知道隐式绑定无效了：</p>
<pre><code class="language-JavaScript">var a = 0;
function foo(){
    console.log(this.a);
}
var obj100 = {
  a : 100,
  foo: foo
}
var obj1 = {
    a:1
};
var obj2 = {
    a:2
};
obj100.foo.call(obj1);//1
obj100.foo.call(obj2);//2
obj100.foo() // 100，普通的显式绑定无法解决隐式丢失问题
</code></pre>
<h3 id="es6显示绑定api"><a class="header-anchor" href="#es6显示绑定api"></a>es6显示绑定API</h3>
<p>es6中新增了许多内置函数，具有显式绑定的功能，如数组的5个<a href="http://www.cnblogs.com/xiaohuochai/p/5682621.html#anchor10" target="_blank" rel="noopener">迭代方法</a>：<code>map()、forEach()、filter()、some()、every()</code></p>
<pre><code class="language-JavaScript">var id = 'window';
function foo(el){
    console.log(el,this.id);
}
var obj = {
    id: 'fn'
};
[1,2,3].forEach(foo);//1 &quot;window&quot; 2 &quot;window&quot; 3 &quot;window&quot;
[1,2,3].forEach(foo,obj);//1 &quot;fn&quot; 2 &quot;fn&quot; 3 &quot;fn&quot;
</code></pre>
<h2 id="new绑定"><a class="header-anchor" href="#new绑定"></a>new绑定</h2>
<p>new绑定通常指的是构造器中的this。</p>
<p>1.构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值：</p>
<pre><code class="language-JavaScript">function fn() {
  this.a = 2;
}
var test = new fn();
console.log(test); // {a:2}
</code></pre>
<p>2.如果构造函数显式地没有返回值 或者 显式地返回为基本类型时，那么这时将忽略返回值，将隐式默认值返回：</p>
<pre><code class="language-JavaScript">function fn() {
  this.a = 2;
  return;
}
var test = new fn();
console.log(test); // {a:2}
</code></pre>
<p>3.如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象：</p>
<pre><code class="language-JavaScript">function C2() {
  this.a = 26;
  return {
    a: 24
  };
}

o = new C2();
console.log(o.a); // 24
</code></pre>
<p><strong>[注意]尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为this。也就是说，例如在表达式new o.m()中，this并不是指向o</strong>：</p>
<pre><code class="language-JavaScript">var o = {
    m: function() {
        this.a = 'test a';    
        return this;
    }
}
var obj = new o.m();
console.log(obj.constructor === o); // false
console.log(obj.constructor === o.m); // true
console.log(obj.a) // 'test a'
</code></pre>
<h2 id="严格模式的严谨修正"><a class="header-anchor" href="#严格模式的严谨修正"></a>严格模式的严谨修正</h2>
<p>在非严格模式下，独立调用的函数的this指向window；而在严格模式下，独立调用的函数的this指向undefined：</p>
<pre><code class="language-JavaScript">function fn(){
    'use strict';
    console.log(this);//undefined
}
fn();

function fn(){
    console.log(this);//window
}
fn();
</code></pre>
<p>在非严格模式下，使用函数的call()或apply()方法时，第一个参数若使用null或undefined，值会被转换为全局对象；而在严格模式下，函数的this值始终是表达式中所指定的值：</p>
<pre><code class="language-JavaScript">var color = 'red';
function displayColor(){
    console.log(this.color);
}
displayColor.call(null);//red

var color = 'red';
function displayColor(){
    'use strict';
    console.log(this.color);
}
displayColor.call(null);//TypeError: Cannot read property 'color' of null
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IIFE </tag>
            
            <tag> 进阶 </tag>
            
            <tag> this </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器事件冒泡或者捕获相关]]></title>
      <url>https://alexzhong22c.github.io/2017/07/02/js-event4/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="事件流-事件捕获或者冒泡相关"><a class="header-anchor" href="#事件流-事件捕获或者冒泡相关"></a>事件流（事件捕获或者冒泡相关）</h2>
<p><a href="https://www.cnblogs.com/st-leslie/p/5907556.html" target="_blank" rel="noopener">建议看：博客园谢灿勇 js事件流</a></p>
<p>每次用addEventListener这个api，你需要<strong>选择绑定事件在冒泡阶段还是捕获阶段</strong>。（通常设置为false即为冒泡） 而这个api就是基于事件流的原理。</p>
<ul>
<li>事件流的本质：比如在页面上点击一个元素，这是一个点击事件。事实上，被点击的元素及其所有祖先元素都是能感知到的，只不过是，如果你没有绑定事件，它们就不会对应地触发事件响应。</li>
<li>事件流的过程：<strong>事件流</strong>被分为三个阶段捕获过程、<strong>目标过程</strong>、冒泡过程。表示事件流中“某元素的某个被触发的事件”是绑定在哪个阶段的属性是<code>eventPhase</code>。</li>
<li>一个完整的JS事件流是从window开始，最后回到window的一个过程（有些浏览器是到body）
<ul>
<li>也就是从window开始，依次触发<strong>绑定在</strong>捕获过程的(有绑定的)事件响应，然后是目标过程的（不分冒泡还是捕获按注册顺序），再然后是依次触发<strong>绑定在</strong>冒泡过程的直到回到window</li>
<li><strong>而目标阶段非常特别，目标阶段是按注册顺序决定的（也就是假如先绑定冒泡，则冒泡早于捕获得到响应）</strong>  <a href="https://www.cnblogs.com/alvinwei1024/p/4739344.html" target="_blank" rel="noopener">1</a> #面试题</li>
</ul>
</li>
</ul>
<h4 id="并不是所有事件都支持冒泡-局限性"><a class="header-anchor" href="#并不是所有事件都支持冒泡-局限性"></a>并不是所有事件都支持冒泡 #局限性</h4>
<p>1、最适合使用事件冒泡/事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup和keypress</p>
<p>2、<strong>某些事件类型天生就不支持事件冒泡！不支持事件冒泡就更谈不上事件委托了。</strong></p>
<ul>
<li>blur: 在元素失去焦点时触发，该事件不支持冒泡</li>
<li>focus: 在元素获得焦点时触发，该事件不支持冒泡</li>
<li>mouseenter: 当鼠标移入元素时触发，该事件不支持冒泡</li>
<li>mouseleave: 当鼠标移出元素时触发，该事件不支持冒泡</li>
</ul>
<p>3、mousemove、mouseover、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的???<a href="https://juejin.im/post/58fd95bcac502e0063b197db" target="_blank" rel="noopener">https://juejin.im/post/58fd95bcac502e0063b197db</a></p>
<blockquote>
<p>mouseover的定义：当鼠标移入某元素时触发，移入和移出其子元素时也会触发。</p>
</blockquote>
<h2 id="如何应用：冒泡或者捕获事件-在事件绑定的时候"><a class="header-anchor" href="#如何应用：冒泡或者捕获事件-在事件绑定的时候"></a>如何应用：冒泡或者捕获事件  在事件绑定的时候</h2>
<blockquote>
<p>IE8及以下都不支持addEventListener，他们用attachEvent被称为IE事件处理程序；IE9及以后都支持addEventListener和attachEvent。</p>
</blockquote>
<blockquote>
<p>用addEventListener，在实战的时候，往往需要配合判断target和阻止冒泡。注意：<strong>currentTarget属性返回事件正在执行的监听函数所绑定的节点，而target属性返回事件的实际目标节点。</strong></p>
</blockquote>
<p>所以对于现代浏览器，可以同时用addEventListener绑定事件在冒泡和捕获阶段。<strong>（第三个参数通常设置为false即为冒泡）</strong></p>
<p>我们知道，如果要封装兼容IE事件处理程序attachEvent和addEventListener：因为attachEvent没有第三个参数，也就是说attachEvent只支持监听冒泡，所以为了统一，在使用addEventListener的时候第三参数传递 false。</p>
<pre><code class="language-js">function stopPropagation(e) {
  var e = e || window.event;
  if(window.event) {       //这是IE浏览器
      e.cancelBubble = true;//阻止冒泡事件
  }else if(e &amp;&amp; e.stopPropagation) {     //这是其他浏览器
      e.stopPropagation();//阻止冒泡事件
  }
}
</code></pre>
<h3 id="事件处理程序的event对象-ie兼容"><a class="header-anchor" href="#事件处理程序的event对象-ie兼容"></a>事件处理程序的Event对象 IE兼容</h3>
<p>首先作为基础，要稍微了解一下<a href="https://alexzhong22c.github.io/2017/07/01/js-event3/">浏览器js的四种事件处理程序</a>。</p>
<p><a href="http://yujiangshui.com/javascript-event/#%E4%BA%8B%E4%BB%B6%E8%BF%9B%E9%98%B6%E8%AF%9D%E9%A2%98" target="_blank" rel="noopener">摘自：于江水</a></p>
<p>IE 中往回调函数中传递的事件对象与标准有一些差异，你需要使用 <code>window.event</code> 来获取事件对象。所以你通常会写出下面代码来获取事件对象：</p>
<pre><code class="language-js">event = event || window.event
</code></pre>
<p>此外还有一些事件属性有差别，比如比较常用的 <code>event.target</code> 属性，IE 中没有，而是使用 <code>event.srcElement</code> 来代替。如果你的回调函数需要处理触发事件的节点，那么需要写：</p>
<pre><code class="language-js">target = event.srcElement || event.target;
</code></pre>
<p>常见的就是这点，更细节的不再多说。在概念学习中，我们没必要为不标准的东西支付学习成本；在实际应用中，类库已经帮我们封装好这些兼容性问题。可喜的是 IE 浏览器现在也开始不断向标准进步。</p>
<p><strong>最后总结一下就是：</strong></p>
<pre><code class="language-js">// 兼容性处理
var event = e || window.event;
// 获取到目标阶段指向的元素
var target = event.target || event.srcElement;
// 获取当前触发的事件处理函数所绑定的元素
var currentTarget = event.currentTarget;
</code></pre>
<h4 id="提取冷知识："><a class="header-anchor" href="#提取冷知识："></a>提取冷知识：</h4>
<ul>
<li>为了统一多种事件处理程序（有些它不支持捕获），一般来说都是利用冒泡比较顺手。
<ul>
<li>举例：DOM Level 0即onclick等等不支持捕获：比如，onclick只支持冒泡。（PS：基本全部浏览器都支持DOM Level 0也就是onclick这些api。）</li>
</ul>
</li>
<li>绑定多个事件的效果是：onclick只能绑定一个事件，即<strong>同一个元素的</strong>后面的绑定会覆盖前面的绑定。addEventListener是先绑定先触发，<strong>老浏览器的attachEvent</strong>则相反。（IE9、10浏览器是按正序执行的，<strong>而IE8-浏览器则是按倒序执行的</strong>）</li>
</ul>
<h2 id="事件代理-你所需要知道的"><a class="header-anchor" href="#事件代理-你所需要知道的"></a>事件代理 你所需要知道的</h2>
<h3 id="优点："><a class="header-anchor" href="#优点："></a>优点：</h3>
<ul>
<li>减少了事件的注册，节省内存。</li>
<li>在新增/移除DOM时，节省了的事件绑定/解绑。</li>
</ul>
<p>使用事件代理主要有两个优势：</p>
<ol>
<li>减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。</li>
<li>动态变化的 DOM 结构，仍然可以监听。以前，当一个 DOM 动态创建之后，不会带有任何事件监听，除非你重新执行事件监听函数；而使用事件监听无须担忧这个问题。</li>
</ol>
<h3 id="缺点："><a class="header-anchor" href="#缺点："></a>缺点：</h3>
<p>好像没有缺点，妥善的管理和合理运用能够规避问题。</p>
<h3 id="实战技巧-合理运用"><a class="header-anchor" href="#实战技巧-合理运用"></a>实战技巧，合理运用</h3>
<ul>
<li>通常需要就近委托或者不需要委托：
<ul>
<li>如果层级过多，或者绑定在靠近底层的元素上，冒泡过程中，可能会被某层阻止掉。</li>
<li>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在ul上代理li，而不是在document上代理li。</li>
</ul>
</li>
<li>考虑因项目协作可能引发的冲突：
<ul>
<li>把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。</li>
</ul>
</li>
</ul>
<h3 id="如何利用原生实现事件代理"><a class="header-anchor" href="#如何利用原生实现事件代理"></a>如何利用原生实现事件代理</h3>
<p><a href="https://juejin.im/post/58fd95bcac502e0063b197db" target="_blank" rel="noopener">如果想学代码封装实现 事件代理 可以看这篇</a></p>
<p>如果使用原生的方式实现事件代理，需要注意过滤非目标节点，可以通过 id、class 或者 tagname 等等，例如：</p>
<pre><code class="language-js">element.addEventListener('click', function(event) {
    // 判断是否是 a 节点
    if ( event.target.tagName == 'A' ) {
        // a 的一些交互操作
    }
}, false);
</code></pre>
<h2 id="vue的事件冒泡和事件代理-从vue专题复制而来"><a class="header-anchor" href="#vue的事件冒泡和事件代理-从vue专题复制而来"></a>vue的事件冒泡和事件代理 #从vue专题复制而来</h2>
<p>还有，vue在组件间不冒泡，在同一个组件内的元素是可以冒泡的。如果以后能够成功实现组件间冒泡，那么就可以通过冒泡或事件代理来实现“跨组件通信”了。在vue里面，如果想阻止冒泡用的是<code>.stop</code>修饰符。</p>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 事件 </tag>
            
            <tag> 笔记副本 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js四种事件处理程序]]></title>
      <url>https://alexzhong22c.github.io/2017/07/01/js-event3/</url>
      <content type="html"><![CDATA[<p>随着W3C不断推进DOM事件模型和IE浏览器事件模型的历史变化，为了方便理解，程序员们中逐渐形成 四种事件处理程序 的概念划分。</p>
<a id="more"></a>
<hr>
<p>在 JavaScript 中，通常分为四种事件处理程序：</p>
<ol>
<li>HTML事件处理程序</li>
<li>DOM0事件处理程序</li>
<li>DOM2事件处理程序</li>
<li>IE事件处理程序</li>
</ol>
<h2 id="简单比较"><a class="header-anchor" href="#简单比较"></a>简单比较</h2>
<table>
<thead>
<tr>
<th></th>
<th>HTML</th>
<th>DOM0级</th>
<th>DOM2级</th>
<th>IE</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码形式</td>
<td><code>onclick=&quot;fun()&quot;</code></td>
<td><code>btn.onclick = fun(){}</code></td>
<td><code>addEventListener()</code></td>
<td><code>attachEvent()</code></td>
</tr>
<tr>
<td>作用域</td>
<td>扩展的作用域（全局）</td>
<td>元素的作用域</td>
<td>元素的作用域</td>
<td>全局作用域</td>
</tr>
<tr>
<td>触发阶段</td>
<td></td>
<td>冒泡阶段</td>
<td>冒泡/捕获阶段</td>
<td>冒泡阶段</td>
</tr>
</tbody>
</table>
<h2 id="html事件处理程序"><a class="header-anchor" href="#html事件处理程序"></a>HTML事件处理程序</h2>
<p>在HTML的内联属性中添加事件处理。</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click&quot; onclick=&quot;alert('Hello world!')&quot; /&gt;
</code></pre>
<p>如上，可直接在<code>onclick = &quot;&quot;</code>里添加执行语句；也可如下，调用一个函数：</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot; /&gt;
&lt;script type=&quot;text/javascript&quot;&gt; function showMessage(){ alert(&quot;Hello world!&quot;); } &lt;/script&gt;
</code></pre>
<p>关于它的执行作用域，比较特别，是不断扩展、修改的。可以访问到document以及元素本身的成员，就像访问局部变量一样。</p>
<p><strong>优势：</strong></p>
<p>显而易见的直观、方便，在某些情况下使用尤其便捷，比如统计某个按钮/链接的点击次数。</p>
<p><strong>劣势</strong>：</p>
<p>html和javascript耦合，当需要修改时，就会一下进行两处变动，可维护性是很差的。</p>
<p>在事件与调用函数分离时，如果调用函数较晚加载，就会出现点击事件而无响应的情况。</p>
<blockquote>
<p>而在现今，比如Vue.js，框架本身能够补足这种写法的劣势，越来越多的主流JavaScript框架都是推崇这种内联属性的写法。</p>
</blockquote>
<h2 id="dom0级事件处理程序"><a class="header-anchor" href="#dom0级事件处理程序"></a>DOM0级事件处理程序</h2>
<pre><code>var element = document.getElementById(&quot;myBtn&quot;); 
element.onclick = function(){
//操作
};
</code></pre>
<p>在事件的冒泡阶段被处理。</p>
<p>作用域是元素的作用域，换句话说，就是程序中的 <code>this</code>引用当前元素。</p>
<p><strong>优势：</strong></p>
<p>简单明晰，易于使用和理解。并且具有跨浏览器的优势。</p>
<p><strong>劣势</strong>：</p>
<p>因为直接赋值给对应属性，如果你在后面代码中再次为 <code>element</code> 绑定一个回调函数，会覆盖掉之前回调函数的内容，通俗来说就是很难实现多个绑定。</p>
<p>代码运行以前不会指定事件处理程序,因此如果这些代码在页面中位于按钮后面,就有可能在一段时间内没有响应。</p>
<blockquote>
<p>虽然也可以用一些小技巧实现<strong>多个绑定</strong>，但还是推荐下面的DOM2级事件处理程序实现<strong>多个绑定</strong></p>
</blockquote>
<h3 id="dom0移除事件绑定"><a class="header-anchor" href="#dom0移除事件绑定"></a>DOM0移除事件绑定</h3>
<p>如果想要删除element的点击事件，将其置为null即可：</p>
<pre><code>element.onclick = null
</code></pre>
<blockquote>
<p>1级DOM–(为什么没有1级DOM)</p>
<p>DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型</p>
</blockquote>
<h2 id="dom2级事件处理程序"><a class="header-anchor" href="#dom2级事件处理程序"></a>DOM2级事件处理程序</h2>
<pre><code>var btn = document.getElementById('btn');
btn.addEventListener('click', function(){ 
  alert('你点击了这里');
}, false);
</code></pre>
<p>addEventListener是<strong>标准的事件处理程序</strong>，亦称为绑定事件监听，提供三个参数可供传递。(IE9+也支持addEventListener)</p>
<p>第三个参数是一个布尔值，<code>true</code>表示在捕获阶段被处理，<code>fasle</code>表示在冒泡阶段被处理，考虑到IE的兼容问题，一般不使用<code>true</code>。</p>
<p><strong>优势：</strong> 可以为一个元素添加多个事件处理程序。</p>
<h3 id="dom2移除事件监听"><a class="header-anchor" href="#dom2移除事件监听"></a>DOM2移除事件监听</h3>
<p>需要注意的是，<strong>绑定事件时的回调函数一般不能是匿名函数，</strong> 必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如：</p>
<pre><code class="language-javascript">var fun = function() {
    // function logic
};

element.addEventListener('click', fun, false);
element.removeEventListener('click', fun, false);
</code></pre>
<h2 id="ie事件处理程序"><a class="header-anchor" href="#ie事件处理程序"></a>IE事件处理程序</h2>
<blockquote>
<p>IE 浏览器就是特立独行，它对于事件的操作与标准有一些差异。不过 IE 浏览器现在也开始慢慢努力改造，让浏览器变得更加标准。</p>
</blockquote>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;);
btn.attachEvent(&quot;onclick&quot;, function(){ 
  alert(&quot;Clicked&quot;);
});
</code></pre>
<p>（IE事件处理程序：IE5到IE10支持，IE11就不再支持了。但是最好应用于IE5到IE8，因为IE9之后又略有变化）</p>
<p>实际上与addEventListener的使用十分相似。</p>
<p>区别在于，第二个参数传入的是<code>onclick</code>而并非<code>click</code>，且IE只支持在冒泡阶段进行程序处理，所以没有第三个参数布尔值的选择。
它的作用域为全局作用域，即<code>this</code>指向<code>window</code>。
此外，如果为同一个元素添加了两个事件处理程序，addEventListener会以添加的顺序依次执行事件处理，而attachEvent则相反。</p>
<blockquote>
<p>如果要封装兼容attachEvent和addEventListener：因为attachEvent没有第三个参数，也就是说attachEvent只支持监听冒泡，所以为了统一，在使用addEventListener的时候第三参数传递 false。</p>
</blockquote>
<h3 id="ie移除事件监听"><a class="header-anchor" href="#ie移除事件监听"></a>IE移除事件监听</h3>
<p>detachEvent()，用法与DOM2级的removeEventListener类似</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>一般情况下为了最大限度发挥事件处理程序的作用，使用标准事件处理程序，即addEventListener，并且把第三个参数设为<code>fasle</code>；如果专门为了兼容IE，则使用attachEvent；如果是在编写一个小程序，为了简单快捷，可以使用DOM0级处理程序或者考虑HTML处理程序。</p>
<p>另外，依照上面的知识，如果想要得到跨浏览器的事件处理程序代码，请在网上自行搜索，找到一款合适自己的。</p>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js取消默认事件行为]]></title>
      <url>https://alexzhong22c.github.io/2017/07/01/js-pv-default/</url>
      <content type="html"><![CDATA[<p>常见的默认行为有，点击链接后，浏览器跳转到指定页面；再比如<code>&lt;form&gt;</code>表单元素的&quot;submit&quot;事件，当我们触发表单的提交事件时，就可以提交当前表单。</p>
<a id="more"></a>
<p>关于取消默认行为的属性包括cancelable、defaultPrevented、preventDefault()和returnValue。</p>
<p>而“return false”这种方式不算是属性，我们后面会介绍到。</p>
<blockquote>
<p>作为程序员，原本我们应该优先考虑cancelable属性，</p>
<p>不过我们先拿preventDefault()、returnValue和“return false”这三者来讲：</p>
<p>在DOM0级事件处理程序中取消默认行为，这三者都有效；</p>
<p>在DOM2级事件处理程序中取消默认行为，使用”return false“无效;</p>
<p>在IE事件处理程序中取消默认行为，使用preventDefault()无效。</p>
</blockquote>
<h2 id="preventdefault"><a class="header-anchor" href="#preventdefault"></a>preventDefault()</h2>
<p>preventDefault()方法取消浏览器对当前事件的默认行为，无返回值。（IE8-浏览器不支持该方法）</p>
<pre><code class="language-html">&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    e.preventDefault();
}
&lt;/script&gt;
</code></pre>
<h2 id="returnvalue"><a class="header-anchor" href="#returnvalue"></a>returnValue</h2>
<p>returnValue属性可读写，默认值是true，但将其设置为false就可以取消事件的默认行为，与preventDefault()方法的作用相同。（firefox和IE9+浏览器不支持）</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    e.returnValue = false;
}
&lt;/script&gt;
</code></pre>
<h3 id="如果不用到dom0-考虑兼容："><a class="header-anchor" href="#如果不用到dom0-考虑兼容："></a>// 如果不用到DOM0，考虑兼容：</h3>
<p>在本文开头：</p>
<blockquote>
<p>我们先拿preventDefault()、returnValue和“return false”这三者来讲：</p>
<p>在DOM0级事件处理程序中取消默认行为，这三者都有效；</p>
<p>在DOM2级事件处理程序中取消默认行为，使用”return false“无效;</p>
<p>在IE事件处理程序中取消默认行为，使用preventDefault()无效。</p>
</blockquote>
<p>所以，如果<strong>不使用到DOM0</strong>，考虑兼容可以这么写：</p>
<p>(即，如果我们要用addEventListener()或者attachEvent()来绑定的话，就要用preventDefault()方法或者设置事件对象的returnValue属性。)</p>
<pre><code>var handler = function(e){
    e = e || event;
    if(e.preventDefault){
        e.preventDefault(); // 针对支持DOM标准的浏览器
    }else{
        e.returnValue = false; // 针对IE
    }
}
</code></pre>
<h2 id="return-false"><a class="header-anchor" href="#return-false"></a>return false</h2>
<p>除了以上方法外，取消默认事件还可以使用&quot;return false&quot;</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    return false;
}
&lt;/script&gt;
</code></pre>
<p>HTML5规范中有指出在mouseover等几种特殊事件情况下，return false;并不一定能终止事件。所以，在实际使用中，我们需要尽量避免通过&quot;return false&quot;的方式来取消事件的默认行为。</p>
<p>**若使用的是jquery，“return false ”既会阻止默认行为，也会阻止事件的冒泡。**这样使用return false往往会造成意想不到的失误。</p>
<hr>
<h2 id="cancelable"><a class="header-anchor" href="#cancelable"></a>cancelable</h2>
<p>cancelable属性返回一个布尔值，表示事件是否可以取消。</p>
<p>该属性为<strong>只读</strong>属性。返回true时，表示可以取消；返回false时，要么表示没有默认动作，要么表示不能阻止默认动作。（IE8-浏览器不支持cancelable属性）</p>
<p>这样来看，优先考虑到cancelable属性才是比较合理的逻辑顺序。</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    test.innerHTML = e.cancelable;
}
&lt;/script&gt;
</code></pre>
<h2 id="defaultprevented"><a class="header-anchor" href="#defaultprevented"></a>defaultPrevented</h2>
<p>defaultPrevented属性表示默认行为是否被阻止，返回true时表示被阻止，返回false时，表示未被阻止。（IE8-浏览器不支持）</p>
<pre><code class="language-html">&lt;a id=&quot;test&quot; href=&quot;http://www.cnblogs.com&quot;&gt;链接&lt;/a&gt;
&lt;script&gt;
test.onclick= function(e){
    e = e || event;
    if(e.preventDefault){
        e.preventDefault();
    }else{
        e.returnValue = false;
    }
    test.innerHTML = e.defaultPrevented; // defaultPrevented在这里用到
}
&lt;/script&gt;
</code></pre>
<blockquote>
<p>很明显 cancelable属性 和 defaultPrevented属性 针对的不是同一回事。</p>
</blockquote>
<hr>
<h2 id="jquery的写法："><a class="header-anchor" href="#jquery的写法："></a>JQuery的写法：</h2>
<p>JQuery的思想就是和原生的对应，并且作一定兼容：</p>
<pre><code>$(&quot;a&quot;).click(function(event){
  event.preventDefault();
});
</code></pre>
<ul>
<li>如果使用jQuery绑定的事件处理函数&quot;return false&quot;，jQuery也会阻止触发元素的默认行为。
<ul>
<li><strong>若使用的是jquery，“return false ”既会阻止默认行为，也会阻止事件的冒泡。</strong></li>
<li><a href="http://www.365mini.com/page/jquery-event-preventdefault.htm" target="_blank" rel="noopener">http://www.365mini.com/page/jquery-event-preventdefault.htm</a></li>
</ul>
</li>
<li>使用  <a href="http://www.runoob.com/jquery/event-isdefaultprevented.html" target="_blank" rel="noopener">event.isDefaultPrevented() 方法</a> 来检查指定的事件上是否调用了 preventDefault() 方法。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[let和const旧话新编]]></title>
      <url>https://alexzhong22c.github.io/2017/05/08/let-n-const/</url>
      <content type="html"><![CDATA[<p>本文的结构是：首先看完了前文就能快速把代码从ES5的变量声明改到ES6，后续部分是作为拓展和详细的介绍：</p>
<a id="more"></a>
<hr>
<p>（虽然现在ES8都出来了，但是依然是一直用var的工程也不少啊）</p>
<p>ES6提出了两个新的声明变量的命令：<code>let</code>和<code>const</code> 。说大白话就是：除了极为极为少数的情况，var可以完全被它们俩替换掉。</p>
<p>用let替代var时，你需要注意到它们的不同点有三个：</p>
<p><strong>1.块级作用域：</strong></p>
<pre><code>for (var i = 0; i &lt; 10; i++) {}
console.log(i);   // 10

for (let j = 0; j &lt; 10; j++) {}
console.log(j);   // ReferenceError: j is not defined
</code></pre>
<p>在 console.log(i) 的时候，仍在函数作用域内，所以那时 i 还没有被销毁。</p>
<p>在 console.log(j) 的时候，已经在各个块级作用域外了，所以那时 j 已经都被销毁了。</p>
<p><strong>2.变量提升：</strong>  var会变量提升，但let不会：</p>
<pre><code>console.log(bar); // undefined
var bar = 1;

console.log(baz); // ReferenceError: baz is not defined
let baz = 1;
</code></pre>
<p><strong>3.let定义的变量 不准在同一个作用域中被重复定义</strong> （，幸运的是，浏览器会很清晰地报错以提醒你这条规则）：</p>
<pre><code>var count = 30;
let count = 40; //Uncaught SyntaxError: Identifier 'count' has already been declared
</code></pre>
<hr>
<p>const同样有以上的三条规则，即：</p>
<p>1.块级作用域</p>
<p>2.const不再能变量提升</p>
<p>3.const定义的变量是不能被重复定义的</p>
<p>另外，更适合用const而不是let的地方是：声明一个常量，尤其是全局常量的时候。</p>
<blockquote>
<p>另外，const声明的变量<strong>只可以在声明时赋值</strong>，它被设计的本意就是不可随意修改，修改变量会报错，这是最大的特点。</p>
</blockquote>
<hr>
<h2 id="以下为详细内容："><a class="header-anchor" href="#以下为详细内容："></a>以下为详细内容：</h2>
<h3 id="let"><a class="header-anchor" href="#let"></a>let</h3>
<p>let的规则其实可以帮助你捕捉可能造成bug的地方，写出更健壮的代码。除了<code>NaN</code>错误以外，每一个异常都能在当前行抛出。</p>
<blockquote>
<p>比如，如果你只是在代码中将<code>var</code>全局搜索替换为<code>let</code>，一些依赖<code>var</code>声明的独特特性（可能你不是故意这样写）的代码可能无法正常运行。再根据异常提示来修改你的代码，会使你的代码更加健壮。</p>
</blockquote>
<h4 id="let的块级作用域"><a class="header-anchor" href="#let的块级作用域"></a>let的块级作用域</h4>
<p><code>let</code>与<code>var</code>一样，也可以用来声明变量，但let有着更好的作用域规则：</p>
<p><strong>let声明的变量拥有块级作用域。</strong> 也就是说用<code>let</code>声明的变量的作用域只是<strong>外层块</strong>，而不是整个外层函数。</p>
<p>【注意该话题下的细节】：</p>
<ul>
<li><strong>let声明的全局变量不是全局对象的属性。</strong> 这就意味着，你<strong>不可以</strong>通过<code>window.变量名</code>的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的<strong>外层块</strong>。</li>
<li><strong>形如for (let i…)的循环在每次迭代时都为 i 创建新的绑定。</strong></li>
</ul>
<h5 id="例如：-如果你看不懂解释-只要记住例子的结果就行了"><a class="header-anchor" href="#例如：-如果你看不懂解释-只要记住例子的结果就行了"></a>// 例如：（如果你看不懂解释，只要记住例子的结果就行了）</h5>
<p>可以先看一个<strong>循环内变量过度共享</strong>的例子：</p>
<pre><code>var messages = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
for (var i = 0; i &lt; messages.length; i++) {
	setTimeout(function () {
		console.log(messages[i]);
	}, i * 500);
}
// 控制台输出三次 &quot;undefined&quot;
</code></pre>
<p>控制台的输出结果可能会不同于你的预期，输出了三次“undefined”。</p>
<h5 id="解释该例："><a class="header-anchor" href="#解释该例："></a>// 解释该例：</h5>
<p>在 var声明的变量是函数作用域的 的规则下，一共循环了三次，其实用到的都是同一个子函数，这个子函数对应的闭包<strong>最终</strong>保留了循环三次之后变量 i 的值，即为3。</p>
<p>换而言之，由 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">任务队列</a> 的知识我们可知：</p>
<p>当循环结束执行时，i 的值为3（因为<code>messages.length</code>的值为3），此时回调尚未被触发。</p>
<p>然后，所以当第一个timeout执行时，此时i的值已为3，所以打印出来的是<code>messages[3]</code>的值即为“undefined”。</p>
<p>之后同理，第二个、第三个timeout执行时，都是打印<code>messages[3]</code>，也就是“undefined”。</p>
<h5 id="而如果我们在该例中使用的是let："><a class="header-anchor" href="#而如果我们在该例中使用的是let："></a>// 而如果我们在该例中使用的是let：</h5>
<pre><code>var messages = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
for (let i = 0; i &lt; messages.length; i++) {
	setTimeout(function () {
		console.log(messages[i]);
	}, i * 500);
}
// 控制台输出 &quot;A&quot; &quot;B&quot; &quot;C&quot;，符合我们的预期
</code></pre>
<p><code>for (let i...)</code>循环执行三次，<strong>每次循环都会产生新的块级作用域，</strong> 并且 为 每次循环里面的函数 保持了一个闭包，那么每个闭包将捕捉当时循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。</p>
<blockquote>
<p>因为let是块级作用域规则，</p>
<p>而每一次循环都是进入新的块级作用域，都会创建一个新的变量 i，并将其初始化为 i 的当前值，所以每一次循环中创建的各个函数都能有属于它们自己的 i 的副本（值分别为 0 1 2）。</p>
<p>由于这些timeout函数都需要被推入 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">任务队列</a> ，稍后再执行，所以最终为它们每一个都保留了一个闭包。</p>
<ul>
<li>第一个timeout函数对应的闭包中保留了一个值为0的 i 的副本，它执行时输出messages[0]</li>
<li>第二个timeout函数对应的闭包中保留了一个值为1的 i 的副本，它执行时输出messages[1]</li>
<li>第三个timeout函数对应的闭包中保留了一个值为2的 i 的副本，它执行时输出messages[2]</li>
</ul>
<p>（所谓的俗称的“加载”，其实就是 执行流 执行到该函数的声明。）</p>
<p>结合这个例子，我们对闭包的理解为：如果一个子函数需要在 其父函数的作用域 之外被执行，那么<strong>在这个子函数被加载时，</strong> 会先去分析子函数用到了父函数的哪些变量和指针，并且在内存中形成一个闭包保存<strong>这个时刻的</strong>这些父函数的变量和指针的值，以供 对应的子函数在执行的时候 使用。</p>
<ul>
<li>可见，子函数是先会被“加载”，然后再会被“执行”。而闭包是在子函数被“加载”的时候形成的。
<ul>
<li>比如，在上例中，setTimeout一次的时候，子函数会被加载一次。（由于在三次循环各不同的块级作用域中，<code>function () { console.log(messages[i]); }</code>总共被加载了三次，所以可视为三个子函数。）</li>
<li>再比如，如果有一个子函数被父函数return的时候，子函数会被加载一次。</li>
</ul>
</li>
<li>可见，闭包和子函数是一一对应的，一个闭包对应着一个子函数。</li>
<li>PS：“子函数在 其父函数的作用域 之外被执行”这种说法等价于：“子函数在 父函数的执行环境被销毁后 被执行”。</li>
</ul>
</blockquote>
<p>所以在上例中，直接可以将<code>var</code>替换为<code>let</code>修复bug。</p>
<p>这种解决办法，适用于现有的三种循环方式：<code>for-of</code>、<code>for-in</code>、以及传统的用分号分隔的类C循环。</p>
<p><strong>刚才的例子有点扯远了，涉及到的知识太多，反正只要记住let有块级作用域，就基本上没问题了。</strong></p>
<h4 id="let不再变量提升"><a class="header-anchor" href="#let不再变量提升"></a>let不再变量提升</h4>
<p><strong>let声明的变量直到执行流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误</strong> 。举个例子：</p>
<pre><code>  function foo() {
  	console.log(&quot;当前值: &quot; + x);  // 引用错误（ReferenceError）
  	...
  	let x = &quot;hello&quot;;
  }
  foo()
</code></pre>
<p>不可访问的这段时间里，变量 x 一直处于作用域中，但是尚未装载，它位于 临时死区（Temporal Dead Zone，简称TDZ）中。</p>
<p>换句话说就是：let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，就会引发错误。因而从作用域顶部到声明变量语句之前的这个区域，被称为“临时死区”。</p>
<p>PS：但是，在let或const声明的作用域之外使用该变量就不会<strong>报错</strong>：</p>
<pre><code>console.log(typeof value);
if(true){
    let value = &quot;blue&quot;;
}
</code></pre>
<h4 id="let不可以重复定义"><a class="header-anchor" href="#let不可以重复定义"></a>let不可以重复定义</h4>
<p>let定义的变量 不准在同一个作用域中被重复定义。</p>
<p>此时，重定义会抛出一个语法错误（SyntaxError）。</p>
<pre><code>var count = 30;
let count = 40; //Uncaught SyntaxError: Identifier 'count' has already been declared
</code></pre>
<p>这一条规则也可以帮助你检测琐碎的小问题。当你全局搜索<code>var</code>替换为<code>let</code>时可能会发现<code>let</code>重定义语法错误。</p>
<ul>
<li>如果你的多个脚本中都声明了相同的全局变量，你最好继续用<code>var</code>声明这些变量。因为如果你换用了<code>let</code>，后加载的脚本都会执行失败并抛出错误；或者你可以考虑使用ES6内建的模块机制。</li>
</ul>
<h3 id="const"><a class="header-anchor" href="#const"></a>const</h3>
<blockquote>
<p>const声明的变量只可以在声明时赋值，它被设计的本意就是不可随意修改，这是最大的特点。</p>
</blockquote>
<p><code>const</code>声明的变量与<code>let</code>声明的变量类似，它们的不同之处在于：</p>
<p>1.<code>const</code>声明的变量不可随意修改，否则会导致SyntaxError（语法错误）：</p>
<pre><code>const MY_PI = 3.14159; // 正确

MY_PI = 5000; // 语法错误（SyntaxError）
MY_PI++; // 虽然换了一种方式，但仍然会导致语法错误
</code></pre>
<p>2.<strong>用 const 声明变量后必须要赋值，否则也抛出语法错误。</strong></p>
<pre><code>const MY_NEW_PI;  // 依然是语法错误
</code></pre>
<h4 id="注意1："><a class="header-anchor" href="#注意1："></a>// 注意1：</h4>
<p>const声明不允许修改绑定，但允许修改值。</p>
<p>即：对象属性不在const的保护范围之内：</p>
<pre><code>// 常量可以定义成对象
const MY_OBJECT = {&quot;key&quot;: &quot;value&quot;};

// 重写对象会失败
MY_OBJECT = {&quot;OTHER_KEY&quot;: &quot;value&quot;};

// 但对象属性并不在保护的范围内，下面这个声明会成功执行
MY_OBJECT.key = &quot;otherValue&quot;;

// 也可以用来定义数组
const MY_ARRAY = [];
// 可以向数组填充数据
MY_ARRAY.push('A'); // [&quot;A&quot;]
// 但是，将一个新数组赋给变量会引发错误
MY_ARRAY = ['B']
</code></pre>
<h4 id="注意2："><a class="header-anchor" href="#注意2："></a>// 注意2：</h4>
<p>因为const声明的变量不能改变，所以普通的for循环不能用const声明循环变量。</p>
<p>而由于for-in循环中每次迭代不会修改已有绑定，而是创建一个新绑定，所以在for-in循环中可以使用const：</p>
<pre><code>for(const key in obj){
       console.log(key);
}
</code></pre>
<h2 id="能用let和const的环境"><a class="header-anchor" href="#能用let和const的环境"></a>能用let和const的环境</h2>
<p>如果要在web上使用<code>let</code>和<code>const</code>特性，你需要使用一个诸如<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>、<a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="noopener">Traceur</a>或<a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a>的ES6转译器。（Babel和Traceur暂不支持临时死区特性。）</p>
<p>io.js支持<code>let</code>和<code>const</code>，但是只在严格模式下编码可以使用。Node.js同样支持，但是需要启用<code>--harmony</code>选项。</p>
<blockquote>
<p>本人对“临时死区”的理解有限，但是想深入理解的话再单独研究它就可以了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 作用域 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 任务队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript Date对象回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/05/07/js-date/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<p>Date 对象：涉及基于1970年1月1日(世界标准时间)起的毫秒数。</p>
<a id="more"></a>
<h2 id="构造函数"><a class="header-anchor" href="#构造函数"></a>构造函数</h2>
<pre><code>new Date();
// 依据系统设置的当前时间来创建一个Date对象
new Date(value);
// value 代表自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数。表达式的结果为一个字符串。
new Date(dateString);
// new Date(&quot;05 October 2011 14:48 UTC&quot;);
new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);
// 注意：month 代表月份的整数值从0（1月）到11（12月）。
</code></pre>
<p>解释：</p>
<ul>
<li>如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。</li>
<li><strong>JavaScript的Date对象为跨平台提供了统一的行为。</strong> 时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。</li>
<li>JavaScript 的Date对象提供了数个UTC时间的方法，也相应提供了当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。</li>
</ul>
<ul>
<li><strong>以一个函数的形式来调用JavaScript的Date对象（i.e., 不使用new操作符）会返回一个代表当前日期和时间的字符串。</strong></li>
</ul>
<h2 id="方法"><a class="header-anchor" href="#方法"></a>方法</h2>
<pre><code>Date.now()
// 返回自 1970-1-1 00:00:00  UTC (时间标准时间)至今所经过的毫秒数。也可以直接new Date()
Date.parse()
// 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。IE9
Date.UTC()
// 接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。
</code></pre>
<h2 id="实例方法"><a class="header-anchor" href="#实例方法"></a>实例方法</h2>
<h3 id="date-prototype-getmonth"><a class="header-anchor" href="#date-prototype-getmonth"></a>Date.prototype.getMonth()</h3>
<p>根据本地时间返回指定日期对象的月份（0-11）。（0表示一年中的第一月）</p>
<h3 id="date-prototype-gettime"><a class="header-anchor" href="#date-prototype-gettime"></a>Date.prototype.getTime()</h3>
<pre><code>new Date(1994, 1, 10)
// Thu Feb 10 1994 00:00:00 GMT+0800 (中国标准时间)
new Date(1994, 1, 10).getTime()
// 760809600000
</code></pre>
<h4 id="利用gettime-创建一个拥有相同时间值的日期对象："><a class="header-anchor" href="#利用gettime-创建一个拥有相同时间值的日期对象："></a>利用getTime()创建一个拥有相同时间值的日期对象：</h4>
<pre><code>var birthday = new Date(1994, 12, 10)
var copy = new Date()
copy.setTime(birthday.getTime())
</code></pre>
<h3 id="date-prototype-toutcstring"><a class="header-anchor" href="#date-prototype-toutcstring"></a>Date.prototype.toUTCString()</h3>
<p>而Date.prototype.toISOString()其实也同理：</p>
<pre><code>var today = new Date();
var UTCstring = today.toUTCString()
// Mon, 03 Jul 2006 21:44:38 GMT
</code></pre>
<blockquote>
<p>GMT和UTC：</p>
<p>从理论上说，GMT和UTC应该是两回事。</p>
<p>但是由于一开始设计者的失误，现在我们将错就错，在JavaScript Date对象的范畴里面，我们把GMT和UTC看做是同一回事。</p>
</blockquote>
<h3 id="date-prototype-totimestring"><a class="header-anchor" href="#date-prototype-totimestring"></a>Date.prototype.toTimeString()</h3>
<p><code>toTimeString()</code> 方法以人类易读形式返回一个日期对象时间部分的字符串，该字符串以美式英语格式化。</p>
<p>Date 对象的实例引用一个具体的时间点。 调用 toString 方法以美式英语和人类易读的形式，返回日期对象的格式化字符串。</p>
<p>而<code>toDateString()</code>也同理：</p>
<pre><code>var d = new Date(1993, 6, 28, 14, 39, 7)

console.log(d.toString());     // &quot;Wed Jul 28 1993 14:39:07 GMT+0800 (中国标准时间)&quot;
console.log(d.toTimeString()); // &quot;14:39:07 GMT+0800 (中国标准时间)&quot;

console.log(d.toString());     // &quot;Wed Jul 28 1993 14:39:07 GMT+0800 (中国标准时间)&quot;
console.log(d.toDateString()); // &quot;Wed Jul 28 1993&quot;
</code></pre>
<h2 id="将iso转utc："><a class="header-anchor" href="#将iso转utc："></a>将ISO转UTC：</h2>
<pre><code>new Date(&quot;2017-05-05T12:59:16.373Z&quot;)
// d为&quot;Fri May 05 2017 21:00:20 GMT+0800&quot;
d.toUTCString()
// &quot;Fri, 05 May 2017 13:00:20 GMT&quot;
</code></pre>
<p>如果不想自己折腾的话，就使用别人的轮子吧，<a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment</a>。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[纯vue实现checkbox父子联动]]></title>
      <url>https://alexzhong22c.github.io/2017/05/07/vue-checkbox-table/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/vue-checkbox-table" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-checkbox-table</a></p>
<p><a href="https://alexzhong22c.github.io/vue-checkbox-table/vue-checkbox-table.html">demo</a> (在线演示初次加载会有点慢，请稍等)</p>
<p>vue.js的出现，导致很多小插件的简单实现成为可能。</p>
<p>但是，正是由于<strong>vue的数据绑定</strong>使用起来耦合度太强，导致一些比较常规的插件的实现方式要稍微有所不同。</p>
<a id="more"></a>
<hr>
<p>这是一个带复选框(checkbox)的表格，只用纯vue不用其他框架实现<strong>checkbox父子联动</strong>：</p>
<p><img src="https://cloud.az22c.top/show-vue-checkbox-table.png-az22cgithub" alt></p>
<h2 id="效果："><a class="header-anchor" href="#效果："></a>效果：</h2>
<ul>
<li>表头的checkbox视之为一个全局(global)的checkbox，点击它可以实现“全选”和“全不选”</li>
<li>其他的checkbox视之为表中每个条目的一部分，若被勾选则代表该条目被勾选</li>
<li><strong>如果全部条目的checkbox都被勾上，表头的checkbox会被自动勾上</strong></li>
</ul>
<h2 id="实现："><a class="header-anchor" href="#实现："></a>实现：</h2>
<ul>
<li>每个条目中的checkbox用<code>:value=&quot;item['id']&quot;</code>来绑定，每当被勾选，对应的value(也就是这个id)会被放进<strong>数组checkedIds</strong></li>
<li>用一个<strong>深度 watcher</strong>，通过判断<strong>数组checkedIds</strong>的长度，实现 “如果所有条目被勾选，<strong>变量isAllChecked</strong>变为true，则全局checkbox被自动勾选”</li>
<li>全局checkbox不能用<code>:value</code>来绑定状态，要用<code>:checked</code>和一个<strong>onclick函数</strong>绑定状态，否则逻辑会混乱</li>
</ul>
<h2 id="作用原理链："><a class="header-anchor" href="#作用原理链："></a>作用原理链：</h2>
<h3 id="当我点击全局checkbox："><a class="header-anchor" href="#当我点击全局checkbox："></a>当我点击全局checkbox：</h3>
<ol>
<li>触发一个<strong>onclick函数</strong></li>
<li>改变<strong>数组checkedIds</strong>（因为<code>:value</code>的数据绑定，影响其他checkbox是否会被勾选）</li>
<li>通过一个<strong>深度watcher</strong>得出<strong>变量isAllChecked</strong>的值(因为<code>:checked</code>的数据绑定，影响全局checkbox是否被勾选)</li>
</ol>
<h3 id="当我点击某个条目中的checkbox："><a class="header-anchor" href="#当我点击某个条目中的checkbox："></a>当我点击某个条目中的checkbox：</h3>
<ol>
<li>因为<code>:value</code>的数据绑定，改变<strong>数组checkedIds</strong></li>
<li>通过一个<strong>深度watcher</strong>得出<strong>变量isAllChecked</strong>的值(因为<code>:checked</code>的数据绑定，影响全局checkbox是否被勾选)</li>
</ol>
<h2 id="最后："><a class="header-anchor" href="#最后："></a>最后：</h2>
<p>如果对<code>:value</code>和<code>:checked</code>的用法不清楚可以看看官网的checkbox是怎么写的：</p>
<p><a href="https://cn.vuejs.org/v2/guide/forms.html#checkbox" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/forms.html#checkbox</a></p>
<p>但是官网并没有像这里这样做出一个带复选框的表格。</p>
<p>重申一次，正是由于<strong>vue的数据绑定</strong>使用起来耦合度太强，全局checkbox不能用<code>:value</code>来绑定状态，要用<code>:checked</code>和一个<strong>onclick函数</strong>绑定状态，否则逻辑会混乱。</p>
<p>另，如果你想找<strong>带分页导航条的</strong>demo，可以参考我的：</p>
<p><a href="https://github.com/AlexZhong22c/vue-table-nav" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-table-nav</a></p>
<blockquote>
<p>如果各位看官喜欢的话留一个Star吧！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 全选 </tag>
            
            <tag> 复选框 </tag>
            
            <tag> 表格 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[经典vue单页路由入门全家桶]]></title>
      <url>https://alexzhong22c.github.io/2017/04/25/vue-time-tracker/</url>
      <content type="html"><![CDATA[<p>vue-cli + vue2 + vue-router + axios + vuex2 + express + mongoose</p>
<p>一个简单的ToDoList——经典vue单页路由入门全家桶，我在大神们demo的基础上不断地改进。</p>
<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/vue-time-tracker" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-time-tracker</a></p>
<a id="more"></a>
<ul>
<li>使用vue-cli创建项目</li>
<li>.vue文件组件化的开发</li>
<li>使用vue-router实现单页路由</li>
<li>使用axios请求我们的node服务端，即express</li>
<li>使用vuex管理我们的数据流</li>
<li>express 和 MongoDB做后台和数据库，演示了前后台的数据交互，ajax请求</li>
<li>使用mongoose操作MongoDB</li>
</ul>
<p>“计划列表”界面</p>
<p><img src="https://cloud.az22c.top/time-tracker1.png-az22cgithub" alt="演示图1"></p>
<p>创建任务：</p>
<p><img src="https://cloud.az22c.top/time-tracker2.png-az22cgithub" alt="演示图2"></p>
<h2 id="运行demo"><a class="header-anchor" href="#运行demo"></a>运行demo:</h2>
<p>用<code>npm install</code>之后，总共需要打开两个命令行窗口，一个命令行运行：</p>
<pre><code>node app.js // 会在8888端口开启一个后台
</code></pre>
<p>另一个命令行运行：</p>
<pre><code>npm run dev
</code></pre>
<h3 id="历史版本的commit记录："><a class="header-anchor" href="#历史版本的commit记录："></a>历史版本的commit记录：</h3>
<table>
<thead>
<tr>
<th>commit名</th>
<th>commit时间</th>
<th>版本内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>finish-first-time</td>
<td>2017/4/25</td>
<td>vue-cli + vue2 + vue-router + vue-resource + vuex2 + express + MongoDB</td>
</tr>
<tr>
<td>use-mongoose</td>
<td>2017/4/26</td>
<td>使用mongoose，重写app.js文件，使其简单易懂</td>
</tr>
<tr>
<td>use-axios</td>
<td>2017/5/2</td>
<td>使用axios代替原来的vue-resource</td>
</tr>
</tbody>
</table>
<h2 id="懒人速查"><a class="header-anchor" href="#懒人速查"></a>懒人速查</h2>
<h3 id="main-js文件"><a class="header-anchor" href="#main-js文件"></a>main.js文件</h3>
<ul>
<li><code>main.js</code>将会作为我们应用的入口文件而<code>App.vue</code>会作为我们应用的初始化组件</li>
</ul>
<ul>
<li><code>...App</code>这句代码等价于<code>render:h =&gt; h(App)</code></li>
<li>使用axios代替原来的vue-resource做ajax请求</li>
</ul>
<h4 id="eslint-disable-no-new"><a class="header-anchor" href="#eslint-disable-no-new"></a>eslint-disable no-new</h4>
<p>我们这个项目是用vue-cli帮助配置生成的，如果在生成时你选择了启用eslint检测语法，那么eslint默认是不允许你使用new的，如果eslint不通过会报错，你的项目因此就无法让webpack用浏览器调试。</p>
<p>解决办法有很多，正如它提示的一样：eslint-disable no-new，就是去项目的根目录找到.eslintrc.js配置文件，然后在rules字段里面添加<code>&quot;no-new&quot;: 0</code>，取消对no-new规则的检查，就像是这样：</p>
<pre><code>  'rules': {
    // allow paren-less arrow functions
    'arrow-parens': 0,
    &quot;no-new&quot;: 0,
    // allow async-await
    'generator-star-spacing': 0,
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0
  }
</code></pre>
<p>此后，当我们调试或者打包项目的时候就不会因为这个new语法报错。</p>
<p>如果你想要了解各个eslint配置的含义，强烈推荐去 <a href="http://eslint.cn/" target="_blank" rel="noopener">eslint中文官网</a> 在官网用搜索栏一搜就能查到含义。</p>
<p>另外，可以看到这个demo的eslint配置主要是在引入 <em>eslint-config-standard</em> 的基础上稍稍修改的，其他的配置如果你不想浪费时间在自定义上，你可以参考我的博文：<a href="https://alexzhong22c.github.io/2017/03/11/try-eslint/">https://alexzhong22c.github.io/2017/03/11/try-eslint/</a></p>
<h3 id="app-vue文件"><a class="header-anchor" href="#app-vue文件"></a>App.vue文件</h3>
<ul>
<li><code>main.js</code>将会作为我们应用的入口文件而<code>App.vue</code>会作为我们应用的初始化组件</li>
<li><a href="#%60ready%60%E8%A2%AB%E5%BA%9F%E9%99%A4"><code>ready</code>已被废除</a> ，见本项目的App.vue 或 <a href="https://cn.vuejs.org/v2/guide/migration.html#ready-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></li>
</ul>
<h3 id="timeentries-vue文件"><a class="header-anchor" href="#timeentries-vue文件"></a>TimeEntries.vue文件</h3>
<ul>
<li><a href="#%60$dispatch%60%E8%A2%AB%E5%BA%9F%E9%99%A4"><code>$dispatch</code>已被废除</a> ，本demo使用的就是vuex，见本项目TimeEntries.vue文件和src/store下的各个文件夹或 <a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></li>
</ul>
<p>总结：<strong>在vue2.0中废除了使用事件的方式进行通信，所以在小项目中我们可以使用Event Bus，其余最好都使用vuex，本demo我们使用Vuex来实现数据通信</strong>。</p>
<pre><code>// this.$dispatch('deletePlan', timeEntry)，事件*通信*的写法
// $dispatch是vue1.x的写法，现已被废除，改为vuex来*通信*：
this.$store.dispatch('deletePlan', timeEntry)，用vuex*通信*
</code></pre>
<h3 id="logtime-vue文件"><a class="header-anchor" href="#logtime-vue文件"></a>LogTime.vue文件</h3>
<ul>
<li>组件可以没有“name&quot;，如果给组件一个name可以方便在调试的时候在控制台打印错误是来自哪个组件的</li>
<li>对 <a href="#axios%E5%9C%A8vue%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">axios</a> 的用法做了粗浅介绍</li>
</ul>
<h3 id="app-js文件"><a class="header-anchor" href="#app-js文件"></a>app.js文件</h3>
<blockquote>
<p>demo经过了版本更新，原本使用MongoClient，现在用mongoose改写了一次</p>
</blockquote>
<h4 id="mpromise-mongoose-s-default-promise-library-is-deprecated"><a class="header-anchor" href="#mpromise-mongoose-s-default-promise-library-is-deprecated"></a>mpromise (mongoose’s default promise library) is deprecated</h4>
<p><a href="http://blog.csdn.net/fd214333890/article/details/53486862" target="_blank" rel="noopener">http://blog.csdn.net/fd214333890/article/details/53486862</a></p>
<p>增加一句： <code>mongoose.Promise = global.Promise</code> 即可</p>
<h4 id="mongoose是怎么找collections的"><a class="header-anchor" href="#mongoose是怎么找collections的"></a>mongoose是怎么找collections的?</h4>
<p><a href="https://cnodejs.org/topic/4f71363f8a04d82a3d1e4aea" target="_blank" rel="noopener">https://cnodejs.org/topic/4f71363f8a04d82a3d1e4aea</a></p>
<pre><code>mongoose.model('User', UserSchema);
</code></pre>
<p>去命令行：</p>
<pre><code>use node_club show collections //只能看到有一个名为users的collection，而没有User的collection
</code></pre>
<p>由此我们可以推断mongoose在内部创建collection时将我们传递的collection名小写化，同时如果小写化的名称后面没有字母——s,则会在其后面添加一s,针对我们刚建的collection,则会命名为：users。</p>
<p><strong>可以通过下面两种方式更改collection的名字：</strong></p>
<pre><code>1.xxschema = new Schema({
…
}, {collection: “your collection name”});

2.mongoose.model(‘User’, UserSchema, “your collection name”);
</code></pre>
<h2 id="深入理解数据的请求"><a class="header-anchor" href="#深入理解数据的请求"></a>深入理解数据的请求</h2>
<h3 id="生命周期和数据请求的时机"><a class="header-anchor" href="#生命周期和数据请求的时机"></a>生命周期和数据请求的时机</h3>
<p>vue实例的生命周期看这一篇：<a href="http://blog.csdn.net/sexy_squirrel/article/details/60764504" target="_blank" rel="noopener">http://blog.csdn.net/sexy_squirrel/article/details/60764504</a></p>
<p>同样是向后台请求数据，App.vue是在mounted的时机，而TimeEntries是在created的时机。</p>
<p>那主要是因为我们需要先挂载好App组件，然后再请求数据。</p>
<p>而TimeEntries要等到请求完数据之后才会挂载上去，所以我们为TimeEntries做了一个loading提示，代表正在请求数据。</p>
<h3 id="导航钩子和数据请求的时机"><a class="header-anchor" href="#导航钩子和数据请求的时机"></a>导航钩子和数据请求的时机</h3>
<p>强烈推荐看这一篇：<a href="https://github.com/vuefe/vuefe.github.io/blob/1f6e110db81a0a385955ce4ec998f23e7190d2a9/src/router/advanced/data-fetching.md" target="_blank" rel="noopener">https://github.com/vuefe/vuefe.github.io/blob/1f6e110db81a0a385955ce4ec998f23e7190d2a9/src/router/advanced/data-fetching.md</a></p>
<h3 id="vuex和数据请求"><a class="header-anchor" href="#vuex和数据请求"></a>vuex和数据请求</h3>
<p>谈一谈下面这一段被注释的代码：</p>
<pre><code>    watch: {
      如果路由有变化，会再次执行该方法，进入和离开都会触发
      由于我们用了vuex--让timeEntries作为计算属性就能拿到数据，不必fetchData
      '$route': 'fetchData'
    },
</code></pre>
<ul>
<li>我们经常拿计算属性和watch做对比</li>
<li>一般vue组件从vuex的state拿到数据的方式有二：
<ul>
<li>一个是计算属性</li>
<li>一个是封装getter函数再调用getter(适用于多个组件都需要相同的state数据的情况)</li>
</ul>
</li>
<li>vuex其实相当于一个前台的小数据库</li>
<li>使用vuex的一大特点就是：有vuex帮忙管理数据，<strong>应用一开始从后台拿大量的数据也不会混乱</strong>，之后用户每次增删改查一小部分数据的时候，先ajax让后台数据库实现增删改查，成功之后直接通过vuex的actions–&gt;mutations–&gt;state来增删改查state那里的数据就行了。
<ul>
<li>因为ajax比较容易失败，所以一般都是ajax成功之后，再在回调函数中同步对应的前台state数据</li>
</ul>
</li>
<li><strong>尤其是“查”，页面切换回来或者路由切换回来的时候，需要重复再查一次此页的数据。</strong> 使用vuex后，查数据不必去用ajax访问数据库，直接从state查数据就行了</li>
</ul>
<p>结论：使用vuex后，原本这次需要调用fetchData函数去再查数据库，而现在直接用计算属性从state那里查就行了。</p>
<hr>
<blockquote>
<p>2017/5/2更新：使用axios代替原来的vue-resource：</p>
</blockquote>
<h3 id="axios在vue中如何使用"><a class="header-anchor" href="#axios在vue中如何使用"></a>axios在vue中如何使用</h3>
<p>安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能在每个需要发送请求的组件中即时引入。</p>
<p>为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，（另一种是在vuex的actions内封装一下，由于考虑到某些小伙伴不使用vuex，我们选用第一种方法）。</p>
<blockquote>
<p>对这方面好奇的同学可以参考：<a href="http://blog.csdn.net/fen747042796/article/details/70660419?locationNum=6&amp;fps=1" target="_blank" rel="noopener">http://blog.csdn.net/fen747042796/article/details/70660419?locationNum=6&amp;fps=1</a></p>
</blockquote>
<p>在 main.js 中引入 axios：</p>
<pre><code>import axios from 'axios'
Vue.prototype.$ajax = axios
// 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $ajax 命令
</code></pre>
<p><a href="http://www.cnblogs.com/wisewrong/p/6402183.html" target="_blank" rel="noopener">http://www.cnblogs.com/wisewrong/p/6402183.html</a></p>
<h4 id="回调函数的this"><a class="header-anchor" href="#回调函数的this"></a>回调函数的this</h4>
<p>当请求成功时，会执行 .then，否则执行 .catch</p>
<p>这两个回调函数都有各自独立的作用域，<strong>如果直接在里面访问 this，将会无法访问到 Vue 实例</strong>，所以我们改为用箭头函数，详见demo中LogTime.vue文件的注释说明。</p>
<p><a href="https://segmentfault.com/q/1010000005932552" target="_blank" rel="noopener">https://segmentfault.com/q/1010000005932552</a></p>
<p><a href="http://blog.csdn.net/qtwwyl/article/details/70094361?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.csdn.net/qtwwyl/article/details/70094361?utm_source=itdadao&amp;utm_medium=referral</a></p>
<h2 id="深入理解vuex"><a class="header-anchor" href="#深入理解vuex"></a>深入理解vuex</h2>
<h3 id="state的数据在内存中"><a class="header-anchor" href="#state的数据在内存中"></a>state的数据在内存中</h3>
<p>vuex的本质作用是管理组件之间复杂的状态的（如购物车逻辑等等…）,所以当F5刷新浏览器时，这些状态也会一并被清空。</p>
<p>如果想在F5之后不要丢失数据，一般都会采用cookie或者localStorage等方法存储：</p>
<p><a href="https://segmentfault.com/q/1010000007336361" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007336361</a></p>
<p><a href="https://www.zhihu.com/question/54164220/answer/138185671" target="_blank" rel="noopener">https://www.zhihu.com/question/54164220/answer/138185671</a></p>
<h3 id="既然vuex2-可以直接去store拿state-那getters还有什么用啊"><a class="header-anchor" href="#既然vuex2-可以直接去store拿state-那getters还有什么用啊"></a>既然vuex2 可以直接去store拿state, 那getters还有什么用啊?</h3>
<p>getters可以看做是store的计算属性。另外，我们最好遵循vuex的通讯流程：</p>
<h4 id="vuex单向数据流"><a class="header-anchor" href="#vuex单向数据流"></a>vuex单向数据流</h4>
<p>Vuex实际上是类<a href="https://link.juejin.im/?target=https%3A%2F%2Ffacebook.github.io%2Fflux%2F" target="_blank" rel="noopener">Flux</a>的数据管理架构。下面这张图很好的诠释了Vuex和组件之间的通讯关系。</p>
<p><img src="https://cloud.az22c.top/vuex.png-az22cgithub" alt="Vuex和组件之间的通讯关系"></p>
<p>这个图告诉我们不应该直接在vue Components去操作state中的数据，而是应该按照vue Components–&gt;actions–&gt;mutations–&gt;state这个过程来操作数据。</p>
<blockquote>
<p>组件永远都不应该直接改变 Vuex store 的状态。因为我们想要让状态的每次改变都很明确且可追踪，Vuex 状态的所有改变都必须在 store 的 mutation handler (变更句柄)中管理。</p>
</blockquote>
<h3 id="区分-actions-和-mutations"><a class="header-anchor" href="#区分-actions-和-mutations"></a>区分 actions 和 mutations</h3>
<p>更改 Vuex 的 store 中的<strong>状态</strong>的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行<strong>状态</strong>更改的地方，并且它会接受 state 作为第一个参数。</p>
<h4 id="mutation-必须是同步函数-什么意思"><a class="header-anchor" href="#mutation-必须是同步函数-什么意思"></a>mutation 必须是同步函数，什么意思?</h4>
<p>一条重要的原则就是要记住mutation 必须是<strong>同步函数</strong>，即<strong>不准在mutations中编写异步回调的操作。</strong></p>
<pre><code>mutations: {
  someMutation (state) {
    api.callAsyncMethod(() =&gt; {
      // 这句话在异步函数的回调函数中 
      state.count++
    })
  }
}
</code></pre>
<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。</p>
<p>然而，在上面的例子中 mutation 中的<strong>异步函数中的回调</strong>让这不可能完成：(当 mutation 触发的时候，回调函数还没有被调用)，devtools 不知道什么时候<strong>回调函数实际上被调用</strong> —— 实质上任何在回调函数中进行的的状态的改变都是不可追踪记录的。</p>
<h5 id="从另一个角度去理解："><a class="header-anchor" href="#从另一个角度去理解："></a>从另一个角度去理解：</h5>
<p><code>Store</code>理解为一个仓库，<code>action</code>是一次操作，<code>mutation</code>是让仓库中存储的东西产生某种变化的方式，<code>state</code>则是存储的东西当前的状态。</p>
<p>一个操作可能需要对数据产生变动，另一个操作也需要对数据产生同样的变动，那这个变动可以抽取出来，称为一个<code>mutation</code>，这样，通过<code>commit</code>触发指定<code>的mutation</code>就可以了, 不必使其与操作业务的代码混在一起，导致代码混乱、可维护性差的结果。</p>
<h5 id="作者在知乎上的解释："><a class="header-anchor" href="#作者在知乎上的解释："></a>作者在知乎上的解释：</h5>
<p>区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪记录状态的变化。</p>
<p>事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点。[在 redux 里面就好像 reducer 必须同步返回(而不能异步返回)下一个状态一样。]</p>
<p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p>
<p>如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。其实尤雨溪有个点子一直没时间做，那就是把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助。</p>
<p>作者：尤雨溪链接：<a href="https://www.zhihu.com/question/48759748/answer/112823337" target="_blank" rel="noopener">https://www.zhihu.com/question/48759748/answer/112823337</a></p>
<h3 id="mutations-需遵守-vue-的响应规则"><a class="header-anchor" href="#mutations-需遵守-vue-的响应规则"></a>Mutations 需遵守 Vue 的响应规则</h3>
<p>1. 最好提前在你的 store 中初始化好所有所需属性。</p>
<p>2. 当需要在对象上添加<strong>新属性</strong>时，你应该</p>
<ul>
<li>使用 <code>Vue.set(obj, 'newProp', 123)</code>, 或者 -</li>
<li>以新对象替换老对象。例如，利用 stage-3 的<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">对象展开运算符</a>我们可以这样写：</li>
</ul>
<pre><code>  state.obj = { ...state.obj, newProp: 123 }
</code></pre>
<p>(这个demo并没有为对象添加新属性的操作，这里只是提醒一下有这个知识点)</p>
<h2 id="vue2-新旧替换"><a class="header-anchor" href="#vue2-新旧替换"></a>vue2 新旧替换</h2>
<h3 id="ready被废除"><a class="header-anchor" href="#ready被废除"></a><code>ready</code>被废除</h3>
<p>使用新的 <code>mounted</code> 钩子函数替代。应该注意的是，使用 <code>mounted</code> 并不能保证钩子函数中的 <code>this.$el</code> 在 document 中。为此还应该引入 <code>Vue.nextTick</code>/<code>vm.$nextTick</code>。例如：</p>
<pre><code class="language-vue">mounted: function () {
  this.$nextTick(function () {
    // 使用$nextTick，代码保证 this.$el 在 document 中
  })
}
</code></pre>
<p>见本项目的App.vue 或 <a href="https://cn.vuejs.org/v2/guide/migration.html#ready-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></p>
<h3 id="dispatch被废除"><a class="header-anchor" href="#dispatch被废除"></a><code>$dispatch</code>被废除</h3>
<p>总结：<strong>在vue2.0中废除了使用事件的方式进行通信，所以在小项目中我们可以使用Event Bus，其余最好都使用vuex，本demo我们使用Vuex来实现数据通信</strong>。</p>
<pre><code>// this.$dispatch('deletePlan', timeEntry)，事件*通信*的写法
// $dispatch是vue1.x的写法，现已被废除，改为vuex来*通信*：
this.$store.dispatch('deletePlan', timeEntry)，用vuex*通信*
</code></pre>
<p><code>$dispatch</code> 和 <code>$broadcast</code> 已经被弃用。因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好。</p>
<p>对于<code>$dispatch</code> 和 <code>$broadcast</code>最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。</p>
<blockquote>
<p>这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 <a href="https://cn.vuejs.org/v2/guide/components.html#Form-Input-Components-using-Custom-Events" target="_blank" rel="noopener"><code>v-on</code>监听子组件上 $emit 的变化</a>。这可以允许你很方便的添加事件显性。</p>
<p>然而，如果是跨多层父子组件通信的话， <code>$emit</code> 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。（这会让组件之间的通信非常顺利，即使是兄弟组件。）</p>
</blockquote>
<h4 id="单独的事件中心"><a class="header-anchor" href="#单独的事件中心"></a>单独的事件中心</h4>
<p>比如，假设我们有个 todo 的应用结构如下：</p>
<pre><code>Todos
|-- NewTodoInput
|-- Todo
    |-- DeleteTodoButton
</code></pre>
<p>可以通过单独的事件中心管理组件间的通信：</p>
<pre><code>// 将在各处使用该事件中心
// 组件通过它来通信
var eventHub = new Vue()
</code></pre>
<p>然后在组件中，可以使用 <code>$emit</code>, <code>$on</code>, <code>$off</code> 分别来分发、监听、取消监听事件：</p>
<pre><code>// NewTodoInput
// ...
methods: {
  addTodo: function () {
    eventHub.$emit('add-todo', { text: this.newTodoText })
    this.newTodoText = ''
  }
}
// --------------------------------------------
// DeleteTodoButton
// ...
methods: {
  deleteTodo: function (id) {
    eventHub.$emit('delete-todo', id)
  }
}
// --------------------------------------------
// Todos
// ...
created: function () {
  eventHub.$on('add-todo', this.addTodo)
  eventHub.$on('delete-todo', this.deleteTodo)
},
// 最好在组件销毁前
// 清除事件监听
beforeDestroy: function () {
  eventHub.$off('add-todo', this.addTodo)
  eventHub.$off('delete-todo', this.deleteTodo)
},
methods: {
  addTodo: function (newTodo) {
    this.todos.push(newTodo)
  },
  deleteTodo: function (todoId) {
    this.todos = this.todos.filter(function (todo) {
      return todo.id !== todoId
    })
  }
}
</code></pre>
<p>在简单的情况下可以这样用事件中心替代 <code>$dispatch</code> 和 <code>$broadcast</code>，但是对于大多数复杂情况，更推荐使用一个专用的状态管理层如：<a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">Vuex</a> ，Vuex意味着更多简明清晰的组件间通信和更好的状态管理方案。</p>
<h5 id="vuex"><a class="header-anchor" href="#vuex"></a>vuex</h5>
<p>本demo使用的就是vuex，见本项目TimeEntries.vue文件和src/store下的各个文件夹或 <a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">官网原文</a></p>
<h2 id="最后还有小尾巴："><a class="header-anchor" href="#最后还有小尾巴："></a>最后还有小尾巴：</h2>
<ul>
<li>后台的代码主要在app.js文件里，已经解决了跨域请求的问题，还没有解释这部分代码</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> express </tag>
            
            <tag> MongoDB </tag>
            
            <tag> vuex </tag>
            
            <tag> 异步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[按条目展示表格数据小插件]]></title>
      <url>https://alexzhong22c.github.io/2017/04/15/vue-table-nav/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/vue-table-nav" target="_blank" rel="noopener">https://github.com/AlexZhong22c/vue-table-nav</a></p>
<p><a href="https://alexzhong22c.github.io/vue-table-nav/vue-table-nav.html">demo</a> (在线演示初次加载会有点慢，请稍等)</p>
<a id="more"></a>
<hr>
<p>vue.js的出现，导致很多小插件的简单实现成为可能。</p>
<p>这是一个关于表格数据的分页导航，按照表格中的每个条目作为单元来展示数据。</p>
<p><strong>这样的数据呈现方式可读性更强，设计更人性化。</strong></p>
<p>当然它只适用于少量表格数据的直观呈现，如果数据太多，还是用传统的表格来呈现比较合适。demo的下方我还展示了原始的表格，方便各位看官做做对比。</p>
<p><img src="https://cloud.az22c.top/show-vue-table-nav.png-az22cgithub" alt></p>
<h2 id="分页导航"><a class="header-anchor" href="#分页导航"></a>分页导航</h2>
<ul>
<li>可设置每页显示的条目数</li>
<li>用vue的 计算属性 和对象数组的slice()实现分页显示，非常简便</li>
<li>在总页数比较多的情况下仍能维持导航样式的统一</li>
</ul>
<h2 id="引用boostrap的样式"><a class="header-anchor" href="#引用boostrap的样式"></a>引用boostrap的样式</h2>
<ul>
<li>css写得比较潦草，让大家见笑</li>
<li>对于class=“pagination”，直接从bootstrap库复制了那部分的css样式</li>
</ul>
<h2 id="用dl-dt-dd标签展示键值对"><a class="header-anchor" href="#用dl-dt-dd标签展示键值对"></a>用dl dt dd标签展示键值对</h2>
<ul>
<li>阻止dt标签之后的换行</li>
<li>阻止dd标签之前的空白</li>
<li><strong>为了方便阅读，直接用中文作为键值对的键名。在实际工程中当然不能这样。</strong></li>
</ul>
<h2 id="最后："><a class="header-anchor" href="#最后："></a>最后：</h2>
<blockquote>
<p>如果各位看官喜欢的话去留一个Star吧！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 表格 </tag>
            
            <tag> 插件 </tag>
            
            <tag> 条目 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭合浮动和BFC和阻止上下外边距的合并]]></title>
      <url>https://alexzhong22c.github.io/2017/04/01/clearfix-n-bfc/</url>
      <content type="html"><![CDATA[<p>本文部分内容参考 <a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="noopener">那些年我们一起清除过的浮动</a> ，但是 一丝冰凉 的这篇文章有很多地方我都不认同，取其精华去其糟粕，所以本文并没有包含那些我所不认同的内容。</p>
<a id="more"></a>
<h2 id="区分-清除浮动-和-闭合浮动"><a class="header-anchor" href="#区分-清除浮动-和-闭合浮动"></a>区分 清除浮动 和 闭合浮动</h2>
<ul>
<li>清除浮动：清除对应的英文单词是 clear，对应CSS中的属性是 clear：left | right | both | none；</li>
<li>闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。</li>
</ul>
<p>两者的区别 <a href="http://www.iyunlu.com/demo/enclosing-float-and-clearing-float/index.html" target="_blank" rel="noopener">请看Demo</a></p>
<p>闭合浮动主要用来解决<strong>因为子元素浮动导致父元素高度塌陷</strong>的问题。</p>
<h2 id="闭合浮动的一些老方法："><a class="header-anchor" href="#闭合浮动的一些老方法："></a>闭合浮动的一些老方法：</h2>
<ol>
<li>在子元素们的最后追加一个<code>style=&quot;clear:both&quot;</code>的空标签，这个不好</li>
<li>在子元素们的最后追加一个br标签，使用br标签的<code>clear=&quot;all | left | right | none&quot;</code> 属性，因为一般不建议在HTML中使用br，这个也不好</li>
<li>通过<strong>设置父元素</strong>overflow值设置为hidden；在IE6中还需要触发 hasLayout ，例如 zoom：1；因为最终还是有补不了的bug被大家弃用</li>
<li>通过<strong>设置父元素</strong>overflow值设置为auto，同样也有bug</li>
<li>父元素也设置浮动，缺点是<strong>使得与父元素相邻的元素的布局会受到影响</strong>，不可能一直浮动到body，不推荐使用</li>
<li>父元素设置display:table，盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用。文章最后还会再介绍到给<strong>父元素的伪元素设置display:table</strong>。</li>
</ol>
<h3 id="7-使用：after伪元素"><a class="header-anchor" href="#7-使用：after伪元素"></a>7. 使用<code>：after</code>伪元素</h3>
<blockquote>
<p>需要注意的是 :after是伪元素，不是伪类（另外，某些CSS手册里面称之为“伪对象”，不太对）。</p>
</blockquote>
<p>由于IE6-7不支持:after，要同时使用 zoom:1触发IE6和IE7的 hasLayout。<strong>在后面的demo中会介绍到。</strong></p>
<ul>
<li>优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）</li>
<li>缺点：复用方式不当会造成代码量增加</li>
<li>建议：定义公共类，以减少CSS代码</li>
</ul>
<h3 id="不要使用方案3和4"><a class="header-anchor" href="#不要使用方案3和4"></a>不要使用方案3和4</h3>
<p>方案3、4通过overflow闭合浮动，实际上已经创建了新的 块级格式化上下文，而它们设置的对象都是父元素，这将导致其布局和相对于浮动的行为等发生一系列的变化，闭合浮动只不过是一系列变化中的一个作用而已。所以为了闭合浮动去改变全局特性，这是不明智的，带来的风险就是一系列的bug，比如firefox 早期版本产生 focus，截断绝对定位的层等等。始终要明白，如果单单只是需要闭合浮动，overflow就不要使用，而不是某些文章所说的“慎用”。</p>
<h3 id="父级div定义height的方法"><a class="header-anchor" href="#父级div定义height的方法"></a>父级div定义height的方法</h3>
<ul>
<li>父级div定义height，这样就<strong>不必闭合浮动</strong>了</li>
<li>不推荐使用，只建议高度固定的布局时使用</li>
</ul>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>通过对比，我们不难发现，其实以上列举的方法，无非有两类：</p>
<p>其一，通过在浮动元素的末尾添加一个空的元素</p>
<p>其二，通过设置父元素 overflow 或者display：table 属性来闭合浮动，原理就是BFC，下面探讨一下：</p>
<h2 id="bfc知识"><a class="header-anchor" href="#bfc知识"></a>BFC知识</h2>
<p><a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank" rel="noopener">Block formatting contexts </a>（块级格式化上下文），以下简称 BFC。在CSS3里面改动后称之为flow root。</p>
<h3 id="bfc的特性"><a class="header-anchor" href="#bfc的特性"></a>BFC的特性</h3>
<p>一丝冰凉 对于BFC的特征的解释非常模糊，甚至不正确。我认为她这部分内容所解释的现象只适用到IE7</p>
<p>通俗地来说就是：</p>
<ul>
<li>创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反过来外面的元素也不影响里面的元素</li>
<li>同时BFC仍然属于文档中的普通流</li>
</ul>
<h3 id="如何触发bfc"><a class="header-anchor" href="#如何触发bfc"></a>如何触发BFC</h3>
<ul>
<li>float 除了none以外的值</li>
<li>overflow 除了visible 以外的值（hidden，auto，scroll ）</li>
<li>display (table-cell，table-caption，inline-block)</li>
<li>实际上，用<code>display:table</code>来产生匿名框也可以触发BFC，见文章 <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">A new micro clearfix hack</a> 或见本节的备注</li>
<li>position（absolute，fixed）</li>
<li>fieldset元素</li>
</ul>
<blockquote>
<p>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。</p>
<p>fieldset 元素在www.w3.org里目前没有任何有关这个触发行为的信息，直到HTML5标准里才出现。有些浏览器bugs（Webkit，Mozilla）提到过这个触发行为，但是没有任何官方声明。实际上，即使fieldset在大多数的浏览器上都能创建新的块级格式化上下文，开发者也不应该把这当做是理所当然的。CSS 2.1没有定义哪种属性适用于表单控件，也没有定义如何使用CSS来给它们添加样式。用户代理可能会给这些属性应用CSS属性，建议开发者们把这种支持当做实验性质的，更高版本的CSS可能会进一步规范这个。</p>
</blockquote>
<p><strong>由于浏览器的差异：</strong></p>
<ul>
<li>在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动；</li>
<li>在不支持 BFC的浏览器 （IE6-7），通过触发 hasLayout 闭合浮动。IE6-7的hasLayout 可以等同于 BFC。</li>
</ul>
<h2 id="深入理解伪元素闭合浮动"><a class="header-anchor" href="#深入理解伪元素闭合浮动"></a>深入理解伪元素闭合浮动</h2>
<p>上面已经列举了7种闭合浮动的方法，通过第三节分析的原理，我们发现其实更多的：对父元素使用display：table-cell，display：inline-block等只要触发了BFC的属性值都可以闭合浮动。从各个方面比较，<strong>方案7</strong>：after伪元素闭合浮动无疑是相对比较好的解决方案了。这种思路的演进历史可以参考文章：<a href="https://css-tricks.com/snippets/css/clear-fix/" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/clear-fix/</a></p>
<p>而最后，方案7里面有两个最优的小方案：</p>
<h3 id="最优小方案1："><a class="header-anchor" href="#最优小方案1："></a>最优小方案1：</h3>
<pre><code>.clearfix:before, .clearfix:after {
content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both; }

.clearfix { *zoom:1; }
</code></pre>
<p>1）通过 content:&quot;.&quot;生成内容作为伪元素的内容</p>
<p>2）display:block 使生成的元素以块级元素显示,占满剩余空间;</p>
<p>3）height:0 避免生成内容破坏原有布局的高度。</p>
<p>4）visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;</p>
<p>5）同时要使用 zoom:1触发IE6和IE7的 hasLayout</p>
<p><strong>通过分析发现，除了clear：both用来清除浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0的缘故。</strong></p>
<p><strong>更重要的是，我认为这个方法根本就没产生 BFC 。</strong></p>
<blockquote>
<p>另外，不建议将content设置为空字符串&quot;&quot;，在firefox 7里面会看到它会产生空隙</p>
</blockquote>
<h3 id="最优小方案2："><a class="header-anchor" href="#最优小方案2："></a>最优小方案2：</h3>
<pre><code>.clearfix:before,
.clearfix:after {
    content: &quot; &quot;; /* 1 */
    display: table; /* 2 */
}

.clearfix:after {
    clear: both;
}

.clearfix {
    *zoom: 1;
}
</code></pre>
<p>1. 使用content: &quot; &quot; 是为了避免Opera的bug，否则它会在 被清除浮动的元素的顶部和底部 产生一个看得出的空格</p>
<p>2. 这里对伪元素使用的<code>display: table;</code>会产生一个 <a href="http://www.w3.org/TR/CSS2/tables.html#anonymous-boxes" target="_blank" rel="noopener">anonymous boxes</a> 和一个BFC，这个BFC意味着before伪类会阻止上外边距的合并，同时after伪类会闭合浮动。</p>
<blockquote>
<p>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。</p>
</blockquote>
<p>这个小方案的好处是：不用隐藏用content属性产生的内容，并且代码量特别少。</p>
<h4 id="firefox-3-5版本的问题"><a class="header-anchor" href="#firefox-3-5版本的问题"></a>Firefox &lt; 3.5版本的问题</h4>
<p>Firefox &lt; 3.5禁止在body元素和它的第一个子元素之间插入多余的空格，所以</p>
<ul>
<li>要么对before伪类使用<code>content:&quot;.&quot;</code></li>
<li>要么额外加上<code>visibility:hidden</code>等等属性来隐藏这种情况下所插入的字符(但这也不能解释淘宝网闭合浮动的写法，因为淘宝网主要把它用在after伪类上)</li>
</ul>
<h3 id="设置before伪元素的作用："><a class="header-anchor" href="#设置before伪元素的作用："></a>设置before伪元素的作用：</h3>
<p>设定before伪元素的属性<strong>并不是用来闭合浮动的</strong>，不过它能阻止上外边距的合并，这会带来两个好处：</p>
<ul>
<li>这种清除浮动的方式所表现出来的外貌看上去和 其他的清除浮动的方式(比如overflow:hidden)的 一致。</li>
<li>和IE6/7使用zoom:1后的外貌保持一致</li>
</ul>
<p>毕竟，<strong>使用after伪元素闭合浮动</strong>的时候，下外边距的合并已经被阻止了，为了上下看上去对称，before伪元素也应该这样。</p>
<p>主要译自： <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">A new micro clearfix hack</a></p>
<h3 id="创新方案：零宽度空格"><a class="header-anchor" href="#创新方案：零宽度空格"></a>创新方案：零宽度空格</h3>
<p>通过查询发现Unicode字符里有一个“零宽度空格”，也就是<a href="http://www.fileformat.info/info/unicode/char/200b/index.htm" target="_blank" rel="noopener">U+200B </a>，这个字符本身是不可见的，所以我们完全可以省略掉 visibility:hidden了</p>
<pre><code>.clearfix:after {content:&quot;200B&quot;; display:block; height:0; clear:both; }
.clearfix { *zoom:1; }
</code></pre>
<p>在实际开发中，由于存在Unicode字符不适合内嵌CSS的GB2312编码的页面，使用前面两个小方案完全可以解决我们的需求了。</p>
<h3 id="别混淆了闭合浮动-bfc-阻止上下外边距的合并"><a class="header-anchor" href="#别混淆了闭合浮动-bfc-阻止上下外边距的合并"></a>别混淆了闭合浮动/BFC/阻止上下外边距的合并</h3>
<p>这是一个比较详细的 <a href="https://github.com/AlexZhong22c/IFE-CSS-learning/blob/master/%E9%97%AD%E5%90%88%E6%B5%AE%E5%8A%A8%E5%92%8CBFC%E5%92%8C%E9%98%BB%E6%AD%A2%E4%B8%8A%E4%B8%8B%E5%A4%96%E8%BE%B9%E8%B7%9D%E7%9A%84%E5%90%88%E5%B9%B6.html" target="_blank" rel="noopener">demo</a>：</p>
<p>这个demo里面加入了<strong>企图对伪元素用display:block配合content:&quot; &quot;闭合浮动</strong>这种不太恰当的方法。</p>
<p>从这个demo可以看到：</p>
<ul>
<li><strong>使用伪元素闭合浮动</strong>必然会引发的一个效果是阻止下外边距的合并</li>
<li>BFC必然会引发的一个效果是阻止上下外边距的合并</li>
<li>闭合浮动 的方式不只有 触发BFC ，触发BFC 只是其中的一种方法</li>
<li>阻止上下外边距合并的方式不只有 触发BFC，触发BFC 只是其中的一种方法</li>
<li>而那些能触发BFC的方式可以参考本文前文的说明，其中就说明了浮动会触发BFC</li>
<li>单独的display:block并不会触发BFC</li>
<li>对伪元素用display:table会触发BFC</li>
<li>不应当<strong>企图对伪元素用display:block配合content:&quot; &quot;闭合浮动</strong>，因为这种方式的清除浮动 只有在ie7以下的浏览器里才能阻止上下外边距的合并，所以使用它的话不同浏览器的样式会不统一</li>
<li>要小心地对浮动的子元素设置下外边距，因为在IE7以下浏览器里面，如果没有其他子元素撑起父元素的高度，浮动的子元素的下外边距直接被解释为0(这是为了尽量减小页面的高度)，造成样式的不统一</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 清除浮动 </tag>
            
            <tag> BFC </tag>
            
            <tag> 伪元素 </tag>
            
            <tag> 阻止上下外边距合并 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task02笔记]]></title>
      <url>https://alexzhong22c.github.io/2017/04/01/ife-css-task02/</url>
      <content type="html"><![CDATA[<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="noopener">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<p>这篇文章的内容基本没有用在 <a href="https://alexzhong22c.github.io/IFE-CSS-learning/task02.html">demo</a> 中，这只是一番拓展性总结。</p>
<a id="more"></a>
<h2 id="css选择器优先级"><a class="header-anchor" href="#css选择器优先级"></a>CSS选择器优先级</h2>
<p>在文章 <a href="https://alexzhong22c.github.io/2017/03/31/css-selectors-specificity/">CSS选择器优先级</a> 中我整合了这部分笔记。</p>
<h2 id="list-style-xxx"><a class="header-anchor" href="#list-style-xxx"></a>list-style-xxx</h2>
<p>我们常用list-style，实则它是一个 简写属性。</p>
<h3 id="list-style-type"><a class="header-anchor" href="#list-style-type"></a>list-style-type</h3>
<p>而<code>list-style-type</code>在CSS2中的新特性需要至少IE8的支持，所以我们一般只使用它在CSS1中的内容。况且，很少人提及list-style在移动设备浏览器上的支持，所以不能乱用。</p>
<p>另外，任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “decimal-leading-zero”、“lower-greek”、“lower-latin”、“upper-latin”、“armenian”、“georgian” 或 “inherit”。</p>
<p>可以使用的有：</p>
<ul>
<li>none</li>
</ul>
<p>用于无序列表的：</p>
<ul>
<li>disc 实心圆</li>
<li>circle 空心圆</li>
<li>square 实心方块</li>
</ul>
<p>用于有序列表的：</p>
<ul>
<li>decimal 数字</li>
<li>lower-alpha、upper-alpha</li>
<li>lower-roman、upper-roman</li>
</ul>
<h3 id="list-style-position"><a class="header-anchor" href="#list-style-position"></a>list-style-position</h3>
<p>默认值是outside，和inside的区别，看一下 <a href="http://www.w3school.com.cn/tiy/t.asp?f=csse_list-style-position" target="_blank" rel="noopener">demo</a> 马上就清楚</p>
<h3 id="list-style-image"><a class="header-anchor" href="#list-style-image"></a>list-style-image</h3>
<p>使用图像来替换列表项的标记。</p>
<p>这个属性指定作为一个有序或无序列表项标志的图像。图像相对于列表项内容的放置位置通常使用 list-style-position 属性控制。</p>
<p>注释：<strong>请始终规定一个 “list-style-type” 属性以防图像不可用。</strong></p>
<pre><code>ul {
  list-style:square outside url('/i/arrow.gif');
}
</code></pre>
<h2 id="border-collapse"><a class="header-anchor" href="#border-collapse"></a>border-collapse</h2>
<p>默认值是separate，不会忽略border-spacing和empty-cells属性。</p>
<p>collapse会忽略border-spacing和empty-cells属性。</p>
<p>注释：如果没有规定 !DOCTYPE，则 border-collapse 可能产生意想不到的结果。</p>
<h2 id="text-indent"><a class="header-anchor" href="#text-indent"></a>text-indent</h2>
<p>直接参考：<a href="http://ued.ctrip.com/blog/text-indent-summing-up.html" target="_blank" rel="noopener">http://ued.ctrip.com/blog/text-indent-summing-up.html</a></p>
<p>其总结就是：</p>
<p>1.text-indent只用于div，p这样的元素上，像image、input、inline-block、inline元素绝对不用。</p>
<p>2.text-indent的值如果子元素也要用到父元素的值，用px单位，而绝不用em。</p>
<h2 id="禁止用户选择文字"><a class="header-anchor" href="#禁止用户选择文字"></a>禁止用户选择文字</h2>
<p>一般情况下用<code>user-select:none</code>，</p>
<p>IE6-9不支持该属性，但支持使用标签属性 <code>onselectstart=&quot;return false;&quot;</code> 来达到 <code>user-select:none</code> 的效果；Safari和Chrome也支持该标签属性；</p>
<p>直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 <code>unselectable=&quot;on&quot;</code> 来达到 <code>user-select:none</code> 的效果；unselectable 的另一个值是 off；</p>
<p>除Chrome和Safari外，在其它浏览器中，如果将文本设置为 <code>-ms-user-select:none;</code>，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 <code>-ms-user-select:none;</code> 的区域文本；</p>
<p><strong>所以，“禁止用户选择文字”一般是用来引导用户在界面的操作，而不能用来 控制用户的行为 或者 重度依赖这个trick。</strong></p>
<p>参考： <a href="http://www.css88.com/book/css/properties/user-interface/user-select.htm" target="_blank" rel="noopener">user-select-css88</a> 说明很完备。</p>
<pre><code class="language-html">&lt;body&gt;
前方的文字&lt;div class=&quot;test&quot; onselectstart=&quot;return false;&quot; unselectable=&quot;on&quot;&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>CSS代码：</p>
<pre><code class="language-css">.test{
  -webkit-user-select:none;
  -moz-user-select:none;
  -o-user-select:none;
  user-select:none;
  /*onselectstart和unselectable在html那里*/
}
</code></pre>
<p><strong>另外，结合JavaScript代码来实现禁止效果，效果会更好。</strong></p>
<p>例如：<a href="http://stackoverflow.com/questions/2700000/how-to-disable-text-selection-using-jquery" target="_blank" rel="noopener">http://stackoverflow.com/questions/2700000/how-to-disable-text-selection-using-jquery</a></p>
<h2 id="text-align"><a class="header-anchor" href="#text-align"></a>text-align</h2>
<p><a href="http://www.css88.com/book/css/properties/text/text-align.htm" target="_blank" rel="noopener">text-align–CSS88</a> 还介绍了单行文字怎么应用justify</p>
<h2 id="fieldset默认样式隐藏"><a class="header-anchor" href="#fieldset默认样式隐藏"></a>fieldset默认样式隐藏</h2>
<p>看到一篇文章介绍 <a href="http://canfly2010.iteye.com/blog/678584" target="_blank" rel="noopener">Extjs FieldSet组件</a> 的文章很有趣，这个组件的目的是将fieldset的边框去掉或者改变内边距。</p>
<p>学到的一个知识是：</p>
<blockquote>
<p>fieldset默认是带边框的，而legend默认一般显示在左上角。但在某些场合或许不愿意让fieldset和legend的默认样式或默认布局影响设计方案中的美观。</p>
<p>解决方法：在CSS中将fieldset的border设置为0，legend的display设置为none即可。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> list-style </tag>
            
            <tag> 文字 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS选择器优先级]]></title>
      <url>https://alexzhong22c.github.io/2017/03/31/css-selectors-specificity/</url>
      <content type="html"><![CDATA[<p>CSS优先级计算的快速回顾，最后附上一些应用知识的实例。</p>
<a id="more"></a>
<h2 id="计算特殊性值的情况"><a class="header-anchor" href="#计算特殊性值的情况"></a>计算特殊性值的情况</h2>
<p>选择器的特殊性值 由4个位构成，基础值用 0,0,0,0 表示，为了方便描述用 A,B,C,D 分别对应代表各个位：</p>
<p>能令A位增加的：行间样式</p>
<p>能令B位增加的：ID选择器</p>
<p>能令C位增加的：类选择器、属性选择器或伪类</p>
<p>能令D位增加的：元素和伪元素</p>
<p><strong>通配选择器 *</strong> 对特殊性值没有贡献，也当做是经过加 0 计算了</p>
<hr>
<p>例如：以下规则中选择器的特殊性分别是：</p>
<pre><code>a{color: yellow;} /*特殊性值：0,0,0,1*/
div a{color: green;} /*特殊性值：0,0,0,2*/
.demo a{color: black;} /*特殊性值：0,0,1,1*/
.demo input[type=&quot;text&quot;]{color: blue;} /*特殊性值：0,0,2,1*/
.demo *[type=&quot;text&quot;]{color: grey;} /*特殊性值：0,0,2,0*/
#demo a{color: orange;} /*特殊性值：0,1,0,1*/
div#demo a{color: red;} /*特殊性值：0,1,0,2*/
</code></pre>
<p><a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="noopener">验证结果参考demo</a></p>
<h3 id="应对常见疑问："><a class="header-anchor" href="#应对常见疑问："></a>应对常见疑问：</h3>
<ul>
<li>特殊性值不会进位</li>
<li><strong>假如特殊性值相同</strong>的两条规则应用到同一个元素，只有后声明的那条规则会生效</li>
<li>由上文可得：外联样式优先级并不一定低于内联样式</li>
</ul>
<blockquote>
<p>外联样式指的是，样式放在.css文件里，然后html调用该文件</p>
<p>内联样式指的是，样式放在head标签的style标签里面</p>
<p>行内样式指的是，写在具体元素的style属性里面的样式</p>
</blockquote>
<h2 id="不计算特殊性值的情况"><a class="header-anchor" href="#不计算特殊性值的情况"></a>不计算特殊性值的情况</h2>
<ul>
<li><code>!important</code>(权重) 优先于 任何需要计算的特殊性值，可以视它为1,0,0,0,0</li>
<li><strong>通配选择器 *</strong> 定义的规则 优先于 元素<strong>继承</strong>过来的规则</li>
</ul>
<h2 id="not伪类例外"><a class="header-anchor" href="#not伪类例外"></a><code>:not</code>伪类例外</h2>
<p><code>:not</code> 否定伪类 在优先级计算中不会被看作是伪类，但是在计算选择器数量时还是会把<strong>其中的选择器</strong>当做普通选择器进行计数：</p>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
div.outer p {
  color:red;
}
div:not(.outer) p {
  color: blue;
}
&lt;/style&gt;
&lt;div class=&quot;outer&quot;&gt;
  &lt;p&gt;This is in the outer div.&lt;/p&gt;
  &lt;div class=&quot;inner&quot;&gt;
    &lt;p&gt;This text is in the inner div.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>结果：</p>
<p>“This is in the outer div.”红色；“This text is in the inner div.”蓝色。</p>
<p>解释：</p>
<p>选择器div.outer p 和选择器div:not(.outer) p的优先级是相同的。</p>
<p>:not被忽略掉了。</p>
<p>:not(.outer)中的.outer正常计数。</p>
<h2 id="知识应用实例"><a class="header-anchor" href="#知识应用实例"></a>知识应用实例</h2>
<h3 id="a的四种状态实例"><a class="header-anchor" href="#a的四种状态实例"></a>a的四种状态实例</h3>
<p>我们知道a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active。</p>
<p>如果用这四个伪类对同一个元素设置同一个属性，那它们的<strong>声明顺序</strong>应该有一定要求，一般大家都遵循“爱恨原则LVHA”（LoVe HAte），为什么是这个顺序？不能是其它顺序吗？</p>
<blockquote>
<p>当鼠标滑过a链接时，满足:link和:hover两个伪类，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；同理，当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。</p>
</blockquote>
<p>因此得出LVHA这个顺序。</p>
<blockquote>
<p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</p>
</blockquote>
<p><strong>对于:hover在IE6下只有a元素支持，:active只有IE6-7不支持，:focus在IE6-7下不被支持。</strong>  <a href="https://www.quirksmode.org/css/selectors/" target="_blank" rel="noopener">查阅文档</a></p>
<h3 id="继承失效实例"><a class="header-anchor" href="#继承失效实例"></a>继承失效实例</h3>
<h4 id="代码示例："><a class="header-anchor" href="#代码示例："></a>代码示例：</h4>
<pre><code class="language-html">&lt;p&gt;Hello,&lt;span&gt;CSS&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p>CSS代码：</p>
<pre><code class="language-css">* {
    color:red;
}
p {
    color:green;
}
</code></pre>
<p>结果：<code>span</code>标签内的文本颜色是红色，而不是绿色。</p>
<h4 id="解释："><a class="header-anchor" href="#解释："></a>解释：</h4>
<p>我们常用*来做CSS reset，这常见的问题是<strong>导致继承失效</strong>：</p>
<p>继承的样式根本没有任何特殊性，而使用通配选择器<code>*</code>的声明具有0, 0, 0, 0特殊性。当二者冲突时，通配选择器胜出，导致继承失效。</p>
<p>自己写 CSS 时不要滥用 <code>*</code>，reset.css 也只是设置 margin, padding, box-sizing 等少数几个属性时才使用，这几个被重置的属性都不继承。</p>
<p>另外，不要用<code>*</code>设置font-family</p>
<h2 id="进一步理解-important"><a class="header-anchor" href="#进一步理解-important"></a>进一步理解<code>!important</code></h2>
<p>使用<code>!important</code>不是一个好习惯，因为它改变了你样式表本来的级联规则，从而难以调试。</p>
<h3 id="一些不成文规则"><a class="header-anchor" href="#一些不成文规则"></a>一些不成文规则</h3>
<ul>
<li><strong>不要</strong>在全站范围的css中使用<code>!important</code>.</li>
<li><strong>只在</strong>需要覆盖全站范围的css或是外部css（例如引用的ExtJs或是YUI）的时候才在指定的页面上使用<code>!important</code>。</li>
<li><strong>不要</strong>在你的插件中使用<code>!important</code>。</li>
<li><strong>永远</strong>都要优先考虑使用样式规则的优先级来解决问题而不是<code>!important</code>。</li>
</ul>
<p><strong>取而代之，你可以:</strong></p>
<p>更好的利用CSS的级联属性</p>
<p>更多的使用适合的选择器。比如在你需要选定的对象元素前加上更多的元素，使选择的范围缩小，你的选择器就变得更有针对性，从而提高优先级。</p>
<h3 id="什么时候应该使用："><a class="header-anchor" href="#什么时候应该使用："></a>什么时候应该使用：</h3>
<p>你的网站上有一个设定了全站样式的CSS文件，同时你（或是你同事）写了一些效果很差的行内样式（行内样式的优先级是最高的）。</p>
<p>在这种情况下，你就可以在你全局的CSS文件中写一些<code>!important</code>的样式来覆盖掉那些直接写在元素上的行内样式。</p>
<p>活生生的例子比如：有人在jQuery插件里写了糟糕的行内样式。</p>
<hr>
<p>参考：<a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="noopener">css优先级计算规则–王美建</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS选择器 </tag>
            
            <tag> 优先级 </tag>
            
            <tag> 权重 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H5新标签和被H5拥抱的老元素们]]></title>
      <url>https://alexzhong22c.github.io/2017/03/28/h5-new-ele/</url>
      <content type="html"><![CDATA[<p>事实上，所有元素都能被归类为几个 元素内容模型（content model），详情请参考MDN：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories</a></p>
<p>这里不大谈内容模型，只不过按照这种思路划分我们的元素，谈谈那些比较广为接受的HTML5新元素和那些被HTML5拥抱的老元素。</p>
<a id="more"></a>
<h2 id="元数据内容"><a class="header-anchor" href="#元数据内容"></a>元数据内容</h2>
<h3 id="base元素"><a class="header-anchor" href="#base元素"></a>base元素</h3>
<p>老元素，假如你不是使用前端框架，基本上都可以用到。</p>
<p>base元素为页面上的所有的相对链接规定默认 URL 或默认目标，所以最好放在head元素里比较靠前的位置。</p>
<p><strong>在一个文档中，最多能使用一个 base 元素。base 元素必须位于 head 元素内部。</strong></p>
<p><strong>如果使用了 base 标签，则必须具备 href 属性或者 target 属性或者两个属性都具备。</strong></p>
<pre><code class="language-html">&lt;head&gt;
&lt;base href=&quot;http://www.runoob.com/images/&quot; target=&quot;_blank&quot;&gt;
&lt;/head&gt;
 
&lt;body&gt;
&lt;img src=&quot;logo.png&quot; width=&quot;24&quot; height=&quot;39&quot; alt=&quot;Stickman&quot;&gt;
&lt;a href=&quot;http://www.runoob.com&quot;&gt;runoob.com&lt;/a&gt;
&lt;/body&gt;
</code></pre>
<p>href属性：规定页面中所有相对链接的基准 URL。</p>
<p>target属性：规定页面中所有的超链接和表单在何处打开。该属性会被每个链接中的 target 属性覆盖。</p>
<h3 id="noscript元素"><a class="header-anchor" href="#noscript元素"></a>noscript元素</h3>
<p>老元素，浏览器们都支持。</p>
<p>此标签可被用于可识别 noscript 标签但无法支持js脚本的时候，通常写上它也不会有什么损失。</p>
<p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p>
<blockquote>
<p>其他“元数据内容”标签的介绍可在此先省略。</p>
</blockquote>
<h2 id="章节元素-sectioning-content"><a class="header-anchor" href="#章节元素-sectioning-content"></a>章节元素（Sectioning content）</h2>
<p>在当前的大纲中创建一个<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="noopener">分节</a>，此分节将定义 <a href="#header%E5%85%83%E7%B4%A0">header元素</a>、<a href="#footer%E5%85%83%E7%B4%A0">footer元素</a> 和“标题元素”的范围。</p>
<blockquote>
<p>属于此类的H5元素总共有：</p>
<ul>
<li><a href="#article%E5%85%83%E7%B4%A0">article元素</a></li>
<li><a href="#section%E5%85%83%E7%B4%A0">section元素</a></li>
<li><a href="#aside%E5%85%83%E7%B4%A0">aside元素</a></li>
<li><a href="#nav%E5%85%83%E7%B4%A0">nav元素</a></li>
</ul>
<p><strong>都是比较新出的元素，还好IE9及以上都作了基本支持。</strong></p>
<p>用法可参考 <a href="https://alexzhong22c.github.io/IFE-CSS-learning/task02.html">demo</a></p>
</blockquote>
<h3 id="article元素"><a class="header-anchor" href="#article元素"></a>article元素</h3>
<p>article元素 表示文档、页面、应用或网站中的<strong>独立结构</strong>，其意在成为<strong>可独立分配的或可复用的结构</strong>。</p>
<p>如在发布中，它可能是论坛帖子或新闻文章、博客文章、用户提交的评论、交互式组件，或者其他独立的内容项目。</p>
<p><strong>用时要特别注意内容的独立性：一般独立完整的内容才使用article元素，如果只是一段内容的话应该是用section元素。</strong></p>
<blockquote>
<p>使用说明：</p>
<ul>
<li>当 article元素 嵌套使用时，则该元素代表与外层元素有关的文章。
<ul>
<li>例如，代表博客评论的 article元素 可嵌套在代表博客文章的 article元素 中。</li>
</ul>
</li>
<li>article元素 的作者信息可通过 <a href="#address%E5%85%83%E7%B4%A0">address元素</a> 提供，但是不适用于嵌套的 article元素。</li>
<li>article元素 的发布日期和时间可通过 <a href="#time%E5%85%83%E7%B4%A0">time元素</a> 表示。</li>
</ul>
</blockquote>
<h3 id="section元素"><a class="header-anchor" href="#section元素"></a>section元素</h3>
<ul>
<li>用于定义文章中的章节(通常应该有标题和段落内容)。</li>
</ul>
<ul>
<li>用来定义文档中特定的内容区块，可视为一个区域分组元素。</li>
</ul>
<ul>
<li>用一句话来概括它的作用就是：给内容分段，给页面分区。</li>
</ul>
<ul>
<li>注意它与div的区别，div强调在形式上的独立性，section强调的是内容上的独立性，注意它的语义。</li>
</ul>
<blockquote>
<p>article和section对比：</p>
<p>1.语义不同：article元素是独立完整的内容，section元素页面内容分块。</p>
<p>2.相同点：本质上都是带有语义的div块元素 。</p>
<p>分别可以看做<code>&lt;div id=&quot;section&quot;&gt;</code>和<code>&lt;div id=&quot;article&quot;&gt;</code></p>
</blockquote>
<h3 id="aside元素"><a class="header-anchor" href="#aside元素"></a>aside元素</h3>
<ul>
<li>aside元素通常用来设置侧边栏。</li>
<li>用于定义article元素之外的内容，前提是这些内容与article元素内的内容相关。</li>
<li>同时也可嵌套在article元素内部使用，作为主要内容的附属信息。比如与内容有关的参考资料，名词解释等。</li>
</ul>
<h3 id="nav元素"><a class="header-anchor" href="#nav元素"></a>nav元素</h3>
<ul>
<li>用来定义目录、导航栏。</li>
<li>并非所有的超链接都放在nav元素中，<strong>通常只把一个文档中的主导航栏放在nav中。</strong></li>
</ul>
<h2 id="流式元素"><a class="header-anchor" href="#流式元素"></a>流式元素</h2>
<blockquote>
<p><strong>header元素 和 footer元素 都是比较新出的元素，还好IE9及以上都作了基本支持。</strong></p>
<p>用法可参考 <a href="https://alexzhong22c.github.io/IFE-CSS-learning/task02.html">demo</a></p>
</blockquote>
<h3 id="header元素"><a class="header-anchor" href="#header元素"></a>header元素</h3>
<p>header元素 表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</p>
<h3 id="footer元素"><a class="header-anchor" href="#footer元素"></a>footer元素</h3>
<p>footer元素 表示最近一个章节内容或者 根节点元素 的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p>
<blockquote>
<ul>
<li>footer元素 内的作者信息应包含在 <a href="#address%E5%85%83%E7%B4%A0">address元素</a> 中。</li>
<li>footer元素 不是章节内容，因此在<a href="https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="noopener">outline</a>中不能包含新的章节。</li>
</ul>
</blockquote>
<h3 id="address元素"><a class="header-anchor" href="#address元素"></a>address元素</h3>
<p>address元素 虽然是老元素，但是一直大受 WHATWG组织 青睐，也进入了HTML5行列，浏览器兼容很好，尽量使用。</p>
<p>HTML的 address元素 可以让作者为它最近的 <code>&lt;article&gt;</code> 或者 <code>&lt;body&gt;</code> 祖先元素提供联系信息。在后一种情况下，它应用于整个文档。</p>
<ul>
<li>通常用来说明作者的联系信息，例如名字、E-mail、电话、地址等。</li>
<li>address元素中的内容会以斜体显示。</li>
<li>通常， address元素 可以放在当前section的 footer元素中，如果存在的话。</li>
<li>浏览器兼容很好，尽量使用。</li>
</ul>
<hr>
<blockquote>
<p>HTML5强调多媒体在网页的嵌入：</p>
<ul>
<li>figure元素 和 figcaption元素</li>
<li>video元素</li>
</ul>
<p>在IE9及之后都可以支持基本的使用。</p>
</blockquote>
<h3 id="figure元素"><a class="header-anchor" href="#figure元素"></a>figure元素</h3>
<p>figure元素 是一个媒体组合元素，也就是对其他的媒体元素（比如：图像、图标等等）进行组合后代表一段独立的内容。</p>
<p>当它属于主体(main flow)时，它的位置独立于主体。当 figure元素 转移到附录中或者其他页面时不会影响到主体。</p>
<p>经常与 figcaption元素 配合使用，并且作为一个独立的引用单元。</p>
<h3 id="figcaption元素"><a class="header-anchor" href="#figcaption元素"></a>figcaption元素</h3>
<p>是与其相关联的图片的说明/标题，用于描述其父节点 figure元素 里的其他数据。</p>
<p><strong>这意味着 figcaption元素 是 figure元素块里的第一个或者最后一个。</strong></p>
<p>同时，该元素是可以使用，也可以不使用的。</p>
<pre><code>&lt;figure&gt;
  &lt;img src=&quot;https://developer.cdn.mozilla.net/media/img/mdn-logo-sm.png&quot; alt=&quot;An awesome picture&quot;&gt;	
  &lt;figcaption&gt;Fig1. MDN Logo&lt;/figcaption&gt;
&lt;/figure&gt;
</code></pre>
<h3 id="video元素"><a class="header-anchor" href="#video元素"></a>video元素</h3>
<p>该元素的各个属性才是研究的重点，需要大家去深入总结。</p>
<h2 id="短语元素"><a class="header-anchor" href="#短语元素"></a>短语元素</h2>
<h3 id="time元素"><a class="header-anchor" href="#time元素"></a>time元素</h3>
<p>浏览器的支持非常差，最好把它当做一个有“时间”语义的 span标签 来用。尽量不使用它的属性。</p>
<pre><code>&lt;p&gt;The concert starts at &lt;time&gt;20:00&lt;/time&gt;.&lt;/p&gt;
</code></pre>
<h3 id="mark元素"><a class="header-anchor" href="#mark元素"></a>mark元素</h3>
<p>HTML5中的全新标签，需要IE9及以上的浏览器。不过低版本浏览器用了也无妨，只不过该标签没有默认的CSS样式而已。</p>
<p>突出一段文字，这段文字通常是被外部引用/需要被搜索引擎搜索获得/用来方便读者的某种特定的审阅。</p>
<blockquote>
<ul>
<li>虽然 mark元素 本身有高亮效果，但是不要为了语法高亮而使用 mark元素，这时候应该使用 strong元素达到语法高亮。</li>
<li>mark元素 通常用于标注<strong>用来衔接上下文关系的文本</strong>，而strong元素用来标注在该大段文字中的重要语句。</li>
</ul>
</blockquote>
<h3 id="cite元素"><a class="header-anchor" href="#cite元素"></a>cite元素</h3>
<p>老元素，通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</p>
<p>按照惯例，引用的文本将以斜体显示。</p>
<p>cite标签 还有一个隐藏的功能：它可以使你或者其他人从文档中自动摘录参考书目。我们可以很容易地想象一个浏览器，它能够自动整理引用表格，并把它们作为脚注或者独立的文档来显示。</p>
<h2 id="表单相关内容"><a class="header-anchor" href="#表单相关内容"></a>表单相关内容</h2>
<blockquote>
<p>HTML5推崇新的表单控件，<strong>以及 表单相关的老元素 的更合理的使用，</strong> 这些老元素中常用的有：</p>
<ul>
<li>form元素</li>
<li>fieldset元素</li>
<li>legend元素</li>
<li>label元素</li>
</ul>
<p>用法可参考 <a href="https://alexzhong22c.github.io/IFE-CSS-learning/task02.html">demo</a></p>
</blockquote>
<h3 id="form元素"><a class="header-anchor" href="#form元素"></a>form元素</h3>
<p>和表单相关的元素都由 form元素 包着，一个form代表一个表单。</p>
<h3 id="fieldset元素"><a class="header-anchor" href="#fieldset元素"></a>fieldset元素</h3>
<p>通常用来对表单的相关元素进行分组，如果不需要分组就可以直接不用fieldset这一层。</p>
<p>HTML5 中新增了一些 fieldset元素 的新属性：disabled、form、name，而HTML 4.01 中不支持这些属性。</p>
<p><strong>目前，这些新属性被浏览器们支持得都很差。不建议fieldset使用任何属性。</strong></p>
<h3 id="legend元素"><a class="header-anchor" href="#legend元素"></a>legend元素</h3>
<p>legend元素 代表一个用于表示 它的父元素<code>&lt;fieldset&gt;</code> 的内容的标题。</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Title&lt;/legend&gt;
    &lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio&quot;&gt; &lt;label for=&quot;radio&quot;&gt;Click me&lt;/label&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h3 id="label元素"><a class="header-anchor" href="#label元素"></a>label元素</h3>
<p>label元素 表示用户界面中项目的标题。</p>
<pre><code>&lt;form&gt;
  &lt;label for=&quot;GET-name&quot;&gt;Name:&lt;/label&gt;
  &lt;input id=&quot;GET-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;
&lt;/form&gt;
</code></pre>
<h4 id="使用-label配合控件使用："><a class="header-anchor" href="#使用-label配合控件使用："></a>使用 label配合控件使用：</h4>
<p>在下面这个例子中，点击label会选中对应的input控件。靠的就是 for属性 和 id属性 产生的联系。</p>
<pre><code>&lt;label for=&quot;User&quot;&gt;Click me&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;
</code></pre>
<h3 id="progress元素"><a class="header-anchor" href="#progress元素"></a>progress元素</h3>
<p><strong>需要IE10及以上的浏览器。</strong></p>
<p>标示任务的进度：</p>
<pre><code>&lt;progress value=&quot;22&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 
</code></pre>
<h2 id="提高html代码性能的几点建议："><a class="header-anchor" href="#提高html代码性能的几点建议："></a>// 提高HTML代码性能的几点建议：</h2>
<h3 id="语义化标记"><a class="header-anchor" href="#语义化标记"></a>语义化标记</h3>
<p>语义指意义相关的事物，HTML 可从页面内容中看出语义：元素和属性的命名一定程度上表达了内容的角色和功能。HTML5 引入了新的语义元素，如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>及<code>&lt;nav&gt;</code>。</p>
<p>选择合适的元素来编写代码可保证代码的易读性：</p>
<ul>
<li>使用<code>&lt;h1&gt;</code>(<code>&lt;h2&gt;</code>,<code>&lt;h3&gt;</code>…)表示标题，<code>&lt;ul&gt;</code>或<code>&lt;ol&gt;</code>实现列表</li>
<li>注意使用<code>&lt;article&gt;</code>标签之前应添加<code>&lt;h1&gt;</code>标签；</li>
<li>选择合适的HTML5语义元素如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>,<code>&lt;nav&gt;</code>,<code>&lt;aside&gt;</code>;</li>
<li>使用<code>&lt;p&gt;</code>描述Body 文本，HTML5 语义元素可以形成内容，反之不成立。</li>
<li>使用<code>&lt;label&gt;</code>元素，输入类型，占位符及其他属性来强制验证。</li>
<li>将文本和元素混合，并作为另一元素的子元素，会导致布局错误。</li>
<li>img元素记得加alt属性。</li>
</ul>
<h4 id="i-b-em-strong元素"><a class="header-anchor" href="#i-b-em-strong元素"></a>i/b/em/strong元素</h4>
<p><code>&lt;em&gt;</code> 用于对文本内容进行强调，强调位置的不同通常会改变句子的含义。如果仅仅在语态或语气上为了突出某一个文本，那应该使用<code>&lt;i&gt;</code>。</p>
<p>但如果为了突出某一部分的重要性、严重性或紧急性，那应该使用 <code>&lt;strong&gt;</code>。根据 W3C 对 <code>&lt;b&gt;</code>元素的说明，<code>&lt;b&gt;</code>元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签。</p>
<p>相同的，在考虑使用 <code>&lt;i&gt;</code> 之前，也要想想是否用<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;dfn&gt;</code> 或 <code>&lt;mark&gt;</code> 等元素更合适。</p>
<h3 id="布局"><a class="header-anchor" href="#布局"></a>布局</h3>
<p>要提高HTML代码的性能，要遵循HTML 代码以实现功能和为目标，而不是样式。</p>
<ul>
<li>使用<code>&lt;p&gt;</code>元素修饰文本，而不是布局；默认<code>&lt;p&gt;</code>是自动提供边缘，而且其他样式也是浏览器默认提供的。</li>
<li>避免使用<code>&lt;br&gt;</code>分行，可以使用block元素或CSS显示属性来代替。</li>
<li>避免使用<code>&lt;hr&gt;</code>来添加水平线，可使用CSS的border-bottom 来代替。</li>
<li>不到关键时刻不要使用div标签。</li>
<li>尽量少用Tables来布局。</li>
<li>可以多使用Flex Box</li>
<li>使用CSS 来调整边距等。</li>
</ul>
<h2 id="被嫌弃的h5标签们："><a class="header-anchor" href="#被嫌弃的h5标签们："></a>// 被嫌弃的H5标签们：</h2>
<p><a href="http://www.w3school.com.cn/tags/tag_command.asp" target="_blank" rel="noopener">command标签</a> ：</p>
<p>目前只有IE支持。</p>
<p><a href="http://www.qianxingzhem.com/post-1882.html" target="_blank" rel="noopener">hgroup标签</a> ：</p>
<p>用来表明标题的集合，这样功能就比较鸡肋了，在最新的 HTML5.1 版中被废除了。</p>
<p><a href="http://www.w3school.com.cn/tags/tag_keygen.asp" target="_blank" rel="noopener">keygen标签</a> ：</p>
<p>IE和Safari都不支持。</p>
<p><a href="http://www.w3school.com.cn/tags/tag_meter.asp" target="_blank" rel="noopener">meter标签</a> ：</p>
<p>IE不支持。</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE2017-CSS-task01笔记]]></title>
      <url>https://alexzhong22c.github.io/2017/03/27/ife-css-task01/</url>
      <content type="html"><![CDATA[<p>因为大家对html代码不是很重视，所以整理了一些容易忽略的问题并且对一些知识点作了梳理。</p>
<p>对应代码的github仓库的地址：<a href="https://github.com/AlexZhong22c/IFE-CSS-learning" target="_blank" rel="noopener">https://github.com/AlexZhong22c/IFE-CSS-learning</a></p>
<p>task01其实就是对HTML的学习，对应的代码其实就是task02的<a href="https://alexzhong22c.github.io/IFE-CSS-learning/task02.html">demo</a>的HTML部分。</p>
<a id="more"></a>
<h2 id="细节问题总结"><a class="header-anchor" href="#细节问题总结"></a>细节问题总结</h2>
<h3 id="i-b-em-strong元素"><a class="header-anchor" href="#i-b-em-strong元素"></a>i/b/em/strong元素</h3>
<p><code>&lt;em&gt;</code> 用于对文本内容进行强调，强调位置的不同通常会改变句子的含义。如果仅仅在语态或语气上为了突出某一个文本，那应该使用<code>&lt;i&gt;</code>。</p>
<p>但如果为了突出某一部分的重要性、严重性或紧急性，那应该使用 <code>&lt;strong&gt;</code>。根据 W3C 对 <code>&lt;b&gt;</code>元素的说明，<code>&lt;b&gt;</code>元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签。</p>
<p>相同的，在考虑使用 <code>&lt;i&gt;</code> 之前，也要想想是否用<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;dfn&gt;</code> 或 <code>&lt;mark&gt;</code> 等元素更合适。</p>
<h3 id="单标签要闭合吗"><a class="header-anchor" href="#单标签要闭合吗"></a>单标签要闭合吗</h3>
<p>一句话总结，xhtml严格要求空标签必须自闭合，html5又不要求自闭合但是兼容xhtml的自闭合写法。</p>
<h3 id="alt属性"><a class="header-anchor" href="#alt属性"></a>alt属性</h3>
<p>为了写优雅的代码：img元素记得加alt属性。</p>
<h3 id="表单控件"><a class="header-anchor" href="#表单控件"></a>表单控件</h3>
<ul>
<li>name对于radio很重要；name对于checkbox很重要</li>
<li>对于表单中的单选radio控件和复选checkbox控件以及下拉框select控件，可以为radio, checkbox添加checked属性以及为option添加selected属性让其默认选中</li>
</ul>
<h3 id="h5加id的观点"><a class="header-anchor" href="#h5加id的观点"></a>H5加id的观点</h3>
<p>虽然语义化标签好用，但是当它需要加id的时候还是加吧：id=“header”</p>
<hr>
<h3 id="form元素"><a class="header-anchor" href="#form元素"></a>form元素</h3>
<p>和表单相关的元素都由 form元素 包着，一个form代表一个表单。</p>
<h3 id="fieldset元素"><a class="header-anchor" href="#fieldset元素"></a>fieldset元素</h3>
<p>通常用来对表单的相关元素进行分组，如果不需要分组就可以直接不用fieldset这一层。</p>
<p>HTML5 中新增了一些 fieldset元素 的新属性：disabled、form、name，而HTML 4.01 中不支持这些属性。</p>
<p><strong>目前，这些新属性被浏览器们支持得都很差。不建议fieldset使用任何属性。</strong></p>
<h3 id="legend元素"><a class="header-anchor" href="#legend元素"></a>legend元素</h3>
<p>legend元素 代表一个用于表示 它的父元素<code>&lt;fieldset&gt;</code> 的内容的标题。</p>
<pre><code>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Title&lt;/legend&gt;
    &lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;radio&quot;&gt; &lt;label for=&quot;radio&quot;&gt;Click me&lt;/label&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h3 id="label元素"><a class="header-anchor" href="#label元素"></a>label元素</h3>
<p>label元素 表示用户界面中项目的标题。</p>
<pre><code>&lt;form&gt;
  &lt;label for=&quot;GET-name&quot;&gt;Name:&lt;/label&gt;
  &lt;input id=&quot;GET-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;
&lt;/form&gt;
</code></pre>
<h4 id="使用-label配合控件使用："><a class="header-anchor" href="#使用-label配合控件使用："></a>使用 label配合控件使用：</h4>
<p>在下面这个例子中，点击label会选中对应的input控件。靠的就是 for属性 和 id属性 产生的联系。</p>
<pre><code>&lt;label for=&quot;User&quot;&gt;Click me&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;
</code></pre>
<hr>
<h3 id="和按钮相关的元素"><a class="header-anchor" href="#和按钮相关的元素"></a>和按钮相关的元素</h3>
<p>在一个页面上画一个按钮，有四种办法：</p>
<ul>
<li><code>&lt;input type=&quot;button&quot; /&gt;</code>这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><code>&lt;input type=&quot;submit&quot; /&gt;</code> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。</li>
<li><code>&lt;button&gt;</code>这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题（<a href>葛亮</a>）。</li>
<li>其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。</li>
</ul>
<p>type=&quot;button&quot;和type=&quot;submit&quot;各写一个，绑个alert或者dom操作。可以发现：button如果没别的，就会一动不动；submit如果没别的，就会刷新页面（应该是一闪然后保持原页面）；sb绑了dom，就是js的效果一闪，然后保持原页面。可以写js事件来绑定button，js是客户端的。但submit的实质作用是提交给服务端的，不是写个js阻止就能完事。</p>
<h3 id="dl-dt-dd元素"><a class="header-anchor" href="#dl-dt-dd元素"></a>dl dt dd元素</h3>
<p>严格来说定义列表只用来<strong>标记字典或术语表</strong>这样的结构，也有一说是它也可以用来标记对话。在实践中，如果有一系列的“标题 + 详情”这样的结构，使用定义列表也勉强说得过去。但实际上是有更好的标记方式，比如 hx + div/p 本身就表达了标题与详情的对应关系；如果一定要强调这一系列数据的并列关系，可以在外围使用 ul 或 ol。</p>
<p><a href="http://know.webhek.com/html5/html-dl-dt-dd.html" target="_blank" rel="noopener">http://know.webhek.com/html5/html-dl-dt-dd.html</a></p>
<p><a href="http://www.cnblogs.com/duhuo/p/5656511.html" target="_blank" rel="noopener">http://www.cnblogs.com/duhuo/p/5656511.html</a></p>
<h2 id="h5新标签和被h5拥抱的老元素们"><a class="header-anchor" href="#h5新标签和被h5拥抱的老元素们"></a>H5新标签和被H5拥抱的老元素们</h2>
<ul>
<li>在HTML5之后，哪些新标签可以放心使用、哪些老标签需要继续使用？</li>
<li>这个demo用到的标签的详细介绍？</li>
</ul>
<p>这些话题的主要内容都写到了我的博客里： <a href="https://alexzhong22c.github.io/2017/03/28/h5-new-ele/">H5新标签和被H5拥抱的老元素们</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML </tag>
            
            <tag> H5 </tag>
            
            <tag> IFE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IIFE回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/03/10/iife-intro/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="定义"><a class="header-anchor" href="#定义"></a>定义</h2>
<p>IIFE: 意为立即调用的函数表达式，也就是说，<strong>声明函数的同时立即调用这个函数。</strong></p>
<h3 id="对比"><a class="header-anchor" href="#对比"></a>对比</h3>
<p>如果不采用IIFE：</p>
<pre><code>function foo(){
  var a = 10;
  console.log(a);
}

foo();
</code></pre>
<p>函数声明和执行是可以分离的。</p>
<hr>
<p>如果采用IIFE：</p>
<pre><code>(function foo(){
  var a = 10;
  console.log(a);
})();
</code></pre>
<p>JS编译器不再认为这是一个函数声明，而是一个IIFE，即需要立刻执行声明的函数。</p>
<p>两者达到的目的是相同的，都是声明了一个函数foo并且随后调用函数foo。</p>
<h2 id="为什么需要iife"><a class="header-anchor" href="#为什么需要iife"></a>为什么需要IIFE</h2>
<ul>
<li>立即执行一个函数</li>
<li>需要用函数实现作用域隔离</li>
</ul>
<p>在这两种情景下，使用IIFE就比较方便。</p>
<p>如果只是为了立即执行一个函数，显然IIFE所带来的好处有限。实际上，IIFE的出现是为了弥补JS在scope方面的缺陷：JS只有全局作用域（global scope）、函数作用域（function scope），从ES6开始才有块级作用域（block scope）。对比现在流行的其他面向对象的语言可以看出，JS在访问控制这方面是多么的脆弱！那么如何实现作用域的隔离呢？在JS中，只有function，只有function，**只有function才能实现作用域隔离，**因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。</p>
<p>在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，当然声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：这通常的目的是为了隔离作用域了！<strong>既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。</strong></p>
<h2 id="iife的函数名和参数"><a class="header-anchor" href="#iife的函数名和参数"></a>IIFE的函数名和参数</h2>
<pre><code>var a = 2;
(function IIFE(global){
    var a = 3;
    console.log(a); // 3
    console.log(global.a); // 2
})(window);

console.log(a); // 2
</code></pre>
<h2 id="iife构造单例模式"><a class="header-anchor" href="#iife构造单例模式"></a>IIFE构造单例模式</h2>
<p>JS的模块就是函数，最常见的模块定义如下：</p>
<pre><code>function myModule(){
  var someThing = &quot;123&quot;;
  var otherThing = &quot;456&quot;;

  function doSomeThing(){
    console.log(someThing);
  }

  function doOtherThing(){
    console.log(otherThing);
  }

  return {
    doSomeThing:doSomeThing,
    doOtherThing:doOtherThing
  }
}

var foo = myModule();
foo.doSomeThing();
foo.doOtherThing();

var foo1 = myModule();
foo1.doSomeThing();
</code></pre>
<p>如果需要一个单例模式的模块，那么可以利用IIFE：</p>
<pre><code>var myModule = (function module(){
  var someThing = &quot;123&quot;;
  var otherThing = &quot;456&quot;;

  function doSomeThing(){
    console.log(someThing);
  }

  function doOtherThing(){
    console.log(otherThing);
  }

  return {
    doSomeThing:doSomeThing,
    doOtherThing:doOtherThing
  }
})();

myModule.doSomeThing();
myModule.doOtherThing();
</code></pre>
<p>参考：<a href="http://dz.sdut.edu.cn/blog/subaochen/2016/02/%E8%AF%B4%E4%B8%80%E8%AF%B4js%E7%9A%84iife/" target="_blank" rel="noopener">IIFE–subaochen</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> IIFE </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js的for循环回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/03/09/for-loop/</url>
      <content type="html"><![CDATA[<p>非常经典，还分析了老的几个浏览器：<a href="http://www.zhangxinxu.com/wordpress/2013/04/es5%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">es5新增数组方法和兼容性问题</a></p>
<p>ES5 中分别有三种 for 循环：</p>
<ul>
<li>简单的for循环</li>
<li>for in</li>
<li>for each</li>
</ul>
<p>ES6 新增了for of</p>
<p>因为for循环和Array关系非常密切，所以先谈谈Array。</p>
<a id="more"></a>
<h2 id="array的本质"><a class="header-anchor" href="#array的本质"></a>Array的本质</h2>
<p>Javascript 中的 Array 并不像大部分其他语言的数组。</p>
<ul>
<li>Javascript 中的 Array 在内存上并不连续</li>
<li>Array 的索引并不是指偏移量</li>
<li>Array 的索引也不是 Number 类型，而是 String 类型的
<ul>
<li>我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0”</li>
</ul>
</li>
</ul>
<p>有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p>
<h2 id="简单-for-循环"><a class="header-anchor" href="#简单-for-循环"></a>简单 for 循环</h2>
<p>最常见的写法是：</p>
<pre><code>const arr = [1, 2, 3];
for(let i = 0;i &lt; arr.length; i++) {
  console.log(arr[i]);
}
</code></pre>
<p>当数组长度在循环过程中不会改变时，我们最好将数组长度用变量存储起来，这样会获得更好的效率：</p>
<pre><code>const arr = [1, 2, 3];
for(let i = 0,len=arr.length; i &lt; len; i++) {
  console.log(arr[i]);
}
</code></pre>
<h2 id="for-in"><a class="header-anchor" href="#for-in"></a>for in</h2>
<p>for-in 一般情况下只用于遍历稀疏数组，这样的好处大大的：</p>
<pre><code>let key;
const arr = [];
arr[0] = &quot;a&quot;;
arr[100] = &quot;b&quot;;
arr[10000] = &quot;c&quot;;
for(key in arr) {
    if(arr.hasOwnProperty(key)  &amp;&amp;    
        /^0$|^[1-9]\d*$/.test(key) &amp;&amp;    
        key &lt;= 4294967294               
        ) {
        console.log(arr[key]);
    }
}
</code></pre>
<p>for-in 只会遍历存在的实体，上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，普通 for 循环则会遍历 10001 次）。</p>
<p>为了避免重复劳动，我们可以包装一下上面的代码：</p>
<pre><code>function arrayHasOwnIndex(array, prop) {
    return array.hasOwnProperty(prop) &amp;&amp;
        /^0$|^[1-9]\d*$/.test(prop) &amp;&amp;
        prop &lt;= 4294967294; // 2^32 - 2
}
</code></pre>
<p>使用示例如下：</p>
<pre><code>for (let key in arr) {
    if (arrayHasOwnIndex(arr, key)) {
        console.log(arr[key]);
    }
}
</code></pre>
<h3 id="为什么上面代码要加那么多条件判断"><a class="header-anchor" href="#为什么上面代码要加那么多条件判断"></a>为什么上面代码要加那么多条件判断</h3>
<p>for-in 循环遍历的是对象的属性，而不是数组的索引。因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。</p>
<pre><code>const person = {
    fname: &quot;san&quot;,
    lname: &quot;zhang&quot;,
    age: 99
};
let info;
for(info in person) {
    console.log(&quot;person[&quot; + info + &quot;] = &quot; + person[info]);
}
</code></pre>
<p>结果如下：</p>
<pre><code>person[fname] = san
person[lname] = zhang
person[age] = 99
</code></pre>
<p>需要注意的是， for-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p>
<p>因为期望的是对象，所以<strong>不应该用for in来循环遍历数组</strong>：如果采用prototype扩展原生的Array，这些属性也会被for in遍历出来，这样就有可能出乎程序员的意料：</p>
<pre><code>// Somewhere deep in your JavaScript library...
Array.prototype.foo = 1;

// Now you have no idea what the below code will do.
var a = [1, 2, 3, 4, 5];
for (var x in a){
  // Now foo is a part of EVERY array and 
  // will show up here as a value of 'x'.
  console.log(x);
}

/**
 * 输出:
 * 0
 * 1
 * 2
 * 3
 * 4
 * foo
 */
</code></pre>
<h3 id="注意"><a class="header-anchor" href="#注意"></a>注意</h3>
<p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener">for…in–MDN</a>：</p>
<blockquote>
<p><code>for...in</code> 循环以任意序迭代一个对象的属性。</p>
<p>如果一个属性在一次迭代中被修改，在稍后被访问，其在循环中的值是其在稍后时间的值。正常。</p>
<p>一个在被访问之前已经被删除的属性将不会在之后被访问。正常。</p>
<p>在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略。不正常。</p>
<p><strong>通常，在迭代过程中最好不要在对象上进行添加属性的值、修改或者删除属性的操作，除非是对当前正在被访问的属性。</strong></p>
<p>因为一个被添加的属性在迭代过程中可能会不被访问到。如果不是当前正在被访问的元素：一个修改后的属性可能会在修改前或者修改后被访问 并且 一个被删除的属性可能会在它被删除之前被访问。</p>
</blockquote>
<p>通俗来讲就是：要改的话就只能改当前循环访问到的属性，而其他<strong>没有被访问的</strong>或者<strong>还未被当前循环访问到的</strong>属性就不能改。</p>
<h3 id="for-in-性能"><a class="header-anchor" href="#for-in-性能"></a>for in 性能</h3>
<p>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：</p>
<pre><code>const obj = {
    &quot;prop1&quot;: &quot;value1&quot;,
    &quot;prop2&quot;: &quot;value2&quot;
};

const props = [&quot;prop1&quot;, &quot;prop2&quot;];
for(let i = 0; i &lt; props.length; i++) {
    console.log(obj[props[i]]);
}
</code></pre>
<p>上面代码中，将对象的属性都存入一个数组中，相对于 <code>for-in</code> 查找每一个属性，该代码只关注<strong>给定的</strong>属性，节省了循环的开销和时间。</p>
<h2 id="foreach"><a class="header-anchor" href="#foreach"></a>forEach</h2>
<p>forEach只支持IE9及以上。forEach把数组对象的引索当做是number类型。本文章的最后有它的polyfill。</p>
<p><code>forEach</code> 可以当做是<code>for(let i = 0; i &lt; len; i++)</code>的简写，但是不能完成 <code>i + n</code> 这种循环，同时也不支持 <code>continue</code>和 <code>break</code>，只能通过 <code>return</code> 来控制循环。另外，使用<code>forEach</code>的话，是不能退出循环本身的。</p>
<p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 callback 函数会被依次传入三个参数：</p>
<ul>
<li>数组当前项的值；</li>
<li>数组当前项的索引；</li>
<li>数组对象本身；</li>
</ul>
<p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</p>
<pre><code>const arr = [];
arr[0] = &quot;a&quot;;
arr[3] = &quot;b&quot;;
arr[10] = &quot;c&quot;;
arr.name = &quot;Hello world&quot;;
arr.forEach((data, index, array) =&gt; {
    console.log(data, index, array);
});
</code></pre>
<p>运行结果：</p>
<pre><code>a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
</code></pre>
<p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p>
<p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p>
<p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p>
<ul>
<li>every: 循环在第一次 return false 后返回</li>
<li>some: 循环在第一次 return true 后返回</li>
<li>filter: 返回一个新的数组，该数组内的元素满足回调函数</li>
<li>map: 将原数组中的元素处理后再返回</li>
<li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li>
</ul>
<h3 id="foreach的性能"><a class="header-anchor" href="#foreach的性能"></a>forEach的性能</h3>
<p>大家可以看 jsPerf ，在不同浏览器下测试的结果都是 forEach 的速度不如 for。如果大家把测试代码放在控制台的话，可能会得到不一样的结果，主要原因是控制台的执行环境与真实的代码执行环境有所区别。</p>
<h2 id="for-of"><a class="header-anchor" href="#for-of"></a>for of</h2>
<pre><code>const arr = ['a', 'b', 'c'];
for(let data of arr) {
    console.log(data);
}
</code></pre>
<p>运行结果是：</p>
<pre><code>a
b
c
</code></pre>
<h3 id="为什么要引进-for-of？"><a class="header-anchor" href="#为什么要引进-for-of？"></a>为什么要引进 for-of？</h3>
<p>要回答这个问题，我们先来看看ES6之前的 3 种 for 循环有什么缺陷：</p>
<ul>
<li>forEach 不能 break 和 return；</li>
<li>for-in 缺点更加明显，它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。而且，遍历数组元素的顺序可能是随机的。</li>
</ul>
<p>所以，鉴于以上种种缺陷，我们需要改进原先的 for 循环。但 ES6 不会破坏你已经写好的 JS 代码。目前，成千上万的 Web 网站依赖 for-in 循环，其中一些网站甚至将其用于数组遍历。如果想通过修正 for-in 循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在 ES6 中增加了一种新的循环语法来解决目前的问题，即 for-of 。</p>
<p>那 for-of 到底可以干什么呢？</p>
<ul>
<li>跟 forEach 相比，可以正确响应 break, continue, return。</li>
<li>for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</li>
<li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li>
<li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历。</li>
</ul>
<p>总结一下，for-of 循环有以下几个特征：</p>
<ul>
<li>这是最简洁、最直接的遍历数组元素的语法。</li>
<li>这个方法避开了 for-in 循环的所有缺陷。</li>
<li>与 forEach 不同的是，它可以正确响应 break、continue 和 return 语句。</li>
<li>其不仅可以遍历数组，还可以遍历类数组对象和其他可迭代对象。</li>
</ul>
<p>但需要注意的是，for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用</p>
<p>for-in 循环（这也是它的本职工作）。</p>
<p>最后要说的是，ES6 引进的另一个方式也能实现遍历数组的值，那就是 Iterator。上个例子：</p>
<pre><code>const arr = ['a', 'b', 'c'];
const iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
</code></pre>
<p>Iterator 要另外再介绍。</p>
<h2 id="补充foreach的polyfill"><a class="header-anchor" href="#补充foreach的polyfill"></a>补充forEach的polyfill</h2>
<pre><code>// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {
    var T, k;
    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }
    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);
    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument &quot;length&quot;.
    // 3. Let len be toUint32(lenValue).
    var len = O.length &gt;&gt;&gt; 0;
    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== &quot;function&quot;) {
      throw new TypeError(callback + ' is not a function');
    }
    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length &gt; 1) {
      T = thisArg;
    }
    // 6. Let k be 0
    k = 0;
    // 7. Repeat, while k &lt; len
    while (k &lt; len) {
      var kValue;
      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {
        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];
        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[float和绝对定位比较]]></title>
      <url>https://alexzhong22c.github.io/2017/03/04/float-n-absolute/</url>
      <content type="html"><![CDATA[<p>因为float实现的效果和绝对定位比较类似，稍后会对它们进行比较。</p>
<a id="more"></a>
<h2 id="float"><a class="header-anchor" href="#float"></a>float</h2>
<ul>
<li>在浮动一张图片或者其他元素时，是在要求浏览器把它往上方推，直到它碰到父元素的内边界。</li>
<li>浮动非图片元素时，要给它设定宽度。</li>
<li>默认情况下浮动元素的位置一般要受到父元素位置的限制，而且改变浮动元素在html文档中的次序，有可能会影响float的实现效果。</li>
</ul>
<h2 id="position"><a class="header-anchor" href="#position"></a>position</h2>
<ul>
<li>static 静态定位，每个元素都处于常规文档流中</li>
<li>relative 相对的是它原来在文档流中的位置（或者默认位置） 。
<ul>
<li>这个元素原来占据的空间没有动，其他元素也没动。</li>
<li>top right bottom left(可以给top left属性设定负值，把元素向上向左移动)</li>
</ul>
</li>
<li>absolute 绝对定位会把元素彻底从文档流中拿出来，再相对其他元素定位。</li>
<li>fixed 固定定位元素的定位上下文是视口，因此它不会随页面滚动而移动。</li>
</ul>
<h2 id="float和绝对定位比较"><a class="header-anchor" href="#float和绝对定位比较"></a>float和绝对定位比较</h2>
<p>我最常见的一个问题就是在一些布局中不知道用float好还是用绝对定位好，因为他们有一些相似的作用。</p>
<p>float 的诞生本来就是为了让文字环绕图片。</p>
<p><code>position: absolute</code>会导致元素脱离文档流，被定位的元素等于在文档中不占据任何位置，在另一个层呈现，可以设置z-index。PS的图层效果就是position: absolute。</p>
<p>float也会导致元素脱离文档流，但还在文档或容器中占据位置(不会跑到父元素的外面去)，把文档流和其它float元素向左或向右挤，并可能导致换行。图片的文字环绕布局效果就是float：</p>
<pre><code class="language-html">&lt;p&gt;
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
&lt;img src=&quot;/i/eg_cute.gif&quot; /&gt;
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
This is some text. This is some text. This is some text.
&lt;/p&gt;
</code></pre>
<p>CSS：</p>
<pre><code class="language-css">img 
{
float:right
}
</code></pre>
<h2 id="left-和-top属性"><a class="header-anchor" href="#left-和-top属性"></a>left 和 top属性</h2>
<p>float和绝对定位可以一起用在同一个元素，但是效果不好。
**left和top等属性应该用于position的定位，**但是我经常见到有些老手也会把它们用到float的元素上，这就很尴尬地滥用了，一般情况下这是因为对基础知识掌握不牢固所导致的。</p>
<h2 id="用到float的三栏布局所带来的启发"><a class="header-anchor" href="#用到float的三栏布局所带来的启发"></a>用到float的三栏布局所带来的启发</h2>
<p>需要说明的是，浮动布局依然遵循常规文档流，所以与绝对定位相比，浮动定位时HTML源文件中元素声明的位置显得格外重要。所以，在用到float实现的三栏布局中，交换左栏和右栏的声明次序会有很大影响，也有方法不用交换各栏的次序也可以实现同样的布局，但是，这就要用到一种比较晦涩的使用负边距值的方法。一般情况下，人们十有八九会选择交换源文件中左中两栏的声明次序。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> float </tag>
            
            <tag> 绝对定位 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[和margin有关的知识]]></title>
      <url>https://alexzhong22c.github.io/2017/03/04/about-margin/</url>
      <content type="html"><![CDATA[<p>总结一下和margin有关的基本知识，属于必须了解的范畴。</p>
<a id="more"></a>
<h2 id="基本知识"><a class="header-anchor" href="#基本知识"></a>基本知识</h2>
<h3 id="外边距的单位"><a class="header-anchor" href="#外边距的单位"></a>外边距的单位</h3>
<ul>
<li>为文本元素设置外边距时通常需要混合使用不同的单位</li>
<li>左右边距使用像素，使文本始终和包含元素边界保持固定间距</li>
<li>上下外边距以em为单位，让段间距随字号变化而响应增大或缩小</li>
</ul>
<h3 id="如果没有设置width属性"><a class="header-anchor" href="#如果没有设置width属性"></a>如果没有设置width属性</h3>
<ul>
<li>如果不设置块级元素的width属性，那么这个属性的默认值是auto,结果会让元素的宽度扩展到与父元素同宽。</li>
</ul>
<ul>
<li>没有宽度(没有设置width)的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边框和外边框，会导致内容宽度减少，减少量等于水平边框、内边框和外边框的和。</li>
</ul>
<h3 id="margin可以写1到4个值"><a class="header-anchor" href="#margin可以写1到4个值"></a>margin可以写1到4个值</h3>
<p>在实际应用中，个人不推荐使用三个值的margin，一是容易记错，二是不容易日后修改，一开始如果写成margin:10px 20px 30px;日后需求改动为上10px，右30px，下30px，左20px，你不得不还是得把这个margin拆开为margin:10px 30px 30px 20px;费力且不讨好，不如一开始就老老实实的写成margin:10px 20px 30px 20px;来的实在，不要为了现在节省俩个字节而让日后再次开发的成本上升。</p>
<h2 id="垂直外边距合并问题"><a class="header-anchor" href="#垂直外边距合并问题"></a>垂直外边距合并问题</h2>
<p>简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。你可以查看 <a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="noopener">W3Shool CSS外边距合并</a> 了解这个基本知识。</p>
<p>实际工作中，垂直外边距合并问题常见于<strong>第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距</strong>，而且只在标准浏览器下 (FirfFox、Chrome、Opera、Sarfi)产生问题，IE下反而表现良好。例子可以查看下面代码(IE下表现“正常”，标准浏览器下查看出现“bug”)：</p>
<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
	&lt;head&gt;
        &lt;title&gt;垂直外边距合并&lt;/title&gt;
        &lt;style&gt;
        .top{width:160px; height:50px; background:#ccf;}
        .middle{width:160px; background:#cfc;}
        .middle .firstChild{margin-top:20px;}
        &lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
        &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;middle&quot;&gt;
        &lt;div class=&quot;firstChild&quot;&gt;我其实只是想和我的父元素隔开点距离。&lt;/div&gt;
        &lt;div class=&quot;secondChild&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果按照CSS规范，IE的“良好表现”其实是一个错误的表现，因为IE的hasLayout渲染导致了这个“表现良好”的外观。而其他标准浏览器则会表现出“有问题”的外观。好了，如果你读过了上面W3Shcool的CSS外边距合并的文章后，就很容易讨论这个问题了。这个问题发生的原因是根据规范，一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>
<p>再说了白点就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己 “领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级，假传圣旨，把自己的margin当领导的margin执行。 对于垂直外边距合并的解决方案上面已经解释了，<strong>为父元素例子中的middle元素增加一个border-top或者padding-top即可解决这个问题。</strong></p>
<blockquote>
<p>一般说来这个问题解释到这里，大多数文章就不会再深入下去了，但作为一名实战开发者，最求的是知其然知其所以然，原本使用margin-top就是为了与父元素隔开距离，而按照你这么一个解法，其实是一种“修复”，为了“弥补修复”这个父子垂直外边距合并这个CSS规范“Bug”，而强制在父元素上使用border-top和padding-top，不舒服，也不容易记住，下次再发生这样的情况还是会忘记这条准则，而且在页面设计稿里如果不需要 border-top加个上边框，这么一加反而画蛇添足，为以后修改留下隐患。</p>
<p>为什么一定要用border-top,padding-top去为了这么一个所谓的标准规范而多写这么一行代码呢？答案你可以参考另外一篇文章<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="noopener">用Margin还是用Padding</a>里找到答案。</p>
</blockquote>
<h2 id="用margin还是用padding"><a class="header-anchor" href="#用margin还是用padding"></a>用Margin还是用Padding</h2>
<h3 id="何时应当使用margin："><a class="header-anchor" href="#何时应当使用margin："></a>何时应当使用margin：</h3>
<p>需要在border外侧添加空白时。</p>
<p>空白处不需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，需要相互抵消时。如15px + 20px的margin，将得到20px的空白。</p>
<h3 id="何时应当时用padding："><a class="header-anchor" href="#何时应当时用padding："></a>何时应当时用padding：</h3>
<p>需要在border内测添加空白时。</p>
<p>空白处需要背景（色）时。</p>
<p>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px + 20px的padding，将得到35px的空白。</p>
<p>个人认为：margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p>
<p>这里我截取了部分另外一篇文章的内容，详细内容请见<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="noopener">用Margin还是用Padding</a></p>
<hr>
<h2 id="margin在块元素-内联元素中的区别"><a class="header-anchor" href="#margin在块元素-内联元素中的区别"></a>margin在块元素、内联元素中的区别</h2>
<p>HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。</p>
<p>另外有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。</p>
<p>margin在块级元素下，他的性能可以完全体现，上下左右任你设定。且记住块级元素的margin的参照基准是前一个元素即相对于自身之前的元素有margin距离。如果元素是第一个元素，则就是相对于父元素的margin距离（但第一个元素相对于父元素margin-top而父元素又没有设定 padding-top/border-top的话要需要印证上面的垂直外边距合并的知识）</p>
<p>margin也能用于内联元素，这是规范所允许的，但是margin-top和margin-bottom对内联元素（对行）的高度没有影响，并且由于边界效果(margin效果)是透明的，他也没有任何的视觉影响。</p>
<p>这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距，那么你只能使用这三个属性：line- height，fong-size，vertical-align。</p>
<blockquote>
<p>请记住，这个影响内联元素高度的是line-height而不是height，因为内联元素是一行行的，定一个height的话，那这到底是整段inline元素的高呢？还是inline元素一行的高呢？这都说不准，所以统一都给每行定一个高，只能是line-height了。</p>
</blockquote>
<p>margin-top/margin-bottom对内联元素没有多大实际效果，不过margin-left/margin-right还是能够对内联元素产生影响的。应用margin:10px 20px 30px 40px;，左边这个css如果写在inline元素上，他的效果大致是，上下无效果，左边离他相邻元素或者文本距离为40px，右边离他相邻元素或者文本距离为20px。你可以自行尝试一番。</p>
<p>最后在内联元素中还有上文我们提到的非可置换inline元素（non-replaced element），这些个元素img|input|select|textarea|button|label虽然是内联元素，但margin依旧可以影响到他的上下左右！</p>
<p>总结下来margin 属性可以应用于几乎所有的元素，除了表格显示类型（不包括 table-caption, table and inline-table）的元素，而且垂直外边距对非置换内联元素（non-replaced inline element）不起作用。</p>
<hr>
<h2 id="常见的浏览器下margin出现的bug"><a class="header-anchor" href="#常见的浏览器下margin出现的bug"></a>常见的浏览器下margin出现的bug</h2>
<p>林林总总写了那么多，最后总结一些浏览器中常见的margin Bug吧，以后遇到margin下的布局问题可以查看这里找到解决的方案，如果你还发现其他关于浏览器下margin的Bug你可以发表留言，核对采纳后我会及时添加进去，感谢你的分享：</p>
<p>IE6中双边距Bug：</p>
<p>发生场合：当给父元素内第一个浮动元素设置margin-left（元素float:left）或margin-right（元素float:right）时margin加倍。</p>
<p>解决方法：是给浮动元素加上display:inline;CSS属性；或者用padding-left代替margin-left。</p>
<p>原理分析：块级对象默认的display属性值是block，当设置了浮动的同时，还设置了它的外边距就会出现这种情况。也许你会问：“为什么之后的对象和第一个对象之间就不存在双倍边距的Bug”？因为浮动都有其相对应的对象，只有相对于其父对象的浮动对象才会出现这样的问题。第一个对象是相对父对象的，而之后对象是相对第一个对象的，所以之后对象在设置后不会出现问题。为什么display:inline可以解决这个双边距bug，首先是 inline元素或inline-block元素是不存在双边距问题的。然后，float:left等浮动属性可以让inline元素 haslayout，会让inline元素表现得跟inline-block元素的特性一样，支持高宽，垂直margin和padding等，所以div class的所有样式可以用在这个display inline的元素上。</p>
<p>IE6中浮动元素3px间隔Bug：</p>
<p>发生场合：发生在一个元素浮动，然后一个不浮动的元素自然上浮与之靠近会出现的3px的bug。</p>
<p>解决方法：右边元素也一起浮动；或者为右边元素添加IE6 Hack _margin-left:-3px;从而消除3px间距。</p>
<p>原理分析：IE6浏览器缺陷Bug。</p>
<p>IE6/7负margin隐藏Bug：</p>
<p>发生场合：当给一个有hasLayout的父元素内的非hasLayout元素设置负marin时，超出父元素部分不可见。</p>
<p>解决方法：去掉父元素的hasLayout；或者赋hasLayout给子元素,并添加position:relative;</p>
<p>原理分析：iE6/7独有的hasLayout产生问题。</p>
<p>IE6/7下ul/ol标记消失bug：</p>
<p>发生场合：当ul/ol触发了haslayout并且是在ul/ol上写margin-left，前面默认的ul/ol标记会消失。</p>
<p>解决方法：给li设置margin-left，而不是给ul/ol设置margin-left。</p>
<p>原理分析：IE6/7浏览器Bug</p>
<p>IE6/7下margin与absolute元素重叠bug：</p>
<p>发生场合：双栏自适应布局中，左侧元素absolute绝对定位，右侧的margin撑开距离定位。在IE6/7下左侧应用了absolute属性的块级元素与右边的自适应的文字内容重叠。</p>
<p>解决方法：把左侧块级元素更改为内联元素，比如把div更换为span。</p>
<p>原理分析：这是由于IE6/IE7浏览器将inline水平标签元素和block水平的标签元素没有加以区分一视同仁渲染了。属于IE6/7浏览器渲染Bug。</p>
<p>IE6/7/8下auto margin居中bug：</p>
<p>发生场合：给block元素设置margin auto无法居中</p>
<p>解决方法：出现这种bug的原因通常是没有Doctype，然后触发了ie的quirks mode，加上Doctype声明就可以了。</p>
<p>在《打败IE的葵花宝典》里给出的方法是给block元素添加一个width能够解决，但根据本人亲测，加 with此种方法是无效的，如果没有Doctype即使给元素添加width也无法让block元素居中。
原理分析：缺少Doctype声明。</p>
<p>IE8下input[button | submit] 设置margin:auto无法居中</p>
<p>发生场合：ie8下，如果给像button这样的标签（如button input[type=“button”] input[type=“submit”]）设置{ display: block; margin:0 auto; }如果不设置宽度的话无法居中。</p>
<p>解决方法：可以给为input加上宽度</p>
<p>原理分析：IE8浏览器Bug。</p>
<p>IE8百分比padding垂直margin bug：</p>
<p>发生场合：当父元素设置了百分比的padding，子元素有垂直的margin的时候，就好像父元素被设置了margin一样。</p>
<p>解决方法：给父元素加一个overflow:hidden/auto。</p>
<p>原理分析：IE8浏览器Bug</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> margin </tag>
            
            <tag> bug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp的入门和一些简单使用]]></title>
      <url>https://alexzhong22c.github.io/2017/03/02/gulp-usage/</url>
      <content type="html"><![CDATA[<p>总结gulp的入门和一些简单使用，以便于快速上手。</p>
<a id="more"></a>
<p>建议参考 <a href="http://www.ydcss.com/archives/18" target="_blank" rel="noopener">gulp详细入门教程-一点</a></p>
<p>大概的过程为</p>
<ol>
<li>安装nodejs</li>
<li>安装npm</li>
<li>全局安装gulp</li>
<li>新建package.json文件</li>
<li>本地安装gulp插件</li>
<li>新建gulpfile.js文件</li>
<li>运行gulp</li>
</ol>
<h2 id="某些过程的详细介绍"><a class="header-anchor" href="#某些过程的详细介绍"></a>某些过程的详细介绍</h2>
<h3 id="全局安装gulp"><a class="header-anchor" href="#全局安装gulp"></a>全局安装gulp</h3>
<p>命令行执行<code>npm install gulp -g</code>或者<code>cnpm install gulp -g</code></p>
<p>查看是否正确安装：命令提示符执行<code>gulp -v</code>，出现版本号即为正确安装。</p>
<h3 id="应不应该共用node-modules文件夹"><a class="header-anchor" href="#应不应该共用node-modules文件夹"></a>应不应该共用node_modules文件夹</h3>
<p>共用node_modules有好处也有不便之处。npm的设计之初就不考虑共用node_modules的问题，所以如果硬要多个项目共用同一个node_modules会有许多不便之处。应该为每一个项目创建一个node_modules。</p>
<p>在提交项目的时候在.gitignore文件中设置不提交node_modules文件夹即可。</p>
<p>或者使用</p>
<pre><code>rm -rf node_modules
</code></pre>
<p>PS：不要直接删除本地插件包</p>
<p>下一次下载项目的时候用<code>npm install</code>就能下载回来在 package.json 中记录的插件，能够重新形成node_modules文件夹。</p>
<h3 id="安装参数-save-dev"><a class="header-anchor" href="#安装参数-save-dev"></a>安装参数–save-dev</h3>
<p>当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下<code>npm install module-name</code>），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（<code>dependencies</code>）。</p>
<p><code>-save</code>和<code>save-dev</code>可以省掉你手动修改package.json文件的步骤。
<code>spm install module-name -save</code> 自动把模块和版本号添加到dependencies部分
<code>spm install module-name -save-dve</code> 自动把模块和版本号添加到devdependencies部分</p>
<p>至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 <code>devDepandencies</code>主要是配置测试框架， 例如jshint、mocha。</p>
<blockquote>
<p>再做一个试验就懂得了区别：删除node_modules目录，然后执行 npm install --production，可以看到，npm只帮我们自动安装package.json中dependencies部分的模块；如果执行npm install ，则package.json中指定的dependencies和devDependencies都会被自动安装进来。</p>
</blockquote>
<h3 id="本地安装gulp插件"><a class="header-anchor" href="#本地安装gulp插件"></a>本地安装gulp插件</h3>
<pre><code>npm install gulp --save-dev
</code></pre>
<p>全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用</p>
<h3 id="安装组件"><a class="header-anchor" href="#安装组件"></a>安装组件</h3>
<p><a href="http://www.dbpoo.com/getting-started-with-gulp/" target="_blank" rel="noopener">Gulp安装及配合组件构建前端开发一体化</a></p>
<h4 id="gulp-jshint"><a class="header-anchor" href="#gulp-jshint"></a>gulp-jshint</h4>
<p><a href="https://www.npmjs.com/package/gulp-jshint" target="_blank" rel="noopener">gulp-jshint</a></p>
<p>如果无法在文件夹创建<code>.jshintrc</code>文件的话，就去网上别人的工程里面下载一个：<a href="https://github.com/fex-team/GMU" target="_blank" rel="noopener">GMU-github</a></p>
<hr>
<p>入门和进阶视频教程：</p>
<p><a href="https://ninghao.net/video/2003" target="_blank" rel="noopener">ninghao.net</a></p>
<p>一些比较细致介绍和问题的解决：</p>
<p><a href="http://web.jobbole.com/86025/" target="_blank" rel="noopener">gulp使用小结(一)</a></p>
<p><a href="http://jeffjade.com/2015/11/25/2015-11-25-toss-gulp/" target="_blank" rel="noopener">Gulp探究折腾之路(I)</a></p>
]]></content>
      
        <categories>
            
            <category> gulp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[桌面端和移动端图标的引入]]></title>
      <url>https://alexzhong22c.github.io/2017/02/27/icon-usage/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://bitsofco.de/all-about-favicons-and-touch-icons/" target="_blank" rel="noopener">All About Favicons-bitsofcode</a> ：</p>
</blockquote>
<p>这星期我决定找到一些合适的方式来使用网站的favicon（另外还包括移动端的touch icon）。我想总结一下我自己的观点并且通过简明的语言来表述清楚：</p>
<a id="more"></a>
<h2 id="一些基础的知识"><a class="header-anchor" href="#一些基础的知识"></a>一些基础的知识</h2>
<p>favicon 是浏览器展示web网页时用到的一种图片。最典型的就是16x16像素大小，不过现在通常需要更多更大的尺寸以供不同的用途使用：</p>
<ul>
<li>地址栏</li>
<li>链接栏</li>
<li>书签</li>
<li>标签</li>
<li>桌面图标</li>
</ul>
<p>如果没有指明favicon的位置，所有主流的浏览器（甚至包括IE5时代的浏览器）都会默认去网站根目录找一个叫&quot;favicon.ico&quot;的文件。从技术层面来讲，这意味着我们不需要用作任何声明就能在网站中使用图标。</p>
<p>然而，这种情况下图标的格式需要受到限制。另外还不支持带透明的图标，这并不是一个最优的办法。因为现在我们能使用更多格式的图标：<a href="http://caniuse.com/#feat=link-icon-png" target="_blank" rel="noopener">png</a>, gif, jpeg，在某些情况下还有<a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="noopener">svg</a> 。</p>
<h2 id="favicon声明和link标签"><a class="header-anchor" href="#favicon声明和link标签"></a>favicon声明和link标签</h2>
<p>你可以用link标签设置你喜欢的图标：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;&quot; type=&quot;&quot; sizes=&quot;&quot; href=&quot;&quot;&gt;  
</code></pre>
<h3 id="rel属性"><a class="header-anchor" href="#rel属性"></a>rel属性</h3>
<p>用于声明链接目标和html文档的关系。通常用来引入css样式表。如果是图标，比较官方的写法应该是：</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;icon&quot;&gt;
</code></pre>
<p>曾经你可能见过这种写法：</p>
<pre><code class="language-JavaScript"> &lt;link rel=&quot;shortcut icon&quot;&gt;
</code></pre>
<p>这是因为某些老浏览器（IE8或者更早）需要这么写，否则浏览器会忽略这整个link标签。因此，即便<code>rel=&quot;shortcut icon&quot;</code>不在HTML5标准里面，它依然在现代浏览器中有效。然而后面我们会讲到，在实际中你可能只需要使用<code>&lt;link rel=&quot;icon&quot;&gt;</code> 这一种写法即可。</p>
<h3 id="type属性"><a class="header-anchor" href="#type属性"></a>type属性</h3>
<p>用来	指定链接目标的<a href="http://www.iana.org/assignments/media-types/media-types.xhtml#image" target="_blank" rel="noopener">MIME type format</a>。比如，指定一个图标文件是<code>image/x-icon</code> 类型还一个png文件 <code>image/png</code>。</p>
<p>根据W3C，指定type类型仅仅只是一个建议。但除此之外，IE9和IE10需要指定type属性。在这些版本的浏览器里面，虽然不必指定<code>rel=&quot;shortcut icon&quot;</code>，作为替代，它们需要指定媒体文件的type为 <code>image/x-icon</code> 。</p>
<p>幸运的是，IE11和其他现代浏览器不需要指定媒体文件的type。</p>
<h3 id="sizes属性"><a class="header-anchor" href="#sizes属性"></a>sizes属性</h3>
<p>用于声明特定被链接的文件的大小，不同大小用于不同用途。你能为每种用途提供各自最优的文件。这对使用png图片的情景尤为重要，因为png是不能拓展的。这是一张很好的<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="noopener">备忘单</a>,它会告诉你应该使用的文件的大小和用途。</p>
<h3 id="href属性"><a class="header-anchor" href="#href属性"></a>href属性</h3>
<p>不必多说，这是用来指定图标的位置和地址的。</p>
<h2 id="做个小结"><a class="header-anchor" href="#做个小结"></a>做个小结</h2>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Link “rel”/ “type”</th>
<th>Accepted Formats</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE 8 and below</td>
<td>link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 9, IE 10</td>
<td>link rel=”icon” type=”image/x-icon” or link rel=”shortcut icon”</td>
<td>ico</td>
</tr>
<tr>
<td>IE 11</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Chrome</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Firefox</td>
<td>link rel=”icon”</td>
<td>ico, png, gif, <a href="http://caniuse.com/#feat=link-icon-svg" target="_blank" rel="noopener">svg*</a></td>
</tr>
<tr>
<td>Safari</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
<tr>
<td>Opera</td>
<td>link rel=”icon”</td>
<td>ico, png, gif</td>
</tr>
</tbody>
</table>
<p>看上去，最好的方案应该是声明两个版本，用现代浏览器的方法引用png，IE8的方法引用ico文件。</p>
<p>然而，如果ico和png同时被引用，现代浏览器会不论标签顺序的先后，只选择ico。这意味着，如果我们要兼容老浏览器，现代浏览器可能会被提供一个错误的图片文件的格式。</p>
<h3 id="当只引入ico时"><a class="header-anchor" href="#当只引入ico时"></a>当只引入ico时</h3>
<pre><code class="language-html">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;
</code></pre>
<h3 id="当需要引入ico和png"><a class="header-anchor" href="#当需要引入ico和png"></a>当需要引入ico和png</h3>
<p>最佳的方案应该是<strong>只声明引入png，让老浏览器使用默认的方式引入ico</strong>，这样最稳妥。(但实际上，把ico文件放在根目录时，某些现代浏览器可能并不会引入它)</p>
<pre><code class="language-JavaScript">&lt;!-- For IE 10 and below --&gt;  
&lt;!--  No link, just place a file called favicon.ico in the root directory --&gt;

&lt;!-- For IE 11, Chrome, Firefox, Safari, Opera --&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-16.png&quot; sizes=&quot;16x16&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-32.png&quot; sizes=&quot;32x32&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-48.png&quot; sizes=&quot;48x48&quot; type=&quot;image/png&quot;&gt;  
&lt;link rel=&quot;icon&quot; href=&quot;path/to/favicon-62.png&quot; sizes=&quot;62x62&quot; type=&quot;image/png&quot;&gt;  
</code></pre>
<h2 id="移动设备的touch-icon"><a class="header-anchor" href="#移动设备的touch-icon"></a>移动设备的touch Icon</h2>
<p>一些移动设备允许用户自定义浏览器主页书签。像原生app图标一样，在这种情景下，我们应该提供专门的图标。</p>
<p>怎么指定这个图标由浏览器/移动设备决定：</p>
<table>
<thead>
<tr>
<th>Device / Browser</th>
<th>Link “rel”</th>
<th>Sizes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apple / Safari</td>
<td>link rel=”apple-touch-icon” or link rel=”apple-touch-icon-precomposed”</td>
<td>76x76 - iPad 2 and iPad mini ;120x120 - iPhone 4s, 5, 6 ;152x152 - iPad (retina) ;180x180 - iPhone 6 Plus</td>
</tr>
<tr>
<td>Apple / Opera Coast</td>
<td>link rel=”icon” (<a href="https://dev.opera.com/articles/opera-coast/" target="_blank" rel="noopener">Will also accept Safari and Windows formats</a>)</td>
<td>228x228</td>
</tr>
<tr>
<td>Android / Chrome</td>
<td>link rel=”icon” (<a href="https://developer.chrome.com/multidevice/android/installtohomescreen" target="_blank" rel="noopener">Will, for a limited time, also accept Safari format</a>)</td>
<td>192x192</td>
</tr>
</tbody>
</table>
<p>对于Windows，这些图标应该用meta标签指定。</p>
<p>For Windows 8 / IE 10 -</p>
<pre><code class="language-html">&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;pinned-tile.png&quot;&gt;  
&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#009900&quot;&gt;  
</code></pre>
<p>For Windows 8.1 / IE 11 -</p>
<pre><code class="language-html">&lt;!-- In &lt;head&gt; --&gt;  
&lt;meta name=&quot;msapplication-config&quot; content=&quot;ieconfig.xml&quot; /&gt;

&lt;!--  In ieconfig.xml --&gt;  
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;browserconfig&gt;  
  &lt;msapplication&gt;
    &lt;tile&gt;
      &lt;square70x70logo src=&quot;images/smalltile.png&quot;/&gt;
      &lt;square150x150logo src=&quot;images/mediumtile.png&quot;/&gt;
      &lt;wide310x150logo src=&quot;images/widetile.png&quot;/&gt;
      &lt;square310x310logo src=&quot;images/largetile.png&quot;/&gt;
      &lt;TileColor&gt;#009900&lt;/TileColor&gt;
    &lt;/tile&gt;
  &lt;/msapplication&gt;
&lt;/browserconfig&gt;  
</code></pre>
<p>就是这样，用到 favicon的地方还挺多的。如果是一个很基础的网站，我可能只会使用ico图标	。期待 SVG favicon 时代的到来。</p>
<p>另可参考：<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" rel="noopener">https://github.com/audreyr/favicon-cheat-sheet</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图标 </tag>
            
            <tag> meta标签 </tag>
            
            <tag> link标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发事件入门概述]]></title>
      <url>https://alexzhong22c.github.io/2017/02/25/webapp-events-intro/</url>
      <content type="html"><![CDATA[<p>本文修改自<a href="http://www.infoq.com/cn/articles/touch-pointer-event" target="_blank" rel="noopener">PPK的《移动Web手册》</a></p>
<a id="more"></a>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<p>触摸事件为苹果发明，它将触摸和鼠标两种行为区分开，而微软的指针事件则将它们合并，此标准更具前瞻性，现已被W3C采纳为正式标准。</p>
<p>早在2007年，苹果公司就发布了第一款真正支持触摸屏的浏览器。这款浏览器会监控用户的触摸操作，并派发相应的事件。</p>
<p>除了指针事件的发明者微软外，其他多数浏览器厂商复制谷歌或Mozilla的实现。这两套事件是本章讨论的主题。</p>
<p>乍一看，在指针事件上，IE又是那么“与众不同”，但事实并不如你所想。</p>
<p>微软在这方面提出了一个有趣的哲学观点，我们将在后面详细讨论。在撰写本书时，谷歌和Mozilla正在考虑着手实现指针事件。W3C也正在从触摸事件过渡到指针事件。</p>
<p>在大多数方面，触摸事件和指针事件是普通的JavaScript事件。当触摸动作发生时，触摸事件和指针事件被触发。你可以为它们指定事件处理函数，它们的事件对象也提供了有用的触摸相关的信息。触控事件和传统的鼠标、键盘事件之间有一些技术上的差异。 此外，出于兼容性的考虑，触屏设备必须触发鼠标事件，因为很多网站仍然依赖于它们。但是，在没有鼠标的设备上触发鼠标事件会发生什么事情呢？本章专门讨论这些问题。</p>
<p>本章的其余部分在本质上更具有哲学性。随着iPhone的推出，苹果引入了一种新的交互模式：触摸。 现在，触摸、传统鼠标、键盘三种交互模式并存。Web开发人员需要确保网站适应这三种交互模式。乍一看，触摸事件和鼠标事件差不多。那它们之间有什么区别呢？我们真的需要为触摸交互模式再设计一套事件吗？</p>
<h2 id="触摸事件"><a class="header-anchor" href="#触摸事件"></a>触摸事件</h2>
<ol>
<li>touchstart，在用户的手指触摸屏幕的瞬间触发。</li>
<li>touchmove，在用户移动手指的过程中连续触发。</li>
<li>touchend，用户的手指离开屏幕的瞬间触发。</li>
<li>touchcancel ，（不太被使用），其含义取决于浏览器。后面将会讨论。</li>
</ol>
<p>pointerdown、pointermove和pointerup事件在同一时刻触发</p>
<p>这些事件得到了大多数触屏浏览器的支持，但IE浏览器是一个例外。还有一些很古老的和不完善的浏览器也不支持，比如塞班Anna的默认浏览器。代理浏览器也不支持，因为这些事件不适用于代理浏览模式。其中的原因我们将会在“浏览器”一章讨论。</p>
<h3 id="touchcancel"><a class="header-anchor" href="#touchcancel"></a>touchcancel</h3>
<p>不同浏览器对<code>touchcancel</code>的实现有所不同。</p>
<p>幸运的是，我还没有发现必须使用touchcancel的情景。貌似其他脚本和库也几乎没有使用
touchcancel。有些代码为了安全起见，把它等同于touchend。综上所述，本章将忽略touchcancel事件。如果在某些情况下浏览器
没有触发touchend事件，导致一些奇怪的问题，你可以将touchend的处理函数绑定到touchcancel上。</p>
<h2 id="指针事件"><a class="header-anchor" href="#指针事件"></a>指针事件</h2>
<p><strong>指针事件合并了触摸和鼠标操作，它的必要性在于有一些超极本、平板电脑（Surface系列）同时支持触摸和鼠标操作，并且需要在两者间进行无缝的切换。</strong></p>
<ul>
<li>pointerdown</li>
<li>pointermove</li>
<li>pointerup</li>
<li>pointerover</li>
<li>pointerout</li>
</ul>
<h2 id="键盘事件"><a class="header-anchor" href="#键盘事件"></a>键盘事件</h2>
<p>因为容易理解，不解释。</p>
<h2 id="其他事件"><a class="header-anchor" href="#其他事件"></a>// 其他事件</h2>
<h3 id="触摸：touchenter和touchleave"><a class="header-anchor" href="#触摸：touchenter和touchleave"></a>触摸：touchenter和touchleave</h3>
<p>触摸事件规范中曾经包含<code>touchenter</code>和<code>touchleave</code>事件，这两个事件在用户手指移入
或移出某个元素时触发。但是这两个事件从来没有被实现。微软有这两个事件的替代事件，但是只有IE浏览器支持。某些情况下可以知道用户手指滑入、滑出某个
元素是非常有用的，所以我希望这两个事件可以重返规范。现在暂时不应该用它们。</p>
<h3 id="缩放事件-不在规范"><a class="header-anchor" href="#缩放事件-不在规范"></a>缩放事件(不在规范)</h3>
<p>能响应用户缩放还是很有用的：比如你可以在用户缩放后改变界面，或者只是收集缩放数据以得知页面字号是不是过小。但既然不在规范内，就不应该使用。</p>
<h3 id="手势事件："><a class="header-anchor" href="#手势事件："></a>手势事件：</h3>
<p>两个或多个触摸事件同时发生。放大放小图片时等等场景会用到。仅Safari和IE支持，不建议使用。</p>
<p>手势事件存在两个问题：一来，其他浏览器不支持。二来，它们根本没什么用处。理论上，通过这套事件检
测用户的手势听起来很不错，但实际上，你需要分析触摸坐标、移动速度甚至加速度才能搞清楚用户真正的意图。所以我们不需要手势事件，因为普通的触摸事件已
经提供了同样的信息。所以本章不再讨论手势事件。</p>
<h2 id="实例"><a class="header-anchor" href="#实例"></a>实例</h2>
<p>通过实例对比触摸、指针事件与鼠标键盘事件。</p>
<ul>
<li>下拉菜单。对于用mouseover的下拉菜单，触摸事件几乎不可用。</li>
<li>拖拽。触摸和鼠标差不多，键盘难操作。</li>
<li>滚动层。鼠标难操作。</li>
</ul>
<h3 id="下拉菜单"><a class="header-anchor" href="#下拉菜单"></a>下拉菜单</h3>
<p>跨设备环境的最好解决方案是使用点击事件。点击展开菜单，而不是鼠标悬停时展开。点击另一菜单项则会收起当前菜单。我们在本章后面会看到，点击事件很安全。并且基于点击的下拉菜单可以适用于鼠标和触摸交互。</p>
<p>尽管如此，移动浏览器仍然需要与现实抗争：网上仍然有成千上万基于鼠标悬停的下拉菜单。幸运的是，下拉菜单是一个特殊的用例。苹果公司在设计触摸事件的时候已经考虑到了并且其他浏览器照搬了他们的实现。这点我们在本章后面会遇到。</p>
<p>与下拉菜单完全不同的一个实例是拖动和拖放。用户在鼠标按下时选中一个元素，然后移动，最后松开鼠标将元素放在某个地方。最后脚本会计算放置点是否有效并根据计算结果做出处理。</p>
<h3 id="拖放"><a class="header-anchor" href="#拖放"></a>拖放</h3>
<p>将这个实现移植到基于触摸的交互非常简单：将mousedown替换为touchstart，mousemove替换为touchmove，mouseup替换为touchend就可以了。唯一的问题是如何确定事件的坐标。后面我们会讲到。</p>
<p>这里的问题是键盘的可访问性。如何让用户通过键盘移动可拖动元素？你可以将一个区域的元素设置成可以 通过键盘聚焦，一旦某个元素得到焦点，就开始监听方向键。这在技术上并不困难，但是用户体验很差。这个问题基本上无法解决：拖放操作本身就是为鼠标和触摸 交互设计的，无法在键盘上得到好的体验。</p>
<h3 id="滚动层"><a class="header-anchor" href="#滚动层"></a>滚动层</h3>
<p>在2011年时，我需要一个可以在所有设备上工作的水平滚动元素。那时候设备还没有原生支持，仍需要脚本，所以我写过一个。现在设备已经原生支持，那段脚本不再需要了。这点我们在CSS章节已经看到。不过这段脚本仍然是一个很有用的实例，所以我们假设仍然需要那段脚本。</p>
<p><img src="https://cloud.az22c.top/roll-layer.png-az22cgithub" alt="img"></p>
<p>写这段脚本不是什么难事：在ontouchstart事件中计算滚动元素的当前位置，并初始化其他事 件处理函数；在ontouchmove事件中将元素移动相应像素的距离；在ontouchend中，运行一个函数来计算合理的减速，一旦被移动的元素停止 移动，这个函数结束。很简单吧，我花了大概两个小时。</p>
<p>非触摸设备怎么办呢？为了让滚动层可以工作，我需要将触摸交互翻译成鼠标、键盘交互。键盘很简单，只需监听keydown事件，当用户按下左/右键时滚动元素。这点可能不是那么容易发现，但是现在这个脚本算是正式支持键盘操作了。</p>
<p>鼠标设备怎么办？从技术上来讲，增加对mousedown、mousemove和mouseup事件的处理并不难，但是交互非常奇怪：用户必须一直按下鼠标按键才能滚动元素。这种交互和拖放一样，但是对于滚动层来说并不是那么直观。</p>
<p>我可以用老式的滚动条箭头：当鼠标移动到箭头上时脚本开始工作。但是视觉上看，增加箭头有些零乱。除此之外，当用户触摸或者使用键盘时还得隐藏箭头。我没有找到一种安全正确的方法（我们在后面会再次遇到这个问题），最终我并没有支持鼠标交互。</p>
<h2 id="事件和交互模式"><a class="header-anchor" href="#事件和交互模式"></a>事件和交互模式</h2>
<ul>
<li>鼠标事件。1996年Netscape引入</li>
<li>键盘事件。后来引入。</li>
<li>触摸交互。2007年左右开始出现。</li>
</ul>
<p>Web开发者必须确保他们的网站可以在三种交互模式下正常工作。做到这点有时候很简单，有时候却很困难，不过都是必要的。不仅是为你现在的网站增加这些支持，你应该开始思考为UI元素增加对各种操作模式的支持。</p>
<p>在未来，我们可能会有更多的交互模式，比如Xbox
Kinect，它将身体动作转换成屏幕动作。这样你可以用你的手来控制屏幕上的指针。从技术角度来讲，控制指针意味着将使用鼠标事件，但是从用户的角度看这是一种新的操作模式。毕竟感觉上完全不同。</p>
<p>汽车、冰箱、可穿戴以及新兴的设备都可能为用户和Web开发人员带来新的交互模式，比如doorclose（关门）事件。</p>
<p>思考交互模式和JavaScript事件带来三个问题：</p>
<ol>
<li>是不是每个交互模式都需要自己的事件？</li>
<li>已有的交互模式的事件在新设备上不再有意义时，是否需要继续支持？</li>
<li>如何判断设备支持哪种交互模式或用户正在使用哪种模式？</li>
</ol>
<p>目前来看，前两个问题的答案是肯定的，第三个问题的答案比较复杂。但是，在将来，第一个问题的答案可能是否定的。再看看Kinect的例子：我们是发明全新的硬件事件，还是使用指针和鼠标事件呢？从技术上来讲，无论用户怎么移动，指针还是指针。</p>
<h3 id="等价事件"><a class="header-anchor" href="#等价事件"></a>等价事件</h3>
<p>目前每种交互模式都有自己的一套事件，但这并不意味着它们是完全无关且不同的。事实上，某些事件是等价的。下面的表格给出了这方面的情况。</p>
<p><img src="https://cloud.az22c.top/compare-3-events1.png-az22cgithub" alt="img"></p>
<p>很显然，触摸动作序列：touchstart-touchmove-touchend和鼠标序 列：mousedown-mousemove-mouseup以及键盘序列：keydown-keypress-keyup很相似，这并不是巧合，因为这 三种交互模式都可以描述为start-move-stop。（所以我们不需要完全不同的事件，对不对？）</p>
<p>但是，有时候两个操作模式很像，但第三个却不。比如在下拉菜单的例子里，鼠标和键盘很像，而触摸不同。在拖放实例中，鼠标和触摸几乎一致，但键盘非常不同。在滚动层的例子里，这三种操作模式完全不同。（所以我们还是需要不同的事件，对吧？）</p>
<p>最后是mouseover和mouseout的问题。focus和blur是它们的键盘模式的等价事件，但是触摸模式没有这样的等价事件。就像我们在“CSS”一章看到的，在触摸屏设备中不存在“悬停”。</p>
<h3 id="触摸事件的不同之处"><a class="header-anchor" href="#触摸事件的不同之处"></a>触摸事件的不同之处</h3>
<p>可以看出，等价事件确实存在，这取决于上下文。但是触摸、按键和鼠标事件并不完全相同。显然，由于键盘是这三种交互模式中最与众不同的，所以Web开发人员倾向于将注意力集中在鼠标与触摸上。让我们先来讨论这二者的差异吧。</p>
<p>当鼠标指针移入某个元素，或者用户按下某个鼠标按键时，系统可以立即判断出应该触发哪个事件。而对于 触摸操作来说就不同了，**触摸操作可以引出不同的动作：在你的手指触碰屏幕的瞬间，系统还无法判断出你的意图。**你只是想轻触（Tap）某个元素？还是想滚动 某个可滚动元素？亦或是想缩放？还是想双触（Double-Tap）？浏览器必须等待一定时间间隔才能做出判断。这个时间间隔并不是非常短，而是一个可察 觉的间隔。这点在后面还会讲到。</p>
<p>**多个触摸动作可以同时发生。**这一点对鼠标动作来说是不可能的：一台计算机只能有一个鼠标（指针）。通 常来说，多点触摸不会带来麻烦：大多数网站只支持单点触摸。单点触摸很容易用鼠标来模拟。即便是网页中有两个滑动条，它们之间也不会互相干扰。因为就算用 户同时滑动它们，你也可以认为它们之间是相互独立的。二者都可以很好地通过触摸和鼠标进行操作。</p>
<p>当网站允许并需要多点触摸时，情况就不同了。如果脚本将同时发生的多点触摸翻译成手势、旋转或者缩放动作，鼠标就无法模拟了。多点触摸带来的问题需要具体问题具体分析。但是你必须意识到这一点。</p>
<p>鼠标指针总是指着某一个像素，而手指触摸会覆盖很多像素点。通常，系统会从这些像素点计算出一个中心点作为触摸事件的坐标。并且在touchstart和touchend之间给手指移动留有余地。但是后面会讲到有些浏览器并没有这么做。</p>
<p>**触摸事件是不连续的，而鼠标事件是连续的。**当你将鼠标指针从元素A移动到元素B时，鼠标指针会不可避 免地掠过AB之间的元素。鼠标移动是连续的还意味着你可以通过脚本进行监控。触摸操作就不同了，你可以放开元素A，抬起手直接去碰元素B。这正是我们在下 拉菜单实例里试图支持触摸事件时遇到的问题。下拉菜单设计之初就需要连续的事件，因为它是为鼠标环境而设计的。</p>
<p>**触摸事件比鼠标事件携带了更多的信息。**比如，触摸屏可以探测到用户手指的温度，触摸区域的半径，触摸的压力值。现在虽然没有给出这些数据，不过将来很有可能给出。因为在IE的指针事件中，已经预留了一些对应的属性。</p>
<p>不管怎样，鼠标和触摸虽然相似但又不完全相同。</p>
<h3 id="指针事件-v2"><a class="header-anchor" href="#指针事件-v2"></a>指针事件</h3>
<blockquote>
<p>事实上因为兼容性问题，**直到现在指针事件仍是不可用的，**最好还是用苹果的触摸事件。</p>
</blockquote>
<p>我们发现，通常情况下鼠标事件和触摸事件非常相似，但是二者还是有一些本质区别的。有了这个认识，我们就可以更好地理解微软的指针事件，以及为什么会提出指针事件。</p>
<p>微软认为没有必要分出鼠标、触摸两种事件。不管是鼠标指针、手指（触摸）还是触控笔（也叫定位笔），统称为指针，只要通过这些指针改变了些什么，就触发指针事件。所以，下面是微软版本的等价事件：</p>
<p><img src="https://cloud.az22c.top/compare-3-events2.png-az22cgithub" alt="img"></p>
<p>现在我们有了两种事件分类方式：鼠标、触摸分离的苹果版本；鼠标、触摸整合的微软版本。到目前为止， 只有IE支持微软的版本。其他浏览器都支持苹果版本。又如我们在前面看到的，Mozilla和Google正在考虑实现指针事件 （PointerEvent）。所以未来情况可能还会发生变化。</p>
<p>Google 之所以对指针事件感兴趣，是因为它的Chromebook Pixel笔记本和微软的Surface平板电脑一样，都有触摸屏和带触摸板的键盘。二者都支持鼠标和触摸操作。如果这两种事件能统一成一种，网站对它们的支持就会变得简单很多。</p>
<p>微软的Surface是一个触屏平板电脑，你还可以外接一个带触摸板的键盘。在访问网站时你可以在鼠标和触摸之间切换。这种情况需要通过指针事件来处理。</p>
<p>我个人认为微软的方案是个好主意。随着时间的推移，越来越多的设备会同时支持鼠标和触摸操作。所以指 针事件是超前意识。同时指针事件可以方便地扩展以支持其他操作，而不局限于触控笔，还包括Wacom绘图板之类的设备。在将来，可以方便地囊括体感电视遥 控器、Kinect动作。这两种操作都可以操控指针、激活元素，比如激活链接。（不过，关冰箱门事件不在这个范围内。）所以，指针事件比相互分离的鼠标和 触摸事件有更好的前景。</p>
<p>我们来试试在刚才上面三个实例中实现指针事件。</p>
<ol>
<li>拖放操作完美匹配：无论用户是用鼠标还是触摸，亦或是触控笔选中了一个元素，拖动它然后放下它。指针事件都可以在不增加代码的情况下支持Kinect、电视遥控和其他类似指针的操作。</li>
<li>滚动层可以在指针事件下正常工作。在触摸交互模式下，滚动层完美工作。当使用触控笔时，用户在滚动层按下、滚动，最后释放。这个操作也讲得 通。鼠标操作和触控笔相似，但是按下笔选取滚动层这个操作有些奇怪。这也是为什么我觉得对滚动层的操作很难移植到鼠标操作。不过，无论我们使用分离的鼠 标、触摸事件还是使用指针事件，这个问题仍然存在。所以指针事件不会带来额外的问题。</li>
<li>下拉菜单是三个实例中最复杂的一个。pointerover和pointerout看似恰是为下拉菜单设计的。但是仔细一看，完全不是。<strong>下拉菜单无法很好地在触摸交互下工作，就算换成指针事件也一样。最好的处理方法还是用点击（click）事件。</strong></li>
</ol>
<p>上面的实例说明，当某种交互不是专门针对某个操作模式设计的时候，指针事件就能很好地工作。在后面我 们会讨论，如果你愿意，你还是可以<strong>通过指针事件对象的pointerType属性来判断是鼠标还是触摸操作。</strong>（指针事件的初衷是统一鼠标、触摸事件，显然 这个属性与初衷相悖，不过这也是实践所需。）</p>
<h3 id="mouseover和-pointerover"><a class="header-anchor" href="#mouseover和-pointerover"></a>mouseover和 pointerover</h3>
<p>pointerover融合了mouseover事件和我们虚构的“touchover”事件：在鼠 标指针或用户手指滑入某个元素时触发。pointerout则是在用户手指或鼠标指针离开某个元素时触发。这就是我们在CSS章节讨论的:hover问 题，只不过是在JavaScript上下文中。</p>
<p>我们再一次遇到了连续事件和非连续事件的本质区别。当使用鼠标从A移动到B时，用户必须经过A、B之 间的元素，别无选择。但是触摸操作就可以先触摸A，再直接触摸B，中间不会碰到其他任何元素。除非是在拖放元素，手指不能离开屏幕。此时 pointerover就很有用了：可以在pointerover时判断当前滑入的对象是不是一个合法的放置区域。</p>
<p>除了这种情景，pointerover与mouseover还是有本质区别的。尤其是在鼠标移入某个 区域后显示额外信息这类精细的操作中，鼠标移入（mouseover）根本无法正常工作。因为此时用户的触摸操作不太可能从某个地方移入期望的区域。更可 能的情况是，用户直接触摸相应的元素，而没有任何移入（pointerover）操作。当然，额外的信息也就无法展现出来了。</p>
<p>解决办法是，只处理mouseover和mouseout事件。因为这两个事件在触摸操作时都会被触发。仅在触摸点移入和移出时不会触发，这一点我们在后面会详细解释。虽然有了这个解决方案，但是由于悬停操作在触摸环境下实在是太另类了，所以这个方案并不完美。</p>
<h3 id="输入模式的渐进增强"><a class="header-anchor" href="#输入模式的渐进增强"></a>输入模式的渐进增强</h3>
<p>渐进增强就像响应式设计教导我们的，要支持各种屏幕尺寸的设备，我们必须想办法来支持多种输入模式（这里的输入模式指鼠标、触摸、键盘等输入模式）。我们暂且称之为输入模式的渐进增强。不过“输入模式的渐进增强”的概念并没有“响应式设计”那么一目了然。</p>
<p>“响应式设计”的基本思想是以同一个设计适应多种屏幕尺寸。而“输入模式的渐进增强”在很多情况下需要我们为不同输入模式分别编写不同的脚本。比如前面讲到的滚动层实例就需要我们为鼠标、键盘和触摸写三个不同的脚本。</p>
<p>除此之外，在用户与网站交互的过程中，屏幕尺寸通常是不会改变的。而输入模式却可以频繁改变。以微软的Surface平板为例：在浏览同一页面时，用户可以在鼠标和触摸操作之间随意切换。而你的脚本必须支持这种复杂的操作。</p>
<p>通常情况下，相比智能手机来说，这种支持对平板电脑来说更重要。因为手机上的输入模式相对少一些。尽管如此，也不要一厢情愿地假设在浏览页面时用户只使用一种输入模式。虽然这种假设可以让Web开发者的工作变得轻松一些，但是并不能改变这骨感的现实。</p>
<p>我们可以从响应式设计中借鉴一些思想应用到“输入模式的渐进增强”中。在“响应式设计”中有一个好的 思想：**从限制最多的情况着手，<strong>比如最小的屏幕。类似的，D-pad可以算是最局限的输入模式了。它由四个方向键和一个OK键组成。好消息是，D-pad的 按键完全和普通键盘兼容：触发相同的事件、使用相同的键码。所以我们不需要区分D-pad和普通键盘。坏消息是，尽管如此，它们还是很有局限性。更坏的消息是，在这方面我也没有什么指导意见可以分享。因为“输入模式的渐进增强”这个概念太新了，以至于我们</strong>还没有找到普适的应对策略。**而且连一些可以帮助大家 的好点子都很少。你可以把这视为一个问题，也可以视为一个挑战。谁知道呢，没准你就是那个教会这个世界如何实现“输入模式的渐进增强”的人。</p>
<h3 id="判断当前的交互模式"><a class="header-anchor" href="#判断当前的交互模式"></a>判断当前的交互模式</h3>
<p>“输入模式的渐进增强”可能需要你去检测用户的当前交互模式。尽管很困难，但这在技术上可以实现。然而，我们真正的问题是，它究竟能提供哪些有用的信息呢？</p>
<p>让我们再次以微软Surface的用户为例。你可以检测到用户正在使用鼠标。但这是否意味着他们将在 整个会话中一直使用鼠标呢?不尽其然。事实上，他们很有可能、或者至少是偶尔地会使用键盘或是触摸屏，又或者干脆把键盘和鼠标触控板折叠起来，只使用触摸 屏。假如发生了以上任一情况，那么你的互动模式检测的价值何在呢？</p>
<p>你唯一可以确定的合理判断是，当用户以某种模式开始某个动作时，他们不会在中途切换模式。因此，如果 你检测到用户正移动鼠标进行拖放，那么他们不太可能在拖曳过程中切换到触摸操作。但是，一旦拖放完成，用户就可能选择切换到触摸、或继续使用鼠标、亦或使 用键盘，来进行下一步操作。</p>
<p>**你必须确保所有交互在任何交互模式下均可实现，**这一点至关重要。鼠标、触摸甚至键盘都应该可以执行拖放操作。一旦做到了这一点，那么用户正在使用何种交	互模式都将无关紧要。</p>
<p>让我们假设，你有很好的理由去寻找当前的交互模式。也许你想收集一些数据来研究用户的模式使用偏好。那么我们来看一下几种可能性。</p>
<ul>
<li>指针事件最简单明了：它具备pointerType属性，其值可以是mouse、touch或pen。找到当前值即可知道用户的操作。另一 个简单的情况：当有任何按键事件触发时，用户一定会使用键盘。但这与未来的交互无关——用户仍然可能随时转换到键盘或是触摸。但无论如何，这还是提供了一 些有用的信息。</li>
<li>与之类似的，当一个触摸事件触发时，你可以肯定你的用户在当下一定正在使用触摸交互模式。同理，这并不影响未来的交互，但至少提供了一些信息。</li>
<li>对于鼠标事件要格外小心：当用户触摸屏幕时，鼠标事件也会触发，因此检测交互模式并不适用于鼠标事件。检测鼠标使用的方法就是排除其他交互模式。如果用户没有使用触摸或键盘，那么他有可能正在使用鼠标。</li>
</ul>
<p>目前有很多方法可以检测到一个触摸交互模式是否可用。其中有一种由Modernizr普及，但可惜并不十分可靠的方法是：</p>
<pre><code class="language-javascript">var hasTouch = !!('ontouchstart' in window);
</code></pre>
<p>“如果window对象有ontouchstart属性，说明浏览器支持触摸事件，我们就可以放心地 使用。”这可能正是你所想的。前半句的结论是“虽然正确”，但是，支持触摸事件的浏览器并不一定运行在具有触摸屏的设备上。比如，黑莓6的浏览器支持触摸 事件，但它却运行在一个非触摸设备上。老版本的Chrome浏览器也有类似的问题。并且，依赖ontouchstart的方法让IE变得无能为力。</p>
<p>唯一安全的检测浏览器支持触摸事件、运行在触摸设备上并且用户正在使用触摸交互的方法就是看是否确实有触摸或指针事件被触发。</p>
<pre><code class="language-javascript">    var hasTouch = false;
    document.ontouchstart = function () { 
        hasTouch = true;
    }
    document.onpointerdown = function (e) { 
        if (e.pointerType === 'touch') {
            hasTouch = true;
        }
    }
</code></pre>
<p><strong>最好的办法是依次检测各种交互模式：首先从指针事件开始。pointerType属性可以提供有用的信息。然后检测触摸事件。后面我们会看到触摸操作还会触发鼠标事件，所以只有当触摸事件没有触发时，才考虑鼠标事件。最后轮到键盘。</strong></p>
<pre><code class="language-javascript">    var interactionMode;
    document.onpointerdown = function (e) { 
        interactionMode = e.pointerType;
    }
    document.ontouchstart = function () {
        if (!interactionMode) {
            interactionMode = 'touch';
        }
    }
    document.onmousedown = function () {
        if (!interactionMode) {
            interactionMode = 'mouse';
        }
    }
    document.onkeydown = function () { 
        if (!interactionMode) {
            interactionMode = 'keyboard';
        }
    }
</code></pre>
<p>登录界面或类似的地方是运行上面代码的理想场景。在这个场景中，用户必须与网站交互。当用户登录时， 用类似上面的代码检测用户正在使用哪种交互方式。要注意，这也只能说明用户在登录时使用的交互模式，并不是整个交互过程都会使用这个模式。虽然信息有限， 但这段代码还是有一定预测功能的。</p>
<p>尽管上面的方法无法预测用户接下来会使用哪种交互模式，但是目前最好的处理不同交互模式的方法还是<strong>为鼠标、键盘和触摸编写不同的代码。</strong></p>
<h2 id="补充"><a class="header-anchor" href="#补充"></a>补充</h2>
<h3 id="触摸事件的级联"><a class="header-anchor" href="#触摸事件的级联"></a>触摸事件的级联</h3>
<p>移动浏览器同时支持触摸事件和鼠标事件，会导致一个触摸动作触发多个事件。</p>
<ul>
<li>触摸（Tap）：touchstart/pointerdown、touchend/pointerup、mouseover、mousemove、mousedown、mouseup、click、:hover样式（需要注意的是为了兼容mouseover，抬起手指并不会触发mouseout，再次触摸才会）</li>
<li>滑动（Swipe）：touchstart、touchmove、touchend、scroll</li>
<li>缩放（Pinch）：touchstart、touchmove、touchend、scroll，可能还有resize</li>
<li>双触（double-tap）：touchstart、两次touchend、scroll，可能还有resize</li>
<li>按住（touchhold）：touchstart、touchend，有些浏览器还有contextmenu</li>
</ul>
<h3 id="剖析click"><a class="header-anchor" href="#剖析click"></a>剖析click</h3>
<p>300毫秒问题，无解。（Chrome支持但苹果不可能支持）</p>
]]></content>
      
        <categories>
            
            <category> WebApp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 触摸事件 </tag>
            
            <tag> 指针事件 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发入门概述]]></title>
      <url>https://alexzhong22c.github.io/2017/02/24/webapp-intro/</url>
      <content type="html"><![CDATA[<p><strong>PPK的《移动Web手册》</strong> 是对移动Web现状（2014年夏）的一个系统检阅，市场上有不少公司将赌注放在HTML5上，因此对于HTML5在移动Web上的应用多有炒作，但实际上如何呢？看完本书能让你有个清醒的认识。</p>
<p>移动浏览器虽然大都实现了桌面浏览器的功能，但实际上移动设备上的情况更加复杂，而且由于Android系统的碎片化直接导致浏览器的碎片化，它们对于一些和桌面不同情况的处理，以及一些最新特性的支持都是不尽相同的。</p>
<p><strong>所以HTML5在移动Web上的兼容性目前是很差的，</strong> 还有像触摸事件向指针事件标准化的过渡，估计最少需要5-10年才能达到一个比较理想的状态。</p>
<a id="more"></a>
<h2 id="浏览器相关"><a class="header-anchor" href="#浏览器相关"></a>浏览器相关</h2>
<h3 id="浏览器的类型"><a class="header-anchor" href="#浏览器的类型"></a>浏览器的类型</h3>
<ul>
<li>内置浏览器</li>
<li>可下载浏览器</li>
<li>代理浏览器</li>
<li>webview</li>
</ul>
<p>大多数内置浏览器都被紧密集成到底层的操作系统中，也就是说，无法单独升级浏览器。因此，为了得到新的Safary版本，你必须升级IOS。内置浏览器都有不同的内核比如：安卓是webkit、winphone是ie、ios是safari，大致上就是这样。</p>
<p>可下载浏览器，顾名思义用户可下载安装的浏览器，见的多的就是firefox、chrome了、360等。</p>
<p>代理浏览器是指服务端进行对页面的渲染，再把结果发送给客户端进行显示，比较少见。代理浏览器与完备浏览器（full browser）相对，代表为opera mini、UC mini。</p>
<p>WebView是留给原生应用的一个操作系统浏览接口。苹果不允许在IOS设备上安装其他渲染引擎。（其他平台是可以的）因此，其他浏览器要想在IOS上安装就必须用苹果的WebView。IOS上的Chrome就是这样的，同样的还有Opera Coast。大体上，WebView是独立的程序，用了内置浏览器很多底层的组件（比如渲染引擎），但是在其他方面可能会有所不同。<strong>如果希望你的页面能在WebView里跑起来的话，你最好在WebView上测试一下。</strong></p>
<p>补充：</p>
<blockquote>
<p>代理浏览器的原理：当用户请求页面，它不会发送一个普通HTTP请求而是通过加密链接发送特殊请求到一个特殊的代理服务器。代理服务器来抓取用户希望访问的内容，渲染页面，然后压缩渲染的页面成为某种图片，类似于PDF，然后代理服务器将这个文件发到客户端。</p>
<ul>
<li>好处：给用户节省流量。</li>
<li>弊端：页面内的javascript不能正常工作。</li>
</ul>
<p>随着现在wifi的普及等原因，代理浏览器用得很少。</p>
</blockquote>
<hr>
<h3 id="手机上的webkit"><a class="header-anchor" href="#手机上的webkit"></a>手机上的WebKit</h3>
<p>先列出不使用WebKit的浏览器：</p>
<blockquote>
<p>1. IE Mobile(即将替换为edge)，使用Trident
2. Opera Mini使用Presto，但是最终会换成Blink
3. Chrome浏览器用Blink
4. Firefox Mobile和Firefox OS使用Gecko
5. UC Mini、Nokia Xpress还有Jolla的Sailfish OS上的内置浏览器也用的是Gecko</p>
</blockquote>
<p>任何没在上面提到的浏览器都用WebKit。乍一看，这么多浏览器都用WebKit的事实对于Web开发者似乎是一个强大的支持，不幸的是，一个浏览器用Webkit并不意味着它跟其他任何基于Webkit的浏览器一样。实际上，**它们有很大的不同，依赖于操作系统、键盘、鼠标还有触屏交互。平台所有者必须提供所有这些功能。**手机上的Webkit名存实亡。</p>
<p>很多浏览器用着差不多一样的渲染引擎但是在细节上却大不相同。你最好在所有不同的基于WebKit的浏览器上测试你的网站。</p>
<hr>
<h3 id="测试android浏览器"><a class="header-anchor" href="#测试android浏览器"></a>测试Android浏览器</h3>
<p>对于Android设备的浏览器，有三个必须测试的浏览器：</p>
<blockquote>
<p>1. 安卓WebKit4，富含不同的设备和不同版本的安卓系统。一个专门的设备实验室需要大概6到8个这样的来自不同厂商的设备。一个小型实验室必须拥有2到3个：三星、HTC和一个其他厂商的设备
2. Google Chrome。如果你的设备上没有，下载一个。
3. 三星Chrome（三星字Galaxy S4发布以来，三星开始使用他自己开发的基于Chromium的一款浏览器作为内置浏览器，因此出现三星Chrome）。你讲需要购买一个2013年获以后发布的三星高端手机——类似Galaxy S4或更新的设备</p>
</blockquote>
<h2 id="视口相关"><a class="header-anchor" href="#视口相关"></a>视口相关</h2>
<h3 id="css像素和设备像素"><a class="header-anchor" href="#css像素和设备像素"></a>css像素和设备像素</h3>
<p>设备像素：设备屏幕的物理像素。</p>
<p>CSS像素：为Web开发者创造的，在CSS和JS中使用的一个抽象层。CSS像素和设备像素的比例取决于屏幕是否高DPI和用户缩放的比例。</p>
<blockquote>
<p>css像素是专门为我们Web开发者创造的一个抽象层。当在使用css和javascript的时候，你并不在意一个css像素跨越了多少个设备像素。你开心地将这个依赖于屏幕特性和用户缩放程度的复杂计算交给了浏览器。</p>
<p>用户放大得越大，一个css像素覆盖的设备像素越多。</p>
</blockquote>
<hr>
<h3 id="布局视口"><a class="header-anchor" href="#布局视口"></a>布局视口</h3>
<p>CSS布局会根据它来计算，并被它约束。在手机上，为了容纳为桌面浏览器设计的网站，**默认的布局视口宽度远大于屏幕的宽度。**为了让用户看到网站全貌，它会缩小网站。</p>
<pre><code class="language-html">&lt;!-- width属性设置布局视口的宽度为特定的值 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
</code></pre>
<p>但在另一篇文章里面，并不推荐设置width属性。</p>
<h3 id="视觉视口"><a class="header-anchor" href="#视觉视口"></a>视觉视口</h3>
<p>它是用户正在看到的网站的区域。这个视口与设备屏幕一样宽。</p>
<p>用户可以缩放来操作视觉视口，同时不会影响布局视口，布局视口仍保持在原来的宽度。视觉视口与设备屏幕一样宽，并且它的CSS像素的数量会随着用户缩放而改变。</p>
<h3 id="理想视口"><a class="header-anchor" href="#理想视口"></a>理想视口</h3>
<p>对于特定设备上的特定浏览器的布局视口的一个理想尺寸，在这个尺寸下，用户刚进入页面时不再需要缩放，拥有最理想的浏览和阅读的宽度。</p>
<hr>
<h3 id="缩放"><a class="header-anchor" href="#缩放"></a>缩放</h3>
<p>桌面浏览器的缩放仅改变内容尺寸，不改变布局视口；移动端缩放则整体改变。</p>
<p><strong>不要禁止缩放！</strong> 禁止缩放是邪恶的，并且浏览器可以关闭禁止缩放功能。</p>
<p>禁止缩放的代码为：</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
</code></pre>
<h3 id="分辨率"><a class="header-anchor" href="#分辨率"></a>分辨率</h3>
<p>物理分辨率：设备每英寸内点数（DPI）</p>
<p>设备像素比：设备像素个数和理想视口的比（DPR）</p>
<p>dppx和dpi：每一个像素的点数。JS中的<code>window.devicePixelRatio</code>和媒体查询的<code>device-pixel-ratio</code>的单位。IE不支持，因此要使用dpi单位：</p>
<pre><code class="language-javascript">if(window.devicePixelRatio) {
    // DPR大于等于2时执行
}

@media all and((-webkit-min-device-pixel-ratio:2), (min-resolution:192dpi)) {
    // DPR大于等于2时生效
}
</code></pre>
<p>1dppx = 96dpi：一英寸对应CSS中96个像素。</p>
<h3 id="meta视口标签："><a class="header-anchor" href="#meta视口标签："></a>meta视口标签：</h3>
<p>meta视口标签存在的主要目的是让布局视口的尺寸和理想视口的尺寸匹配。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot;&gt;
</code></pre>
<p>其中可用的name为：</p>
<ul>
<li>width：device-width适用于大多数情况。</li>
<li>initial-scale：一般设为1，为了兼容应同时设置width=device-width。</li>
<li>minimum-scale</li>
<li>maximum-scale</li>
<li>user-scalable</li>
</ul>
<h3 id="媒体查询"><a class="header-anchor" href="#媒体查询"></a>媒体查询</h3>
<p>媒体类型：目前只有print被正确实现。一般使用all。</p>
<blockquote>
<p>Web开发者希望区分能力弱和能力强的浏览器，而弱浏览器为了避免探测开始伪装自己。</p>
<p>过去的浏览器最多可处理WAP和HTML的子集XHTML-MP，它们大都遵循标准并实现handheld，Web开发者为这些类型提供简单的样式。而新的现代移动浏览器出现后，它们支持全部样式、JS，因此宁愿不实现handheld而获得和桌面浏览器一样的待遇。</p>
</blockquote>
<h3 id="javascript"><a class="header-anchor" href="#javascript"></a>JavaScript</h3>
<p>媒体查询与JavaScript属性相对应。</p>
<ul>
<li>物理屏幕分辨率：screen.width/height（有兼容问题不建议使用）</li>
<li>布局视口：document.documentElement.clientWidth</li>
<li>视觉视口：window.innerWidth</li>
<li>理想视口：screen.width/height（有兼容问题不建议使用）</li>
<li>设备像素比：window.devicePixelRatio</li>
<li>屏幕方向：window.orientation</li>
</ul>
<p><code>document.documentElement.clientWidth/Height</code>返回的是布局视口的尺寸，被普遍支持。</p>
<p><code>window.innerWidth/Height</code>返回视觉视口的尺寸。接近被普遍支持。</p>
<p><code>screen.width/height</code>返回理想视口的尺寸。有很严重的浏览器兼容性问题，	不建议使用。</p>
<h2 id="css相关"><a class="header-anchor" href="#css相关"></a>CSS相关</h2>
<p>移动浏览器与桌面浏览器对CSS支持的差异：</p>
<ul>
<li>桌面用例在移动端不存在。如hover。</li>
<li>视口不统一。如单位vw和vh。</li>
<li>对独立可滚动层的需求在移动设备上更难实现。如background-attachment。</li>
<li>硬件限制。在老设备上transition和animation可能无法使用。</li>
</ul>
<p>以下属性都<strong>不建议</strong>在移动Web上使用:</p>
<h3 id="position-fixed"><a class="header-anchor" href="#position-fixed"></a>position:fixed</h3>
<p>此属性标准没有支持缩放。</p>
<h3 id="overflow-auto"><a class="header-anchor" href="#overflow-auto"></a>overflow:auto</h3>
<p>多个可滚动层体验不好，并且移动上默认不显示滚动条会漏掉内容。</p>
<p><code>-webkit-overflow-scrolling:auto</code>：平滑滚动。</p>
<h3 id="background-attachment"><a class="header-anchor" href="#background-attachment"></a>background-attachment</h3>
<p>三个可选值scroll、fixed、local。会创建过多的可滚动层，影响性能。</p>
<h3 id="尺寸单位vw和vh"><a class="header-anchor" href="#尺寸单位vw和vh"></a>尺寸单位vw和vh</h3>
<p>非常冷门的单位，本来也没什么人用，这里就不多说了。</p>
<h3 id="active和-hover"><a class="header-anchor" href="#active和-hover"></a>:active和:hover</h3>
<p><code>:hover</code>在桌面浏览器用的过多，因此移动设备必须支持，但实际上在用户触摸元素时触发，引起事件级联。</p>
<p><code>:active</code>相对支持的不好，可以和<code>:focus</code>同时使用，后者支持的较好。</p>
<h3 id="transition和animation"><a class="header-anchor" href="#transition和animation"></a>transition和animation</h3>
<p>实际上浏览器支持的很好，但这两个属性会用到GPU，而移动设备GPU很糟糕，至少是早期的很糟糕。</p>
<h3 id="css过度和动画"><a class="header-anchor" href="#css过度和动画"></a>css过度和动画</h3>
<p>只要你使用了过度和动画，就在你能找到的最老、最差的设备上进行测试。它们的问题不在浏览器，而在<strong>设备</strong>，浏览器对两者的支持都很好。但是为了达到非常平滑的效果，浏览器必须借助设备GPU的计算能力。在高端智能手机上不成问题，但对于早期和廉价的手机来说，它们可能根本没有响应的硬件和系统API。这就导致最终的动画效果很生硬。</p>
<h2 id="触摸和指针事件"><a class="header-anchor" href="#触摸和指针事件"></a>触摸和指针事件</h2>
<p>触摸事件为苹果发明，它将触摸和鼠标两种行为区分开，而微软的指针事件则将它们合并，此标准更具前瞻性，现已被W3C采纳为正式标准。</p>
<p>内容详见另一篇文章：</p>
<h2 id="克服过时的惯性思维"><a class="header-anchor" href="#克服过时的惯性思维"></a>克服过时的惯性思维</h2>
<ul>
<li>浏览器探测。事实上无论是浏览器探测还是特性探测在移动浏览器上都可能表现不佳。</li>
</ul>
<blockquote>
<p>浏览器只会返回它支持某项特性，但不会告诉你支持程度有多差。</p>
</blockquote>
<ul>
<li>Javascript脚本库。**在编写小功能时不要依赖脚本库而是应该用原生JS实现。 **</li>
</ul>
<h2 id="移动web的未来"><a class="header-anchor" href="#移动web的未来"></a>移动Web的未来</h2>
<h3 id="html5-vs-原生应用"><a class="header-anchor" href="#html5-vs-原生应用"></a>HTML5 vs 原生应用</h3>
<blockquote>
<p>全面追赶原生应用并不是Web技术的关键所在。我感觉我们应该聚焦在Web擅长的方面，并将它们做得更好。或者找出我们能够做好的方面，将它们做得超越原生应用。</p>
</blockquote>
<h3 id="模拟原生应用"><a class="header-anchor" href="#模拟原生应用"></a>模拟原生应用</h3>
<ul>
<li>网络连通性和AppCache。离线存储对移动Web应用非常有意义，但是AppCache简直是个垃圾。新的Service Worker试图取代它。</li>
<li>安装到主屏幕。被支持的并不好。</li>
<li>设备API。第一支持不完善，标准总是落后于现实；第二有安全问题，需要授权，而像安卓的用户授权是行不通的。</li>
</ul>
<blockquote>
<p>当你安装一个安卓应用时，系统会让你授权该应用可以具备哪些权限。这个设计的失败不仅在于我们需要更精细的权限控制，而且还在于它出现的时机不对：当用户安装某个应用时，用户只想尽快的用上它，他们会同意任何事情。</p>
</blockquote>
<h3 id="模拟web"><a class="header-anchor" href="#模拟web"></a>模拟Web</h3>
<p>Applink，直达应用的深层页面。（注：Android M和iOS 9都有类似的更新支持这项特性）</p>
<h3 id="分享应用"><a class="header-anchor" href="#分享应用"></a>分享应用</h3>
<p>PPK的脑洞：Web应用由于其良好的兼容性，应该让它可以通过蓝牙、NFC等在不同设备之间共享。</p>
]]></content>
      
        <categories>
            
            <category> WebApp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> H5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yelee主题改bug总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/22/my-hexo-theme/</url>
      <content type="html"><![CDATA[<p>从找一个喜欢的hexo主题到修改好bug发布到博客上面，整个过程花了我不少时间，下面是对这个改bug过程中发现的小问题做的总结。</p>
<p>此文无图。</p>
<a id="more"></a>
<p>一开始我是在知乎上面找好看的主题，找了很长一段时间才找到一个我比较喜欢的主题，并且挑选了一个已经被大神们优化得不错的主题来借鉴借鉴。</p>
<p>我的hexo主题其实就是直接Fork了<a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="noopener">ngudream</a>的主题，只不过该大神日常比较忙碌，我自己琢磨了一下代码，把一些报错的小bug给修复了，暂时还没有为这个主题添加什么特殊的功能。（原因是这个主题在各位大神的努力下，功能已经非常齐全炫酷了。）</p>
<p>直接参考ngudream的这篇文章就可以了，在此在此表示一万个感谢：</p>
<p><a href="http://ngudream.com/2017/01/24/n-hexo-blog/" target="_blank" rel="noopener">http://ngudream.com/2017/01/24/n-hexo-blog/</a></p>
<p>在这个过程中我发现了一些小问题：</p>
<h2 id="左右搜索栏"><a class="header-anchor" href="#左右搜索栏"></a>左右搜索栏</h2>
<p>一定要先根据这个来安装插件：</p>
<p><a href="http://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Yilia主题添加本地站内搜索-高明飞</a></p>
<h3 id="找不到content-json"><a class="header-anchor" href="#找不到content-json"></a>找不到content.json</h3>
<ul>
<li>这是因为左下角搜索栏找不到content.json</li>
</ul>
<ul>
<li>将<code>yelee\source</code>文件夹下的search文件夹剪切到 根目录的source文件夹里面</li>
<li>生成一次页面</li>
<li>再把刚刚的search文件夹剪切回<code>yelee\source</code>文件夹下即可</li>
</ul>
<h3 id="cb-search-json-404-not-found"><a class="header-anchor" href="#cb-search-json-404-not-found"></a>cb-search.json 404 (Not Found)</h3>
<ul>
<li>是因为没有安装右下角搜索栏插件</li>
</ul>
<ul>
<li>如果安装插件之后语法报错，就把别人项目的文件代码复制过来就行了，省得去检查语法</li>
</ul>
<h3 id="百度分享因为混合内容报错"><a class="header-anchor" href="#百度分享因为混合内容报错"></a>百度分享因为混合内容报错</h3>
<p>如果因为混合内容报错（即https网站引用了http的资源），你可以将百度分享的地址改为：<code>https://github.com/hrwhisper/baiduShare</code>；本来我想把static文件夹放在外面一点的，但是有bug，我现在只是做到不报错而已，具体的百度分享内容都没弄</p>
<h3 id="百度站长要重新配置"><a class="header-anchor" href="#百度站长要重新配置"></a>百度站长要重新配置</h3>
<ul>
<li>查阅相关资料，依照资料放baidu_verify_QshFoK3ZRz.html在yelee的source文件夹下通过站长验证，放googleeff62ed1566e185e.html也是同理。</li>
</ul>
<p>百度sitemap要另外安装：</p>
<pre><code>npm install hexo-generator-baidu-sitemap --save 
</code></pre>
<ul>
<li>如果想要给谷歌提交网站，只需要在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Search Console</a>验证网站，并提交站点地图就可以了。谷歌真的好简单啊！谷歌的<code>sitemap.xml</code>不需要写到配置文件中，自动生效。
<ul>
<li>有个问题是，Github禁止百度爬虫，所以提交的sitemap迟早会显示失败，成功几率非常小</li>
</ul>
</li>
</ul>
<h2 id="温馨提示"><a class="header-anchor" href="#温馨提示"></a>温馨提示</h2>
<ul>
<li>多说也是会因为混合内容而报错，但是我只能改良，不能彻底解决这个问题
<ul>
<li>将多说的<code>embed.js</code>本地化，	将这个文件的地址改动到<code>duoshuo.ejs</code>和<code>click2show.ejs</code>和layout的<code>after-footer.ejs</code>文件里面，但是依然报错</li>
<li>见到http就给它加s</li>
</ul>
</li>
<li>在Markdown文章头部的标注信息的冒号后面要加一个空格，这是语法要求</li>
</ul>
<ul>
<li>在hexo s调试下，百度站长push报错属于正常现象</li>
<li>在hexo s调试下，文章导航的特效会失灵，属于正常现象</li>
</ul>
<ul>
<li>发现大神每篇文章文件的名字都是英文，Markdown里面的标题才是中英随意的，不然isPost()函数会出错
<ul>
<li>用cmd创文件名的时候英文全小写，空格用-表示，为了风格统一</li>
</ul>
</li>
<li>插件这种东西最好不要复制，所以<strong>在重新搭建博客的时候</strong>我没有直接复制node_modules文件夹，这也容易令人忽略了大神自己在这个文件夹下改良的index.js和search.ejs文件</li>
</ul>
<h2 id="请不要fork我的主题"><a class="header-anchor" href="#请不要fork我的主题"></a>请不要Fork我的主题</h2>
<p>去Fork大神ngudream的主题就可以了，因为我的个人改动比较私人化，所以Fork之后别人可能会看不懂。另外我的主题作了几个不好的改动：</p>
<ul>
<li>为了避免报错，一开始我把一些if语句的判断条件直接改为false，原本它们的判断条件是xxx.on的</li>
</ul>
<ul>
<li>还有一个feed属性没研究，应该是订阅博客的功能，好像也被我粗暴地关了</li>
<li>报错<code>Cannot GET /plugins/css/special.css</code>，我直接把“字往下掉”动画关掉</li>
<li>然后就是折腾在显示主页时标签栏出现的undefined，一开始我不知道那个把三项文字的标签转为二项的js文件，所以一直研究ejs代码都没弄好。后来我直接给主页加一个英文名字blog就算了。总算不出现undefined</li>
<li>乱关乱开了一下博文最下方的分享栏，不知道会不会出问题，这个模块应该是百度分享</li>
<li>点击微信之后，那个左右滑动的栏目我暂时改不了代码，本来我想去掉qq的，但是只好把qq的二维码弄上
<ul>
<li>还有就是去掉qq之后，点击微信，上面那个圆形地方就没有图案显示</li>
</ul>
</li>
<li>发现search-result-list模块的文字被顶到后面
<ul>
<li>把.col-3的CSS的marginbottom改为4px就行了</li>
</ul>
</li>
</ul>
<h3 id="我没有完善的内容"><a class="header-anchor" href="#我没有完善的内容"></a>我没有完善的内容</h3>
<ul>
<li>代码压缩没搞</li>
<li>公益404没搞</li>
<li>右下角搜索栏搞了，但是利用的不是打分排名</li>
<li>谷歌分析到现在也不会，所以先不用，应该和百度站长是差不多的，没心思搞</li>
<li>好像就只有360浏览器看不到emoji表情，所以即便安装了插件，文章尽量不要用emoji</li>
</ul>
<h2 id="整个过程的心得"><a class="header-anchor" href="#整个过程的心得"></a>整个过程的心得</h2>
<ul>
<li>在这过程中学会了用HTML-beautify来美化sublime中的html代码排版</li>
<li>对ejs的代码写法有所了解</li>
<li>明白了代码中的partial是干嘛的：复用模板</li>
<li>第一次发现一些私人的代码改动都是写在<code>after-footer.ejs</code>里面</li>
<li>发现dos的报错信息还是有点用的</li>
<li>令我困惑的是填yml文件中的url项，后来发现用来填绑定的域名，域名要自己出钱买</li>
<li>一开始遇到<code>Cannot read property 'on' of undefined</code>不会调，后来发现是yml文件填得不好，可能是不符合语法，导致错误。再比如yml文件中代码没有在适当的地方空空格。</li>
<li>如果在网上打开js文件发现中文变乱码，在谷歌浏览器打开查看就可以了，这是最不消耗脑力的办法</li>
<li>另外，推荐一款布局非常合理的hexo主题： <a href="https://github.com/shenliyang/hexo-theme-snippet" target="_blank" rel="noopener">snippet</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> yelee </tag>
            
            <tag> theme </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ToDo小应用完工总结]]></title>
      <url>https://alexzhong22c.github.io/2017/02/17/todo-app/</url>
      <content type="html"><![CDATA[<p>完成了百度IFE2015的 <a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003" target="_blank" rel="noopener">task3</a> ，实现了一个 ToDo 的单页应用，功能颇为强大。</p>
<p>使用 localStorage 存储数据，JSON 模拟数据表，实现了分类和待办状态的改变，具有良好的交互体验。</p>
<p>repository地址：<a href="https://github.com/AlexZhong22c/ToDoApp-IFE2015" target="_blank" rel="noopener">https://github.com/AlexZhong22c/ToDoApp-IFE2015</a></p>
<p>在线预览地址：<a href="https://alexzhong22c.github.io/ToDoApp-IFE2015/">https://alexzhong22c.github.io/ToDoApp-IFE2015/</a></p>
<p>新增了 <a href="https://alexzhong22c.github.io/ToDo-WebApp/index.html">升级版</a> 修复了一些bug，并且适配移动端：<a href="https://github.com/AlexZhong22c/ToDo-WebApp" target="_blank" rel="noopener">https://github.com/AlexZhong22c/ToDo-WebApp</a></p>
<a id="more"></a>
<h2 id="知识收获"><a class="header-anchor" href="#知识收获"></a>知识收获</h2>
<h3 id="自适应高度布局"><a class="header-anchor" href="#自适应高度布局"></a>自适应高度布局</h3>
<p>分为上中下三栏，中间的一栏自适应浏览器高度。这是参考了横向的三栏布局来写的。</p>
<ul>
<li>中间一栏要在外面包一层div，如果外面本来就有一层div这种布局就非常合适。上栏和下栏用绝对定位即可。</li>
<li>外面的这层div使用大面积的padding</li>
</ul>
<h3 id="在javascript-中创建html元素-用createelement-还是innerhtml好一点？"><a class="header-anchor" href="#在javascript-中创建html元素-用createelement-还是innerhtml好一点？"></a>在JavaScript 中创建HTML元素，用createElement()还是innerHTML好一点？</h3>
<ul>
<li>最叼的好像是 使用<a href="https://github.com/xwcoder/template" target="_blank" rel="noopener">模板技术</a>，其实我的静态博客用的就是这种。</li>
<li>在用js代码的循环创建元素的时候就顺便一个个绑定好事件这是一种比较简单的思路，这样就不用给每个元素增加id或者class了。这时候用createElement来创建元素就比较方便绑定事件，而如果用innerHTML来创建元素的话肯定不能在形成元素的循环里面给元素绑定事件了，这样太硬编码了。</li>
</ul>
<blockquote>
<p>《高性能JavaScript》：</p>
<ul>
<li>如果在对性能有苛刻要求更新一大段的HTML，innerHTML在大多数浏览器中执行更快。在旧版本浏览器中innerHTML方法更快，在基于Webkit内核却相反。</li>
<li>对于大多数日常操作而言，差异不大，根据代码可读性、可维护性、团队习惯、代码风格来决定采用哪种方法。</li>
<li>某答主说：**他一般大段就使用innerHTML了，而用dom创建单个元素或少量元素。 **</li>
<li>或者DOM结构嵌套的级数比较多的就用innerHTML</li>
<li>如果要使用createElement()，强烈推荐一下createDocumentFragment()
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">documentFragment</a> 被所有主流浏览器支持，甚至是IE 6。所以，没有理由不用。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="html属性用双引号-使用小写英文"><a class="header-anchor" href="#html属性用双引号-使用小写英文"></a>html属性用双引号、使用小写英文</h3>
<ul>
<li><strong>HTML4标准里没有单引号的对应实体，</strong> 所以单引号里写单引号很麻烦。后来XML规范才加入了’ 并由XHTML 1.0引入HTML。不过考虑到兼容性，前端几乎从来不写。
<ul>
<li>刚才在单引号里面写单引号只能用实体不能用反斜杠转移字符，根据HTML标准，反斜杠是不行的。</li>
</ul>
</li>
<li><strong>而JS中字符串用单引号，其实可能是HTML属性用双引号的结果。</strong></li>
<li>另外，一般大家惯用的做法是 HTML 用双引号，JS 用单引号的原因是，这样在 JS 中拼 HTML 片段不用转义：
<ul>
<li><code>elem.innerHTML = '&lt;div class=&quot;post&quot;&gt;&lt;/div&gt;';</code></li>
<li>当然你要反过来也可以，但不是主流做法。</li>
</ul>
</li>
<li>HTML属性不仅仅只有URL，另外引号出现在URL也是合法的。</li>
<li>根据W3Cschool的说法，<strong>要求属性和属性值使用小写，属性值应该始终被包括在引号内。</strong>
<ul>
<li>用innerHTML来创建taskid=1和cateid=0这种属性好像没有用啊，因为浏览器自动解析成：taskid=&quot;1&quot;和cateid=“0”</li>
</ul>
</li>
</ul>
<h3 id="ul里面能放除了li的其他标签吗？"><a class="header-anchor" href="#ul里面能放除了li的其他标签吗？"></a>ul里面能放除了li的其他标签吗？</h3>
<p>不能，<code>&lt;ul&gt;</code>里面只能放<code>&lt;li&gt;</code>。但是<code>&lt;li&gt;</code>里面可以放<code>&lt;hx&gt;</code>,<code>&lt;p&gt;</code>等标签。</p>
<p>ul里面放其他标签，不光不符合语义，在IE7- 里面也会有问题：</p>
<p>如果<code>&lt;other&gt;</code>标签前面有<code>&lt;li&gt;</code>标签，浏览器会认为<code>&lt;other&gt;</code>为<code>&lt;li&gt;</code>的子节点。</p>
<h3 id="box-shadow"><a class="header-anchor" href="#box-shadow"></a>box-shadow</h3>
<p>是CSS3里面的属性。只要shadow不占太多px的地方，用一下还是非常好的</p>
<h3 id="jquery"><a class="header-anchor" href="#jquery"></a>JQuery</h3>
<ul>
<li>JQuery的<code>not()</code>方法非常好用，<code>each()</code>也非常好</li>
</ul>
<ul>
<li>在绑定事件 函数中的 JQuery选择器 在函数触发后才会去选择对象</li>
<li>像这个App中分类列表的单击交互，如果想要只有被单击选择的HTML元素有 高亮，那么在绑定单击事件来响应单击选择的时候，记得先清除所有同类HTML元素的 高亮</li>
</ul>
<h4 id="jquery中-this-和-this-有区别："><a class="header-anchor" href="#jquery中-this-和-this-有区别："></a>JQuery中 this 和 $(“this”)有区别：</h4>
<p><a href="http://www.jb51.net/article/57376.htm" target="_blank" rel="noopener">JQuery中 this 和 $(“this”)有区别</a></p>
<p>如果你要使用html元素本身的属性或方法就需要使用this,如果你要使用jQuery包装后的方法或属性就要$(this),一般则有如下的关系.</p>
<pre><code>$(this)[0] == this;
</code></pre>
<p>上文的代码是要使用this的地方是要调用表单form的有reset方法,而这一方法jQuery没有包装支持,所以才有this.reset(),也可以使用$(this)[0].reset();</p>
<hr>
<p>关于什么时候使用二者?可以看如下例子:</p>
<pre><code>$('a').click(function(){
        this.innerHTML==$(this).html()=='jQuery';//三者是一样的.
        this.getAttribute('href')==this.href==$(this).attr('href')//三者是一样的;
        this.getAttribute('target')==this.target==$(this).attr('target')//三者是一样的;
        this.getAttribute('data-id')==$(this).attr('data-id')//二者是一样的;
    });
</code></pre>
<h3 id="caller的经典用法"><a class="header-anchor" href="#caller的经典用法"></a>caller的经典用法</h3>
<p>注：<strong>该特性是非标准的，请尽量不要在生产环境中使用它！</strong></p>
<p><img src="https://cloud.az22c.top/caller%E7%9A%84%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95.png-az22cgithub" alt></p>
<h2 id="匠心勿失"><a class="header-anchor" href="#匠心勿失"></a>匠心勿失</h2>
<h3 id="html-css"><a class="header-anchor" href="#html-css"></a>HTML+CSS</h3>
<ul>
<li><a href="http://blog.bingo929.com/CSS-coding-semantic-naming.html" target="_blank" rel="noopener">CSS命名惯例语义化</a></li>
<li>把需要的li全都设成了<code>cursor:pointer</code></li>
<li>虽然DOM结构是由js代码渲染的，在HTML留下一些<strong>template</strong>方便参考和编写代码</li>
<li>将颜色抽象成单独的class，方便更换颜色：</li>
</ul>
<pre><code>.white-bg {background: #FFFFCC;}
.black-bg {background: #3F3A39;}
.green-bg {background: #CFE8CC;}
.blue-bg {background: #5D6684;}
.grey-bg {background: #E9E9E9;}
.lt-blue-bg {background: #DADADA;}
</code></pre>
<p>我认为，只有占<strong>大块区域</strong>的元素才用色彩的class来设置<strong>背景颜色</strong>。因为如果要上色的元素很多的话，或者元素会短时间内存在再消失的话，一个一个加class就很麻烦。</p>
<h3 id="javascript"><a class="header-anchor" href="#javascript"></a>JavaScript</h3>
<ul>
<li>优化了 JavaScript 函数的命名，使得风格统一，语义明确。
<ul>
<li>这个App里面，用来控制视图层的函数最好用refresh来命名，用update命名的函数用于更新数据库的信息</li>
</ul>
</li>
</ul>
<ul>
<li>一般留下数组index为0的位置来存放一些默认的数组元素。比如存储“分类”的数组就将“默认分类”设为是它的0号元素。</li>
<li>深刻感受到使用主键等等概念管理数据库的简便</li>
<li>如果是 JavaScript 对象字面量，键值对的 键 最好不要用&quot;“包着，转成JSON的时候 键 会自动被”&quot;包上</li>
<li><strong>util.js</strong>是基于前面的小任务写的，它的功能很薄弱。例如<code>$(#modal-foot button)</code>返回来的只是一个元素对象，不合理，所以为了省事我直接用JQuery库就好了。</li>
</ul>
<h3 id="改进代码"><a class="header-anchor" href="#改进代码"></a>改进代码</h3>
<pre><code>function queryCateById(id) {
    var allCates = queryAllCates();
    var result = null;
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            result = allCates[i];
            break;
        }
    }
    return result;
}
</code></pre>
<p>简化为：</p>
<pre><code>function queryCateById(id) {
    var allCates = queryAllCates();
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            return allCates[i];
        }
    }
}
</code></pre>
<h3 id="容易犯的错误"><a class="header-anchor" href="#容易犯的错误"></a>容易犯的错误</h3>
<ul>
<li>JQuery中使用id选择器返回的也是<strong>元素数组</strong>。</li>
</ul>
<pre><code>console.log($(&quot;#modal-foot&quot;))// 元素数组
console.log($(&quot;#modal-foot&quot;)[0])// 这才是想要的元素
</code></pre>
<ul>
<li>HTML会自动忽略空格，要空格请用<code>&amp;nbsp;</code></li>
</ul>
<hr>
<p>在JQuery中，$(selector)[0]中的[0]会将JQuery对象转化为JavaScript对象。所以onclick有两种写法：</p>
<pre><code>$(&quot;#modal-foot button.cancel&quot;)[0].onclick = function() {
	// ```
}; 
///////分割线
$(&quot;#modal-foot button.cancel&quot;).click(function() {
	$(&quot;.cover&quot;).hide();
}); 
// $(selector).click(function() {});
</code></pre>
<p>另外还有一个例子可以看一下：</p>
<pre><code>$(&quot;.cover&quot;).show();
$(&quot;.cover&quot;).css(&quot;display&quot;,&quot;block&quot;);
$(&quot;.cover&quot;)[0].style.display = &quot;block&quot;;
</code></pre>
<h3 id="优化命名"><a class="header-anchor" href="#优化命名"></a>优化命名</h3>
<p><strong>函数名</strong>中包含&quot;all&quot;还是挺有用的，但是<strong>函数中的变量名</strong>包含&quot;all&quot;就没什么作用，如果是数组用&quot;arr&quot;命名就可以了。</p>
<p>比如：</p>
<pre><code>// 函数名中包含all，比较容易与其他类似的函数区分
function queryAllCates() {
    return JSON.parse(localStorage.cate);
}
</code></pre>
<p>再比如：</p>
<pre><code>function queryCateById(id) {
    var allCates = JSON.parse(localStorage.cate);
    for (var i = 0; i &lt; allCates.length; i++) {
        if (allCates[i].id == id) {
            return allCates[i];
        }
    }
}
// 函数内变量名带all好像也没什么用。allCates还不如直接叫cates或者叫catesArr
</code></pre>
<p>但是：</p>
<p>如果用addNewTask作为函数名，肯定不够用addTask作为函数名好。</p>
<h2 id="发现的bug-找时间再fix"><a class="header-anchor" href="#发现的bug-找时间再fix"></a>发现的bug，找时间再fix</h2>
<ol>
<li>火狐浏览器不实现<code>&lt;input type=&quot;date&quot;&gt;</code></li>
</ol>
<h2 id="最后："><a class="header-anchor" href="#最后："></a>最后：</h2>
<blockquote>
<p><a href="https://alexzhong22c.github.io/color-design-22c/color-design.html">color design</a>：<a href="https://alexzhong22c.github.io/color-design-22c/color-design.html">https://alexzhong22c.github.io/color-design-22c/color-design.html</a></p>
<p>如果各位看官喜欢的话留一个Star吧！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 项目总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> App </tag>
            
            <tag> caller </tag>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[相等操作符回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/02/11/equality-operators/</url>
      <content type="html"><![CDATA[<p>最早的ECMAscript中的相等和不相等操作符会在执行比较之前，先将对象转换成相似的类型(即，强制转型)。</p>
<p>后来有人对这种转换的合理性提出质疑。</p>
<p>最后，ECMAcript的解决方案是提供两组操作符：</p>
<ul>
<li>相等和不相等——先转换再比较</li>
<li>全等和不全等——仅比较而不转换</li>
</ul>
<a id="more"></a>
<h2 id="相等-和不相等"><a class="header-anchor" href="#相等-和不相等"></a>相等(==)和不相等(!=)</h2>
<p>&quot;==“和”!=“是互补对立的：如果两个操作数用”==“比较时返回 true，则这两个操作数用”!=“比较时就会返回 false ; 另外，用”==“返回 false 时，用”!=&quot;则返回true，这点很容易理解。</p>
<p>这两个操作符都会强制转型，<strong>在比较相等性之前</strong>会作以下工作：</p>
<ul>
<li>布尔值转换为数值，详见后面的补充。</li>
<li>字符串和数值比较时，将字符串转换成数值</li>
<li>对象和<strong>不是对象的操作数</strong>比较时，调用对象的<code>valueOf()</code>方法，用得到的基本类型值按照前面的规则进行比较。</li>
</ul>
<p>==和!=<strong>在进行比较之时</strong>遵循以下规则：</p>
<ul>
<li>null 和 undefined 是相等的。null == undefined
<ul>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
</ul>
</li>
<li>NaN和任何操作数不等，NaN 不等于NaN。
<ul>
<li>如果有一个操作数是 NaN，则&quot;==“返回 false ，而”!=&quot;返回 true 。</li>
<li>重要提示：即便两个操作数都是NaN，&quot;==&quot;也返回false，因为按照规则，NaN 不等于NaN。</li>
</ul>
</li>
<li>如果两个操作数都是对象，则比较它们是不是指向同一个对象。</li>
</ul>
<p>补充：</p>
<p>1. 相等运算符隐藏的强制转型，会带来一些违反直觉的结果：</p>
<pre><code> '' == 0            // true
' \t\r\n ' == 0     // true

false == 'false'    // false，这个超坑爹
false == '0'        // true
</code></pre>
<p>2.</p>
<pre><code>true == 1 返回true
false == 0 返回true
true == 2 返回true
</code></pre>
<p>还有另外一个概念叫<strong>Boolean 表达式</strong>，容易和以上概念混淆。在需要用到 Boolean 表达式的情景(比如if等语句中的条件判断)，非 Boolean 表达式也可以被转换为 Boolean 值，但是要遵循下列规则：</p>
<ul>
<li>所有的对象都被当作 true。</li>
<li>当且仅当字符串为空时，该字符串被当作 false。</li>
<li><strong>null</strong> 和 <strong>undefined</strong> 被当作 false。</li>
<li>当且仅当数字为零时，该数字被当作 false。</li>
</ul>
<h2 id="全等-和不全等"><a class="header-anchor" href="#全等-和不全等"></a>全等(===)和不全等(!==)</h2>
<p>和**相等(==)和不相等(!=)**类似，只不过在比较之前没有强制转型的过程，两个操作数直接比较。</p>
<h2 id="尽量使用全等和不全等"><a class="header-anchor" href="#尽量使用全等和不全等"></a>尽量使用全等和不全等</h2>
<p>举个简单的例子，团队协作中你肯定需要读别人的代码。而当你看到“==”时，要判断清楚作者的代码意图是确实需要转型，还是无所谓要不要转型只是随手写了，还是不应该转型但是写错了……所花费的脑力和时间比明确的“===”（加上可能需要的明确转型）要多得多。要记得团队中的每个人（包括原作者自己）都需要付出这理解和维护成本。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作符回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/02/11/js-operators/</url>
      <content type="html"><![CDATA[<p>ECMAScript 操作符的与众不同之处在于，它们能适用于很多种基本数据类型的值，例如字符串、数字值、布尔值、甚至对象。</p>
<p>不过，在应用于对象时，响应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p>
<a id="more"></a>
<h2 id="一元操作符"><a class="header-anchor" href="#一元操作符"></a>一元操作符</h2>
<p>自增和自减直接借鉴了C语言</p>
<p>自增、自减、加、减这些一元操作符可以用于转换数据类型。</p>
<h2 id="位操作符"><a class="header-anchor" href="#位操作符"></a>位操作符</h2>
<p>这是借鉴了一些底层的语言，在特殊情况下才会用到，一般情况下已经很少用了</p>
<h2 id="布尔操作符"><a class="header-anchor" href="#布尔操作符"></a>布尔操作符</h2>
<h3 id="逻辑非"><a class="header-anchor" href="#逻辑非"></a>逻辑非</h3>
<p>返回的是布尔值</p>
<h3 id="逻辑与和逻辑或"><a class="header-anchor" href="#逻辑与和逻辑或"></a>逻辑与和逻辑或</h3>
<p>如果操作数不只有布尔值：</p>
<h4 id="none"><a class="header-anchor" href="#none"></a>&amp;&amp;</h4>
<p>如果第一个操作数是 Boolean 类型，而且值为 false ，那么直接返回 false。
如果第一个操作数是 Boolean 类型，而且值为 true，另外一个操作数是 object 类型，那么将返回这个对象。
如果两个操作数都是 object 类型，那么，返回第二个对象。
如果任何一个操作数是 null，那么，返回 null。
如果任何一个操作数是 NaN，那么返回 NaN。
如果任何一个操作数是 undefinded，那么返回 undefined。</p>
<h4 id="none-v2"><a class="header-anchor" href="#none-v2"></a>||</h4>
<p>如果第一个操作数是 boolean 类型，而且值为 true， 那么，直接返回 true。
如果第一个操作数是 Boolean 类型，而且值为 false ，第二个操作数为 object，那么返回 object 对象。
如果两个操作数都是 object 类型，那么返回第一个对象。
如果两个操作数都是 null，那么，返回 null。
如果两个操作数都是 NaN，那么返回 NaN。
如果两个操作数都是 undefined，那么，返回 undefined。</p>
<h4 id="不用搞得这么复杂-推荐大家看这部分的说明"><a class="header-anchor" href="#不用搞得这么复杂-推荐大家看这部分的说明"></a>不用搞得这么复杂 推荐大家看这部分的说明</h4>
<p>a &amp;&amp; b : 将a, b转换为Boolean类型, 再执行逻辑与, true返回b, false返回a
a || b : 将a, b转换为Boolean类型, 再执行逻辑或, true返回a, false返回b
转换规则:
对象为true
非零数字为true
非空字符串为true
其他为false</p>
<hr>
<p>我们可以利用 逻辑或 这一行为来避免为变量赋值 null 或 undefined 值：</p>
<pre><code>var myObject = preferredObject || backupObject;
</code></pre>
<p>变量 preferredObject 的值优先赋给 myObject ，变量 backupObject 的值作为后备。</p>
<h2 id="乘性操作符"><a class="header-anchor" href="#乘性操作符"></a>乘性操作符</h2>
<p>Infinity 和 -Infinity 表示无穷大和负无穷大</p>
<h3 id="乘法"><a class="header-anchor" href="#乘法"></a>乘法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity * 0 ==&gt; NaN</li>
</ul>
<h3 id="除法"><a class="header-anchor" href="#除法"></a>除法</h3>
<ul>
<li>如果有一个是NaN，则结果是NaN</li>
<li>Infinity / Infinity ==&gt; NaN</li>
<li>0 / 0 ==&gt; NaN</li>
</ul>
<h3 id="求模"><a class="header-anchor" href="#求模"></a>求模</h3>
<p>a % b：</p>
<p>如果a有限大，而b无限大，结果为a</p>
<p>如果a为0， 结果为0</p>
<p>其他特殊情况一般为NaN</p>
<h2 id="加性操作符"><a class="header-anchor" href="#加性操作符"></a>加性操作符</h2>
<h3 id="加法"><a class="header-anchor" href="#加法"></a>加法</h3>
<ul>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后拼接字符串
<ul>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的toString() 方法</li>
<li>对于undefined 和 null ，调用String()函数取得字符串&quot;undefined&quot;和&quot;null&quot;</li>
</ul>
</li>
</ul>
<h3 id="减法"><a class="header-anchor" href="#减法"></a>减法</h3>
<p>略</p>
<h2 id="关系操作符"><a class="header-anchor" href="#关系操作符"></a>关系操作符</h2>
<ul>
<li>如果两个操作符都是字符串，则比较两个字符串对应的字符编码值
<ul>
<li>大写字母的字符编码 全部小于 小写字母的字符编码</li>
</ul>
</li>
</ul>
<h2 id="相等操作符"><a class="header-anchor" href="#相等操作符"></a>相等操作符</h2>
<p>见另外一篇文章 <a href="https://alexzhong22c.github.io/2017/02/11/equality-operators/">相等操作符</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[font-face--CSS3]]></title>
      <url>https://alexzhong22c.github.io/2017/01/25/font-face/</url>
      <content type="html"><![CDATA[<p><code>@font-face</code>是一个css命令，用来导入服务器端字体，将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。因此本地浏览器浏览网页时，不需要设置字体，就可以自动看到@font-face设置的任何字体。</p>
<p>如果你看到一些英文网站或blog看到一些很漂亮的自定义Web字体，比如说首页的Logo，Tags以及页面中的手写英文体，这些都是**@font-face**实现的。</p>
<a id="more"></a>
<h2 id="font-face在css中使用"><a class="header-anchor" href="#font-face在css中使用"></a>@font-face在css中使用</h2>
<pre><code>@font-face {
　　font-family: &lt;YourWebFontName&gt;;
　　src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;
　　[font-weight: &lt;weight&gt;];
　　[font-style: &lt;style&gt;];
}
</code></pre>
<p>取值说明：</p>
<ol>
<li>YourWebFontName:你自定义的字体名称，最好是使用你下载的默认字体名（下载回来的叫什么字体，这里就填什么字体名），他将被引用到你的Web元素中的font-family。如“font-family:“YourWebFontName”;”</li>
<li>source:此值指的是自定义的字体的存放路径，可以是相对路径也可以是绝路径；</li>
<li>format：此值指的是自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</li>
<li>weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</li>
</ol>
<h2 id="兼容浏览器"><a class="header-anchor" href="#兼容浏览器"></a>兼容浏览器</h2>
<p>说到浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，这样大家有必要了解一下，各种版本的浏览器支持什么样的字体：</p>
<blockquote>
<p><strong>一、TureTpe(.ttf)格式：</strong></p>
<p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p>
<p><strong>二、OpenType(.otf)格式：</strong></p>
<p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，所以也提供了更多的功能,支持这种字体的浏览器有【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】；</p>
<p><strong>三、Web Open Font Format(.woff)格式：</strong></p>
<p><strong>.woff字体是Web字体中最佳格式</strong>，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p>
<p><strong>四、Embedded Open Type(.eot)格式：</strong></p>
<p>.eot字体是<strong>IE专用字体</strong>，可以从TrueType创建此格式字体,支持这种字体的浏览器有【IE4+】；</p>
<p><strong>五、SVG(.svg)格式：</strong></p>
<p>.svg字体是基于SVG字体渲染的一种格式,支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p>
</blockquote>
<p><strong>这就意味着在@font-face中我们至少需要.woff,.eot两种格式字体</strong>，<strong>甚至还需要.svg等字体达到更多种浏览版本的支持。</strong></p>
<hr>
<p>为了使@font-face达到更多的浏览器支持，<a href="http://paulirish.com/" target="_blank" rel="noopener">Paul Irish</a>写了一个独特的@font-face语法叫<a href="http://paulirish.com/2009/bulletproof-font-face-implementation-syntax/" target="_blank" rel="noopener">Bulletproof @font-face</a>:</p>
<pre><code>  @font-face {
	font-family: 'YourWebFontName';
	src: url('YourWebFontName.eot?#iefix') format('eot');/*IE*/
	src:url('YourWebFontName.woff') format('woff'), url('YourWebFontName.ttf') format('truetype');/*non-IE*/
   }
</code></pre>
<p>但为了让各多的浏览器支持，你也可以写成：</p>
<pre><code>  @font-face {
	font-family: 'YourWebFontName';
	src: url('YourWebFontName.eot'); /* IE9 Compat Modes */
	src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
             url('YourWebFontName.woff') format('woff'), /* Modern Browsers */
             url('YourWebFontName.ttf')  format('truetype'), /* Safari, Android, iOS */
             url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */
   }
</code></pre>
<p>直接改改<code>YourWebFontName</code>就行了。</p>
<p>然后就在CSS 里面引用给对应的元素：</p>
<pre><code>p {
	font-family: 'YourWebFontName'
}
</code></pre>
<hr>
<h2 id="获取特殊字体"><a class="header-anchor" href="#获取特殊字体"></a>获取特殊字体</h2>
<p>我平时都是到Google Web Fonts和Dafont.com寻找自己需要的字体，当然网上也还有别的下载字体的地方,如：<a href="http://webfonts.fonts.com/" target="_blank" rel="noopener">Webfonts</a>,<a href="http://typekit.com/" target="_blank" rel="noopener">Typekit</a>,<a href="http://kernest.com/" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.google.com/webfonts" target="_blank" rel="noopener">Google Web Fonts</a>,<a href="http://kernest.com/licenses" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont</a>,<a href="http://nicewebtype.com/fonts/" target="_blank" rel="noopener">Niec Web Type</a>,不然你点<a href="http://www.google.com/search?q=webfonts" target="_blank" rel="noopener">这里</a>将有更多的免费字体。前面几个链接是帮助你获取一些优美的怪异的特殊字体!</p>
<h3 id="获取-font-face所需字体格式："><a class="header-anchor" href="#获取-font-face所需字体格式："></a>获取@font-face所需字体格式：</h3>
<p>特殊字体已经在你的电脑中了，现在我们需要想办法获得@font-face所需的.eot,.woff,.ttf,.svg字体格式。要获取这些字体格式，我们同样是需要第三方工具或者软件来实现，下面我给大家推荐一款我常用的一个工具<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">fontsquirrel</a>, 链接：<a href="http://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="noopener">http://www.fontsquirrel.com/tools/webfont-generator</a></p>
<p>使用这个在线字体格式生成工具，我们只需要上传我们下载回来的一种字体格式，就能生成其它的.eot,.woff,.ttf,.svg字体格式，很方便地说！这款工具的具体使用方法，可参考原文：</p>
<p><a href="http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2084875.html" target="_blank" rel="noopener">http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2084875.html</a> ，本文也是转载该站 的内容 ，在此表示 感谢 ！</p>
<p>或者这个在线字体格式转换地址：<a href="https://cloudconvert.com/" target="_blank" rel="noopener">https://cloudconvert.com/</a> 也是可以的，有其它比较实用方便的网址，欢迎留言提供，方便大家。</p>
<hr>
<p>推荐给body写：</p>
<pre><code>font-family: -apple-system-font,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Open Sans&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;WenQuanYi Micro Hei&quot;,sans-serif;
</code></pre>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> font-face </tag>
            
            <tag> 字体 </tag>
            
            <tag> 特殊 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js函数基础回顾]]></title>
      <url>https://alexzhong22c.github.io/2017/01/13/js-function/</url>
      <content type="html"><![CDATA[<p>此文用于快速回顾，不适合用来入门。</p>
<a id="more"></a>
<h2 id="创建函数对象的三种方法"><a class="header-anchor" href="#创建函数对象的三种方法"></a>创建函数对象的三种方法</h2>
<h3 id="函数声明"><a class="header-anchor" href="#函数声明"></a>函数声明</h3>
<p>就是对函数进行普通的声明</p>
<pre><code>function add(a, b) {
    return a + b;
}
</code></pre>
<h3 id="函数表达式"><a class="header-anchor" href="#函数表达式"></a>函数表达式</h3>
<ul>
<li>将函数赋值给变量</li>
</ul>
<pre><code>// function variable
var add = function(a, b) {
    // body...
};
</code></pre>
<ul>
<li>立即执行函数，把匿名函数用括号括起来，再直接调用。</li>
</ul>
<pre><code>// IEF(Immediately Executed Function)
(function() {
    // body...
})();
</code></pre>
<ul>
<li>函数对象作为返回值</li>
</ul>
<pre><code>return function() {
    // body...
};
</code></pre>
<ul>
<li>命名式函数表达式</li>
</ul>
<pre><code>//NFE(Named Function Expression)
var add = function foo(a, b) {
    // body...
};
</code></pre>
<p>这里大家肯定会好奇，这个函数怎么调用？到底用哪个名字呢？</p>
<p>做一个测试：</p>
<pre><code>var func = function nfe() {};
console.log(func === nfe);
// 在 IE6~8，得到 false
// 在 IE9+ 及现代浏览器中 Uncaught ReferenceError: nfe is not defined
</code></pre>
<p>那么命名函数表达式有什么使用场景呢？</p>
<ul>
<li>一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。</li>
<li>或者在递归时，使用名字调用自己。</li>
</ul>
<p>但是这两种用法都不常见。</p>
<h3 id="function-构造器"><a class="header-anchor" href="#function-构造器"></a>Function 构造器</h3>
<p>除了函数声明、函数表达式。还有一种创建函数对象的方式，是使用函数构造器。</p>
<pre><code>var func = new Function('a','b','console.log(a+b);');
func(1,2);//3

var func2 = Function('a','b','console.log(a+b);');
func2(1,2);//3
</code></pre>
<p>Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。</p>
<p>还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。</p>
<h3 id="三种方法的对比"><a class="header-anchor" href="#三种方法的对比"></a>// 三种方法的对比:</h3>
<p><img src="https://cloud.az22c.top/%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png-az22cgithub" alt></p>
<h2 id="变量-函数的声明前置"><a class="header-anchor" href="#变量-函数的声明前置"></a>变量 &amp; 函数的声明前置</h2>
<p>举两个例子</p>
<p>例1，函数声明：</p>
<pre><code>var num = add(1,2); // 调用
console.log(num);

function add(a, b) { // 声明
    return a + b;
}
</code></pre>
<p>例2，函数表达式：</p>
<pre><code>var num = add(1, 2);
console.log(num);

var add = function(a, b) {
    return a + b;
};
</code></pre>
<p>例1中得到的结果是 3，而例2中是 <code>Uncaught TypeError: add is not a function</code>。</p>
<p>因为函数和变量在声明的时候，会被前置到当前作用域的顶端。例1将函数声明<code>function add(a, b)</code>前置到作用域前端，例2将声明<code>var add</code>前置到其作用域的前端了，但并没有赋值。<strong>赋值的过程是在函数执行到相应位置的时候才进行的。</strong></p>
<h2 id="调用方式"><a class="header-anchor" href="#调用方式"></a>调用方式</h2>
<ul>
<li>直接调用</li>
</ul>
<pre><code>foo();
</code></pre>
<ul>
<li>对象方法</li>
</ul>
<pre><code>o.method();
</code></pre>
<ul>
<li>构造器</li>
</ul>
<pre><code>new Foo();
</code></pre>
<ul>
<li>函数方法call/apply/bind</li>
</ul>
<pre><code>func.call(o);
</code></pre>
<h2 id="函数属性"><a class="header-anchor" href="#函数属性"></a>函数属性</h2>
<h3 id="arguments属性"><a class="header-anchor" href="#arguments属性"></a>arguments属性</h3>
<p>函数的arguments属性使函数可以处理可变数量的参数。 <code>arguments</code> 对象的 <code>length</code> 属性包含了 传递给函数的参数(即所谓的实参) 的数目。</p>
<p><code>arguments</code> 对象还可以当做是一个数组来用： <code>arguments</code> 对象中包含的各个参数的访问方式与数组元素的访问方式相同：</p>
<pre><code>function ArgTest(arg1, arg2){
   var s = &quot;&quot;;
   s += &quot;The individual arguments are: &quot;
   for (n = 0; n &lt; arguments.length; n++){
      s += ArgTest.arguments[n];
      s += &quot; &quot;;
   }
   return(s);
}
console.log(ArgTest(1, 2, &quot;hello&quot;));
// Output: The individual arguments are: 1 2 hello
</code></pre>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">严格模式对arguments有一些要求</a></p>
</blockquote>
<h3 id="caller属性"><a class="header-anchor" href="#caller属性"></a>caller属性</h3>
<blockquote>
<p>functionName.caller</p>
</blockquote>
<p><em>functionName</em> 是任何正在执行的函数的名称。</p>
<p><code>caller</code> 属性只有当函数正在执行时（实质上就是被调用）才被定义。</p>
<p>假设有这么一个函数foo，它是在全局作用域内被调用的，则<code>foo.caller</code>为<code>null</code>；相反，如果这个函数foo是在另外一个函数作用域内被调用的,则<code>foo.caller</code>指向调用它的那个函数。</p>
<p>可见，其返回结果为函数或者是<code>null</code>。</p>
<p>而如果在字符串上下文中使用 <code>caller</code> 属性，则其结果和 <em>functionName</em>.<code>toString</code> 相同。</p>
<p>下面的示例阐释了 <code>caller</code> 属性的用法：</p>
<pre><code class="language-JavaScript">function CallLevel() {
   if (CallLevel.caller == null)
      return(&quot;CallLevel was called from the top level.&quot;);
   else
      return(&quot;CallLevel was called by another function.&quot;);
}

console.log(CallLevel());
// Output: CallLevel was called from the top level.
</code></pre>
<p>caller也可以用于<code>arguments</code>，常用形式<code>arguments.callee.caller</code>替代了被废弃的<code>arguments.caller</code>。</p>
<p><strong>备注：</strong></p>
<p>caller属性，实质上就是去查找并返回调用者（当前函数）的一个特殊属性<code>_caller_</code> ，返回的是<strong>调用当前函数的函数</strong>的活动对象，因而可以用来重现出整个调用栈。在调试的时候可以它用来帮助找bug；它是不安全的，它不被列入浏览器标准之内，不要在生产环境中使用。</p>
<h3 id="apply属性-方法"><a class="header-anchor" href="#apply属性-方法"></a>apply属性(方法)</h3>
<blockquote>
<p>调用函数，并用指定一个对象替换函数的 <code>this</code> 值，同时用指定数组替换函数的参数。</p>
<p>apply([thisObj[,argArray]])</p>
<p><code>thisObj</code>：可选。要用作 this 对象的对象。即调用这个函数的对象。</p>
<p><code>argArray</code>：可选。要额外传递到函数的一组参数。</p>
</blockquote>
<h3 id="call属性-方法"><a class="header-anchor" href="#call属性-方法"></a>call属性(方法)</h3>
<p><strong>apply 后面的参数需为数组；而call 为扁平化传参</strong></p>
<pre><code class="language-JavaScript">function foo(x, y) {
    console.log(x, y, this);
}

foo.call(100, 1, 2); //1 2 Number {[[PrimitiveValue]]: 100}
foo.apply(true, [3, 4]); //3 4 Boolean {[[PrimitiveValue]]: true}
foo.apply(null); //undefined undefined Window
foo.apply(undefined); //undefined undefined Window
</code></pre>
<p>可见，传入 null/undefined 时，实际为 Window 对象
在严格模式下：上述代码最后两行分别输出 null， undefined</p>
<h3 id="bind属性-方法"><a class="header-anchor" href="#bind属性-方法"></a>bind属性(方法)</h3>
<p>bind和call/apply的区别是：bind返回的是<code>函数</code>，可供稍后继续调用；而call和apply直接就是改变this之后立即调用，返回值是对应的调用结果。</p>
<blockquote>
<p>fun.bind(thisArg[, arg1[, arg2[, …]]])</p>
</blockquote>
<p>下面的代码演示如何使用 <code>bind</code> 方法：</p>
<pre><code class="language-JavaScript">// 定义原始函数：
var checkNumericRange = function (value) {
    if (typeof value !== 'number')
        return false;
    else
        return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;
}

var range = { minimum: 10, maximum: 20 };

var boundCheckNumericRange = checkNumericRange.bind(range);

console.log(boundCheckNumericRange (12));	// true
</code></pre>
<p>上例中结果正常，美中不足的是<code>checkNumericRange</code>只是在特定情境下使用，没必要暴露在全局环境中，所以我们想去把它放在某个对象内部。</p>
<p>在下面的示例中，thisArg对象 与 包含原始函数<code>checkNumericRange</code>的对象不同：</p>
<pre><code class="language-JavaScript">var originalObject = {
    minimum: 50,
    maximum: 100,
    checkNumericRange: function (value) {
        if (typeof value !== 'number')
            return false;
        else
            return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;
    }
}

console.log(originalObject.checkNumericRange(10)); // Output: false，对象调用自身方法
// ------------------分割线----------------------------
var range = { minimum: 10, maximum: 20 };

var boundObjectWithRange = originalObject.checkNumericRange.bind(range);

console.log(boundObjectWithRange(10)); // Output: true
</code></pre>
<p>显然后者更加灵活一点。用<code>bind</code>改变this的指向，一个对象可以使用另外一个对象里面的方法，这是一种常见用法。</p>
<hr>
<p>再来一个例子，说明一下 <a href="https://alexzhong22c.github.io/2017/08/07/js-this/">this的指向</a> 和 <strong>函数的调用者（点运算符之前的对象或者window全局）</strong> 的区别：</p>
<pre><code>this.x = 9;
var module = {
    x: 81,
    getX: function() {
        return console.log(this.x);
    }
};

module.getX(); //81
// 函数的调用者为module，函数的this指向module

var getX = module.getX;
getX(); //9
// var getX = module.getX; 将这个方法赋值给一个全局变量，这时 this 指向了 window
// 函数的调用者为window，函数的this指向window

var boundGetX = getX.bind(module);
boundGetX(); //81
// 应用bind,函数的调用者为window，函数的this指向module
</code></pre>
<p>一般情况下，谁调用函数，函数的this就指向谁。</p>
<p><code>bind</code> 主要用于改变函数中的 <code>this</code></p>
<ul>
<li><code>module.getX();</code>直接通过对象调用自己的方法，结果是 81</li>
<li><code>var getX = module.getX;</code> 将这个方法赋值给一个全局变量，这时 this 指向了 window，所以结果为 9</li>
<li><code>var boundGetX = getX.bind(module);</code> 使用 bind 绑定了自己的对象，这样 this 仍然指向 module 对象，所以结果为 81</li>
</ul>
<hr>
<p>以下代码演示如何使用 arg1[,arg2[,argN]]] 参数：</p>
<pre><code>var displayArgs = function (val1, val2, val3, val4) {
    console.log(val1 + &quot; &quot; + val2 + &quot; &quot; + val3 + &quot; &quot; + val4);
}

var emptyObject = {};

var displayArgs2 = displayArgs.bind(emptyObject, 12, &quot;a&quot;);
// &quot;b&quot;和&quot;c&quot;被传给形参val3和val4
displayArgs2(&quot;b&quot;, &quot;c&quot;);
// Output: 12 a b c 
</code></pre>
<p>在上例中，一开始绑定函数将 <code>bind</code> 方法中指定的参数用作第一个参数和第二个参数。再调用绑定函数时，指定的任何参数将用作第三个、第四个参数（依此类推）。</p>
<h4 id="bind-与-currying"><a class="header-anchor" href="#bind-与-currying"></a>bind 与 currying</h4>
<p>bind 可以使函数柯里化，那么什么是柯里化？</p>
<blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回 <strong>接受</strong>余下的参数且<strong>返回</strong>结果的新函数 的技术。</p>
</blockquote>
<pre><code>function add(a, b, c) {
    return a + b + c;
}

var func = add.bind(undefined, 100); // 接受一个单一参数
func(1, 2); //103

var func2 = func.bind(undefined, 200);// 接受一个单一参数

func2(10); //310
</code></pre>
<p>add 函数拥有 3 个参数。我们想先传入一个参数，再去传其他参数。</p>
<p><code>var func = add.bind(undefined, 100);</code>add 函数对象调用 bind 方法，由于不需要将 this 指向原来的 add 函数对象，所以第一个参数写为 undefined 或 null。第二个参数 100 传给了 add 函数中的形参 a，并赋值给一个新的函数对象 func。</p>
<p>这时，<code>func(1, 2)</code> 即相当于传入后两个参数，所以结果为 103。</p>
<p>同理，基于 func 可以创造一个函数 func2。它只用传最后一个参数。</p>
<p>再见一个柯里化对函数参数拆分的例子：</p>
<pre><code class="language-JavaScript">function getConfig(colors,size,otherOptions){
    console.log(colors,size,otherOptions);
}
var defaultConfig = getConfig.bind(null,'#c00','1024*768');
defaultConfig('123');//'#c00 1024*768 123'
defaultConfig('456');//'#c00 1024*768 456'
</code></pre>
<h4 id="bind-与-new一起用时"><a class="header-anchor" href="#bind-与-new一起用时"></a>bind 与 new一起用时</h4>
<pre><code>function foo() {
    this.b = 100;
    return this.a;
}
console.log(foo()); //undefined
var func = foo.bind({
    a: 1
});
console.log(func()); //1

console.log(new func()); //foo {b: 100} ，bind与new一起用时。
</code></pre>
<p>如果执行普通的某个函数，其返回值可以是任意类型。</p>
<p>而对于使用了 <code>new func()</code> 这种方式创建对象，其返回值<strong>应</strong>为一个对象。</p>
<p>原函数 foo 的返回值不是对象，所以会直接忽视这个 return 方法。而是变为 <code>return this;</code>。并且 this 会被初始化为一个空对象，这个空对象的原型指向 foo.prototype。所以后面的 bind 是不起作用的。</p>
<p>这里面这个 this 对象包含一个属性 <code>b = 100</code>。所以返回的是对象 <code>{b: 100}</code>。</p>
<p>MDN有提到，bind不要和构造函数一起用，各浏览器可能结果不一样。MDN建议不要这样用。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回顾 </tag>
            
            <tag> 函数属性 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
