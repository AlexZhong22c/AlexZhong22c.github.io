---
title: let和const回顾
date: 2016-11-09 17:28:05
categories: [JavaScript]
tags: [回顾]
---

简单来说是： let是修复了var的作用域的一些bug，变的更加好用。let是更好的var。var的作用于是函数作用于，而let是块级别（大括号括起来的内容）
const声明的变量只可以在声明时赋值，它被设计的本意就是不可随意修改，这是最大的特点。

<!--more-->

## let

`let`与`var`一样，也可以用来声明变量，但它有着更好的作用域规则。

`let`与`var`还是有不同之处的，所以如果你只是在代码中将`var`全局搜索替换为`let`，一些依赖`var`声明的独特特性（可能你不是故意这样写）的代码可能无法正常运行。但对于绝大多数代码来说，在ES6的新代码模式下，你应该停止使用`var`声明变量，能使用`let`就用吧！

这一规则可以帮助你捕捉bug，除了`NaN`错误以外，每一个异常都会在当前行抛出。

- **let声明的变量拥有块级作用域。** 也就是说用`let`声明的变量的作用域只是外层块，而不是整个外层函数。
- **let声明的全局变量不是全局对象的属性。** 这就意味着，你不可 以通过`window.变量名`的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。
- **形如for (let x...)的循环在每次迭代时都为x创建新的绑定。**

可以看一个**循环内变量过度共享**的例子：

```
var messages = ["喵！", "我是一只会说话的猫！", "回调（callback）非常有趣!"];
for (var i = 0; i < messages.length; i++) {
	setTimeout(function () {
		cat.say(messages[i]);
	}, i * 1500);
}
```

这只会说话的猫并没有按照预期连说三条消息，它说了三次“undefined”。

事实上，这个问题的答案是，循环本身及三次timeout回调均共享唯一的变量*i*。当循环结束执行时，*i*的值为3（因为`messages.length`的值为3），此时回调尚未被触发。

所以当第一个timeout执行时，调用`cat.say(messages[i])`，此时i的值为3，所以猫咪最终打印出来的是`messages[3]`的值亦即`undefined`。

如果一个`for (let...)`循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。

所以在会说话的猫示例中，也可以通过将`var`替换为`let`修复bug。

这种情况适用于现有的三种循环方式：`for-of`、`for-in`、以及传统的用分号分隔的类C循环。

-  **let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误** 。举个例子：

```
  function update() {
  	console.log("当前时间:", t);  // 引用错误（ReferenceError）
  	...
  	let t = readTachymeter();
  }
```

不可访问的这段时间变量一直处于作用域中，但是尚未装载，它们位于*临时死区（Temporal Dead Zone，简称TDZ*）中。我一直想用科幻小说来类比这个脑洞大开的行话，但是还没想好怎么搞。

（脆弱的性能细节：在大多数情况下，查看代码就可以区分声明是否已经执行，所以事实上，JavaScript引擎不需要在每次代码运行时都额外执行 一次变量可访问检查来确保变量已经被初始化。然而在闭包内部有时不是透明的，这时JavaScript引擎将会做一个运行时检查，也就意味着`let`相对`var`而言比较慢。）

（脆弱的平行宇宙作用域细节：在一些编程语言中，一个变量的作用域始于声明之处，而非前后覆盖整个封闭代码块。标准委员会曾考虑过将这种作用域准则赋予`let`关键词，但是一旦使用这种准则，原本提前使用变量的语句会导致引用错误（ReferenceError），现在该语句不位于`let t`的声明作用域中，根本不会引用此处的变量`t`，而是引用外层作用域的相应变量。但是这个方法无法与闭包和函数提升很好得结合，所以该提案最终被否决了。）

-  **用let重定义变量会抛出一个语法错误（SyntaxError）。**

  这一条规则也可以帮助你检测琐碎的小问题。诚然，这亦是`var`与`let`的不同之处，当你全局搜索`var`替换为`let`时也会导致`let`重定义语法错误，因为这一规则对全局`let`变量也有效。

  如果你的多个脚本中都声明了相同的全局变量，你最好继续用`var`声明这些变量。如果你换用了`let`，后加载的脚本都会执行失败并抛出错误。

  或者你可以考虑使用ES6内建的模块机制，后面的文章中会详细讲解。

  （脆弱的语法细节：`let`是一个严格模式下的保留词。在非严格模式下，出于向后兼容的目的，你仍可以用`let`命名来声明变量、函数和参数，虽然你不会犯傻，但是你确实可以编写`var let = 'q';`这样的代码！不过`let let;`无论如何都是非法的。）

在那些不同之外，`let`和`var`几乎很相似了。举个例子，它们都支持使用逗号分隔声明多重变量，它们也都支持[解构](http://www.infoq.com/cn/articles/es6-in-depth-destructuring)特性。

注意，`class`类声明的行为与`var`不同而与`let`一致。如果你加载一段包含同名类的脚本，后定义的类会抛出重定义错误。

## const

是的，还有一个新的关键词！

ES6引入的第三个声明类关键词与`let`类似：`const`。

`const`声明的变量与`let`声明的变量类似，它们的不同之处在于，`const`声明的变量只可以在声明时赋值，不可随意修改，否则会导致`SyntaxError`（语法错误）。

```
const MAX_CAT_SIZE_KG = 3000; // 正确

MAX_CAT_SIZE_KG = 5000; // 语法错误（SyntaxError）
MAX_CAT_SIZE_KG++; // 虽然换了一种方式，但仍然会导致语法错误
```

当然，规范设计的足够明智，用`const`声明变量后必须要赋值，否则也抛出语法错误。

```
const theFairest;  // 依然是语法错误，你这个倒霉蛋
```

## 现在可以使用let和const了么？

是的。如果要在web上使用`let`和`const`特性，你需要使用一个诸如[Babel](http://babeljs.io/)、[Traceur](https://github.com/google/traceur-compiler#what-is-traceur)或[TypeScript](http://www.typescriptlang.org/)的ES6转译器。（Babel和Traceur暂不支持临时死区特性。）

io.js支持`let`和`const`，但是只在严格模式下编码可以使用。Node.js同样支持，但是需要启用`--harmony`选项